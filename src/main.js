console.log('[MAIN.JS] è…³æœ¬é–‹å§‹åŸ·è¡Œ');
console.log('[MAIN.JS] window.GameData:', typeof window.GameData);

const {
  ATTRIBUTES,
  FLOWS,
  BASE_ATTRIBUTES,
  BASE_STATS,
  SKILL_CHAINS,
  NODE_TYPES,
  FLOW_PALETTE,
  ITEMS,
  STARTING_ITEMS,
  ENEMY_DECK,
  HERO_TYPES,
  COMPANION_TYPES,
  COMPANION_PERSONALITIES,
  EQUIPMENT,
  EQUIPMENT_LOOKUP,
  GAME_CONFIG,
} = window.GameData;

console.log('[MAIN.JS] æ•¸æ“šè§£æ§‹å®Œæˆ');


// è¢«å‹•æŠ€èƒ½å·²ç§»é™¤

// è¼”åŠ©å‡½æ•¸ï¼šç²å–ç¬¬ä¸€å€‹æ´»è‘—çš„åŒä¼´ï¼ˆç”¨æ–¼æˆ°é¬¥ç³»çµ±ï¼Œæš«æ™‚åªæ”¯æŒä¸€å€‹åŒä¼´æˆ°é¬¥ï¼‰
function getActiveCompanion() {
  return state.companions.length > 0 ? state.companions[0] : null;
}

const SKILL_LOOKUP = new Map();
SKILL_CHAINS.forEach((chain) => {
  chain.steps.forEach((step) => {
    SKILL_LOOKUP.set(step.id, { ...step, flow: chain.flow, chainId: chain.id, chainTier: step.tier, aoe: chain.aoe || false });
  });
});
// è¢«å‹•æŠ€èƒ½å·²ç§»é™¤

const ITEM_LOOKUP = new Map(ITEMS.map((item) => [item.id, item]));

const COMMANDS = [
  { id: 'attack', label: 'æˆ°é¬¥' },
  { id: 'skill', label: 'æŠ€èƒ½' },
  { id: 'guard', label: 'é˜²å®ˆ' },
  { id: 'item', label: 'é“å…·' },
];

const SPECTATE_COMMAND = { id: 'spectate', label: 'éˆé­‚è§€æˆ°' };

const STORAGE_KEY = 'rogueQuestSaveV1';
const STAGE_BACKUP_KEY = 'rogueQuestStageBackupV1';
const MAX_LOG_ENTRIES = 100;

const state = {
  hero: null,
  companions: [], // åŒä¼´é™£åˆ—ï¼ˆæ”¯æŒå¤šå€‹åŒä¼´ï¼‰
  relics: [], // åœ£ç‰©æ•°ç»„ï¼ˆ36ä¸ªåœ£ç‰©ï¼Œ6é˜¶æ®µÃ—6æµæ´¾ï¼‰
  obtainedRelics: [], // å·²è·å¾—çš„åœ£ç‰©IDæ•°ç»„
  world: {
    stage: 1, // 1=é’ç¿ å¹³åŸ, 2=å¹½æš—æ£®æ—, 3=éšªå³»å±±è„ˆ, 4=æ·±é‚ƒæ´çªŸ, 5=è¿·å®®è¿´å»Š, 6=é­”ç‹åŸ
    nodes: [],
    currentNodeIndex: 0,
    currentArea: 'field', // 'field', 'forest', 'mountain', 'cave', 'maze', 'castle'
  },
  ui: {
    levelUp: null,
    companionLevelUp: null, // åŒä¼´å‡ç´šç‹€æ…‹
    battle: null,
    startMenu: true,
    heroTypeSelection: null,
    companionSelection: null, // åŒä¼´é¸æ“‡ç‹€æ…‹
    skillTrainer: null, // æŠ€èƒ½è¨“ç·´å¸«ç‹€æ…‹ {step: 'selectCompanion'|'selectSkill'|'selectReplacement', selectedCompanionIndex: number, selectedSkillId: string, replacementOptions: []}
    personalityTherapy: null, // å¿ƒç†æ²»ç™‚æ‰€ç‹€æ…‹ {step: 'selectCompanion'|'selectPersonality', selectedCompanionIndex: number, personalityOptions: []}
    classAdvancement: null, // è·æ¥­é€²éšç‹€æ…‹ {step: 'selectCompanion'|'selectClass', selectedCompanionIndex: number, availableClasses: []}
    skillLearnDialog: null, // æŠ€èƒ½å­¸ç¿’ç¢ºèªè¦–çª— {companionName: string, skills: [{name, description, kind}]}
    testModeAdvancement: null, // æ¸¬è©¦æ¨¡å¼è·æ¥­é€²éšç‹€æ…‹ {companionIndex: number, companion: object}
    heroBlood: null, // å‹‡è€…ä¹‹è¡€ç‹€æ…‹ {step: 'selectBlood', selectedBloodType: string}
    relicSelection: null, // åœ£ç‰©é€‰æ‹©çŠ¶æ€ {relics: [], stage: number}
    statusTab: 'skills', // 'skills', 'items'
    characterView: 'hero', // 'hero' or 'companion' - é¡¯ç¤ºè‹±é›„æˆ–åŒä¼´
    companionViewIndex: 0, // ç•¶å‰æŸ¥çœ‹çš„åŒä¼´ç´¢å¼•ï¼ˆç•¶ characterView === 'companion' æ™‚ï¼‰
    eventResult: null, // äº‹ä»¶çµæœï¼Œç”¨æ–¼é¡¯ç¤ºäº‹ä»¶å°è©±æ¡†
    shop: null, // å•†åº—ç‹€æ…‹
    battleResult: null, // æˆ°é¬¥çµæœï¼Œç”¨æ–¼é¡¯ç¤ºæ‰è½ç‰©å“
    itemChoice: null, // é“å…·é¸æ“‡ï¼ˆç•¶é“å…·æ¬„æ»¿æ™‚ï¼‰
    logExpanded: false, // å†’éšªæ—¥èªŒæ˜¯å¦å±•é–‹ï¼ˆé»˜èªæ”¶èµ·ï¼‰
    accordionState: { hero: true, equipment: false, inventory: false }, // æ‰‹æ©Ÿ accordion å±•é–‹ç‹€æ…‹
    battleTab: 'commands', // æ‰‹æ©Ÿæˆ°é¬¥ tab: 'commands', 'enemies', 'log'
    fieldItemSelection: null, // éæˆ°é¬¥é“å…·ä½¿ç”¨é¸æ“‡ç›®æ¨™ï¼ˆitemIdï¼‰
    fieldSkillSelection: null, // éæˆ°é¬¥æŠ€èƒ½ä½¿ç”¨é¸æ“‡ç›®æ¨™ï¼ˆ{skillId, characterType}ï¼‰
    settings: null, // è¨­å®šå°è©±æ¡†ç‹€æ…‹
    deathInfo: null, // æ­»äº¡ä¿¡æ¯ï¼ˆæ­»äº¡åŸå› ã€æ”»æ“Šè€…ã€å‚·å®³ç­‰ï¼‰
    gameStats: null, // éŠæˆ²çµ±è¨ˆä¿¡æ¯
    stageStory: null, // ç« ç¯€æ•…äº‹ç‹€æ…‹ {stage: number, story: string}
  },
  settings: {
    difficulty: 'normal', // é›£åº¦ï¼š'normal', 'hard', 'hell'ï¼ˆå”¯ä¸€å¯è¨­å®šçš„é …ç›®ï¼‰
  },
  log: [],
};

const AREA_CONFIG = {
  field: {
    name: 'é’ç¿ å¹³åŸ',
    background: 'src/assets/background/field.png',
    stage: 1,
  },
  forest: {
    name: 'å¹½æš—æ£®æ—',
    background: 'src/assets/background/forest.png',
    stage: 2,
  },
  mountain: {
    name: 'éšªå³»å±±è„ˆ',
    background: 'src/assets/background/mountain.png',
    stage: 3,
  },
  cave: {
    name: 'æ·±é‚ƒæ´çªŸ',
    background: 'src/assets/background/cave.png',
    stage: 4,
  },
  maze: {
    name: 'è¿·å®®è¿´å»Š',
    background: 'src/assets/background/maze.png',
    stage: 5,
  },
  castle: {
    name: 'é­”ç‹åŸ',
    background: 'src/assets/background/castle.png',
    stage: 6,
  },
};

// ç« ç¯€æ•…äº‹æ•¸æ“šï¼ˆæƒ¡æå‹‡è€…é¬¥æƒ¡é¾é¢¨æ ¼ï¼‰
const STAGE_STORIES = {
  1: {
    title: 'ç¬¬ä¸€ç« ï¼šé’ç¿ å¹³åŸçš„ç¶ é¾',
    story: `åœ¨é™é çš„éå»ï¼Œæœ‰ä¸€å€‹å‚³èªª...

å‚³èªªä¸­ï¼Œé’ç¿ å¹³åŸä¸Šä½è‘—ä¸€éš»ç¶ é¾ğŸ‰ï¼Œç‰ è‡ªç¨±æ˜¯ã€Œç’°ä¿å¤§ä½¿ã€ï¼Œæ¯å¤©åªåƒæœ‰æ©Ÿå²èŠå§†ï¼Œé‚„å …æŒç”¨å¯å›æ”¶çš„ç«ç„°åæ¯ã€‚

æ‘æ°‘å€‘åŸæœ¬ä»¥ç‚ºç‰ å¾ˆå‹å–„ï¼Œç›´åˆ°ç‰ é–‹å§‹æ”¶ã€Œç’°å¢ƒä¿è­·è²»ã€â€”â€”æ¯æˆ¶äººå®¶æ¯å¤©è¦ä¸Šç¹³10æšé‡‘å¹£ï¼Œå¦å‰‡å°±ã€Œç’°ä¿ã€æ‰ä½ çš„æˆ¿å­ã€‚

åœ‹ç‹å¯¦åœ¨å—ä¸äº†äº†ï¼Œæ–¼æ˜¯è²¼å‡ºå‘Šç¤ºï¼šã€Œèª°èƒ½æ“Šæ•—é€™éš»å‡ç’°ä¿çœŸæ¶åŠ«çš„ç¶ é¾ï¼Œå°±è³ä»–100æšé‡‘å¹£ï¼ã€

ä½ ï¼Œä¸€å€‹å‰›å¾æ–°æ‰‹æ‘ç•¢æ¥­çš„å‹‡è€…ï¼Œçœ‹åˆ°é€™å€‹å‘Šç¤ºå¾Œå¿ƒæƒ³ï¼šã€Œ100æšé‡‘å¹£ï¼Ÿå¤ æˆ‘è²·å¥½å¹¾æŠŠæœ¨åŠäº†ï¼ã€

æ–¼æ˜¯ï¼Œä½ è¸ä¸Šäº†å‰å¾€é’ç¿ å¹³åŸçš„æ—…ç¨‹...

ã€Œåæ­£ç‰ åªæ˜¯éš»ç¶ é¾ï¼Œæ‡‰è©²ä¸æœƒå¤ªå¼·å§ï¼Ÿã€ä½ é€™æ¨£æƒ³è‘—ï¼Œå®Œå…¨æ²’æ³¨æ„åˆ°å‘Šç¤ºä¸Šé‚„æœ‰ä¸€è¡Œå°å­—ï¼šã€Œå·²é™£äº¡å‹‡è€…ï¼š47äººã€`
  },
  2: {
    title: 'ç¬¬äºŒç« ï¼šå¹½æš—æ£®æ—çš„ç›œè³Šé ­ç›®',
    story: `æ“Šæ•—ç¶ é¾å¾Œï¼Œä½ ä»¥ç‚ºå¯ä»¥ä¼‘æ¯äº†ã€‚

æ²’æƒ³åˆ°ï¼Œæ›´éº»ç…©çš„äº‹ä¾†äº†...

å¹½æš—æ£®æ—è£¡å‡ºç¾äº†ä¸€å€‹è‡ªç¨±ã€Œå¹²é”å¦ã€çš„ç›œè³Šé ­ç›®ğŸ—¡ï¸ğŸ‘‘ï¼Œä»–å¸¶è‘—å…©å€‹å°æƒ¡é­”æ‰‹ä¸‹ï¼Œå°ˆé–€æ¶åŠ«è·¯éçš„å‹‡è€…ã€‚

æœ€å¯æƒ¡çš„æ˜¯ï¼Œä»–æ¶å®Œæ±è¥¿é‚„æœƒèªªï¼šã€Œè¬è¬æƒ é¡§ï¼æ­¡è¿ä¸‹æ¬¡å†ä¾†ï¼ã€

ä½ åŸæœ¬æƒ³ç¹è·¯ï¼Œä½†ç™¼ç¾æ‰€æœ‰é€šå¾€ä¸‹ä¸€é—œçš„è·¯éƒ½è¢«ä»–å°é–äº†ã€‚æ›´æ°£äººçš„æ˜¯ï¼Œä»–é‚„ç«‹äº†å€‹ç‰Œå­ï¼š

ã€Œæ­¤è·¯æ˜¯æˆ‘é–‹ï¼Œæ­¤æ¨¹æ˜¯æˆ‘æ ½ï¼Œè¦å¾æ­¤è·¯éï¼Œç•™ä¸‹è²·è·¯è²¡ï¼ã€

ä½ çœ‹è‘—è‡ªå·±å¥½ä¸å®¹æ˜“å¾ç¶ é¾é‚£è£¡è³ºä¾†çš„100æšé‡‘å¹£ï¼Œå¿ƒæƒ³ï¼šã€Œé€™å‚¢ä¼™æ¯”ç¶ é¾é‚„éåˆ†ï¼è‡³å°‘ç¶ é¾é‚„çŸ¥é“ä»€éº¼æ˜¯ç’°ä¿ï¼ã€

æ–¼æ˜¯ï¼Œä½ æ±ºå®šè¦çµ¦é€™å€‹ç›œè³Šé ­ç›®ä¸€é»é¡è‰²ç§ç§ã€‚

ã€Œé€™æ¬¡æˆ‘è¦è®“ä»–çŸ¥é“ï¼Œä¸æ˜¯æ‰€æœ‰å‹‡è€…éƒ½é‚£éº¼å¥½æ¬ºè² çš„ï¼ã€`
  },
  3: {
    title: 'ç¬¬ä¸‰ç« ï¼šéšªå³»å±±è„ˆçš„å…«æ­§å¤§è›‡',
    story: `ç¶“éä¸€ç•ªè‹¦æˆ°ï¼Œä½ çµ‚æ–¼æ‰“æ•—äº†å¹²é”å¦ã€‚

æ­£ç•¶ä½ ä»¥ç‚ºå¯ä»¥ç¹¼çºŒå‰é€²æ™‚ï¼Œä¸€å€‹æ‘æ°‘æ…Œæ…Œå¼µå¼µåœ°è·‘ä¾†å‘Šè¨´ä½ ï¼š

ã€Œå‹‡è€…å¤§äººï¼ä¸å¥½äº†ï¼éšªå³»å±±è„ˆä¸Šå‡ºç¾äº†ä¸€éš»å…«æ­§å¤§è›‡ğŸ‰ğŸ‰ğŸ‰ï¼ã€

ä½ ï¼šã€Œå…«æ­§å¤§è›‡ï¼Ÿè½èµ·ä¾†å¾ˆå²å®³çš„æ¨£å­...ã€

æ‘æ°‘ï¼šã€Œç‰ æœ‰å…«å€‹é ­ï¼æ¯å€‹é ­éƒ½æœƒå™´ç«ï¼è€Œä¸”ç‰ é‚„æœƒé€£çºŒæ”»æ“Šå…©æ¬¡ï¼ã€

ä½ ï¼šã€Œ...é‚£ç‰ ç‚ºä»€éº¼è¦æ”»æ“Šäººé¡ï¼Ÿã€

æ‘æ°‘ï¼šã€Œå› ç‚ºç‰ èªªäººé¡å¤ªåµäº†ï¼Œæ‰“æ“¾ç‰ ç¡è¦ºã€‚ç‰ åŸæœ¬åªæ˜¯æƒ³ç¡å€‹åˆè¦ºï¼Œçµæœè¢«è·¯éçš„å•†äººåµé†’ï¼Œä¸€æ°£ä¹‹ä¸‹å°±é–‹å§‹æ”»æ“Šæ‰€æœ‰ç¶“éçš„äººã€‚ã€

ä½ ï¼šã€Œ...æ‰€ä»¥ç‰ åªæ˜¯æƒ³å®‰éœåœ°ç¡å€‹è¦ºï¼Ÿã€

æ‘æ°‘ï¼šã€Œå°å•Šï¼ä½†å•é¡Œæ˜¯ç‰ çš„å‘¼åš•è²æ¯”æ‰“é›·é‚„å¤§ï¼Œè€Œä¸”ç‰ ç¡è¦ºæ™‚æœƒä¸è‡ªè¦ºåœ°å™´ç«ï¼Œå·²ç¶“ç‡’æ‰ä¸‰å€‹æ‘èŠäº†ï¼ã€

ä½ ï¼šã€Œ...å¥½å§ï¼Œçœ‹ä¾†æˆ‘é‚„æ˜¯å¾—å»è§£æ±ºç‰ ã€‚ã€

æ–¼æ˜¯ï¼Œä½ è¸ä¸Šäº†éšªå³»å±±è„ˆï¼Œæº–å‚™å»ã€Œå«é†’ã€é€™éš»æ„›ç¡è¦ºçš„å…«æ­§å¤§è›‡ã€‚

ã€Œå¸Œæœ›ç‰ èµ·åºŠæ°£ä¸è¦å¤ªå¤§...ã€ä½ é€™æ¨£æƒ³è‘—ã€‚`
  },
  4: {
    title: 'ç¬¬å››ç« ï¼šæ·±é‚ƒæ´çªŸçš„é­”ç‹å·´æ‹‰æ‘©æ–¯',
    story: `æ“Šæ•—å…«æ­§å¤§è›‡å¾Œï¼Œä½ ç™¼ç¾ç‰ å…¶å¯¦åªæ˜¯æƒ³æ‰¾å€‹å®‰éœçš„åœ°æ–¹ç¡è¦ºã€‚

ä½ å¹«ç‰ åœ¨å±±ä¸Šè“‹äº†å€‹éš”éŸ³æ´ï¼Œç‰ å¾ˆæ»¿æ„ï¼Œé‚„é€äº†ä½ ä¸€äº›å¯¶ç‰©ã€‚

ä½†å¥½æ™¯ä¸é•·ï¼Œä½ è½èªªæ·±é‚ƒæ´çªŸè£¡å‡ºç¾äº†ä¸€å€‹çœŸæ­£çš„é­”ç‹â€”â€”å·´æ‹‰æ‘©æ–¯ğŸ‘‘ğŸ˜ˆã€‚

é€™å€‹é­”ç‹éå¸¸ç‰¹åˆ¥ï¼Œä»–è‡ªç¨±æ˜¯ã€Œé­”æ³•å­¸é™¢ç•¢æ¥­ç”Ÿã€ï¼Œæœƒä½¿ç”¨å„ç¨®é«˜ç´šé­”æ³•ï¼ŒåŒ…æ‹¬ã€Œæ¥µå¤§çˆ†ç‚¸ã€å’Œã€Œæ··äº‚å’’æ–‡ã€ã€‚

æœ€è®“äººé ­ç—›çš„æ˜¯ï¼Œä»–æ¯å›åˆå¯ä»¥è¡Œå‹•å…©æ¬¡ï¼Œè€Œä¸”é‚„æœƒè£œè¡€ï¼

ä½ åŸæœ¬æƒ³ï¼šã€Œé€™å‚¢ä¼™æ‡‰è©²å¾ˆå¼·ï¼Œæˆ‘é‚„æ˜¯å…ˆç·´ç·´ç´šå†ä¾†å§ã€‚ã€

ä½†ç•¶ä½ çœ‹åˆ°æ´çªŸå…¥å£çš„å‘Šç¤ºç‰Œæ™‚ï¼Œä½ æ”¹è®Šäº†ä¸»æ„ï¼š

ã€Œå·´æ‹‰æ‘©æ–¯é­”æ³•å­¸é™¢æ‹›ç”Ÿä¸­ï¼å­¸è²»ï¼šä½ çš„ç”Ÿå‘½å€¼ï¼ã€

ä½ ï¼šã€Œ...é€™å‚¢ä¼™æ¯”å¹²é”å¦é‚„éåˆ†ï¼è‡³å°‘å¹²é”å¦é‚„çŸ¥é“ä»€éº¼æ˜¯å…¬å¹³äº¤æ˜“ï¼ã€

æ–¼æ˜¯ï¼Œä½ æ±ºå®šè¦çµ¦é€™å€‹ã€Œé­”æ³•å­¸é™¢ç•¢æ¥­ç”Ÿã€ä¸€é»æ•™è¨“ã€‚

ã€Œé€™æ¬¡æˆ‘è¦è®“ä»–çŸ¥é“ï¼Œä¸æ˜¯æ‰€æœ‰å‹‡è€…éƒ½é‚£éº¼å¥½é¨™çš„ï¼ã€`
  },
  5: {
    title: 'ç¬¬äº”ç« ï¼šè¿·å®®è¿´å»Šçš„å¤§é­”ç‹ä½ç‘ª',
    story: `ç¶“éèˆ‡å·´æ‹‰æ‘©æ–¯çš„æ¿€æˆ°ï¼Œä½ çµ‚æ–¼æ‰“æ•—äº†é€™å€‹ã€Œé­”æ³•å­¸é™¢ç•¢æ¥­ç”Ÿã€ã€‚

ä½†ç•¶ä½ ä»¥ç‚ºå¯ä»¥é¬†ä¸€å£æ°£æ™‚ï¼Œä½ ç™¼ç¾çœŸæ­£çš„è€ƒé©—æ‰å‰›é–‹å§‹...

è¿·å®®è¿´å»Šè£¡ä½è‘—ä¸€å€‹è‡ªç¨±ã€Œå¤§é­”ç‹ä½ç‘ªã€çš„å‚¢ä¼™ğŸ‘‘â„ï¸ï¼Œä»–æ“æœ‰å‡çµæ³¢å‹•çš„èƒ½åŠ›ï¼Œå¯ä»¥æ¶ˆé™¤ä½ æ‰€æœ‰çš„å¢ç›Šæ•ˆæœã€‚

æœ€å¯æƒ¡çš„æ˜¯ï¼Œä»–é‚„æœƒä½¿ç”¨å†°ç³»æœ€å¼·å’’æ–‡ï¼Œè€Œä¸”æ¯å›åˆå¯ä»¥è¡Œå‹•å…©æ¬¡ï¼

ä½ åŸæœ¬æƒ³ï¼šã€Œé€™å‚¢ä¼™è½èµ·ä¾†å°±å¾ˆå¼·ï¼Œæˆ‘é‚„æ˜¯å…ˆæº–å‚™ä¸€ä¸‹å†ä¾†å§ã€‚ã€

ä½†ç•¶ä½ çœ‹åˆ°è¿·å®®å…¥å£çš„å‘Šç¤ºç‰Œæ™‚ï¼Œä½ æ”¹è®Šäº†ä¸»æ„ï¼š

ã€Œå¤§é­”ç‹ä½ç‘ªçš„å†·æ°£æˆ¿ï¼å…¥å ´è²»ï¼šä½ çš„æ‰€æœ‰Buffï¼ã€

ä½ ï¼šã€Œ...é€™å‚¢ä¼™æ¯”å·´æ‹‰æ‘©æ–¯é‚„éåˆ†ï¼è‡³å°‘å·´æ‹‰æ‘©æ–¯é‚„çŸ¥é“ä»€éº¼æ˜¯é­”æ³•å­¸é™¢ï¼ã€

æ›´æ°£äººçš„æ˜¯ï¼Œç•¶ä½ é€²å…¥è¿·å®®å¾Œï¼Œä½ ç™¼ç¾é€™è£¡å†·å¾—è¦å‘½ï¼Œè€Œä¸”åˆ°è™•éƒ½æ˜¯å†°å¡Šã€‚

ä½ ï¼šã€Œé€™è£¡æ˜¯å†·å‡åº«å—ï¼Ÿï¼ã€

ä½ç‘ªçš„è²éŸ³å¾é è™•å‚³ä¾†ï¼šã€Œæ­¡è¿ä¾†åˆ°æˆ‘çš„å†·æ°£æˆ¿ï¼é€™è£¡æ†æº«é›¶ä¸‹20åº¦ï¼Œä¿è­‰è®“ä½ å†·åˆ°éª¨å­è£¡ï¼ã€

ä½ ï¼šã€Œ...æˆ‘ç¾åœ¨çŸ¥é“ç‚ºä»€éº¼ä»–å«ã€å¤§é­”ç‹ã€äº†ã€‚ã€

æ–¼æ˜¯ï¼Œä½ æ±ºå®šè¦çµ¦é€™å€‹ã€Œå†·æ°£æˆ¿ç®¡ç†å“¡ã€ä¸€é»é¡è‰²ç§ç§ã€‚

ã€Œé€™æ¬¡æˆ‘è¦è®“ä»–çŸ¥é“ï¼Œä¸æ˜¯æ‰€æœ‰å‹‡è€…éƒ½é‚£éº¼æ€•å†·çš„ï¼ã€`
  },
  6: {
    title: 'ç¬¬å…­ç« ï¼šé­”ç‹åŸçš„æœ€çµ‚æ±ºæˆ°',
    story: `ç¶“éèˆ‡å¤§é­”ç‹ä½ç‘ªçš„æ¿€æˆ°ï¼Œä½ çµ‚æ–¼æ‰“æ•—äº†é€™å€‹ã€Œå†·æ°£æˆ¿ç®¡ç†å“¡ã€ã€‚

ä½†ç•¶ä½ ä»¥ç‚ºå¯ä»¥çµæŸé€™ä¸€åˆ‡æ™‚ï¼Œä½ ç™¼ç¾çœŸæ­£çš„è€ƒé©—æ‰å‰›é–‹å§‹...

é­”ç‹åŸè£¡ä½è‘—ä¸€å€‹è‡ªç¨±ã€Œé»‘æš—å¤šé›·å§†ã€çš„å‚¢ä¼™ğŸ‘‘ğŸ’€ğŸ”¥ï¼Œä»–è‡ªç¨±æ˜¯ã€Œç ´å£ç¥ã€ï¼Œå¯¦åŠ›å‡Œé§•æ–¼æ‰€æœ‰é­”ç‹ä¹‹ä¸Šã€‚

æœ€å¯æ€•çš„æ˜¯ï¼Œä»–æ“æœ‰æ‰€æœ‰æœ€å¼·ç‰¹æŠ€ï¼Œè€Œä¸”æ¯å›åˆå¯ä»¥è¡Œå‹•å¤šæ¬¡ï¼

ä½ åŸæœ¬æƒ³ï¼šã€Œé€™å‚¢ä¼™è½èµ·ä¾†å°±å¾ˆå¼·ï¼Œæˆ‘é‚„æ˜¯å…ˆæº–å‚™ä¸€ä¸‹å†ä¾†å§ã€‚ã€

ä½†ç•¶ä½ çœ‹åˆ°é­”ç‹åŸå…¥å£çš„å‘Šç¤ºç‰Œæ™‚ï¼Œä½ æ”¹è®Šäº†ä¸»æ„ï¼š

ã€Œé»‘æš—å¤šé›·å§†çš„ç ´å£ç¥å…¬å¸ï¼æœå‹™é …ç›®ï¼šç ´å£ä½ çš„æ‰€æœ‰å¸Œæœ›ï¼ã€

ä½ ï¼šã€Œ...é€™å‚¢ä¼™æ¯”ä½ç‘ªé‚„éåˆ†ï¼è‡³å°‘ä½ç‘ªé‚„çŸ¥é“ä»€éº¼æ˜¯å†·æ°£æˆ¿ï¼ã€

æ›´æ°£äººçš„æ˜¯ï¼Œç•¶ä½ é€²å…¥é­”ç‹åŸå¾Œï¼Œä½ ç™¼ç¾é€™è£¡åˆ°è™•éƒ½æ˜¯é™·é˜±ï¼Œè€Œä¸”æ¯å€‹æˆ¿é–“éƒ½æœ‰ä¸åŒçš„é­”ç‹åœ¨ç­‰ä½ ã€‚

ä½ ï¼šã€Œé€™è£¡æ˜¯é­”ç‹ä¸»é¡Œæ¨‚åœ’å—ï¼Ÿï¼ã€

å¤šé›·å§†çš„è²éŸ³å¾é è™•å‚³ä¾†ï¼šã€Œæ­¡è¿ä¾†åˆ°æˆ‘çš„ç ´å£ç¥å…¬å¸ï¼é€™è£¡æœ‰å„ç¨®æœå‹™ï¼Œä¿è­‰è®“ä½ æ»¿æ„ï¼ã€

ä½ ï¼šã€Œ...æˆ‘ç¾åœ¨çŸ¥é“ç‚ºä»€éº¼ä»–å«ã€ç ´å£ç¥ã€äº†ã€‚ã€

æ–¼æ˜¯ï¼Œä½ æ±ºå®šè¦çµ¦é€™å€‹ã€Œç ´å£ç¥å…¬å¸è€é—†ã€ä¸€é»é¡è‰²ç§ç§ã€‚

    ã€Œé€™æ¬¡æˆ‘è¦è®“ä»–çŸ¥é“ï¼Œä¸æ˜¯æ‰€æœ‰å‹‡è€…éƒ½é‚£éº¼å¥½æ¬ºè² çš„ï¼ã€

ã€Œè€Œä¸”ï¼Œæˆ‘å·²ç¶“å—å¤ äº†é€™äº›è‡ªç¨±ã€é­”ç‹ã€çš„å‚¢ä¼™äº†ï¼ã€`
  }
};
console.log('[MAIN.JS] é–‹å§‹ç²å– DOM å…ƒç´ ...');
console.log('[MAIN.JS] document.readyState:', document.readyState);
console.log('[MAIN.JS] document.getElementById("btn-new"):', document.getElementById('btn-new'));

const dom = {
  backgroundContainer: document.getElementById('background-container'),
  backgroundImage: document.getElementById('background-image'),
  routeDialog: document.getElementById('route-dialog'),
  routeTitle: document.getElementById('route-title'),
  routeDescription: document.getElementById('route-description'),
  routeOptions: document.getElementById('route-options'),
  battleUI: document.getElementById('battle-ui'),
  battleHeroStats: document.getElementById('battle-hero-stats'),
  battleEnemySprites: document.getElementById('battle-enemy-sprites'),
  battleCommands: document.getElementById('battle-commands'),
  battleEnemies: document.getElementById('battle-enemies'),
  battleLog: document.getElementById('battle-log'),
  fieldActionsPanel: document.getElementById('field-actions-panel'),
  heroPanel: document.getElementById('hero-panel'),
  skillsPanel: document.getElementById('skills-panel'),
  activeSkillsPanel: document.getElementById('active-skills-panel'),
  passiveSkillsPanel: document.getElementById('passive-skills-panel'),
  equipmentPanel: document.getElementById('equipment-panel'),
  inventoryPanel: document.getElementById('inventory-panel'),
  itemsPanel: document.getElementById('items-panel'),
  logList: document.getElementById('log-list'),
  logPanelHeader: document.getElementById('log-panel-header'),
  modalLayer: document.getElementById('modal-layer'),
  levelModal: document.getElementById('level-modal'),
  startScreen: document.getElementById('start-screen'),
  continueBtn: document.getElementById('btn-continue'),
  newBtn: document.getElementById('btn-new'),
  settingsBtn: document.getElementById('btn-settings'),
  saveInfo: document.getElementById('save-info'),
};

console.log('[MAIN.JS] DOM å…ƒç´ ç²å–å®Œæˆ');
console.log('[MAIN.JS] dom.newBtn:', dom.newBtn);
console.log('[MAIN.JS] dom.settingsBtn:', dom.settingsBtn);
console.log('[MAIN.JS] dom.continueBtn:', dom.continueBtn);

// === RWD: Device type detection ===
function getDeviceType() {
  const w = window.innerWidth;
  if (w < 768) return 'mobile';
  if (w <= 1024) return 'tablet';
  return 'desktop';
}
let currentDeviceType = getDeviceType();

window.addEventListener('resize', () => {
  const newType = getDeviceType();
  if (newType !== currentDeviceType) {
    currentDeviceType = newType;
    renderAll();
  }
});

// === RWD: Accordion toggle (mobile status panels) ===
function toggleAccordion(panelId) {
  if (!state.ui.accordionState) return;
  state.ui.accordionState[panelId] = !state.ui.accordionState[panelId];
  renderAll();
}
window.toggleAccordion = toggleAccordion;

// === RWD: Battle tab switch (mobile) ===
function switchBattleTab(tab) {
  state.ui.battleTab = tab;
  renderAll();
}
window.switchBattleTab = switchBattleTab;

// ç²å–æŸå€‹æµæ´¾çš„ä¸€éšè¢«å‹•æŠ€èƒ½ï¼ˆtier 1, requiredLevel 0ï¼‰
function getTier1PassiveSkillsByFlow(flow) {
  const candidates = [];
  
  SKILL_CHAINS.forEach((chain) => {
    if (chain.flow === flow) {
      chain.steps.forEach((step) => {
        // åªé¸æ“‡ä¸€éšè¢«å‹•æŠ€èƒ½ï¼ˆtier 1, requiredLevel 0, kind === 'passive'ï¼‰
        if (step.tier === 1 && step.requiredLevel === 0 && step.kind === 'passive') {
          candidates.push({
            ...step,
            flow: chain.flow,
            chainId: chain.id,
          });
        }
      });
    }
  });
  
  return candidates;
}

// ç²å–æŸå€‹æµæ´¾çš„ä¸€éšå–®é«”æŠ€èƒ½ï¼ˆtier 1, requiredLevel 0, aoe: falseï¼‰
function getTier1SingleTargetSkillsByFlow(flow) {
  const candidates = [];
  
  SKILL_CHAINS.forEach((chain) => {
    if (chain.flow === flow && !chain.aoe) {
      chain.steps.forEach((step) => {
        // åªé¸æ“‡ä¸€éšå–®é«”æŠ€èƒ½ï¼ˆtier 1, requiredLevel 0, ä¸æ˜¯è¢«å‹•æŠ€èƒ½ï¼‰
        if (step.tier === 1 && step.requiredLevel === 0 && step.kind !== 'passive') {
          candidates.push({
            ...step,
            flow: chain.flow,
            chainId: chain.id,
          });
        }
      });
    }
  });
  
  return candidates;
}

// DQé¢¨æ ¼çš„åå­—åˆ—è¡¨ï¼ˆ20å€‹ï¼‰
const DQ_NAMES = [
  'ç´¢ç¾…', 'èŠå®‰', 'ç‰¹é­¯å…§å…‹', 'ç‘ªå¦®é›…', 'é˜¿è‰å¨œ',
  'å¸ƒèŠ', 'å…‹é‡Œå¤«ç‰¹', 'ç±³å¦®é›…', 'ç¾…å¾·', 'è‰¾è‰çµ²',
  'é”æ–¯', 'ç‘ªè‰äº', 'å¡ç¾æ‹‰', 'å¥§åˆ©ç¶­', 'éœ²è¥¿äº',
  'é›·æ­', 'è‰¾ç±³', 'å‚‘å…‹', 'èæ‹‰', 'äºç•¶'
];

// éš¨æ©Ÿç²å–ä¸€å€‹DQé¢¨æ ¼çš„åå­—
function getRandomDQName() {
  return DQ_NAMES[Math.floor(Math.random() * DQ_NAMES.length)];
}

// ç²å–ä¸€å€‹ä¸èˆ‡ç¾æœ‰è§’è‰²é‡è¤‡çš„åå­—
function getUniqueDQName(excludeNames = []) {
  const used = new Set(excludeNames.filter(Boolean));
  const candidates = DQ_NAMES.filter(name => !used.has(name));
  if (candidates.length > 0) {
    return candidates[Math.floor(Math.random() * candidates.length)];
  }
  // å¦‚æœ20å€‹åå­—éƒ½ç”¨å®Œäº†ï¼Œå°±åœ¨èˆŠåå­—å¾Œé¢åŠ ç·¨è™Ÿ
  const baseName = DQ_NAMES[Math.floor(Math.random() * DQ_NAMES.length)];
  let suffix = 2;
  let uniqueName = `${baseName}${suffix}`;
  while (used.has(uniqueName) && suffix < 100) {
    suffix += 1;
    uniqueName = `${baseName}${suffix}`;
  }
  return uniqueName;
}

function createHero(gender = 'male', heroType = null) {
  // å‹‡è€…é¡å‹åˆ°æµæ´¾çš„æ˜ å°„ï¼ˆçµ±ä¸€æå–ï¼Œé¿å…é‡è¤‡ï¼‰
  const flowMap = {
    attacker: 'sword',
    defender: 'defender', // é˜²å®ˆå‹è¢«å‹•æŠ€èƒ½ä½¿ç”¨ defender flow
    mage: 'magic',
    healer: 'recovery',
    agile: 'agility',
  };
  
  // å‹‡è€…ä¸€é–‹å§‹çš„åŸºæœ¬èƒ½åŠ›éƒ½æ˜¯7
  const attributes = {
    attack: 7,
    vitality: 7,
    defense: 7,
    recovery: 7,
    magic: 7,
    agility: 7,
  };
  const stats = { 
    ...BASE_STATS,
    hp: Math.ceil(BASE_STATS.hp),
    maxHp: Math.ceil(BASE_STATS.maxHp),
    mp: Math.ceil(BASE_STATS.mp),
    maxMp: Math.ceil(BASE_STATS.maxMp),
    gold: BASE_STATS.gold != null ? BASE_STATS.gold : 0,
    shield: 0, // è­·ç›¾å€¼
  };
  
  // æ‰€æœ‰å‹‡è€…ä¸€é–‹å§‹å°±æ“æœ‰çš„æŠ€èƒ½
  const skills = [
    'hero_strike_1',      // å‹‡è€…æ–¬
    'heal_1',             // æ²»ç™‚è¡“
    'fireball_1',         // ç«çƒï¼ˆæ‰€æœ‰å‹‡è€…å¿…å®šç²å¾—ï¼‰
  ];
  
  // æ ¹æ“šå‹‡è€…é¡å‹å¾ heroTypes.js è®€å–å°ˆå±¬æŠ€èƒ½
  if (heroType && HERO_TYPES[heroType] && HERO_TYPES[heroType].initialSkills) {
    HERO_TYPES[heroType].initialSkills.forEach(skillId => {
      if (!skills.includes(skillId)) {
        skills.push(skillId);
      }
    });
  }
  
  // æ ¹æ“šå‹‡è€…é¡å‹æ‡‰ç”¨åŠ æˆå’Œç²å¾—è¢«å‹•æŠ€èƒ½
  let passiveSkill = null;
  if (heroType && HERO_TYPES[heroType]) {
    const type = HERO_TYPES[heroType];
    
    // æ‡‰ç”¨åˆå§‹å±¬æ€§åŠ æˆ
    Object.keys(type.initialBonus).forEach((attr) => {
      attributes[attr] += type.initialBonus[attr];
    });
    
    // æ‡‰ç”¨åˆå§‹HPåŠ æˆ
    if (type.initialHpBonus) {
      const hpBonus = Math.ceil(type.initialHpBonus * 10); // æ¯å€‹é»æ•¸ä»£è¡¨10 HPï¼Œå‘ä¸Šå–æ•´
      stats.maxHp = Math.ceil(stats.maxHp + hpBonus);
      stats.hp = Math.ceil(stats.hp + hpBonus);
    }
    
    // æ‡‰ç”¨åˆå§‹MPåŠ æˆ
    if (type.initialMpBonus) {
      const mpBonus = Math.ceil(type.initialMpBonus * 5); // æ¯å€‹é»æ•¸ä»£è¡¨5 MPï¼Œå‘ä¸Šå–æ•´
      stats.maxMp = Math.ceil(stats.maxMp + mpBonus);
    }
    
    // æ ¹æ“šé¡å‹æ˜ å°„åˆ°æµæ´¾ï¼Œéš¨æ©Ÿç²å¾—ä¸€å€‹ä¸€éšè¢«å‹•æŠ€èƒ½
    const flow = flowMap[heroType] || 'sword';
    const tier1Passives = getTier1PassiveSkillsByFlow(flow);
    if (tier1Passives.length > 0) {
      const randomPassive = tier1Passives[Math.floor(Math.random() * tier1Passives.length)];
      skills.push(randomPassive.id);
      
      // å¦‚æœæ˜¯é˜²å®ˆå‹è¢«å‹•æŠ€èƒ½ï¼ˆHPåŠ æˆï¼‰ï¼Œç«‹å³æ‡‰ç”¨æ•ˆæœ
      if (randomPassive.hpBonus !== undefined) {
        stats.maxHp = Math.ceil(stats.maxHp + randomPassive.hpBonus);
        stats.hp = Math.ceil(stats.hp + randomPassive.hpBonus);
      }
      
      // ä¿å­˜è¢«å‹•æŠ€èƒ½ä¿¡æ¯ä»¥ä¾¿è¨˜éŒ„åˆ°æ—¥èªŒ
      passiveSkill = randomPassive;
    }
  }
  
  // MPä¸€é–‹å§‹å°±æ˜¯æ»¿çš„
  stats.mp = Math.ceil(stats.maxMp);
  
  // è£å‚™æ¬„ä½ï¼šæ­¦å™¨ã€ç›¾ã€é˜²å…·ã€é£¾å“ï¼ˆæœ€åˆæœŸæ²’æœ‰è£å‚™ï¼‰
  const equipment = {
    weapon: null,
    shield: null,
    armor: null,
    accessory: null,
  };
  
  // å¦‚æœé…ç½®äº†åˆå§‹è£å‚™éšå±¤ï¼Œå‰‡è£å‚™è©²éšå±¤çš„è©²æµæ´¾è£å‚™
  const initialEquipmentTier = GAME_CONFIG.initialEquipmentTier || 0;
  if (initialEquipmentTier >= 1 && heroType) {
    // è‹±é›„é¡å‹åˆ°è£å‚™é¡å‹çš„æ˜ å°„
    const heroTypeToEquipmentType = {
      attacker: 'attack',
      defender: 'defense',
      mage: 'magic',
      healer: 'magic', // æ²»ç™‚å¸«ä½¿ç”¨é­”æ³•è£å‚™
      agile: 'agility',
    };
    
    const equipmentType = heroTypeToEquipmentType[heroType] || 'attack';
    const tier = Math.min(Math.max(1, initialEquipmentTier), 6); // é™åˆ¶åœ¨1-6ä¹‹é–“
    
    // æ§‹å»ºè£å‚™IDä¸¦æª¢æŸ¥æ˜¯å¦å­˜åœ¨
    const weaponId = `${equipmentType}_weapon_t${tier}`;
    const armorId = `${equipmentType}_armor_t${tier}`;
    const shieldId = `${equipmentType}_shield_t${tier}`;
    const accessoryId = `${equipmentType}_accessory_t${tier}`;
    
    // æª¢æŸ¥è£å‚™æ˜¯å¦å­˜åœ¨ï¼Œå¦‚æœå­˜åœ¨å‰‡è£å‚™
    if (EQUIPMENT_LOOKUP.has(weaponId)) {
      equipment.weapon = weaponId;
    }
    if (EQUIPMENT_LOOKUP.has(armorId)) {
      equipment.armor = armorId;
    }
    if (EQUIPMENT_LOOKUP.has(shieldId)) {
      equipment.shield = shieldId;
    }
    if (EQUIPMENT_LOOKUP.has(accessoryId)) {
      equipment.accessory = accessoryId;
    }
  }
  
  // è£å‚™åº«å­˜ï¼ˆå­˜å„²ç²å¾—çš„è£å‚™ï¼‰
  const equipmentInventory = [];
  
  // ç²¾è‰¯è£å‚™å­˜å„²ï¼ˆå­˜å„²è³¼è²·çš„ç²¾è‰¯è£å‚™æ•¸æ“šï¼‰
  const superiorEquipment = {};
  
  const hero = {
    name: getUniqueDQName(), // å‹‡è€…åå­—ï¼ˆç›®å‰ä¸èˆ‡ä»»ä½•äººè¡çªï¼‰
    gender,
    heroType: heroType || null,
    stats,
    attributes,
    skills,
    items: STARTING_ITEMS.map((entry) => ({ ...entry })),
    equipment,
    equipmentInventory,
    superiorEquipment,
  };
  
  return {
    hero,
    passiveSkill,
  };
}

// å‰µå»ºåŒä¼´
function createCompanion(companionTypeId) {
  const companionType = COMPANION_TYPES[companionTypeId];
  if (!companionType) return null;
  
  const heroType = companionType.heroType;
  // ä¼™ä¼´ä¸€é–‹å§‹çš„åŸºæœ¬èƒ½åŠ›éƒ½æ˜¯5
  const attributes = {
    attack: 5,
    vitality: 5,
    defense: 5,
    recovery: 5,
    magic: 5,
    agility: 5,
  };
  const stats = { 
    ...BASE_STATS,
    hp: Math.ceil(BASE_STATS.hp),
    maxHp: Math.ceil(BASE_STATS.maxHp),
    mp: Math.ceil(BASE_STATS.mp),
    maxMp: Math.ceil(BASE_STATS.maxMp),
    shield: 0, // è­·ç›¾å€¼
  };
  
  // ä½¿ç”¨åŒä¼´è‡ªå·±çš„é¡å‹åŠ æˆï¼ˆç¨ç«‹æ–¼å‹‡è€…é¡å‹ï¼‰
  if (companionType.initialBonus) {
    Object.keys(companionType.initialBonus).forEach((attr) => {
      attributes[attr] += companionType.initialBonus[attr];
    });
  }
  
  // æ‡‰ç”¨åˆå§‹HP/MPåŠ æˆ
  if (companionType.initialHpBonus) {
    // å¦‚æœå€¼>=10ï¼Œç›´æ¥ä½œä¸ºHPæ•°å€¼ä½¿ç”¨ï¼›å¦‚æœ<10ï¼Œä¹˜ä»¥10ï¼ˆå…¼å®¹æ—§æ ¼å¼ï¼‰
    const hpBonus = companionType.initialHpBonus >= 10
      ? Math.ceil(companionType.initialHpBonus)
      : Math.ceil(companionType.initialHpBonus * 10);
    stats.maxHp = Math.ceil(stats.maxHp + hpBonus);
    stats.hp = Math.ceil(stats.hp + hpBonus);
  }
  if (companionType.initialMpBonus) {
    const mpBonus = Math.ceil(companionType.initialMpBonus * 5); // æ¯å€‹é»æ•¸ä»£è¡¨5 MPï¼Œå‘ä¸Šå–æ•´
    stats.maxMp = Math.ceil(stats.maxMp + mpBonus);
  }
  
  // MPä¸€é–‹å§‹å°±æ˜¯æ»¿çš„
  stats.mp = Math.ceil(stats.maxMp);
  
  // æ ¹æ“šé¡å‹æ˜ å°„åˆ°æµæ´¾
  const flowMap = {
    attacker: 'sword',
    defender: 'defender',
    mage: 'magic',
    healer: 'recovery',
    agile: 'agility',
    sage: ['magic', 'recovery'], // è³¢è€…å¯ä»¥å­¸ç¿’é­”æ³•å’Œå›å¾©å…©ç¨®æµæ´¾
    paladin: ['defender', 'recovery'], // è–é¨å£«å¯ä»¥å­¸ç¿’é˜²å®ˆå’Œå›å¾©å…©ç¨®æµæ´¾
    weaponmaster: ['sword', 'agility'], // æ­¦å™¨å¤§å¸«å¯ä»¥å­¸ç¿’åŠå£«å’Œç›œè³Šå…©ç¨®æµæ´¾
  };
  
  // ç²å–ä¸»è¦æµæ´¾ï¼ˆå¯èƒ½æ˜¯å–®ä¸€æµæ´¾æˆ–æµæ´¾æ•¸çµ„ï¼‰
  const primaryFlowOrFlows = flowMap[heroType] || 'sword';
  const primaryFlows = Array.isArray(primaryFlowOrFlows) ? primaryFlowOrFlows : [primaryFlowOrFlows];
  const flow = primaryFlows[0]; // ç”¨æ–¼å‘å¾Œå…¼å®¹çš„å–®ä¸€æµæ´¾è®Šé‡
  
  const skills = [];
  
  // æ ¹æ“šåŒä¼´é¡å‹å¾ COMPANION_TYPES è®€å–å°ˆå±¬æŠ€èƒ½
  if (companionType.initialSkills && Array.isArray(companionType.initialSkills)) {
    // å¦‚æœå®šç¾©äº† initialSkillsï¼Œç›´æ¥ä½¿ç”¨
    companionType.initialSkills.forEach(skillId => {
      skills.push(skillId);
    });
  } else {
    // å¦‚æœæ²’æœ‰å®šç¾© initialSkillsï¼Œä½¿ç”¨èˆŠçš„å‹•æ…‹ç²å–é‚è¼¯ï¼ˆå‘å¾Œå…¼å®¹ï¼‰
  if (heroType === 'attacker') {
    // åŠå£«ç³»åŒä¼´ç²å¾—æ–¬æ“Š
    skills.push('slash_1');
  } else if (heroType === 'mage') {
    // é­”æ³•ç³»åŒä¼´ç²å¾—å†°çƒ
    skills.push('iceball_1');
  } else if (heroType === 'healer') {
    // æ²»ç™‚å‹åŒä¼´ç²å¾—è–æ“Š
    skills.push('enhanced_heal_1');
  } else if (heroType === 'sage') {
    // è³¢è€…ç²å¾—é­”æ³•å’Œå›å¾©å„ä¸€å€‹æŠ€èƒ½
    const magicSkills = getTier1SingleTargetSkillsByFlow('magic');
    const recoverySkills = getTier1SingleTargetSkillsByFlow('recovery');
    if (magicSkills.length > 0) {
      skills.push(magicSkills[0].id);
    }
    if (recoverySkills.length > 0) {
      skills.push(recoverySkills[0].id);
    }
  } else if (heroType === 'paladin') {
    // è–é¨å£«ç²å¾—é˜²å®ˆå’Œå›å¾©å„ä¸€å€‹æŠ€èƒ½
    const defenderSkills = getTier1SingleTargetSkillsByFlow('defender');
    const recoverySkills = getTier1SingleTargetSkillsByFlow('recovery');
    if (defenderSkills.length > 0) {
      skills.push(defenderSkills[0].id);
    }
    if (recoverySkills.length > 0) {
      skills.push(recoverySkills[0].id);
    }
  } else if (heroType === 'weaponmaster') {
    // æ­¦å™¨å¤§å¸«ç²å¾—åŠå£«å’Œç›œè³Šå„ä¸€å€‹æŠ€èƒ½
    const swordSkills = getTier1SingleTargetSkillsByFlow('sword');
    const agilitySkills = getTier1SingleTargetSkillsByFlow('agility');
    if (swordSkills.length > 0) {
      skills.push(swordSkills[0].id);
    }
    if (agilitySkills.length > 0) {
      skills.push(agilitySkills[0].id);
    }
  } else {
    // å…¶ä»–é¡å‹ç²å–è©²æµæ´¾çš„å–®é«”æŠ€èƒ½ï¼ˆä¸€éšï¼Œéœ€æ±‚ç­‰ç´š0ï¼‰
  const tier1SingleSkills = getTier1SingleTargetSkillsByFlow(flow);
  if (tier1SingleSkills.length > 0) {
    // é¸æ“‡ç¬¬ä¸€å€‹å–®é«”æŠ€èƒ½ï¼ˆé€šå¸¸æ˜¯è©²æµæ´¾çš„åŸºç¤æŠ€èƒ½ï¼‰
    skills.push(tier1SingleSkills[0].id);
      }
    }
  }
  
  // æ ¹æ“šé¡å‹æ˜ å°„åˆ°æµæ´¾ï¼Œéš¨æ©Ÿç²å¾—ä¸€å€‹ä¸€éšè¢«å‹•æŠ€èƒ½
  // å¤šæµæ´¾è·æ¥­å¾å…©å€‹æµæ´¾ä¸­å„ç²å¾—ä¸€å€‹è¢«å‹•æŠ€èƒ½
  if (heroType === 'sage' || heroType === 'paladin' || heroType === 'weaponmaster') {
    primaryFlows.forEach(primaryFlow => {
      const tier1Passives = getTier1PassiveSkillsByFlow(primaryFlow);
      if (tier1Passives.length > 0) {
        const randomPassive = tier1Passives[Math.floor(Math.random() * tier1Passives.length)];
        skills.push(randomPassive.id);
        
        // å¦‚æœæ˜¯é˜²å®ˆå‹è¢«å‹•æŠ€èƒ½ï¼ˆHPåŠ æˆï¼‰ï¼Œç«‹å³æ‡‰ç”¨æ•ˆæœ
        if (randomPassive.hpBonus !== undefined) {
          stats.maxHp = Math.ceil(stats.maxHp + randomPassive.hpBonus);
          stats.hp = Math.ceil(stats.hp + randomPassive.hpBonus);
        }
        // å¦‚æœæ˜¯é­”æ³•å‹è¢«å‹•æŠ€èƒ½ï¼ˆMPåŠ æˆï¼‰ï¼Œç«‹å³æ‡‰ç”¨æ•ˆæœ
        if (randomPassive.mpBonus !== undefined) {
          stats.maxMp = Math.ceil(stats.maxMp + randomPassive.mpBonus);
          stats.mp = Math.ceil(stats.mp + randomPassive.mpBonus);
        }
      }
    });
  } else {
  const tier1Passives = getTier1PassiveSkillsByFlow(flow);
  if (tier1Passives.length > 0) {
    const randomPassive = tier1Passives[Math.floor(Math.random() * tier1Passives.length)];
    skills.push(randomPassive.id);
    
    // å¦‚æœæ˜¯é˜²å®ˆå‹è¢«å‹•æŠ€èƒ½ï¼ˆHPåŠ æˆï¼‰ï¼Œç«‹å³æ‡‰ç”¨æ•ˆæœ
    if (randomPassive.hpBonus !== undefined) {
      stats.maxHp = Math.ceil(stats.maxHp + randomPassive.hpBonus);
      stats.hp = Math.ceil(stats.hp + randomPassive.hpBonus);
      }
    }
  }
  
  // éš¨æ©Ÿåˆ†é…å€‹æ€§
  const personalityIds = Object.keys(COMPANION_PERSONALITIES);
  const randomPersonalityId = personalityIds[Math.floor(Math.random() * personalityIds.length)];
  const personality = COMPANION_PERSONALITIES[randomPersonalityId];
  
  // ç¢ºä¿åŒä¼´åå­—ä¸èˆ‡ç¾æœ‰åŒä¼´é‡è¤‡ï¼ˆä¹Ÿå¯é¿å…èˆ‡å‹‡è€…ç›¸åŒï¼‰
  const existingNames = [];
  if (state.hero && state.hero.name) existingNames.push(state.hero.name);
  (state.companions || []).forEach(c => {
    if (c && c.name) existingNames.push(c.name);
  });
  const companionName = getUniqueDQName(existingNames);
  
  return {
    companionTypeId,
    heroType,
    name: companionName, // ä½¿ç”¨ä¸é‡è¤‡çš„åå­—
    stats,
    attributes,
    skills,
    lastSkillLevel: 0, // è¨˜éŒ„ä¸Šæ¬¡ç²å¾—æŠ€èƒ½æ™‚çš„ç­‰ç´š
    personalityId: randomPersonalityId, // å€‹æ€§ID
    level10ActiveSkillChainId: null, // 10ç´šå­¸åˆ°çš„å…¶ä»–è·æ¥­ä¸»å‹•æŠ€èƒ½çš„chainId
    level20PassiveSkillChainId: null, // 20ç´šå­¸åˆ°çš„å…¶ä»–è·æ¥­è¢«å‹•æŠ€èƒ½çš„chainId
    equippedRelic: null, // è£å‚™çš„åœ£ç‰©ID
    skillEnabled: {}, // æŠ€èƒ½å•Ÿç”¨ç‹€æ…‹ { skillId: true/false }ï¼Œé è¨­å…¨éƒ¨å•Ÿç”¨ï¼ˆä¸åœ¨å°è±¡ä¸­çš„æŠ€èƒ½é è¨­ç‚ºå•Ÿç”¨ï¼‰
  };
}

// è¨ˆç®—åŒä¼´ç¸½å±¬æ€§ï¼ˆåŒ…å«åœ£ç‰©åŠ æˆï¼‰
function getCompanionTotalAttributes(companion) {
  const attrs = { ...companion.attributes };
  
  // æ‡‰ç”¨åœ£ç‰©å±¬æ€§åŠ æˆ
  if (companion.equippedRelic) {
    const relic = state.relics.find(r => r.id === companion.equippedRelic);
    if (relic && relic.attributeType && relic.attributeBonus) {
      attrs[relic.attributeType] = (attrs[relic.attributeType] || 0) + relic.attributeBonus;
    }
  }
  
  // æ‡‰ç”¨é˜²å®ˆå‹è¢«å‹•æŠ€èƒ½ï¼šå›ºå®šé˜²å®ˆå€¼åŠ æˆ
  const defenderEffects = getDefenderPassiveEffects(companion);
  if (defenderEffects.defenseBonus > 0) {
    attrs.defense = (attrs.defense || 0) + defenderEffects.defenseBonus;
  }
  
  // æ‡‰ç”¨å‹‡è€…ä¹‹è¡€è¢«å‹•æŠ€èƒ½æ•ˆæœ
  const heroBloodEffects = getHeroBloodPassiveEffects(companion);
  if (heroBloodEffects.allAttributesBonus > 0) {
    // å…¨èƒ½åŠ›+20
    attrs.attack = (attrs.attack || 0) + heroBloodEffects.allAttributesBonus;
    attrs.defense = (attrs.defense || 0) + heroBloodEffects.allAttributesBonus;
    attrs.magic = (attrs.magic || 0) + heroBloodEffects.allAttributesBonus;
    attrs.recovery = (attrs.recovery || 0) + heroBloodEffects.allAttributesBonus;
    attrs.agility = (attrs.agility || 0) + heroBloodEffects.allAttributesBonus;
  }
  if (heroBloodEffects.recoveryBonus > 0) {
    // å›å¾©åŠ›+60
    attrs.recovery = (attrs.recovery || 0) + heroBloodEffects.recoveryBonus;
  }
  if (heroBloodEffects.magicBonus > 0) {
    // é­”åŠ›+60
    attrs.magic = (attrs.magic || 0) + heroBloodEffects.magicBonus;
  }
  
  // æ‡‰ç”¨å…‰ç’°æ•ˆæœï¼ˆæ”»æ“ŠåŠ›å’Œé˜²ç¦¦åŠ›åŠ æˆï¼‰
  const auraAttackBonus = getAuraAttributeBonus('attack');
  if (auraAttackBonus > 0) {
    attrs.attack = (attrs.attack || 0) + auraAttackBonus;
  }
  const auraDefenseBonus = getAuraAttributeBonus('defense');
  if (auraDefenseBonus > 0) {
    attrs.defense = (attrs.defense || 0) + auraDefenseBonus;
  }
  
  // æ‡‰ç”¨å‹æ–¹debuffï¼ˆæ•µäººå°å‹æ–¹æ–½åŠ çš„debuffï¼‰
  const battle = state.ui.battle;
  if (battle && battle.friendlyDebuffs && battle.friendlyDebuffs.companions) {
    const companionIndex = state.companions.indexOf(companion);
    if (companionIndex >= 0 && battle.friendlyDebuffs.companions[companionIndex] && battle.friendlyDebuffs.companions[companionIndex].defenseDown) {
      const defenseDown = battle.friendlyDebuffs.companions[companionIndex].defenseDown;
      attrs.defense = Math.max(0, Math.floor(attrs.defense * (1 - defenseDown.ratio)));
    }
  }
  
  // è¿”å›å±¬æ€§æ™‚ï¼Œä½¿ç”¨ç„¡æ¢ä»¶æ¨å»ï¼ˆå‘ä¸‹å–æ•´ï¼‰é¡¯ç¤º
  Object.keys(attrs).forEach(attr => {
    attrs[attr] = Math.floor(attrs[attr] || 0);
  });
  return attrs;
}

// ç²å–è§’è‰²çš„æ•æ·å€¼ï¼ˆç”¨æ–¼è¡Œå‹•é †åºæ’åºï¼‰
function getCharacterAgility(character, type) {
  let agility = 0;
  if (type === 'hero') {
    const totalAttrs = getHeroTotalAttributes(character);
    agility = totalAttrs.agility || 0;
  } else if (type === 'companion') {
    const totalAttrs = getCompanionTotalAttributes(character);
    agility = totalAttrs.agility || 0;
  } else {
    // æ•µäºº
    agility = character.attributes?.agility || 0;
    
    // æª¢æŸ¥æ˜¯å¦æœ‰æ¸›é€Ÿç‹€æ…‹
    const battle = state.ui.battle;
    if (battle && battle.enemyDebuffs) {
      const enemyIndex = battle.enemies.indexOf(character);
      if (enemyIndex >= 0 && battle.enemyDebuffs[enemyIndex] && battle.enemyDebuffs[enemyIndex].slow) {
        const slow = battle.enemyDebuffs[enemyIndex].slow;
        // æ‡‰ç”¨æ¸›é€Ÿæ•ˆæœï¼šæ¸›å°‘1/3é€Ÿåº¦
        agility = Math.max(1, Math.floor(agility * (1 - slow.ratio)));
      }
    }
  }
  
  // æª¢æŸ¥å‹æ–¹æ˜¯å¦æœ‰æ¸›é€Ÿç‹€æ…‹ï¼ˆæ•µäººå°å‹æ–¹æ–½åŠ çš„debuffï¼‰
  const battle = state.ui.battle;
  if (battle && battle.friendlyDebuffs) {
    if (type === 'hero' && battle.friendlyDebuffs.hero && battle.friendlyDebuffs.hero.slow) {
      const slow = battle.friendlyDebuffs.hero.slow;
      agility = Math.max(1, Math.floor(agility * (1 - slow.ratio)));
    } else if (type === 'companion') {
      const companionIndex = state.companions.indexOf(character);
      if (companionIndex >= 0 && battle.friendlyDebuffs.companions && battle.friendlyDebuffs.companions[companionIndex] && battle.friendlyDebuffs.companions[companionIndex].slow) {
        const slow = battle.friendlyDebuffs.companions[companionIndex].slow;
        agility = Math.max(1, Math.floor(agility * (1 - slow.ratio)));
      }
    }
  }
  
  return agility;
}

// ç²å–è£å‚™æ•¸æ“šï¼ˆæ”¯æŒç²¾è‰¯è£å‚™ï¼‰
function getEquipmentData(equipmentId) {
  if (!equipmentId) return null;
  
  // å…ˆæª¢æŸ¥ç²¾è‰¯è£å‚™
  if (state.hero && state.hero.superiorEquipment && state.hero.superiorEquipment[equipmentId]) {
    return state.hero.superiorEquipment[equipmentId];
  }
  
  // å†æª¢æŸ¥æ™®é€šè£å‚™
  return EQUIPMENT_LOOKUP.get(equipmentId) || null;
}

// è¨ˆç®—ç¸½å±¬æ€§ï¼ˆåŸºç¤å±¬æ€§ + è£å‚™åŠ æˆ + è¢«å‹•æŠ€èƒ½åŠ æˆï¼‰
// ç²å–å…‰ç’°å°å±¬æ€§çš„åŠ æˆ
function getAuraAttributeBonus(attributeType) {
  const battle = state.ui.battle;
  if (!battle || !battle.aura || battle.aura.duration <= 0) return 0;
  
  const aura = battle.aura;
  if (aura.type === 'attack' && attributeType === 'attack') {
    return aura.value;
  } else if (aura.type === 'defense' && attributeType === 'defense') {
    return aura.value;
  }
  return 0;
}

function getHeroTotalAttributes(hero) {
  const total = { ...hero.attributes };
  
  // è¨ˆç®—è£å‚™åŠ æˆ
  ['weapon', 'shield', 'armor', 'accessory'].forEach(slot => {
    const equipmentId = hero.equipment[slot];
    if (!equipmentId) return;
    
    const equipment = getEquipmentData(equipmentId);
    if (!equipment) return;
    
    // å±¬æ€§åŠ æˆï¼ˆé£¾å“ä¸æä¾›é˜²ç¦¦åŠ›ï¼Œé˜²å®ˆå‹é˜²å…·ä¸æä¾›é˜²ç¦¦åŠ›å±¬æ€§åŠ æˆï¼‰
    if (equipment.attributes) {
      Object.keys(equipment.attributes).forEach(attr => {
        // å¦‚æœæ˜¯é£¾å“ä¸”å±¬æ€§æ˜¯é˜²ç¦¦ï¼Œå‰‡è·³é
        if (slot === 'accessory' && attr === 'defense') {
          return;
        }
        // å¦‚æœæ˜¯é˜²å®ˆå‹é˜²å…·ä¸”å±¬æ€§æ˜¯é˜²ç¦¦ï¼Œå‰‡è·³éï¼ˆé˜²å®ˆå‹é˜²å…·çš„é˜²ç¦¦åŠ›å·²ç¶“é€šé defense å±¬æ€§è¨ˆç®—ï¼‰
        if (slot === 'armor' && attr === 'defense' && equipmentId && equipmentId.startsWith('defense_armor_')) {
          return;
        }
        total[attr] = (total[attr] || 0) + equipment.attributes[attr];
      });
    }
  });
  
  // æ‡‰ç”¨é˜²å®ˆå‹è¢«å‹•æŠ€èƒ½ï¼šå›ºå®šé˜²å®ˆå€¼åŠ æˆ
  const defenderEffects = getDefenderPassiveEffects(hero);
  if (defenderEffects.defenseBonus > 0) {
    total.defense = (total.defense || 0) + defenderEffects.defenseBonus;
  }
  
  // æ‡‰ç”¨å‹‡è€…ä¹‹è¡€è¢«å‹•æŠ€èƒ½æ•ˆæœ
  const heroBloodEffects = getHeroBloodPassiveEffects(hero);
  if (heroBloodEffects.allAttributesBonus > 0) {
    // å…¨èƒ½åŠ›+20
    total.attack = (total.attack || 0) + heroBloodEffects.allAttributesBonus;
    total.defense = (total.defense || 0) + heroBloodEffects.allAttributesBonus;
    total.magic = (total.magic || 0) + heroBloodEffects.allAttributesBonus;
    total.recovery = (total.recovery || 0) + heroBloodEffects.allAttributesBonus;
    total.agility = (total.agility || 0) + heroBloodEffects.allAttributesBonus;
  }
  if (heroBloodEffects.recoveryBonus > 0) {
    // å›å¾©åŠ›+60
    total.recovery = (total.recovery || 0) + heroBloodEffects.recoveryBonus;
  }
  if (heroBloodEffects.magicBonus > 0) {
    // é­”åŠ›+60
    total.magic = (total.magic || 0) + heroBloodEffects.magicBonus;
  }
  
  // æ‡‰ç”¨å…‰ç’°æ•ˆæœï¼ˆæ”»æ“ŠåŠ›å’Œé˜²ç¦¦åŠ›åŠ æˆï¼‰
  const auraAttackBonus = getAuraAttributeBonus('attack');
  if (auraAttackBonus > 0) {
    total.attack = (total.attack || 0) + auraAttackBonus;
  }
  const auraDefenseBonus = getAuraAttributeBonus('defense');
  if (auraDefenseBonus > 0) {
    total.defense = (total.defense || 0) + auraDefenseBonus;
  }
  
  // è¿”å›æ™‚ä½¿ç”¨ç„¡æ¢ä»¶æ¨å»ï¼ˆå‘ä¸‹å–æ•´ï¼‰é¡¯ç¤º
  Object.keys(total).forEach(attr => {
    total[attr] = Math.floor(total[attr] || 0);
  });
  
  return total;
}

// ç²å–è£å‚™æä¾›çš„æ”»æ“ŠåŠ›ï¼ˆç›´æ¥å¾è£å‚™çš„attackå±¬æ€§è¨ˆç®—ï¼‰
function getEquipmentAttack(hero) {
  if (!hero || !hero.equipment) return 0;
  
  let attack = 0;
  // æ­¦å™¨ç›´æ¥æä¾›æ”»æ“ŠåŠ›
  const weaponId = hero.equipment.weapon;
  if (weaponId) {
    const weapon = getEquipmentData(weaponId);
    if (weapon && weapon.attack !== undefined) {
      attack += weapon.attack;
    }
  }
  
  return attack;
}

// ç²å–è£å‚™æä¾›çš„å‘½ä¸­ç‡åŠ æˆï¼ˆå·²æ”¹ç‚ºè¢«å‹•æŠ€èƒ½ï¼Œæ­¤å‡½æ•¸ä¿ç•™ä»¥å…¼å®¹ï¼‰
function getEquipmentHitRate(hero) {
  return 0; // è£å‚™æ•ˆæœå·²æ”¹ç‚ºè¢«å‹•æŠ€èƒ½ï¼Œé€šé getAgilityPassiveEffects è¨ˆç®—
}

// ç²å–è£å‚™æä¾›çš„æš´æ“Šç‡åŠ æˆï¼ˆå·²æ”¹ç‚ºè¢«å‹•æŠ€èƒ½ï¼Œæ­¤å‡½æ•¸ä¿ç•™ä»¥å…¼å®¹ï¼‰
function getEquipmentCritRate(hero) {
  return 0; // è£å‚™æ•ˆæœå·²æ”¹ç‚ºè¢«å‹•æŠ€èƒ½ï¼Œé€šé getAgilityPassiveEffects è¨ˆç®—
}

// ç²å–è£å‚™æä¾›çš„é˜²ç¦¦åŠ›ï¼ˆç›´æ¥å¾è£å‚™çš„defenseå±¬æ€§è¨ˆç®—ï¼‰
function getEquipmentDefense(hero) {
  if (!hero || !hero.equipment) return 0;
  
  let defense = 0;
  // é˜²å…·å’Œç›¾ç‰Œç›´æ¥æä¾›é˜²ç¦¦åŠ›
  const armorId = hero.equipment.armor;
  if (armorId) {
    const armor = getEquipmentData(armorId);
    if (armor && armor.defense !== undefined) {
      defense += armor.defense;
    }
  }
  
  const shieldId = hero.equipment.shield;
  if (shieldId) {
    const shield = getEquipmentData(shieldId);
    if (shield && shield.defense !== undefined) {
      defense += shield.defense;
    }
  }
  
  return defense;
}

// ç²å–è£å‚™æä¾›çš„é–ƒé¿ç‡ï¼ˆå·²ç§»é™¤è£å‚™ä¸­çš„é–ƒé¿ç‡ï¼Œæ­¤å‡½æ•¸ä¿ç•™ä»¥å…¼å®¹ï¼‰
function getEquipmentDodge(hero) {
  return 0; // è£å‚™ä¸å†æä¾›é–ƒé¿ç‡åŠ æˆ
}

function init() {
  console.log('[INIT] ========== init() å‡½æ•¸è¢«èª¿ç”¨ ==========');
  console.log('[INIT] document.readyState:', document.readyState);
  
  // æ¯æ¬¡åˆå§‹åŒ–æ™‚é‡æ–°è®€å–é…ç½®ï¼ˆç¢ºä¿ä½¿ç”¨æœ€æ–°çš„GAME_CONFIGå€¼ï¼‰
  loadSettings();
  console.log('[INIT] loadSettings() å®Œæˆ');
  
  // ç¢ºä¿ DOM å…ƒç´ å·²è¼‰å…¥
  console.log('[INIT] æª¢æŸ¥æŒ‰éˆ•å…ƒç´ ...');
  console.log('[INIT] dom.newBtn:', dom.newBtn);
  console.log('[INIT] dom.settingsBtn:', dom.settingsBtn);
  console.log('[INIT] dom.continueBtn:', dom.continueBtn);
  
  // ç›´æ¥é‡æ–°ç²å–æŒ‰éˆ•å…ƒç´ ï¼ˆç¢ºä¿æ˜¯æœ€æ–°çš„ï¼‰
  const newBtnElement = document.getElementById('btn-new');
  const settingsBtnElement = document.getElementById('btn-settings');
  const continueBtnElement = document.getElementById('btn-continue');
  
  console.log('[INIT] ç›´æ¥ç²å–å…ƒç´  - newBtn:', newBtnElement);
  console.log('[INIT] ç›´æ¥ç²å–å…ƒç´  - settingsBtn:', settingsBtnElement);
  console.log('[INIT] ç›´æ¥ç²å–å…ƒç´  - continueBtn:', continueBtnElement);
  
  if (newBtnElement) {
    dom.newBtn = newBtnElement;
  }
  if (settingsBtnElement) {
    dom.settingsBtn = settingsBtnElement;
  }
  if (continueBtnElement) {
    dom.continueBtn = continueBtnElement;
  }
  
  if (!dom.newBtn || !dom.settingsBtn || !dom.continueBtn) {
    console.error('[INIT] æŒ‰éˆ•å…ƒç´ æœªæ‰¾åˆ°ï¼');
    console.error('[INIT] newBtn:', dom.newBtn);
    console.error('[INIT] settingsBtn:', dom.settingsBtn);
    console.error('[INIT] continueBtn:', dom.continueBtn);
  } else {
    console.log('[INIT] æ‰€æœ‰æŒ‰éˆ•å…ƒç´ éƒ½å·²æ‰¾åˆ°');
  }
  
  console.log('[INIT] èª¿ç”¨ bindEvents()');
  bindEvents();
  console.log('[INIT] bindEvents() å®Œæˆ');
  
  state.log = [];
  console.log('[INIT] èª¿ç”¨ showStartMenu()');
  showStartMenu();
  console.log('[INIT] èª¿ç”¨ renderAll()');
  renderAll();
  console.log('[INIT] ========== init() å‡½æ•¸åŸ·è¡Œå®Œæˆ ==========');
}

function bindEvents() {
  // è·¯ç·šé¸æ“‡å°è©±æ¡†äº‹ä»¶
  if (dom.routeOptions) {
    dom.routeOptions.addEventListener('click', (event) => {
      const optionBtn = event.target.closest('.dialog-option');
      if (!optionBtn) return;
      const optionIndex = parseInt(optionBtn.dataset.optionIndex, 10);
      if (!isNaN(optionIndex)) {
        selectNodeOption(state.world.currentNodeIndex, optionIndex);
      }
    });
  }

  // éæˆ°é¬¥ç‹€æ…‹ä¸‹ä½¿ç”¨æŠ€èƒ½ï¼ˆæŠ€èƒ½é¢æ¿ï¼‰
  if (dom.activeSkillsPanel) {
    dom.activeSkillsPanel.addEventListener('click', (event) => {
      const useSkillBtn = event.target.closest('.use-skill-btn');
      if (useSkillBtn) {
        const skillId = useSkillBtn.dataset.skill;
        const characterType = useSkillBtn.dataset.character; // 'hero' or 'companion'
        useSkillInField(skillId, characterType);
        return;
      }
    });
  }

  // æŠ€èƒ½å•Ÿç”¨/ç¦ç”¨å¤é€‰æ¡†äº‹ä»¶ï¼ˆä½¿ç”¨äº‹ä»¶å§”æ‰˜ï¼‰
  const heroStatusSection = document.getElementById('hero-status-section');
  if (heroStatusSection) {
    heroStatusSection.addEventListener('change', (event) => {
      const checkbox = event.target;
      if (checkbox.type === 'checkbox' && checkbox.dataset.skillId && checkbox.dataset.companionIndex !== undefined) {
        // æˆ°é¬¥ä¸­ä¸èƒ½ä¿®æ”¹æŠ€èƒ½å•Ÿç”¨ç‹€æ…‹
        if (state.ui.battle) {
          checkbox.checked = !checkbox.checked; // æ¢å¾©åŸç‹€æ…‹
          pushLog('æˆ°é¬¥ä¸­ç„¡æ³•ä¿®æ”¹æŠ€èƒ½å•Ÿç”¨ç‹€æ…‹ï¼');
          return;
        }
        
        const skillId = checkbox.dataset.skillId;
        const companionIndex = parseInt(checkbox.dataset.companionIndex, 10);
        const companions = state.companions || [];
        const companion = companions[companionIndex];
        
        if (companion) {
          // åˆå§‹åŒ– skillEnabled å¯¹è±¡ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
          if (!companion.skillEnabled) {
            companion.skillEnabled = {};
          }
          
          // åˆ‡æ¢æŠ€èƒ½å¯ç”¨çŠ¶æ€
          companion.skillEnabled[skillId] = checkbox.checked;
          
          // é‡æ–°æ¸²æŸ“æŠ€èƒ½é¢æ¿ä»¥æ›´æ–°æ˜¾ç¤º
          renderAll();
        }
      }
    });
  }

  // å·¦å´é¢æ¿ï¼šå¯ç”¨é“å…·/é­”æ³•
  if (dom.fieldActionsPanel) {
    dom.fieldActionsPanel.addEventListener('click', (event) => {
      const actionBtn = event.target.closest('.field-action-btn');
      if (!actionBtn || actionBtn.disabled) return;
      
      const action = actionBtn.dataset.action;
      if (action === 'item') {
        const itemId = actionBtn.dataset.itemId;
        if (itemId) {
          useItemInField(itemId);
        }
      } else if (action === 'skill') {
        const skillId = actionBtn.dataset.skillId;
        const characterType = actionBtn.dataset.character || 'hero';
        if (skillId) {
          if (characterType === 'companion') {
            const companionIndex = parseInt(actionBtn.dataset.companionIndex || '0', 10);
            useSkillInField(skillId, 'companion', companionIndex);
          } else {
            useSkillInField(skillId, 'hero');
          }
        }
      }
    });
  }

  // æˆ°é¬¥UIäº‹ä»¶
  if (dom.battleCommands) {
    dom.battleCommands.addEventListener('click', (event) => {
      const cmdBtn = event.target.closest('[data-command]');
      if (cmdBtn) {
        handleBattleCommand(cmdBtn.dataset.command);
        return;
      }
      const skillBtn = event.target.closest('[data-skill]');
      if (skillBtn) {
        const battle = state.ui.battle;
        const isHeroTurn = battle && battle.turn === 'hero';
        const isCompanionTurn = battle && battle.turn === 'companion';
        
        if (battle && (isHeroTurn || isCompanionTurn)) {
          const skill = SKILL_LOOKUP.get(skillBtn.dataset.skill);
          if (!skill) return;
          
          // AOEæŠ€èƒ½éœ€è¦ç¡®è®¤ï¼šè¡¥è¡€æŠ€èƒ½é€‰æ‹©"æˆ‘æ–¹å…¨é«”"/"å–æ¶ˆ"ï¼Œæ”»å‡»æŠ€èƒ½é€‰æ‹©"æ•µæ–¹å…¨é«”"/"å–æ¶ˆ"
          if (skill.aoe && isHeroTurn) {
            // æª¢æŸ¥æ˜¯å¦ç‚ºæ·¨åŒ–æŠ€èƒ½
            const isPurifySkill = skill.id && (skill.id === 'purify_1' || skill.id === 'mass_purify_1');
            if (skill.kind === 'heal') {
              // å…¨é«”å›å¾©æŠ€èƒ½ï¼šé¡¯ç¤ºç¢ºèªèœå–®
              battle.menu = 'select-aoe-heal';
            } else if (skill.kind === 'support' && !isPurifySkill) {
              // å…¨é«”è¼”åŠ©æŠ€èƒ½ï¼ˆéæ·¨åŒ–ï¼‰ï¼šé¡¯ç¤ºç¢ºèªèœå–®
              battle.menu = 'select-aoe-support';
            } else if (isPurifySkill && skill.aoe) {
              // å…¨é«”æ·¨åŒ–ï¼šé¡¯ç¤ºç¢ºèªèœå–®
              battle.menu = 'select-aoe-support';
            } else if (skill.kind === 'enhance') {
              // æª¢æŸ¥æ˜¯å¦ç‚ºè‡ªèº«buffï¼ˆåŠæ„ï¼‰é‚„æ˜¯å…‰ç’°
              if (skill.selfBuff) {
                // åŠæ„æŠ€èƒ½ï¼šç›´æ¥å°è‡ªå·±ä½¿ç”¨ï¼Œä¸éœ€è¦ç¢ºèª
                battle.selectedEnemyIndex = -1; // -1 è¡¨ç¤ºè‡ªå·±
                battle.heroAction = {
                  type: 'skill',
                  skillId: skillBtn.dataset.skill,
                  targetEnemyIndex: -1,
                  target: null,
                };
                battle.menu = 'root';
                battle.pendingSkill = null;
                endHeroTurn();
                return;
              } else {
                // å…¨é«”å¢å¼·æŠ€èƒ½ï¼ˆå…‰ç’°ï¼‰ï¼šç›´æ¥ä½¿ç”¨ï¼Œä¸éœ€è¦ç¢ºèª
                battle.heroAction = {
                  type: 'skill',
                  skillId: skillBtn.dataset.skill,
                  targetEnemyIndex: null,
                  target: null,
                };
                battle.menu = 'root';
                battle.pendingSkill = null;
                endHeroTurn();
                return;
              }
            } else if (skill.kind === 'attack') {
              // å…¨é«”æ”»æ“ŠæŠ€èƒ½ï¼šé¡¯ç¤ºç¢ºèªèœå–®
              battle.menu = 'select-aoe-attack';
            } else {
              // å…¶ä»–é¡å‹çš„AOEæŠ€èƒ½ç›´æ¥åŠ å…¥é˜Ÿåˆ—
              battle.heroAction = {
                type: 'skill',
                skillId: skillBtn.dataset.skill,
                targetEnemyIndex: null,
                target: null,
              };
              battle.menu = 'root';
              battle.pendingSkill = null;
              endHeroTurn();
              return;
            }
            battle.pendingSkill = skillBtn.dataset.skill;
            renderBattleDialog();
            return;
          }
          
          // å–®é«”æŠ€èƒ½éœ€è¦é¸æ“‡ç›®æ¨™
            if (isCompanionTurn && skill.kind === 'attack') {
            // åŒä¼´å›åˆæ™‚ï¼Œæ”»æ“ŠæŠ€èƒ½è‡ªå‹•é¸æ“‡ç›®æ¨™ï¼Œä¸é¡¯ç¤ºé¸æ“‡ç•Œé¢
              const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
              if (aliveEnemies.length > 0) {
                battle.selectedEnemyIndex = battle.enemies.indexOf(aliveEnemies[Math.floor(Math.random() * aliveEnemies.length)]);
                performSkill(skillBtn.dataset.skill);
              }
            } else {
            // éœ€è¦ç©å®¶é¸æ“‡ç›®æ¨™
              // æª¢æŸ¥æ˜¯å¦ç‚ºè‡ªèº«buffæŠ€èƒ½ï¼ˆåŠæ„ï¼‰- åªèƒ½å°è‡ªå·±ä½¿ç”¨ï¼Œç›´æ¥åŸ·è¡Œ
              if (skill.kind === 'enhance' && skill.selfBuff) {
                // åŠæ„æŠ€èƒ½ï¼šç›´æ¥å°è‡ªå·±ä½¿ç”¨ï¼Œä¸éœ€è¦é¸æ“‡ç›®æ¨™
                battle.selectedEnemyIndex = -1; // -1 è¡¨ç¤ºè‡ªå·±
                performSkill(skillBtn.dataset.skill);
                return;
              }
              
              // æª¢æŸ¥æ˜¯å¦ç‚ºæ·¨åŒ–æŠ€èƒ½ï¼ˆéœ€è¦é¸æ“‡å‹æ–¹ï¼‰
              const isPurifySkill = skill.id && (skill.id === 'purify_1' || skill.id === 'mass_purify_1');
              if (skill.kind === 'heal' || (skill.kind === 'support' && !isPurifySkill)) {
              battle.menu = 'select-target'; // å–®é«”å›å¾©æŠ€èƒ½å’Œè¼”åŠ©æŠ€èƒ½ï¼ˆé˜²è­·ç½©ï¼‰åªèƒ½é¸æ“‡æˆ‘æ–¹ç›®æ¨™ï¼ˆè‡ªå·±æˆ–åŒä¼´ï¼‰
              } else if (isPurifySkill) {
                if (skill.aoe) {
                  // å…¨é«”æ·¨åŒ–ï¼šé¸æ“‡æˆ‘æ–¹å…¨é«”
                  battle.menu = 'select-aoe-support';
                } else {
                  // å–®é«”æ·¨åŒ–ï¼šé¸æ“‡æˆ‘æ–¹å–®é«”
                  battle.menu = 'select-target';
                }
              } else if (skill.kind === 'debuff') {
                battle.menu = 'select-enemy'; // debuffæŠ€èƒ½ï¼ˆä¸‹æ¯’ï¼‰åªèƒ½é¸æ“‡æ•µäºº
              } else {
                battle.menu = 'select-enemy'; // æ”»æ“ŠæŠ€èƒ½åªèƒ½é¸æ“‡æ•µäºº
              }
              battle.pendingSkill = skillBtn.dataset.skill;
              renderBattleDialog();
          }
        }
        return;
      }
      const itemBtn = event.target.closest('[data-item]');
      if (itemBtn) {
        useBattleItem(itemBtn.dataset.item);
        return;
      }
      const aoeConfirmBtn = event.target.closest('[data-aoe-confirm]');
      if (aoeConfirmBtn) {
        const battle = state.ui.battle;
        if (!battle || battle.turn !== 'hero' || !battle.pendingSkill) return;
        
        const confirmType = aoeConfirmBtn.dataset.aoeConfirm; // 'allies' æˆ– 'enemies'
        const skill = SKILL_LOOKUP.get(battle.pendingSkill);
        if (!skill || !skill.aoe) return;
        
        // ç¢ºèªå¾ŒåŠ å…¥éšŠåˆ—
        battle.heroAction = {
          type: 'skill',
          skillId: battle.pendingSkill,
          targetEnemyIndex: null, // AOEæŠ€èƒ½ä¸éœ€è¦ç›®æ¨™
          target: null, // AOEæŠ€èƒ½ä¸éœ€è¦ç›®æ¨™
        };
        battle.menu = 'root';
        battle.pendingSkill = null;
        endHeroTurn();
        return;
      }
    });
  }

  // æ€ªç‰©åˆ—è¡¨é»æ“Šäº‹ä»¶
  if (dom.battleEnemies) {
    dom.battleEnemies.addEventListener('click', (event) => {
      const enemyInfo = event.target.closest('.enemy-info');
      if (!enemyInfo) return;
      
      const enemyIndex = parseInt(enemyInfo.dataset.enemyIndex, 10);
      if (isNaN(enemyIndex)) return;
      
      const battle = state.ui.battle;
      if (!battle) return;
      
      // æª¢æŸ¥æ˜¯å¦æ­£åœ¨é¸æ“‡ç›®æ¨™ï¼ˆåªæœ‰åœ¨è‹±é›„å›åˆä¸”æ­£åœ¨é¸æ“‡ç›®æ¨™æ™‚æ‰å…è¨±ï¼‰
      const isHeroTurn = battle.turn === 'hero';
      const isSelectingTarget = battle.menu === 'select-enemy' || battle.menu === 'select-target' || (battle.menu === 'skills' && battle.pendingSkill) || (battle.menu === 'items' && battle.pendingItem);
      
      // åªæœ‰è‹±é›„å›åˆä¸”æ­£åœ¨é¸æ“‡ç›®æ¨™æ™‚æ‰èƒ½é»æ“Šæ•µäºº
      if (!isHeroTurn || !isSelectingTarget) return;
      
      // æª¢æŸ¥æ˜¯å¦é¸æ“‡äº†è‹±é›„è‡ªå·±ï¼ˆ-1è¡¨ç¤ºè‡ªå·±ï¼‰
      if (enemyIndex === -1) {
        battle.selectedEnemyIndex = -1;
        if (battle.pendingSkill) {
          // å–®é«”æŠ€èƒ½é¸æ“‡ç›®æ¨™å¾ŒåŠ å…¥éšŠåˆ—
          const skill = SKILL_LOOKUP.get(battle.pendingSkill);
          if (skill) {
            battle.heroAction = {
              type: 'skill',
              skillId: battle.pendingSkill,
              target: 'hero', // -1è¡¨ç¤ºè‡ªå·±
            };
            battle.selectedEnemyIndex = null;
            battle.pendingSkill = null;
            battle.menu = 'root';
            endHeroTurn();
          }
        } else if (battle.pendingItem) {
          useBattleItem(battle.pendingItem);
        }
        return;
      }
      
      // æª¢æŸ¥æ˜¯å¦é¸æ“‡äº†åŒä¼´ï¼ˆ-2è¡¨ç¤ºåŒä¼´ï¼‰
      // è™•ç†åŒä¼´ç›®æ¨™é¸æ“‡ï¼ˆ-2 è¡¨ç¤ºç¬¬ä¸€å€‹åŒä¼´ï¼Œ-3 è¡¨ç¤ºç¬¬äºŒå€‹ï¼Œä»¥æ­¤é¡æ¨ï¼‰
      if (enemyIndex <= -2) {
        battle.selectedEnemyIndex = enemyIndex;
        if (battle.pendingSkill) {
          // å–®é«”æŠ€èƒ½é¸æ“‡ç›®æ¨™å¾ŒåŠ å…¥éšŠåˆ—
          const skill = SKILL_LOOKUP.get(battle.pendingSkill);
          if (skill) {
            // è¨ˆç®—åŒä¼´ç´¢å¼•ï¼š-2 -> 0, -3 -> 1, -4 -> 2, ...
            const companionIndex = Math.abs(enemyIndex) - 2;
            battle.heroAction = {
              type: 'skill',
              skillId: battle.pendingSkill,
              target: 'companion', // è¡¨ç¤ºåŒä¼´
              companionIndex: companionIndex, // æŒ‡å®šæ˜¯å“ªå€‹åŒä¼´
            };
            battle.selectedEnemyIndex = null;
            battle.pendingSkill = null;
            battle.menu = 'root';
            endHeroTurn();
          }
        } else if (battle.pendingItem) {
          useBattleItem(battle.pendingItem);
        }
        return;
      }
      
      // æª¢æŸ¥æ•µäººæ˜¯å¦é‚„æ´»è‘—
      const enemy = battle.enemies[enemyIndex];
      if (!enemy || enemy.stats.hp <= 0) return;
      
      // é¸æ“‡ç›®æ¨™
      battle.selectedEnemyIndex = enemyIndex;
      
      // å¦‚æœæœ‰å¾…ä½¿ç”¨çš„æŠ€èƒ½ï¼ŒåŠ å…¥éšŠåˆ—
      if (battle.pendingSkill) {
        const skill = SKILL_LOOKUP.get(battle.pendingSkill);
        if (skill) {
          battle.heroAction = {
            type: 'skill',
            skillId: battle.pendingSkill,
            targetEnemyIndex: enemyIndex,
          };
          battle.selectedEnemyIndex = null;
          battle.pendingSkill = null;
          battle.menu = 'root';
          endHeroTurn();
        }
      } else if (battle.pendingItem) {
        useBattleItem(battle.pendingItem);
      } else {
        // å¦å‰‡åŸ·è¡Œæ™®é€šæ”»æ“Š
        performBasicAttack();
      }
    });
  }

  // æ•µäººé¸æ“‡äº‹ä»¶
  if (dom.battleEnemies) {
    dom.battleEnemies.addEventListener('click', (event) => {
      const enemyInfo = event.target.closest('.enemy-info');
      if (!enemyInfo || !enemyInfo.dataset.enemyIndex) return;
      
      const battle = state.ui.battle;
      if (!battle || battle.turn !== 'hero') return;
      
      // æª¢æŸ¥æ˜¯å¦æ­£åœ¨é¸æ“‡ç›®æ¨™
      const isSelectingTarget = battle.menu === 'select-enemy' || battle.menu === 'select-target' || (battle.menu === 'skills' && battle.pendingSkill) || (battle.menu === 'items' && battle.pendingItem);
      if (!isSelectingTarget) return;
      
      // æª¢æŸ¥æ•µäººæ˜¯å¦å¯é¸ï¼ˆæœ‰ selectable é¡ï¼‰
      if (!enemyInfo.classList.contains('selectable')) return;
      
      const enemyIndex = parseInt(enemyInfo.dataset.enemyIndex, 10);
      if (isNaN(enemyIndex)) return;
      
      // æª¢æŸ¥æ˜¯å¦é¸æ“‡äº†è‹±é›„è‡ªå·±ï¼ˆ-1è¡¨ç¤ºè‡ªå·±ï¼‰
      if (enemyIndex === -1) {
        battle.selectedEnemyIndex = -1;
        if (battle.pendingSkill) {
          performSkill(battle.pendingSkill);
        } else if (battle.pendingItem) {
          useBattleItem(battle.pendingItem);
        }
        return;
      }
      
      // æª¢æŸ¥æ˜¯å¦é¸æ“‡äº†åŒä¼´ï¼ˆ-2è¡¨ç¤ºåŒä¼´ï¼‰
      if (enemyIndex === -2) {
        battle.selectedEnemyIndex = -2;
        if (battle.pendingSkill) {
          performSkill(battle.pendingSkill);
        } else if (battle.pendingItem) {
          useBattleItem(battle.pendingItem);
        }
        return;
      }
      
      // æª¢æŸ¥æ•µäººæ˜¯å¦é‚„æ´»è‘—
      const enemy = battle.enemies[enemyIndex];
      if (!enemy || enemy.stats.hp <= 0) return;
      
      // é¸æ“‡ç›®æ¨™
      battle.selectedEnemyIndex = enemyIndex;
      
      // å¦‚æœæœ‰å¾…ä½¿ç”¨çš„æŠ€èƒ½ï¼ŒåŸ·è¡ŒæŠ€èƒ½
      if (battle.pendingSkill) {
        performSkill(battle.pendingSkill);
      } else if (battle.pendingItem) {
        useBattleItem(battle.pendingItem);
      } else {
        // å¦å‰‡åŸ·è¡Œæ™®é€šæ”»æ“Š
        performBasicAttack();
      }
    });
  }

  dom.modalLayer.addEventListener('click', (event) => {
    // å¦‚æœé»æ“Šçš„æ˜¯ inputã€selectã€textarea ç­‰è¡¨å–®å…ƒç´ ï¼Œä¸è™•ç†ï¼ˆè®“å®ƒå€‘æ­£å¸¸å·¥ä½œï¼‰
    if (event.target.tagName === 'INPUT' || event.target.tagName === 'SELECT' || event.target.tagName === 'TEXTAREA') {
      return;
    }
    
    const actionTarget = event.target.closest('[data-action]');
    if (actionTarget) {
      const action = actionTarget.dataset.action;
      switch (action) {
        case 'continue-levelup':
          // å¾èƒ½åŠ›æå‡ç•«é¢é€²å…¥å±¬æ€§é¸æ“‡ï¼Œç„¶å¾Œæ‰æ˜¯æŠ€èƒ½é¸æ“‡
          if (state.ui.levelUp && state.ui.levelUp.step === 'stats') {
            // å¾ stats æ­¥é©Ÿé€²å…¥å±¬æ€§é¸æ“‡æ­¥é©Ÿ
            if (state.ui.levelUp.attributeSelections && state.ui.levelUp.attributeSelections.length > 0) {
              // æœ‰å±¬æ€§éœ€è¦é¸æ“‡ï¼Œé€²å…¥å±¬æ€§é¸æ“‡
              state.ui.levelUp.step = 'attribute-selection';
              // å¦‚æœæ˜¯åˆå§‹è‡ªå‹•å‡ç´šï¼Œè‡ªå‹•é¸æ“‡æ‰€æœ‰å±¬æ€§
              const isInitialAutoLevel = state.ui.levelUp.isInitialAutoLevel || false;
              if (isInitialAutoLevel) {
                // è‡ªå‹•é¸æ“‡æ‰€æœ‰å±¬æ€§
                const hero = state.hero;
                state.ui.levelUp.attributeSelections.forEach(selection => {
                  if (!selection.selected) {
                    // æ ¹æ“šè·æ¥­é¡å‹å„ªå…ˆé¸æ“‡æˆé•·å€¼é«˜çš„å±¬æ€§
                    let selectedAttr = null;
                    if (hero && hero.heroType && HERO_TYPES[hero.heroType]) {
                      const type = HERO_TYPES[hero.heroType];
                      const levelUpBonus = type.levelUpBonus || {};
                      // æ‰¾å‡ºæˆé•·å€¼æœ€é«˜çš„å±¬æ€§
                      const sortedAttrs = Object.entries(levelUpBonus)
                        .sort((a, b) => b[1] - a[1])
                        .map(([attrId]) => attrId);
                      if (sortedAttrs.length > 0) {
                        // 70%æ©Ÿç‡é¸æ“‡æˆé•·å€¼æœ€é«˜çš„å±¬æ€§ï¼Œ30%æ©Ÿç‡é¸æ“‡ç¬¬äºŒé«˜çš„å±¬æ€§
                        const index = Math.random() < 0.7 ? 0 : Math.min(1, sortedAttrs.length - 1);
                        selectedAttr = ATTRIBUTES.find(attr => attr.id === sortedAttrs[index]);
                      }
                    }
                    // å¦‚æœæ²’æœ‰æ‰¾åˆ°åˆé©çš„å±¬æ€§ï¼Œéš¨æ©Ÿé¸æ“‡
                    if (!selectedAttr) {
                      selectedAttr = ATTRIBUTES[Math.floor(Math.random() * ATTRIBUTES.length)];
                    }
                    // ç›´æ¥è¨­ç½®å±¬æ€§é¸æ“‡
                    hero.attributes[selectedAttr.id] = (hero.attributes[selectedAttr.id] || 0) + selection.bonus;
                    selection.selected = true;
                    selection.selectedAttribute = selectedAttr.id;
                    const attr = ATTRIBUTES.find(a => a.id === selectedAttr.id);
                    pushLog(`Lv ${selection.level}ï¼š${attr.name} +${selection.bonus}`);
                  }
                });
                // æ‰€æœ‰å±¬æ€§é¸æ“‡å®Œç•¢ï¼Œæª¢æŸ¥æ˜¯å¦æœ‰æŠ€èƒ½é¸æ“‡
                state.ui.levelUp.currentAttributeSelectionIndex = state.ui.levelUp.attributeSelections.length;
                if (state.ui.levelUp.shouldGetSkill && state.ui.levelUp.skillOptions.length > 0) {
                  // æœ‰æŠ€èƒ½é¸æ“‡ï¼Œé€²å…¥æŠ€èƒ½é¸æ“‡æ­¥é©Ÿ
                  state.ui.levelUp.step = 'skills';
                  // è‡ªå‹•é¸æ“‡æŠ€èƒ½
                  const initialFlowMap = {
                    attacker: 'sword',
                    mage: 'magic',
                    healer: 'recovery',
                    defender: 'defender',
                    agile: 'agility',
                  };
                  const initialFlow = hero.heroType ? (initialFlowMap[hero.heroType] || 'sword') : 'sword';
                  const primaryFlow = initialFlow;
                  let selectedSkill = null;
                  if (Math.random() < 0.7) {
                    const primaryFlowSkills = state.ui.levelUp.skillOptions.filter(skill => {
                      const skillObj = SKILL_LOOKUP.get(skill.id);
                      return skillObj && skillObj.flow === primaryFlow;
                    });
                    if (primaryFlowSkills.length > 0) {
                      selectedSkill = primaryFlowSkills[Math.floor(Math.random() * primaryFlowSkills.length)];
                    }
                  }
                  if (!selectedSkill) {
                    const availableSkills = state.ui.levelUp.skillOptions.filter(skill => {
                      const heroLevel = hero ? hero.stats.level : 1;
                      return heroLevel >= (skill.requiredLevel || 0);
                    });
                    if (availableSkills.length > 0) {
                      selectedSkill = availableSkills[Math.floor(Math.random() * availableSkills.length)];
                    }
                  }
                  if (selectedSkill) {
                    confirmSkillSelection(selectedSkill.id);
                    return;
                  }
                }
                // æª¢æŸ¥æ˜¯å¦æœ‰ä¼™ä¼´å‡ç´šä¿¡æ¯
                if (state.ui.levelUp.companionUpgrades && state.ui.levelUp.companionUpgrades.length > 0) {
                  startCompanionUpgrade(state.ui.levelUp);
                } else {
                  concludeLevelUp();
                }
                return;
              }
              renderLevelModal();
            } else {
              // æ²’æœ‰å±¬æ€§éœ€è¦é¸æ“‡ï¼Œç›´æ¥é€²å…¥æŠ€èƒ½é¸æ“‡æˆ–çµæŸ
            if (state.ui.levelUp.shouldGetSkill && state.ui.levelUp.skillOptions.length > 0) {
              // æ‡‰è©²ç²å¾—æŠ€èƒ½ï¼Œé€²å…¥æŠ€èƒ½é¸æ“‡
              state.ui.levelUp.step = 'skills';
              // æˆ°é¬¥å¾Œçš„å‡ç´šç¸½æ˜¯æ‰‹å‹•é¸æ“‡æŠ€èƒ½ï¼ˆå››é¸ä¸€ï¼‰ï¼Œä¸å—è‡ªå‹•é¸æ“‡è¨­ç½®å½±éŸ¿
              // åªæœ‰åœ¨åˆå§‹è‡ªå‹•å‡ç´šæ™‚æ‰ä½¿ç”¨è‡ªå‹•é¸æ“‡è¨­ç½®
              const isInitialAutoLevel = state.ui.levelUp.isInitialAutoLevel || false;
                if (isInitialAutoLevel && state.ui.levelUp.skillOptions.length > 0) {
                  // è‡ªå‹•å‡ç´šæ™‚ï¼Œ70%æ©Ÿç‡é¸æ“‡è©²æµæ´¾çš„æŠ€èƒ½
                  const hero = state.hero;
                  const initialFlowMap = {
                    attacker: 'sword',
                    mage: 'magic',
                    healer: 'recovery',
                    defender: 'defender',
                    agile: 'agility',
                  };
                  const initialFlow = hero.heroType ? (initialFlowMap[hero.heroType] || 'sword') : 'sword';
                  
                  // ä¸»è¦æµæ´¾å°±æ˜¯ä¸€é–‹å§‹å†’éšªæ‰€é¸çš„æµæ´¾
                  const primaryFlow = initialFlow;
                  
                  // 70%æ©Ÿç‡é¸æ“‡è©²æµæ´¾çš„æŠ€èƒ½
                  let selectedSkill = null;
                  if (Math.random() < 0.7) {
                    // å„ªå…ˆé¸æ“‡è©²æµæ´¾çš„æŠ€èƒ½
                    const primaryFlowSkills = state.ui.levelUp.skillOptions.filter(skill => {
                      const skillObj = SKILL_LOOKUP.get(skill.id);
                      return skillObj && skillObj.flow === primaryFlow;
                    });
                    if (primaryFlowSkills.length > 0) {
                      selectedSkill = primaryFlowSkills[Math.floor(Math.random() * primaryFlowSkills.length)];
                    }
                  }
                  
                  // å¦‚æœæ²’æœ‰æ‰¾åˆ°è©²æµæ´¾çš„æŠ€èƒ½ï¼Œæˆ–30%æ©Ÿç‡ï¼Œéš¨æ©Ÿé¸æ“‡
                  if (!selectedSkill) {
                    const availableSkills = state.ui.levelUp.skillOptions.filter(skill => {
                  const heroLevel = state.hero ? state.hero.stats.level : 1;
                  return heroLevel >= (skill.requiredLevel || 0);
                });
                    if (availableSkills.length > 0) {
                      selectedSkill = availableSkills[Math.floor(Math.random() * availableSkills.length)];
                    }
                  }
                  
                  if (selectedSkill) {
                    confirmSkillSelection(selectedSkill.id);
                  return;
                }
              }
              // æˆ°é¬¥å¾Œçš„å‡ç´šç¸½æ˜¯é¡¯ç¤ºæŠ€èƒ½é¸æ“‡ç•Œé¢
              renderLevelModal();
            } else {
              // ä¸æ‡‰è©²ç²å¾—æŠ€èƒ½ï¼Œæª¢æŸ¥æ˜¯å¦æœ‰ä¼™ä¼´å‡ç´šä¿¡æ¯
                if (state.ui.levelUp.companionUpgrades && state.ui.levelUp.companionUpgrades.length > 0) {
                  // æœ‰ä¼™ä¼´å‡ç´šä¿¡æ¯ï¼Œé–‹å§‹è™•ç†ç¬¬ä¸€å€‹ä¼™ä¼´çš„å‡ç´š
                  startCompanionUpgrade(state.ui.levelUp);
              } else {
                // æ²’æœ‰ä¼™ä¼´å‡ç´šä¿¡æ¯ï¼Œç›´æ¥çµæŸå‡ç´š
                concludeLevelUp();
              }
            }
            }
          } else if (state.ui.levelUp && state.ui.levelUp.step === 'attribute-selection') {
            // å±¬æ€§é¸æ“‡æ­¥é©Ÿï¼Œç”± selectAttribute å‡½æ•¸è™•ç†
            // ç•¶æ‰€æœ‰å±¬æ€§é¸æ“‡å®Œç•¢å¾Œï¼ŒselectAttribute æœƒé€²å…¥ skills æ­¥é©Ÿï¼ˆå¦‚æœæœ‰æŠ€èƒ½é¸æ“‡ï¼‰æˆ–çµæŸ
          } else if (state.ui.levelUp && state.ui.levelUp.step === 'skills') {
            // æŠ€èƒ½é¸æ“‡å®Œæˆå¾Œï¼Œæª¢æŸ¥æ˜¯å¦æœ‰ä¼™ä¼´å‡ç´šä¿¡æ¯
            if (state.ui.levelUp.companionUpgrades && state.ui.levelUp.companionUpgrades.length > 0) {
              // æœ‰ä¼™ä¼´å‡ç´šä¿¡æ¯ï¼Œé–‹å§‹è™•ç†ç¬¬ä¸€å€‹ä¼™ä¼´çš„å‡ç´š
              startCompanionUpgrade(state.ui.levelUp);
            } else {
              // æ²’æœ‰ä¼™ä¼´å‡ç´šä¿¡æ¯ï¼Œç›´æ¥çµæŸå‡ç´š
            concludeLevelUp();
            }
          } else if (state.ui.levelUp && state.ui.levelUp.step === 'companion-upgrade') {
            // å¾ä¼™ä¼´å‡ç´šç•«é¢ç¹¼çºŒï¼ˆæ ¹æ“šç•¶å‰æ­¥é©Ÿè™•ç†ï¼‰
            const compUpgrade = state.ui.levelUp.companionUpgrades?.[state.ui.levelUp.currentCompanionIndex || 0];
            if (compUpgrade && compUpgrade.step === 'stats') {
              continueCompanionLevelUp();
            } else {
              // å…¶ä»–æ­¥é©Ÿæ‡‰è©²ç”±å…·é«”çš„æŒ‰éˆ•è™•ç†
              renderLevelModal();
            }
          }
          break;
        case 'confirm-stage-story':
          // ç¢ºèªç« ç¯€æ•…äº‹ï¼Œé—œé–‰æ•…äº‹ä¸¦ç¹¼çºŒéŠæˆ²
          if (state.ui.stageStory) {
            state.ui.stageStory = null;
            // ç¢ºä¿æ¨¡æ…‹è¦–çª—é—œé–‰
            dom.modalLayer.classList.add('hidden');
            dom.levelModal.innerHTML = '';
            // ç¢ºä¿é–‹å§‹é¸å–®å·²é—œé–‰
            state.ui.startMenu = false;
            if (dom.startScreen) {
              dom.startScreen.classList.add('hidden');
              dom.startScreen.style.display = 'none';
            }
            // ç¢ºä¿éŠæˆ²å¯ä»¥æ­£å¸¸é–‹å§‹
            renderAll();
          }
          break;
        case 'confirm-event':
          // ç¢ºèªäº‹ä»¶ï¼ŒåŸ·è¡Œæ•ˆæœä¸¦é€²å…¥ä¸‹ä¸€å€‹ç¯€é»
          if (state.ui.eventResult) {
            const eventResult = state.ui.eventResult;
            // åŸ·è¡Œäº‹ä»¶æ•ˆæœ
            if (eventResult.effect) {
              eventResult.effect();
            }
            // æ¸…é™¤äº‹ä»¶çµæœ
            state.ui.eventResult = null;
            // é€²å…¥ä¸‹ä¸€å€‹ç¯€é»
            advanceToNextNode();
            renderAll();
          }
          break;
        case 'select-event-choice':
          // é¸æ“‡äº‹ä»¶é¸é …
          if (state.ui.eventResult && state.ui.eventResult.choices) {
            const choiceIndex = parseInt(actionTarget.dataset.choice, 10);
            const choice = state.ui.eventResult.choices[choiceIndex];
            if (choice) {
              // å¦‚æœæœ‰ä¸‹ä¸€æ­¥é€‰æ‹©ï¼ˆå¤šæ­¥éª¤äº‹ä»¶ï¼‰ï¼Œè¿›å…¥ä¸‹ä¸€æ­¥
              if (choice.nextStep) {
                state.ui.eventResult = choice.nextStep;
                renderAll();
                return;
              }
              // åŸ·è¡Œæ•ˆæœ
              if (choice.effect) {
                choice.effect();
              }
              // é¡¯ç¤ºçµæœ
              state.ui.eventResult = {
                type: 'result',
                showResult: true,
                resultTitle: choice.resultTitle || 'çµæœ',
                resultMessage: choice.resultMessage || 'ç™¼ç”Ÿäº†æŸäº›äº‹æƒ…...',
                effect: null, // æ•ˆæœå·²ç¶“åŸ·è¡Œ
              };
            }
            renderAll();
          }
          break;
        case 'drop-item-for-new':
          handleDropItemForNew(event.target.dataset.item);
          return;
        case 'cancel-item-choice':
          const hero = state.hero;
          if (state.ui.itemChoice && state.ui.itemChoice.newItem) {
            pushLog(`æœªç²å¾— ${state.ui.itemChoice.newItem.name}ï¼ˆé“å…·æ¬„å·²æ»¿ï¼‰ã€‚`);
          }
          state.ui.itemChoice = null;
          renderAll();
          return;
        case 'confirm-battle-result':
          // ç¢ºèªæˆ°é¬¥çµæœï¼Œæ‡‰ç”¨æ‰è½ç‰©å“ä¸¦é€²å…¥ä¸‹ä¸€å€‹ç¯€é»
          if (state.ui.battleResult) {
            const battleResult = state.ui.battleResult;
            // åŸ·è¡Œæˆ°é¬¥çµæœæ•ˆæœ
            if (battleResult.effect) {
              battleResult.effect();
            }
            // æ¸…é™¤æˆ°é¬¥çµæœ
            state.ui.battleResult = null;
            renderAll();
          }
          break;
        case 'select-attribute':
          selectAttribute(actionTarget.dataset.attribute);
          break;
        case 'pick-skill':
          confirmSkillSelection(actionTarget.dataset.skill);
          break;
        case 'skip-skill':
          // è·³éæŠ€èƒ½é¸æ“‡ï¼Œæª¢æŸ¥æ˜¯å¦æœ‰ä¼™ä¼´å‡ç´šä¿¡æ¯
          if (state.ui.levelUp && state.ui.levelUp.companionUpgrades && state.ui.levelUp.companionUpgrades.length > 0) {
            // æœ‰ä¼™ä¼´å‡ç´šä¿¡æ¯ï¼Œé–‹å§‹è™•ç†ç¬¬ä¸€å€‹ä¼™ä¼´çš„å‡ç´š
            startCompanionUpgrade(state.ui.levelUp);
          } else {
            // æ²’æœ‰ä¼™ä¼´å‡ç´šä¿¡æ¯ï¼Œç›´æ¥çµæŸå‡ç´š
            concludeLevelUp();
          }
          break;
        case 'continue-companion-levelup':
          continueCompanionLevelUp();
          break;
        case 'select-companion-attribute':
          selectCompanionAttribute(actionTarget.dataset.attribute);
          break;
        case 'pick-companion-skill':
          confirmCompanionSkillSelection(actionTarget.dataset.skill);
          break;
        case 'skip-companion-skill':
          skipCompanionSkill();
          break;
        case 'select-hero-type':
          selectHeroType(actionTarget.dataset.heroType);
          break;
        case 'select-companion':
          selectCompanion(actionTarget.dataset.companionType);
          break;
        case 'select-relic':
          selectRelic(parseInt(actionTarget.dataset.relicIndex));
          break;
        case 'complete-companion-selection':
          // å®ŒæˆåŒä¼´é¸æ“‡ï¼ˆæå‰çµæŸï¼Œå³ä½¿é‚„æ²’é”åˆ°åˆå§‹æ•¸é‡ï¼‰
          if (state.companions.length > 0) {
            state.ui.companionSelection = null;
            
            // ç¢ºä¿æ‰€æœ‰åŒä¼´éƒ½å‡ç´šåˆ°ç›®æ¨™ç­‰ç´šï¼ˆéæ¸¬è©¦æ¨¡å¼ï¼‰
            if (!GAME_CONFIG.testMode) {
              const targetLevel = GAME_CONFIG.defaultTargetLevel || 15;
              if (targetLevel > 1) {
                const activeCompanions = (state.companions || []).filter(c => c && c.stats);
        activeCompanions.forEach(companion => {
          if (companion.stats.level < targetLevel) {
            const companionLevelsToGain = targetLevel - companion.stats.level;
            const upgradeInfo = levelUpCompanion(companion, companionLevelsToGain);
            // è‡ªå‹•è™•ç†å±¬æ€§é¸æ“‡å’ŒæŠ€èƒ½é¸æ“‡ï¼ˆåˆå§‹å‡ç´šæ™‚è‡ªå‹•é¸æ“‡ï¼‰
            if (upgradeInfo) {
              autoProcessCompanionUpgrade(upgradeInfo);
            }
            companion.stats.hp = companion.stats.maxHp;
            companion.stats.mp = companion.stats.maxMp;
          }
        });
              }
            }
            
            // å¦‚æœå¾ç¬¬ä¸€éšæ®µé–‹å§‹ï¼Œé¡¯ç¤ºç¬¬ä¸€ç« æ•…äº‹ï¼ˆåœ¨å®Œæˆæ‰€æœ‰åˆå§‹è¨­ç½®å¾Œï¼‰
            const currentStage = state.world?.stage || 1;
            if (currentStage === 1) {
              // é¡¯ç¤ºæ•…äº‹ï¼Œæ•…äº‹æœƒè‡ªå·±ç®¡ç†æ¨¡æ…‹è¦–çª—
              showStageStory(1);
            } else {
              // å¦‚æœä¸æ˜¯ç¬¬ä¸€éšæ®µï¼Œç›´æ¥é—œé–‰æ¨¡æ…‹è¦–çª—ä¸¦é–‹å§‹éŠæˆ²
            dom.modalLayer.classList.add('hidden');
            dom.levelModal.innerHTML = '';
            }
            
            setTimeout(() => {
              renderAll();
            }, 0);
          }
          break;
        case 'close-shop':
          state.ui.shop = null;
          // é—œé–‰å•†åº—å¾Œè‡ªå‹•å‰é€²åˆ°ä¸‹ä¸€å€‹ç¯€é»
          advanceToNextNode();
          renderAll();
          break;
        case 'save-settings':
          saveSettings();
          break;
        case 'cancel-settings':
          cancelSettings();
          break;
        case 'restart-from-stage-start':
          restartFromStageStart();
          break;
        case 'restart-game':
          // é‡æ–°é–‹å§‹éŠæˆ²
          state.hero = null;
          state.companions = [];
          state.world = { stage: 1, nodes: [], currentNodeIndex: 0, currentArea: 'field' };
          state.ui.battle = null;
          state.ui.levelUp = null;
          state.ui.deathInfo = null;
          state.ui.gameStats = null;
          clearSavedGame();
          clearStageBackup(); // æ¸…é™¤éšæ®µå‚™ä»½
          dom.modalLayer.classList.add('hidden');
          showStartMenu();
          renderAll();
          break;
        default:
          break;
      }
    }
    
    // å•†åº—æ¨™ç±¤åˆ‡æ›
    const shopTab = event.target.closest('[data-shop-type]');
    if (shopTab && state.ui.shop) {
      state.ui.shop.type = shopTab.dataset.shopType;
      renderShop();
      return;
    }
    
    // è³¼è²·è£å‚™ï¼ˆæ’é™¤å–å‡ºè£…å¤‡çš„æŒ‰é’®ï¼Œå–å‡ºæŒ‰é’®æœ‰data-action="sell-equipment"ï¼‰
    const buyBtn = event.target.closest('.shop-buy-btn[data-equipment]');
    if (buyBtn && !buyBtn.dataset.action && buyBtn.dataset.price) {
      // ç²å– equipmentDataï¼Œéœ€è¦å…ˆé€²è¡Œ HTML åè½‰ç¾©
      let equipmentData = buyBtn.dataset.equipment;
      // HTML åè½‰ç¾©å‡½æ•¸
      const unescapeHtml = (str) => {
        if (typeof str !== 'string') return str;
        return str
          .replace(/&quot;/g, '"')
          .replace(/&#39;/g, "'")
          .replace(/&lt;/g, '<')
          .replace(/&gt;/g, '>')
          .replace(/&amp;/g, '&');
      };
      equipmentData = unescapeHtml(equipmentData);
      
      const price = parseInt(buyBtn.dataset.price, 10);
      const autoEquip = buyBtn.dataset.autoEquip === 'true';
      buyEquipment(equipmentData, price, autoEquip);
      return;
    }
    
    // è³¼è²·é“å…·
    const buyItemBtn = event.target.closest('.shop-buy-btn[data-action="buy-item"]');
    if (buyItemBtn) {
      const itemId = buyItemBtn.dataset.item;
      const price = parseInt(buyItemBtn.dataset.price, 10);
      buyItem(itemId, price);
      return;
    }
    
    // è³¼è²·è£œçµ¦ï¼ˆå®Œå…¨æ¢å¾©ï¼‰
    const supplyBtn = event.target.closest('.shop-buy-btn[data-action="heal"]');
    if (supplyBtn) {
      const price = parseInt(supplyBtn.dataset.price, 10);
      buySupply('heal', price);
      return;
    }
    
    // è³£å‡ºé“å…·
    const sellBtn = event.target.closest('.shop-buy-btn[data-action="sell-item"]');
    if (sellBtn) {
      const itemId = sellBtn.dataset.item;
      const item = ITEM_LOOKUP.get(itemId);
      const sellPrice = item ? Math.floor((item.price || 10) / 2) : 5;
      sellItem(itemId, sellPrice);
      return;
    }
    
    // è³£å‡ºè£å‚™
    const sellEquipmentBtn = event.target.closest('.shop-buy-btn[data-action="sell-equipment"]');
    if (sellEquipmentBtn) {
      const equipmentId = sellEquipmentBtn.dataset.equipment;
      sellEquipment(equipmentId);
      return;
    }
  });

  if (dom.battlePanel) {
    dom.battlePanel.addEventListener('click', (event) => {
      const commandBtn = event.target.closest('[data-command]');
      if (commandBtn) {
        handleBattleCommand(commandBtn.dataset.command);
        return;
      }
      const skillBtn = event.target.closest('[data-skill]');
      if (skillBtn) {
        performSkill(skillBtn.dataset.skill);
        return;
      }
      const itemBtn = event.target.closest('[data-item]');
      if (itemBtn) {
        useBattleItem(itemBtn.dataset.item);
        return;
      }
      const targetEnemyBtn = event.target.closest('[data-target-enemy]');
      if (targetEnemyBtn) {
        const battle = state.ui.battle;
        if (battle) {
          battle.selectedEnemyIndex = parseInt(targetEnemyBtn.dataset.targetEnemy, 10);
          if (battle.pendingSkill) {
            performSkill(battle.pendingSkill);
          } else {
            performBasicAttack();
          }
        }
        return;
      }
      // é»æ“Šæ•µäººåˆ—è¡¨ä¸­çš„æ•µäººï¼ˆåœ¨é¸æ“‡ç›®æ¨™æ¨¡å¼ä¸‹ï¼‰
      const enemyEntry = event.target.closest('.enemy-entry');
      if (enemyEntry && battle.menu === 'select-enemy') {
        const enemyName = enemyEntry.dataset.enemyName;
        if (enemyName) {
          // æ‰¾åˆ°è©²åç¨±çš„ç¬¬ä¸€å€‹æ´»è‘—çš„æ•µäºº
          const targetIndex = battle.enemies.findIndex(e => e.name === enemyName && e.hp > 0);
          if (targetIndex >= 0) {
            battle.selectedEnemyIndex = targetIndex;
            if (battle.pendingSkill) {
              performSkill(battle.pendingSkill);
            } else {
              performBasicAttack();
            }
          }
        }
        return;
      }
    });
  }

  console.log('[BIND] é–‹å§‹ç¶å®šæŒ‰éˆ•äº‹ä»¶...');
  
  // é‡æ–°ç²å–æŒ‰éˆ•å…ƒç´ ï¼ˆç¢ºä¿æ˜¯æœ€æ–°çš„ï¼‰
  const continueBtnEl = document.getElementById('btn-continue');
  const newBtnEl = document.getElementById('btn-new');
  const settingsBtnEl = document.getElementById('btn-settings');
  
  console.log('[BIND] é‡æ–°ç²å–å…ƒç´  - continueBtn:', continueBtnEl);
  console.log('[BIND] é‡æ–°ç²å–å…ƒç´  - newBtn:', newBtnEl);
  console.log('[BIND] é‡æ–°ç²å–å…ƒç´  - settingsBtn:', settingsBtnEl);
  
  if (continueBtnEl) {
    console.log('[BIND] ç¶å®š continueBtn äº‹ä»¶');
    // ç§»é™¤èˆŠçš„äº‹ä»¶ç›£è½å™¨ï¼ˆå¦‚æœæœ‰çš„è©±ï¼‰
    const newContinueBtn = continueBtnEl.cloneNode(true);
    continueBtnEl.parentNode.replaceChild(newContinueBtn, continueBtnEl);
    dom.continueBtn = newContinueBtn;
    newContinueBtn.addEventListener('click', function(e) {
      console.log('[EVENT] continueBtn è¢«é»æ“Š', e);
      console.log('[EVENT] continueBtn target:', e.target);
      continueAdventure();
    });
    console.log('[BIND] continueBtn äº‹ä»¶ç¶å®šå®Œæˆ');
  } else {
    console.error('[BIND] continueBtn å…ƒç´ ä¸å­˜åœ¨');
  }
  
  if (newBtnEl) {
    console.log('[BIND] ç¶å®š newBtn äº‹ä»¶');
    // ç§»é™¤èˆŠçš„äº‹ä»¶ç›£è½å™¨ï¼ˆå¦‚æœæœ‰çš„è©±ï¼‰
    const newNewBtn = newBtnEl.cloneNode(true);
    newBtnEl.parentNode.replaceChild(newNewBtn, newBtnEl);
    dom.newBtn = newNewBtn;
    newNewBtn.addEventListener('click', function(e) {
      console.log('[EVENT] newBtn è¢«é»æ“Š', e);
      console.log('[EVENT] newBtn target:', e.target);
      startNewAdventure();
    });
    console.log('[BIND] newBtn äº‹ä»¶ç¶å®šå®Œæˆ');
  } else {
    console.error('[BIND] newBtn å…ƒç´ ä¸å­˜åœ¨');
  }
  
  if (settingsBtnEl) {
    console.log('[BIND] ç¶å®š settingsBtn äº‹ä»¶');
    // ç§»é™¤èˆŠçš„äº‹ä»¶ç›£è½å™¨ï¼ˆå¦‚æœæœ‰çš„è©±ï¼‰
    const newSettingsBtn = settingsBtnEl.cloneNode(true);
    settingsBtnEl.parentNode.replaceChild(newSettingsBtn, settingsBtnEl);
    dom.settingsBtn = newSettingsBtn;
    newSettingsBtn.addEventListener('click', function(e) {
      console.log('[EVENT] settingsBtn è¢«é»æ“Š', e);
      console.log('[EVENT] settingsBtn target:', e.target);
      openSettings();
    });
    console.log('[BIND] settingsBtn äº‹ä»¶ç¶å®šå®Œæˆ');
  } else {
    console.error('[BIND] settingsBtn å…ƒç´ ä¸å­˜åœ¨');
  }
  
  console.log('[BIND] æŒ‰éˆ•äº‹ä»¶ç¶å®šå®Œæˆ');

  // ç‹€æ…‹é¢æ¿æ¨™ç±¤é åˆ‡æ›ï¼ˆå·²ç§»é™¤ï¼Œç¾åœ¨ä¸éœ€è¦æ¨™ç±¤é ï¼‰

  // è£å‚™é¢æ¿äº‹ä»¶
  if (dom.equipmentPanel) {
    dom.equipmentPanel.addEventListener('click', (event) => {
      const unequipBtn = event.target.closest('.unequip-btn');
      if (unequipBtn) {
        const slot = unequipBtn.dataset.slot;
        unequipItem(slot);
        return;
      }
      
      const equipBtn = event.target.closest('.equip-from-inventory-btn');
      if (equipBtn) {
        const slot = equipBtn.dataset.slot;
        const equipmentId = equipBtn.dataset.equipment;
        equipItem(equipmentId, slot);
        return;
      }
      
      // å°‡è£å‚™æ”¾å…¥é“å…·è¢‹
      const equipmentToBagBtn = event.target.closest('.equipment-to-bag-btn');
      if (equipmentToBagBtn) {
        const equipmentId = equipmentToBagBtn.dataset.equipment;
        const slot = equipmentToBagBtn.dataset.slot;
        moveEquipmentToBag(equipmentId, slot);
        return;
      }
      
      // å¸ä¸‹åœ£ç‰©
      const unequipRelicBtn = event.target.closest('.unequip-relic-btn');
      if (unequipRelicBtn) {
        const companionIndex = parseInt(unequipRelicBtn.dataset.companionIndex);
        unequipRelicFromCompanion(companionIndex);
        return;
      }
    });
  }

  // é“å…·æ¬„äº‹ä»¶
  if (dom.inventoryPanel) {
    dom.inventoryPanel.addEventListener('click', (event) => {
      const dropBtn = event.target.closest('.drop-item-btn');
      if (dropBtn) {
        const itemId = dropBtn.dataset.item;
        dropItem(itemId);
        return;
      }
      
      const useBtn = event.target.closest('.use-item-btn');
      if (useBtn) {
        const itemId = useBtn.dataset.item;
        useItemInField(itemId);
        return;
      }
      
      // å¾é“å…·è¢‹è£å‚™
      const equipFromBagBtn = event.target.closest('.equip-from-bag-btn');
      if (equipFromBagBtn) {
        const equipmentId = equipFromBagBtn.dataset.equipment;
        const itemId = equipFromBagBtn.dataset.item;
        equipItemFromBag(equipmentId, itemId);
        return;
      }
    });
  }

  window.addEventListener('storage', () => {
    if (state.ui.startMenu) {
      updateStartMenuButtons();
    }
  });
}

// å¸ä¸‹è£å‚™
// ç²å–è£å‚™å°æ‡‰çš„è¢«å‹•æŠ€èƒ½ID
function getEquipmentPassiveSkillId(equipmentId) {
  const skillMap = {
    'rod_sword': 'rod_sword_passive',
    'rod_shield': 'rod_shield_passive',
    'rod_armor': 'rod_armor_passive',
    'rod_emblem': 'rod_emblem_passive',
  };
  return skillMap[equipmentId] || null;
}

function unequipItem(slot) {
  const hero = state.hero;
  if (!hero || !hero.equipment) return;
  
  // æˆ°é¬¥ä¸­ä¸èƒ½å¸ä¸‹è£å‚™
  if (state.ui.battle) {
    pushLog('æˆ°é¬¥ä¸­ç„¡æ³•å¸ä¸‹è£å‚™ï¼');
    return;
  }
  
  const equipmentId = hero.equipment[slot];
  if (!equipmentId) return;
  
  const equipment = getEquipmentData(equipmentId);
  if (equipment) {
    // ç§»é™¤è£å‚™çš„HP/MPåŠ æˆ
    if (equipment.hpBonus !== undefined && equipment.hpBonus > 0) {
      const oldMaxHp = hero.stats.maxHp;
      hero.stats.maxHp = Math.max(1, hero.stats.maxHp - equipment.hpBonus);
      // æŒ‰æ¯”ä¾‹èª¿æ•´ç•¶å‰HP
      if (oldMaxHp > 0) {
        const hpPercent = hero.stats.hp / oldMaxHp;
        hero.stats.hp = Math.max(1, Math.ceil(hero.stats.maxHp * hpPercent));
      }
    }
    if (equipment.mpBonus !== undefined && equipment.mpBonus > 0) {
      const oldMaxMp = hero.stats.maxMp;
      hero.stats.maxMp = Math.max(1, hero.stats.maxMp - equipment.mpBonus);
      // æŒ‰æ¯”ä¾‹èª¿æ•´ç•¶å‰MP
      if (oldMaxMp > 0) {
        const mpPercent = hero.stats.mp / oldMaxMp;
        hero.stats.mp = Math.max(0, Math.ceil(hero.stats.maxMp * mpPercent));
      }
    }
    
    // ç§»é™¤è£å‚™å°æ‡‰çš„è¢«å‹•æŠ€èƒ½ï¼ˆç¾…å¾·è£å‚™ï¼‰
    const passiveSkillId = getEquipmentPassiveSkillId(equipmentId);
    if (passiveSkillId && hero.skills && hero.skills.includes(passiveSkillId)) {
      hero.skills = hero.skills.filter(id => id !== passiveSkillId);
      pushLog(`å¸ä¸‹${equipment.name}ï¼Œå¤±å»è¢«å‹•æŠ€èƒ½æ•ˆæœã€‚`);
    }
    
    // å°‡è£å‚™æ”¾å…¥é“å…·è¢‹ï¼ˆåŒ…æ‹¬ç¾…å¾·è£å‚™ï¼‰
    const itemId = `equipment_${equipmentId}`;
    let itemEntry = hero.items.find(entry => entry.id === itemId);
    if (itemEntry) {
      itemEntry.qty += 1;
    } else {
      // æª¢æŸ¥é“å…·æ¬„æ˜¯å¦å·²æ»¿
      limitInventorySize();
      const currentItemCount = hero.items.filter(item => item.qty > 0).length;
      if (currentItemCount >= 8) {
        pushLog(`å¸ä¸‹äº†${equipment.name}ï¼Œä½†é“å…·æ¬„å·²æ»¿ï¼Œè£å‚™å·²ä¸Ÿå¤±ï¼`);
  hero.equipment[slot] = null;
        renderAll();
        return;
      }
      hero.items.push({ id: itemId, qty: 1 });
    }
    
    // å¦‚æœè£å‚™åœ¨è£å‚™åº«å­˜ä¸­ï¼Œç§»é™¤å®ƒï¼ˆç¾…å¾·è£å‚™å¯èƒ½ä¸åœ¨åº«å­˜ä¸­ï¼‰
    if (hero.equipmentInventory && hero.equipmentInventory.includes(equipmentId)) {
      hero.equipmentInventory = hero.equipmentInventory.filter(id => id !== equipmentId);
    }
  }
  
  hero.equipment[slot] = null;
  pushLog(`å¸ä¸‹äº†${equipment?.name || 'è£å‚™'}ï¼ˆå·²æ”¾å…¥é“å…·è¢‹ï¼‰ã€‚`);
  renderAll();
}

// è£å‚™ç‰©å“
function equipItem(equipmentId, slot) {
  const hero = state.hero;
  if (!hero || !hero.equipment) return;
  
  // æˆ°é¬¥ä¸­ä¸èƒ½è£å‚™
  if (state.ui.battle) {
    pushLog('æˆ°é¬¥ä¸­ç„¡æ³•è£å‚™ï¼');
    return;
  }
  
  const equipment = getEquipmentData(equipmentId);
  if (!equipment) return;
  
  // æª¢æŸ¥æ˜¯å¦åœ¨åº«å­˜ä¸­
  if (!hero.equipmentInventory || !hero.equipmentInventory.includes(equipmentId)) {
    pushLog('ä½ æ²’æœ‰é€™ä»¶è£å‚™ï¼');
    return;
  }
  
  // æª¢æŸ¥è£å‚™é¡å‹æ˜¯å¦åŒ¹é…æ¬„ä½
  const typeMap = {
    weapon: 'weapon',
    shield: 'shield',
    armor: 'armor',
    accessory: 'accessory',
  };
  
  const expectedSlot = typeMap[equipment.type];
  if (expectedSlot && slot !== expectedSlot) {
    pushLog('è£å‚™é¡å‹èˆ‡æ¬„ä½ä¸åŒ¹é…ï¼');
    return;
  }
  
  // å¸ä¸‹èˆŠè£å‚™ï¼ˆå¦‚æœæœ‰ï¼‰ï¼Œè‡ªå‹•è³£æ‰ï¼Œä¸¦ç§»é™¤HP/MPåŠ æˆ
  const oldEquipmentId = hero.equipment[slot];
  if (oldEquipmentId) {
    const oldEquipment = getEquipmentData(oldEquipmentId);
    if (oldEquipment) {
      // ç§»é™¤èˆŠè£å‚™çš„HP/MPåŠ æˆ
      if (oldEquipment.hpBonus !== undefined && oldEquipment.hpBonus > 0) {
        const oldMaxHp = hero.stats.maxHp;
        hero.stats.maxHp = Math.max(1, hero.stats.maxHp - oldEquipment.hpBonus);
        // æŒ‰æ¯”ä¾‹èª¿æ•´ç•¶å‰HP
        if (oldMaxHp > 0) {
          const hpPercent = hero.stats.hp / oldMaxHp;
          hero.stats.hp = Math.max(1, Math.ceil(hero.stats.maxHp * hpPercent));
        }
      }
      if (oldEquipment.mpBonus !== undefined && oldEquipment.mpBonus > 0) {
        const oldMaxMp = hero.stats.maxMp;
        hero.stats.maxMp = Math.max(1, hero.stats.maxMp - oldEquipment.mpBonus);
        // æŒ‰æ¯”ä¾‹èª¿æ•´ç•¶å‰MP
        if (oldMaxMp > 0) {
          const mpPercent = hero.stats.mp / oldMaxMp;
          hero.stats.mp = Math.max(0, Math.ceil(hero.stats.maxMp * mpPercent));
        }
      }
      
      const sellPrice = Math.floor((oldEquipment.price || 50) / 2);
      hero.stats.gold += sellPrice;
      pushLog(`è‡ªå‹•è³£æ‰äº†è¢«å–ä»£çš„ ${oldEquipment.name}ï¼Œç²å¾— ${sellPrice} é‡‘å¹£ã€‚`);
      
      // å¾è£å‚™åº«å­˜ä¸­ç§»é™¤èˆŠè£å‚™
      if (hero.equipmentInventory) {
        hero.equipmentInventory = hero.equipmentInventory.filter(id => id !== oldEquipmentId);
      }
      // å¦‚æœæ˜¯ç²¾è‰¯è£å‚™ï¼Œä¹Ÿè¦å¾superiorEquipmentä¸­ç§»é™¤
      if (oldEquipment.isSuperior && hero.superiorEquipment && hero.superiorEquipment[oldEquipmentId]) {
        delete hero.superiorEquipment[oldEquipmentId];
      }
    }
  }
  
  // å¸ä¸‹èˆŠè£å‚™å°æ‡‰çš„è¢«å‹•æŠ€èƒ½ï¼ˆå¦‚æœæœ‰ï¼‰
  if (oldEquipmentId) {
    const oldPassiveSkillId = getEquipmentPassiveSkillId(oldEquipmentId);
    if (oldPassiveSkillId && hero.skills && hero.skills.includes(oldPassiveSkillId)) {
      hero.skills = hero.skills.filter(id => id !== oldPassiveSkillId);
    }
  }
  
  // è£å‚™æ–°è£å‚™ï¼Œä¸¦æ‡‰ç”¨HP/MPåŠ æˆ
  hero.equipment[slot] = equipmentId;
  
  // æ‡‰ç”¨æ–°è£å‚™çš„HP/MPåŠ æˆ
  if (equipment.hpBonus !== undefined && equipment.hpBonus > 0) {
    const oldMaxHp = hero.stats.maxHp;
    hero.stats.maxHp = Math.ceil(hero.stats.maxHp + equipment.hpBonus);
    // å¦‚æœç•¶å‰HPæœªæ»¿ï¼ŒæŒ‰æ¯”ä¾‹å¢åŠ 
    if (hero.stats.hp < oldMaxHp) {
      const hpPercent = hero.stats.hp / oldMaxHp;
      hero.stats.hp = Math.ceil(hero.stats.maxHp * hpPercent);
    } else {
      // å¦‚æœHPå·²æ»¿ï¼Œç›´æ¥å¢åŠ åˆ°æ–°çš„æœ€å¤§å€¼
      hero.stats.hp = hero.stats.maxHp;
    }
  }
  if (equipment.mpBonus !== undefined && equipment.mpBonus > 0) {
    const oldMaxMp = hero.stats.maxMp;
    hero.stats.maxMp = Math.ceil(hero.stats.maxMp + equipment.mpBonus);
    // å¦‚æœç•¶å‰MPæœªæ»¿ï¼ŒæŒ‰æ¯”ä¾‹å¢åŠ 
    if (hero.stats.mp < oldMaxMp) {
      const mpPercent = hero.stats.mp / oldMaxMp;
      hero.stats.mp = Math.ceil(hero.stats.maxMp * mpPercent);
    } else {
      // å¦‚æœMPå·²æ»¿ï¼Œç›´æ¥å¢åŠ åˆ°æ–°çš„æœ€å¤§å€¼
      hero.stats.mp = hero.stats.maxMp;
    }
  }
  
  // æ·»åŠ è£å‚™å°æ‡‰çš„è¢«å‹•æŠ€èƒ½ï¼ˆç¾…å¾·è£å‚™ï¼‰
  const passiveSkillId = getEquipmentPassiveSkillId(equipmentId);
  if (passiveSkillId) {
    const passiveSkill = SKILL_LOOKUP.get(passiveSkillId);
    if (passiveSkill && (!hero.skills || !hero.skills.includes(passiveSkillId))) {
      if (!hero.skills) {
        hero.skills = [];
      }
      hero.skills.push(passiveSkillId);
      pushLog(`è£å‚™${equipment.name}ï¼Œç²å¾—è¢«å‹•æŠ€èƒ½ï¼š${passiveSkill.name}ã€‚`);
    }
  }
  
  pushLog(`è£å‚™äº†${equipment.name}ã€‚`);
  renderAll();
}

// å¾é“å…·è¢‹è£å‚™ç‰©å“
function equipItemFromBag(equipmentId, itemId) {
  const hero = state.hero;
  if (!hero || !hero.equipment) return;
  
  // æˆ°é¬¥ä¸­ä¸èƒ½è£å‚™
  if (state.ui.battle) {
    pushLog('æˆ°é¬¥ä¸­ç„¡æ³•è£å‚™ï¼');
    return;
  }
  
  const equipment = getEquipmentData(equipmentId);
  if (!equipment) return;
  
  // æª¢æŸ¥é“å…·è¢‹ä¸­æ˜¯å¦æœ‰é€™ä»¶è£å‚™
  const itemEntry = hero.items.find(entry => entry.id === itemId);
  if (!itemEntry || itemEntry.qty <= 0) {
    pushLog('é“å…·è¢‹ä¸­æ²’æœ‰é€™ä»¶è£å‚™ï¼');
    return;
  }
  
  // ç¢ºå®šè£å‚™æ§½ä½
  const typeMap = {
    weapon: 'weapon',
    shield: 'shield',
    armor: 'armor',
    accessory: 'accessory',
  };
  const slot = typeMap[equipment.type];
  if (!slot) {
    pushLog('æœªçŸ¥çš„è£å‚™é¡å‹ï¼');
    return;
  }
  
  // å¸ä¸‹èˆŠè£å‚™ï¼ˆå¦‚æœæœ‰ï¼‰ï¼Œæ”¾å…¥é“å…·è¢‹ï¼Œä¸¦ç§»é™¤HP/MPåŠ æˆ
  const oldEquipmentId = hero.equipment[slot];
  if (oldEquipmentId) {
    const oldEquipment = getEquipmentData(oldEquipmentId);
    if (oldEquipment) {
      // ç§»é™¤èˆŠè£å‚™çš„HP/MPåŠ æˆ
      if (oldEquipment.hpBonus !== undefined && oldEquipment.hpBonus > 0) {
        const oldMaxHp = hero.stats.maxHp;
        hero.stats.maxHp = Math.max(1, hero.stats.maxHp - oldEquipment.hpBonus);
        // æŒ‰æ¯”ä¾‹èª¿æ•´ç•¶å‰HP
        if (oldMaxHp > 0) {
          const hpPercent = hero.stats.hp / oldMaxHp;
          hero.stats.hp = Math.max(1, Math.ceil(hero.stats.maxHp * hpPercent));
        }
      }
      if (oldEquipment.mpBonus !== undefined && oldEquipment.mpBonus > 0) {
        const oldMaxMp = hero.stats.maxMp;
        hero.stats.maxMp = Math.max(1, hero.stats.maxMp - oldEquipment.mpBonus);
        // æŒ‰æ¯”ä¾‹èª¿æ•´ç•¶å‰MP
        if (oldMaxMp > 0) {
          const mpPercent = hero.stats.mp / oldMaxMp;
          hero.stats.mp = Math.max(0, Math.ceil(hero.stats.maxMp * mpPercent));
        }
      }
      
      // å°‡èˆŠè£å‚™æ”¾å…¥é“å…·è¢‹
      const oldItemId = `equipment_${oldEquipmentId}`;
      let oldItemEntry = hero.items.find(entry => entry.id === oldItemId);
      if (oldItemEntry) {
        oldItemEntry.qty += 1;
      } else {
        hero.items.push({ id: oldItemId, qty: 1 });
      }
      pushLog(`å°‡è¢«å–ä»£çš„ ${oldEquipment.name} æ”¾å…¥é“å…·è¢‹ã€‚`);
      
      // å¾è£å‚™åº«å­˜ä¸­ç§»é™¤èˆŠè£å‚™
      if (hero.equipmentInventory) {
        hero.equipmentInventory = hero.equipmentInventory.filter(id => id !== oldEquipmentId);
      }
      // å¸ä¸‹èˆŠè£å‚™å°æ‡‰çš„è¢«å‹•æŠ€èƒ½ï¼ˆå¦‚æœæœ‰ï¼‰
      const oldPassiveSkillId = getEquipmentPassiveSkillId(oldEquipmentId);
      if (oldPassiveSkillId && hero.skills && hero.skills.includes(oldPassiveSkillId)) {
        hero.skills = hero.skills.filter(id => id !== oldPassiveSkillId);
      }
      
      // å¦‚æœæ˜¯ç²¾è‰¯è£å‚™ï¼Œä¹Ÿè¦å¾superiorEquipmentä¸­ç§»é™¤
      if (oldEquipment.isSuperior && hero.superiorEquipment && hero.superiorEquipment[oldEquipmentId]) {
        delete hero.superiorEquipment[oldEquipmentId];
      }
    }
  }
  
  // å¾é“å…·è¢‹ä¸­ç§»é™¤è£å‚™ï¼ˆæ•¸é‡æ¸›1ï¼‰
  itemEntry.qty -= 1;
  if (itemEntry.qty <= 0) {
    hero.items = hero.items.filter(entry => entry.qty > 0);
  }
  
  // è£å‚™æ–°è£å‚™ï¼Œä¸¦æ‡‰ç”¨HP/MPåŠ æˆ
  hero.equipment[slot] = equipmentId;
  
  // æ‡‰ç”¨æ–°è£å‚™çš„HP/MPåŠ æˆ
  if (equipment.hpBonus !== undefined && equipment.hpBonus > 0) {
    const oldMaxHp = hero.stats.maxHp;
    hero.stats.maxHp = Math.ceil(hero.stats.maxHp + equipment.hpBonus);
    // å¦‚æœç•¶å‰HPæœªæ»¿ï¼ŒæŒ‰æ¯”ä¾‹å¢åŠ 
    if (hero.stats.hp < oldMaxHp) {
      const hpPercent = hero.stats.hp / oldMaxHp;
      hero.stats.hp = Math.ceil(hero.stats.maxHp * hpPercent);
    } else {
      // å¦‚æœHPå·²æ»¿ï¼Œç›´æ¥å¢åŠ åˆ°æ–°çš„æœ€å¤§å€¼
      hero.stats.hp = hero.stats.maxHp;
    }
  }
  if (equipment.mpBonus !== undefined && equipment.mpBonus > 0) {
    const oldMaxMp = hero.stats.maxMp;
    hero.stats.maxMp = Math.ceil(hero.stats.maxMp + equipment.mpBonus);
    // å¦‚æœç•¶å‰MPæœªæ»¿ï¼ŒæŒ‰æ¯”ä¾‹å¢åŠ 
    if (hero.stats.mp < oldMaxMp) {
      const mpPercent = hero.stats.mp / oldMaxMp;
      hero.stats.mp = Math.ceil(hero.stats.maxMp * mpPercent);
    } else {
      // å¦‚æœMPå·²æ»¿ï¼Œç›´æ¥å¢åŠ åˆ°æ–°çš„æœ€å¤§å€¼
      hero.stats.mp = hero.stats.maxMp;
    }
  }
  
  // æ·»åŠ è£å‚™å°æ‡‰çš„è¢«å‹•æŠ€èƒ½ï¼ˆç¾…å¾·è£å‚™ï¼‰
  const passiveSkillId = getEquipmentPassiveSkillId(equipmentId);
  if (passiveSkillId) {
    const passiveSkill = SKILL_LOOKUP.get(passiveSkillId);
    if (passiveSkill && (!hero.skills || !hero.skills.includes(passiveSkillId))) {
      if (!hero.skills) {
        hero.skills = [];
      }
      hero.skills.push(passiveSkillId);
      pushLog(`è£å‚™${equipment.name}ï¼Œç²å¾—è¢«å‹•æŠ€èƒ½ï¼š${passiveSkill.name}ã€‚`);
    }
  }
  
  pushLog(`è£å‚™äº†${equipment.name}ã€‚`);
  
  renderAll();
}

function renderAll() {
  // ç¡®ä¿heroçš„goldä¸æ˜¯null
  if (state.hero && state.hero.stats && (state.hero.stats.gold == null || state.hero.stats.gold === undefined)) {
    state.hero.stats.gold = 0;
  }
  
  // ç¢ºä¿é–‹å§‹é¸å–®çš„é¡¯ç¤ºç‹€æ…‹èˆ‡ state åŒæ­¥
  if (dom.startScreen) {
    if (state.ui.startMenu) {
      dom.startScreen.classList.remove('hidden');
      dom.startScreen.style.display = 'flex';
    } else {
      dom.startScreen.classList.add('hidden');
      dom.startScreen.style.display = 'none';
    }
  }
  
  // æ¸²æŸ“èƒŒæ™¯
  renderBackground();
  
  // æ¸²æŸ“ç‹€æ…‹é¢æ¿
  renderHeroPanel();
  renderSkillsPanel();
  renderStatusTabs();
  renderLog();
  
  // æ¸²æŸ“éŠæˆ²å…§å®¹ï¼ˆè·¯ç·šé¸æ“‡æˆ–æˆ°é¬¥ï¼‰
  if (state.ui.battle) {
    renderBattleDialog();
    hideRouteDialog();
    // æˆ°é¬¥æ™‚éš±è—å·¦å´é¢æ¿
    if (dom.fieldActionsPanel) {
      dom.fieldActionsPanel.classList.add('hidden');
    }
  } else if (state.hero && !state.ui.startMenu) {
    renderRouteDialog();
    hideBattleDialog();
    // éæˆ°é¬¥æ™‚ä¹Ÿé¡¯ç¤ºHP/MP
    renderHeroStats();
    // éæˆ°é¬¥æ™‚é¡¯ç¤ºå·¦å´é¢æ¿
    renderFieldActionsPanel();
  } else {
    hideRouteDialog();
    hideBattleDialog();
    // å¦‚æœæ²’æœ‰è‹±é›„æˆ–é–‹å§‹é¸å–®ï¼Œæ¸…ç©ºHP/MPé¡¯ç¤º
    if (dom.battleHeroStats) {
      dom.battleHeroStats.innerHTML = '';
      dom.battleHeroStats.style.display = 'none';
    }
    // éš±è—å·¦å´é¢æ¿
    if (dom.fieldActionsPanel) {
      dom.fieldActionsPanel.classList.add('hidden');
    }
  }
  
  renderLevelModal();
  
  if (state.hero && !state.ui.startMenu && !state.ui.battle) {
    saveGameState();
  }
}

// æ ¹æ“šéšæ®µç²å–å°æ‡‰çš„å€åŸŸéµå€¼
function getAreaKeyByStage(stage) {
  if (stage === 1) return 'field';
  if (stage === 2) return 'forest';
  if (stage === 3) return 'mountain';
  if (stage === 4) return 'cave';
  if (stage === 5) return 'maze';
  if (stage >= 6) return 'castle';
  return 'field';
}

function renderBackground() {
  if (!dom.backgroundImage) return;
  
  const currentStage = state.world.stage || 1;
  
  // æ ¹æ“šéšæ®µé¸æ“‡å°æ‡‰çš„èƒŒæ™¯å’Œå ´æ™¯åç¨±
  const areaKey = getAreaKeyByStage(currentStage);
  
  const areaConfig = AREA_CONFIG[areaKey] || AREA_CONFIG.field;
  dom.backgroundImage.src = areaConfig.background;
  dom.backgroundImage.alt = areaConfig.name;
  
  // æ›´æ–° currentArea
  state.world.currentArea = areaKey;
}

function renderRouteDialog() {
  if (!dom.routeDialog || !state.hero) return;
  const node = state.world.nodes[state.world.currentNodeIndex];
  if (!node) {
    hideRouteDialog();
    return;
  }
  
  // ç²å–ç•¶å‰å ´æ™¯åç¨±
  const areaKey = state.world.currentArea || getAreaKeyByStage(state.world.stage);
  const areaConfig = AREA_CONFIG[areaKey] || AREA_CONFIG.field;
  const areaName = areaConfig.name || 'æœªçŸ¥å ´æ™¯';
  
  // è¨ˆç®—å€åŸŸç·¨è™Ÿï¼ˆå¾1é–‹å§‹ï¼‰
  const areaNumber = state.world.currentNodeIndex + 1;
  
  dom.routeDialog.classList.remove('hidden');
  // ç¬¬ä¸€è¡Œï¼šå ´æ™¯åç¨± + ç¬¬xå€åŸŸ
  if (dom.routeTitle) dom.routeTitle.textContent = `${areaName} ç¬¬${areaNumber}å€åŸŸ`;
  // ç¬¬äºŒè¡Œï¼šé¸æ“‡ä½ çš„è·¯ç·š
  if (dom.routeDescription) dom.routeDescription.textContent = 'é¸æ“‡ä½ çš„è·¯ç·š';
  
  if (dom.routeOptions && node.options) {
    dom.routeOptions.innerHTML = node.options.map((option, index) => `
      <button class="dialog-option" data-option-index="${index}">
        ${option.label}
        <small>${option.description}</small>
      </button>
    `).join('');
  }
}

function hideRouteDialog() {
  if (dom.routeDialog) dom.routeDialog.classList.add('hidden');
} 
// æ ¼å¼åŒ–HPé¡¯ç¤ºï¼ŒåŒ…å«é˜²è­·ç½©æ•¸å€¼
function formatHpDisplay(character) {
  if (!character || !character.stats) return 'HP: 0/0';
  const hp = character.stats.hp || 0;
  const maxHp = character.stats.maxHp || 0;
  const shield = character.stats.shield || 0;
  if (shield > 0) {
    return `HP: ${hp}/${maxHp} [è­·ç›¾: ${shield}]`;
  }
  return `HP: ${hp}/${maxHp}`;
}

// å–å¾—è§’è‰²èº«ä¸Šçš„ buff/debuff åˆ—è¡¨ï¼ˆä¾› UI æ¸²æŸ“ä½¿ç”¨ï¼‰
function getCharacterBuffs(character, isHero) {
  const buffs = [];
  const battle = state.ui.battle;

  if (!battle) return buffs;

  // å…‰ç’°æ•ˆæœ
  if (battle.aura && battle.aura.duration > 0) {
    const aura = battle.aura;
    if (aura.type === 'attack') {
      buffs.push({ type: 'buff', name: `æ”»æ“Šå…‰ç’° +${aura.value}`, color: '#4FC3F7' });
    } else if (aura.type === 'defense') {
      buffs.push({ type: 'buff', name: `é˜²ç¦¦å…‰ç’° +${aura.value}`, color: '#4FC3F7' });
    } else if (aura.type === 'hpRegen') {
      buffs.push({ type: 'buff', name: `ç”Ÿå‘½å…‰ç’° +${aura.value}/å›åˆ`, color: '#4FC3F7' });
    } else if (aura.type === 'mpRegen') {
      buffs.push({ type: 'buff', name: `é­”åŠ›å…‰ç’° +${aura.value}/å›åˆ`, color: '#4FC3F7' });
    }
  }

  // è­·ç›¾
  if (character.stats.shield && character.stats.shield > 0) {
    buffs.push({ type: 'buff', name: `è­·ç›¾ ${character.stats.shield}`, color: '#4FC3F7' });
  }

  // é˜²å®ˆbuffï¼ˆå‚·å®³æ¸›å…ï¼‰
  if (isHero && battle.heroBuffs && battle.heroBuffs.guard > 0) {
    const guardPercent = Math.round(battle.heroBuffs.guard * 100);
    buffs.push({ type: 'buff', name: `é˜²ç¦¦æå‡ ${guardPercent}%`, color: '#4FC3F7' });
  } else if (!isHero && battle.companionBuffs) {
    let companionGuard = 0;
    if (battle.companionBuffs.guard !== undefined) {
      companionGuard = battle.companionBuffs.guard;
    } else {
      const companionIndex = state.companions ? state.companions.indexOf(character) : -1;
      if (companionIndex >= 0 && battle.companionBuffs[companionIndex]) {
        companionGuard = battle.companionBuffs[companionIndex].guard || 0;
      }
    }
    if (companionGuard > 0) {
      const guardPercent = Math.round(companionGuard * 100);
      buffs.push({ type: 'buff', name: `é˜²ç¦¦æå‡ ${guardPercent}%`, color: '#4FC3F7' });
    }
  }

  // åŠæ„buff
  if (isHero && battle.heroBuffs && battle.heroBuffs.swordIntent) {
    const swordIntent = battle.heroBuffs.swordIntent;
    buffs.push({ type: 'buff', name: `åŠæ„ ${swordIntent.duration}å›åˆ (æ”»+${Math.round(swordIntent.attackBoost * 100)}% æš´+${swordIntent.critBoost}%)`, color: '#4FC3F7' });
  } else if (!isHero && battle.companionBuffs) {
    const companionIndex = state.companions ? state.companions.indexOf(character) : -1;
    if (companionIndex >= 0 && battle.companionBuffs[companionIndex] && battle.companionBuffs[companionIndex].swordIntent) {
      const swordIntent = battle.companionBuffs[companionIndex].swordIntent;
      buffs.push({ type: 'buff', name: `åŠæ„ ${swordIntent.duration}å›åˆ (æ”»+${Math.round(swordIntent.attackBoost * 100)}% æš´+${swordIntent.critBoost}%)`, color: '#4FC3F7' });
    }
  }

  // é˜²æ­»è­·ç›¾
  if (isHero && battle.heroBuffs && battle.heroBuffs.deathWard) {
    buffs.push({ type: 'buff', name: 'é˜²æ­»è­·ç›¾', color: '#4FC3F7' });
  } else if (!isHero && battle.companionBuffs) {
    const companionIndex = state.companions ? state.companions.indexOf(character) : -1;
    if (companionIndex >= 0 && battle.companionBuffs[companionIndex] && battle.companionBuffs[companionIndex].deathWard) {
      buffs.push({ type: 'buff', name: 'é˜²æ­»è­·ç›¾', color: '#4FC3F7' });
    }
  }

  // ç ´ç”²ä¹‹åˆƒï¼ˆç„¡è¦–é˜²ç¦¦ï¼‰
  if (isHero && battle.heroBuffs && battle.heroBuffs.ignoreDefense) {
    buffs.push({ type: 'buff', name: 'ç ´ç”²ä¹‹åˆƒ', color: '#FF9800' });
  } else if (!isHero && battle.companionBuffs) {
    const companionIndex = state.companions ? state.companions.indexOf(character) : -1;
    if (companionIndex >= 0 && battle.companionBuffs[companionIndex] && battle.companionBuffs[companionIndex].ignoreDefense) {
      buffs.push({ type: 'buff', name: 'ç ´ç”²ä¹‹åˆƒ', color: '#FF9800' });
    }
  }

  // ç¥è–å›éŸ¿ï¼ˆç·©æ…¢æ¢å¾©ï¼‰
  if (isHero && battle.heroBuffs && battle.heroBuffs.healingEcho && battle.heroBuffs.healingEcho > 0) {
    buffs.push({ type: 'buff', name: `ç·©æ…¢æ¢å¾© +${battle.heroBuffs.healingEcho}`, color: '#81C784' });
  } else if (!isHero && battle.companionBuffs) {
    const companionIndex = state.companions ? state.companions.indexOf(character) : -1;
    if (companionIndex >= 0 && battle.companionBuffs[companionIndex] && battle.companionBuffs[companionIndex].healingEcho && battle.companionBuffs[companionIndex].healingEcho > 0) {
      buffs.push({ type: 'buff', name: `ç·©æ…¢æ¢å¾© +${battle.companionBuffs[companionIndex].healingEcho}`, color: '#81C784' });
    }
  }

  // å‹æ–¹debuffï¼ˆæ•µäººå°å‹æ–¹æ–½åŠ çš„ï¼‰
  if (battle.friendlyDebuffs) {
    if (isHero && battle.friendlyDebuffs.hero) {
      const heroDebuffs = battle.friendlyDebuffs.hero;
      if (heroDebuffs.poison) {
        buffs.push({ type: 'debuff', name: `ä¸­æ¯’ ${heroDebuffs.poison.duration}å›åˆ`, color: '#FF6B6B' });
      }
      if (heroDebuffs.slow) {
        buffs.push({ type: 'debuff', name: `æ¸›é€Ÿ ${heroDebuffs.slow.duration}å›åˆ`, color: '#FF6B6B' });
      }
      if (heroDebuffs.defenseDown) {
        buffs.push({ type: 'debuff', name: `æ¸›é˜² ${heroDebuffs.defenseDown.duration}å›åˆ`, color: '#FF6B6B' });
      }
    } else if (!isHero && battle.friendlyDebuffs.companions) {
      const companionIndex = state.companions ? state.companions.indexOf(character) : -1;
      if (companionIndex >= 0 && battle.friendlyDebuffs.companions[companionIndex]) {
        const companionDebuffs = battle.friendlyDebuffs.companions[companionIndex];
        if (companionDebuffs.poison) {
          buffs.push({ type: 'debuff', name: `ä¸­æ¯’ ${companionDebuffs.poison.duration}å›åˆ`, color: '#FF6B6B' });
        }
        if (companionDebuffs.slow) {
          buffs.push({ type: 'debuff', name: `æ¸›é€Ÿ ${companionDebuffs.slow.duration}å›åˆ`, color: '#FF6B6B' });
        }
        if (companionDebuffs.defenseDown) {
          buffs.push({ type: 'debuff', name: `æ¸›é˜² ${companionDebuffs.defenseDown.duration}å›åˆ`, color: '#FF6B6B' });
        }
      }
    }
  }

  return buffs;
}

// æ¸²æŸ“è‹±é›„å’ŒåŒä¼´çš„HP/MPï¼ˆéæˆ°é¬¥æ™‚ä½¿ç”¨ï¼‰
function renderHeroStats() {
  const hero = state.hero;
  if (!hero || !dom.battleHeroStats) return;
  
  dom.battleHeroStats.style.display = 'block';
  
  // ç²å–è§’è‰²çš„å¢ç›Š/æ¸›ç›Šç‹€æ…‹ï¼ˆéæˆ°é¬¥æ™‚å¯èƒ½æ²’æœ‰å¢ç›Šï¼‰
  const heroBuffs = getCharacterBuffs(hero, true);
  const heroBuffsHtml = heroBuffs.length > 0 ? `
    <div style="margin-top: 4px;">
      ${heroBuffs.map(buff => `<p style="color: ${buff.color}; font-size: 0.85em; margin: 2px 0;">${buff.name}</p>`).join('')}
    </div>
  ` : '';
  
  let heroBox = `
    <div class="battle-stat-box">
      <p class="battle-stat-label">å‹‡è€… Lv ${hero.stats.level}</p>
      <p>${formatHpDisplay(hero)}</p>
      <p>MP: ${hero.stats.mp}/${hero.stats.maxMp}</p>
      ${heroBuffsHtml}
    </div>
  `;
  
  // é¡¯ç¤ºæ‰€æœ‰åŒä¼´çš„ç‹€æ…‹
  const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
  let companionHtml = '';
  activeCompanions.forEach((comp) => {
    const compBuffs = getCharacterBuffs(comp, false);
    const compBuffsHtml = compBuffs.length > 0 ? `
      <div style="margin-top: 4px;">
        ${compBuffs.map(buff => `<p style="color: ${buff.color}; font-size: 0.85em; margin: 2px 0;">${buff.name}</p>`).join('')}
      </div>
    ` : '';
    
    companionHtml += `
      <div class="battle-stat-box">
        <p class="battle-stat-label">${comp.name} Lv ${comp.stats.level}</p>
        <p>${formatHpDisplay(comp)}</p>
        <p>MP: ${comp.stats.mp}/${comp.stats.maxMp}</p>
        ${compBuffsHtml}
      </div>
    `;
  });
  
  // ä½¿ç”¨flexå¸ƒå±€æ°´å¹³æ’åˆ—
  dom.battleHeroStats.innerHTML = `
    <div style="display: flex; gap: 16px; flex-wrap: wrap;">
      ${heroBox}
      ${companionHtml}
    </div>
  `;
}


// æ¸²æŸ“éæˆ°é¬¥æ™‚çš„å¯ç”¨é“å…·/é­”æ³•é¢æ¿
function renderFieldActionsPanel() {
  if (!dom.fieldActionsPanel) return;
  
  const hero = state.hero;
  if (!hero || state.ui.battle || state.ui.startMenu) {
    dom.fieldActionsPanel.classList.add('hidden');
    return;
  }
  
  dom.fieldActionsPanel.classList.remove('hidden');
  
  // ç²å–å¯ç”¨çš„é“å…·ï¼ˆæ¢å¾©é¡ï¼‰
  const usableItems = hero.items
    .filter(entry => entry.qty > 0)
    .map(entry => {
      const item = ITEM_LOOKUP.get(entry.id);
      return item && (item.type === 'heal' || item.type === 'mp' || item.type === 'full') ? { item, entry } : null;
    })
    .filter(Boolean);
  
  let itemsHtml = '';
  if (usableItems.length > 0) {
    itemsHtml = usableItems.map(({ item, entry }) => {
      return `
        <button class="field-action-btn" data-action="item" data-item-id="${item.id}">
          <strong>${item.name}</strong>
          <span>Ã—${entry.qty}</span>
        </button>
      `;
    }).join('');
  } else {
    itemsHtml = '<p style="opacity: 0.6; font-size: 10px;">ç„¡å¯ç”¨é“å…·</p>';
  }
  
  // ç²å–å‹‡è€…çš„å¯ç”¨é­”æ³•ï¼ˆå›å¾©å‹æŠ€èƒ½ï¼‰
  const heroActiveSkills = getActiveSkills();
  const heroUsableSkills = heroActiveSkills.filter(skill => {
    return skill.kind === 'heal' && skill.flow === 'recovery';
  });
  
  let heroSkillsHtml = '';
  if (heroUsableSkills.length > 0) {
    heroSkillsHtml = heroUsableSkills.map(skill => {
      const mpCost = skill.mpCost || 0;
      const canUse = hero.stats.mp >= mpCost;
      return `
        <button class="field-action-btn" data-action="skill" data-skill-id="${skill.id}" data-character="hero" ${!canUse ? 'disabled' : ''}>
          <strong>${skill.name}</strong>
          <span>MP: ${mpCost}</span>
        </button>
      `;
    }).join('');
  } else {
    heroSkillsHtml = '<p style="opacity: 0.6; font-size: 10px;">ç„¡å¯ç”¨é­”æ³•</p>';
  }
  
  // ç²å–æ¯å€‹åŒä¼´çš„å¯ç”¨é­”æ³•
  const companions = state.companions || [];
  const companionsSkillsHtml = companions.map((companion, index) => {
    if (!companion || companion.stats.hp <= 0) return '';
    
    const companionSkills = companion.skills
      .map(id => SKILL_LOOKUP.get(id))
      .filter(skill => skill && skill.kind === 'heal' && skill.flow === 'recovery');
    
    if (companionSkills.length === 0) return '';
    
    const companionName = companion.name || `åŒä¼´${index + 1}`;
    const skillsList = companionSkills.map(skill => {
      const mpCost = skill.mpCost || 0;
      const canUse = companion.stats.mp >= mpCost;
      return `
        <button class="field-action-btn" data-action="skill" data-skill-id="${skill.id}" data-character="companion" data-companion-index="${index}" ${!canUse ? 'disabled' : ''}>
          <strong>${skill.name}</strong>
          <span>MP: ${mpCost}</span>
        </button>
      `;
    }).join('');
    
    return `
      <div class="companion-magic-section">
        <h4 class="companion-magic-title">${companionName}</h4>
        <div class="field-actions-list">
          ${skillsList}
        </div>
      </div>
    `;
  }).filter(Boolean).join('');
  
  dom.fieldActionsPanel.innerHTML = `
    <div class="field-actions-content">
      <div class="field-actions-section">
        <h3 class="field-actions-title">å¯ç”¨é“å…·</h3>
        <div class="field-actions-list">
          ${itemsHtml}
        </div>
      </div>
      <div class="field-actions-section">
        <h3 class="field-actions-title">å¯ç”¨é­”æ³•</h3>
        <div class="magic-sections">
          <div class="character-magic-section">
            <h4 class="character-magic-title">å‹‡è€…</h4>
            <div class="field-actions-list">
              ${heroSkillsHtml}
            </div>
          </div>
          ${companionsSkillsHtml}
        </div>
      </div>
    </div>
  `;
}
function renderBattleDialog() {
  if (!dom.battleUI || !state.ui.battle) {
    // å¦‚æœæ²’æœ‰æˆ°é¬¥ï¼Œç¢ºä¿éš±è—æˆ°é¬¥UI
    hideBattleDialog();
    return;
  }
  const battle = state.ui.battle;
  const hero = state.hero;
  
  dom.battleUI.classList.remove('hidden');
  
  // å·¦ä¸Šæ–¹ï¼šæˆ‘æ–¹HP/MPï¼ˆè‹±é›„å’ŒåŒä¼´ï¼Œæ°´å¹³æ’åˆ—ï¼‰
  if (dom.battleHeroStats) {
    dom.battleHeroStats.style.display = 'block';
    const companion = getActiveCompanion();
    const isHeroTurn = battle.turn === 'hero';
    const isCompanionTurn = battle.turn === 'companion';
    
    // ç²å–è§’è‰²çš„å¢ç›Š/æ¸›ç›Šç‹€æ…‹
    const heroBuffs = getCharacterBuffs(hero, true);
    const heroBuffsHtml = heroBuffs.length > 0 ? `
      <div style="margin-top: 4px;">
        ${heroBuffs.map(buff => `<p style="color: ${buff.color}; font-size: 0.85em; margin: 2px 0;">${buff.name}</p>`).join('')}
      </div>
    ` : '';
    
    let heroBox = `
      <div class="battle-stat-box ${isHeroTurn ? 'active-turn' : ''}" 
           style="${isHeroTurn ? 'border: 2px solid var(--accent);' : ''}">
        <p class="battle-stat-label">å‹‡è€… Lv ${hero.stats.level}</p>
        <p>${formatHpDisplay(hero)}</p>
        <p>MP: ${hero.stats.mp}/${hero.stats.maxMp}</p>
        ${heroBuffsHtml}
      </div>
    `;
    
    // é¡¯ç¤ºæ‰€æœ‰åŒä¼´çš„ç‹€æ…‹
    const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
    let companionHtml = '';
    activeCompanions.forEach((comp, index) => {
      const isThisCompanionTurn = isCompanionTurn && battle.selectedCompanionIndex === index;
      const compBuffs = getCharacterBuffs(comp, false);
      const compBuffsHtml = compBuffs.length > 0 ? `
        <div style="margin-top: 4px;">
          ${compBuffs.map(buff => `<p style="color: ${buff.color}; font-size: 0.85em; margin: 2px 0;">${buff.name}</p>`).join('')}
        </div>
      ` : '';
      
      companionHtml += `
        <div class="battle-stat-box ${isThisCompanionTurn ? 'active-turn' : ''}" 
             style="${isThisCompanionTurn ? 'border: 2px solid var(--accent);' : ''}">
          <p class="battle-stat-label">${comp.name} Lv ${comp.stats.level}</p>
          <p>${formatHpDisplay(comp)}</p>
          <p>MP: ${comp.stats.mp}/${comp.stats.maxMp}</p>
          ${compBuffsHtml}
        </div>
      `;
    });
    
    // ä½¿ç”¨flexå¸ƒå±€æ°´å¹³æ’åˆ—
    const statsGap = getDeviceType() === 'mobile' ? '8px' : '16px';
    dom.battleHeroStats.innerHTML = `
      <div style="display: flex; gap: ${statsGap}; flex-wrap: wrap;">
        ${heroBox}
        ${companionHtml}
      </div>
    `;
  }
  
  // ä¸­é–“ï¼šæ€ªç‰©åœ–ç‰‡
  renderEnemySprites(battle);
  
  // å·¦ä¸‹æ–¹ï¼šæŒ‡ä»¤ï¼ˆæŒ‡ä»¤æ¡†æœ¬èº«ï¼‰
  if (dom.battleCommands) {
    const isHeroTurn = battle.turn === 'hero';
    const isCompanionTurn = battle.turn === 'companion';
    const currentCharacter = isCompanionTurn ? getActiveCompanion() : hero;
    
    if (battle.menu === 'skills') {
      // é¡¯ç¤ºæŠ€èƒ½åˆ—è¡¨ï¼ˆè‹±é›„æˆ–åŒä¼´ï¼‰
      const allSkills = isCompanionTurn 
        ? getCompanionActiveSkills() 
        : getActiveSkills();
      // éæ¿¾æ‰MPä¸è¶³çš„æŠ€èƒ½
      const skills = allSkills.filter(skill => {
        const mpCost = skill.mpCost || 0;
        return currentCharacter.stats.mp >= mpCost;
      });
      dom.battleCommands.innerHTML = `
        <div class="battle-stat-box">
          <p class="battle-stat-label">${isCompanionTurn ? (getActiveCompanion()?.name || 'åŒä¼´') : 'å‹‡è€…'} æŠ€èƒ½</p>
          ${skills.length > 0 ? skills.map(skill => {
            const mpCost = skill.mpCost || 0;
            return `
              <button class="battle-command-btn" data-skill="${skill.id}">
                ${skill.name} ${mpCost > 0 ? `(MP:${mpCost})` : ''}
              </button>
            `;
          }).join('') : '<p style="color: #ff4444;">æ²’æœ‰å¯ç”¨çš„æŠ€èƒ½ï¼ˆMPä¸è¶³ï¼‰</p>'}
          <button class="battle-command-btn" data-command="back">è¿”å›</button>
        </div>
      `;
    } else if (battle.menu === 'select-aoe-heal' && isHeroTurn) {
      // å…¨é«”å›å¾©æŠ€èƒ½ç¢ºèªèœå–®
      const skill = battle.pendingSkill ? SKILL_LOOKUP.get(battle.pendingSkill) : null;
      const skillName = skill ? skill.name : 'æŠ€èƒ½';
      dom.battleCommands.innerHTML = `
        <div class="battle-stat-box">
          <p class="battle-stat-label">é¸æ“‡ã€Œ${skillName}ã€çš„ç›®æ¨™</p>
          <button class="battle-command-btn" data-aoe-confirm="allies">æˆ‘æ–¹å…¨é«”</button>
          <button class="battle-command-btn" data-command="back">å–æ¶ˆ</button>
        </div>
      `;
    } else if (battle.menu === 'select-aoe-support' && isHeroTurn) {
      // å…¨é«”è¼”åŠ©æŠ€èƒ½ç¢ºèªèœå–®
      const skill = battle.pendingSkill ? SKILL_LOOKUP.get(battle.pendingSkill) : null;
      const skillName = skill ? skill.name : 'æŠ€èƒ½';
      dom.battleCommands.innerHTML = `
        <div class="battle-stat-box">
          <p class="battle-stat-label">é¸æ“‡ã€Œ${skillName}ã€çš„ç›®æ¨™</p>
          <button class="battle-command-btn" data-aoe-confirm="allies">æˆ‘æ–¹å…¨é«”</button>
          <button class="battle-command-btn" data-command="back">å–æ¶ˆ</button>
        </div>
      `;
    } else if (battle.menu === 'select-aoe-attack' && isHeroTurn) {
      // å…¨é«”æ”»æ“ŠæŠ€èƒ½ç¢ºèªèœå–®
      const skill = battle.pendingSkill ? SKILL_LOOKUP.get(battle.pendingSkill) : null;
      const skillName = skill ? skill.name : 'æŠ€èƒ½';
      dom.battleCommands.innerHTML = `
        <div class="battle-stat-box">
          <p class="battle-stat-label">é¸æ“‡ã€Œ${skillName}ã€çš„ç›®æ¨™</p>
          <button class="battle-command-btn" data-aoe-confirm="enemies">æ•µæ–¹å…¨é«”</button>
          <button class="battle-command-btn" data-command="back">å–æ¶ˆ</button>
        </div>
      `;
    } else if (battle.menu === 'items' && isHeroTurn) {
      // é¡¯ç¤ºé“å…·åˆ—è¡¨ï¼ˆåªæœ‰è‹±é›„å¯ä»¥ä½¿ç”¨é“å…·ï¼‰
      const items = state.hero.items.filter(item => item.qty > 0);
      dom.battleCommands.innerHTML = `
        <div class="battle-stat-box">
          <p class="battle-stat-label">é“å…·</p>
          ${items.map(entry => {
            const item = ITEM_LOOKUP.get(entry.id);
            if (!item) return '';
            return `
              <button class="battle-command-btn" data-item="${entry.id}">
                ${item.name} Ã—${entry.qty}
              </button>
            `;
          }).join('')}
          <button class="battle-command-btn" data-command="back">è¿”å›</button>
        </div>
      `;
    } else {
      // å¦‚æœæ­£åœ¨åŸ·è¡Œè¡Œå‹•ï¼Œé¡¯ç¤ºã€Œè¡Œå‹•ä¸­ã€
      if (battle.isExecutingActions) {
        dom.battleCommands.innerHTML = `
          <div class="battle-stat-box">
            <p class="battle-stat-label" style="text-align: center; color: #9fc5e8; font-weight: bold; padding: 20px;">
              è¡Œå‹•ä¸­...
            </p>
          </div>
        `;
      } else {
        // é¡¯ç¤ºä¸»è¦æŒ‡ä»¤
        const canControl = isHeroTurn || isCompanionTurn;
        let commandsToShow = COMMANDS;
        
        // å¦‚æœå‹‡è€…æ­»äº¡ï¼Œåªé¡¯ç¤ºéˆé­‚è§€æˆ°
        if (isHeroTurn && hero && hero.stats.hp <= 0) {
          commandsToShow = [SPECTATE_COMMAND];
        } else if (isCompanionTurn) {
        // åŒä¼´ä¸èƒ½ä½¿ç”¨é“å…·
          commandsToShow = COMMANDS.filter(cmd => cmd.id !== 'item');
        }
        
        dom.battleCommands.innerHTML = `
          <div class="battle-stat-box">
            <p class="battle-stat-label">${isCompanionTurn ? (getActiveCompanion()?.name || 'åŒä¼´') : 'å‹‡è€…'} æŒ‡ä»¤</p>
            ${commandsToShow.map(cmd => `
              <button class="battle-command-btn" data-command="${cmd.id}" ${!canControl ? 'disabled' : ''}>
                ${cmd.label}
              </button>
            `).join('')}
          </div>
        `;
      }
    }
  }
  
  // ä¸­é–“ï¼šæ€ªç‰©è³‡è¨Šå’Œé¸æ“‡
  if (dom.battleEnemies) {
    const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
    const enemyGroups = groupEnemiesByName(battle.enemies);
    
    // å¦‚æœæ­£åœ¨é¸æ“‡ç›®æ¨™ï¼Œé¡¯ç¤ºå¯é¸çš„æ•µäºº
    const isSelectingTarget = battle.menu === 'select-enemy' || battle.menu === 'select-target' || battle.menu === 'select-support-target' || (battle.menu === 'skills' && battle.pendingSkill) || (battle.menu === 'items' && battle.pendingItem);
    const isSelectingForHeal = battle.menu === 'select-target' || battle.menu === 'select-support-target';
    
    // å¦‚æœæ­£åœ¨é¸æ“‡å›å¾©ç›®æ¨™ï¼Œé¡¯ç¤ºæˆ‘æ–¹è§’è‰²ï¼ˆè‹±é›„å’ŒåŒä¼´ï¼‰
    let heroTargetHtml = '';
    if (isSelectingForHeal) {
      // æª¢æŸ¥æ˜¯å¦æ˜¯å¾©æ´»æŠ€èƒ½
      const pendingSkill = battle.pendingSkill ? SKILL_LOOKUP.get(battle.pendingSkill) : null;
      const isReviveSkill = pendingSkill && pendingSkill.id === 'revive_companion';
      
      const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
      const allCompanions = (state.companions || []).filter(c => c && c.stats); // åŒ…æ‹¬å·²æ­»äº¡çš„
      const deadCompanions = allCompanions.filter(c => c.stats.hp <= 0); // å·²æ­»äº¡çš„åŒä¼´
      const isHeroTurn = battle.turn === 'hero';
      const isCompanionTurn = battle.turn === 'companion';
      
      // è‹±é›„é¸æ“‡è‡ªå·±æˆ–åŒä¼´
      if (isHeroTurn) {
        // å¦‚æœä¸æ˜¯å¾©æ´»æŠ€èƒ½ï¼Œé¡¯ç¤ºè‡ªå·±é¸é …
        if (!isReviveSkill) {
        const isHeroSelected = battle.selectedEnemyIndex === -1;
        heroTargetHtml = `
          <div class="enemy-info ${isHeroSelected ? 'selected' : ''} selectable" 
               data-enemy-index="-1" style="background: rgba(100, 200, 100, 0.3); border: 2px solid ${isHeroSelected ? 'var(--accent)' : 'var(--text)'};">
            <p><strong>å‹‡è€… Lv ${hero.stats.level}</strong></p>
            <p>${formatHpDisplay(hero)}</p>
            <p>MP: ${hero.stats.mp}/${hero.stats.maxMp}</p>
            <p class="select-hint">é»æ“Šé¸æ“‡è‡ªå·±</p>
          </div>
        `;
        }
        
        // é¡¯ç¤ºæ‰€æœ‰æ´»è‘—çš„åŒä¼´é¸é …ï¼ˆéå¾©æ´»æŠ€èƒ½ï¼‰
        if (!isReviveSkill) {
        activeCompanions.forEach((companion, index) => {
          // ä½¿ç”¨ -2 - index ä¾†å€åˆ†ä¸åŒçš„åŒä¼´ï¼ˆ-2 è¡¨ç¤ºç¬¬ä¸€å€‹åŒä¼´ï¼Œ-3 è¡¨ç¤ºç¬¬äºŒå€‹ï¼Œä»¥æ­¤é¡æ¨ï¼‰
          const companionIndex = -2 - index;
          const isCompanionSelected = battle.selectedEnemyIndex === companionIndex;
          heroTargetHtml += `
            <div class="enemy-info ${isCompanionSelected ? 'selected' : ''} selectable" 
                 data-enemy-index="${companionIndex}" style="background: rgba(100, 200, 100, 0.3); border: 2px solid ${isCompanionSelected ? 'var(--accent)' : 'var(--text)'};">
              <p><strong>${companion.name} Lv ${companion.stats.level}</strong></p>
              <p>${formatHpDisplay(companion)}</p>
              <p>MP: ${companion.stats.mp}/${companion.stats.maxMp}</p>
              <p class="select-hint">é»æ“Šé¸æ“‡${companion.name}</p>
            </div>
          `;
        });
        }
        
        // å¦‚æœæ˜¯å¾©æ´»æŠ€èƒ½ï¼Œé¡¯ç¤ºå·²æ­»äº¡çš„åŒä¼´é¸é …
        if (isReviveSkill) {
          if (deadCompanions.length === 0) {
            heroTargetHtml = `
              <div class="enemy-info" style="background: rgba(100, 100, 100, 0.3); border: 2px solid var(--text); opacity: 0.6;">
                <p><strong>æ²’æœ‰å·²æ­»äº¡çš„åŒä¼´</strong></p>
                <p>æ‰€æœ‰åŒä¼´éƒ½é‚„æ´»è‘—</p>
              </div>
            `;
          } else {
            deadCompanions.forEach((companion, index) => {
              // ä½¿ç”¨ -2 - index ä¾†å€åˆ†ä¸åŒçš„åŒä¼´ï¼ˆ-2 è¡¨ç¤ºç¬¬ä¸€å€‹åŒä¼´ï¼Œ-3 è¡¨ç¤ºç¬¬äºŒå€‹ï¼Œä»¥æ­¤é¡æ¨ï¼‰
              // éœ€è¦æ‰¾åˆ°é€™å€‹åŒä¼´åœ¨æ‰€æœ‰åŒä¼´åˆ—è¡¨ä¸­çš„ç´¢å¼•
              const companionIndexInAll = allCompanions.indexOf(companion);
              const companionIndex = -2 - companionIndexInAll;
              const isCompanionSelected = battle.selectedEnemyIndex === companionIndex;
              heroTargetHtml += `
                <div class="enemy-info ${isCompanionSelected ? 'selected' : ''} selectable" 
                     data-enemy-index="${companionIndex}" style="background: rgba(200, 100, 100, 0.3); border: 2px solid ${isCompanionSelected ? 'var(--accent)' : 'var(--text)'};">
                  <p><strong>${companion.name} Lv ${companion.stats.level} (å·²æ­»äº¡)</strong></p>
                  <p>HP: 0/${companion.stats.maxHp}</p>
                  <p>MP: ${companion.stats.mp}/${companion.stats.maxMp}</p>
                  <p class="select-hint" style="color: var(--accent);">é»æ“Šå¾©æ´»${companion.name}</p>
                </div>
              `;
            });
          }
        }
      } else if (isCompanionTurn && companion) {
        // åŒä¼´é¸æ“‡è‡ªå·±æˆ–è‹±é›„
        const isCompanionSelected = battle.selectedEnemyIndex === -1;
        heroTargetHtml = `
          <div class="enemy-info ${isCompanionSelected ? 'selected' : ''} selectable" 
               data-enemy-index="-1" style="background: rgba(100, 200, 100, 0.3); border: 2px solid ${isCompanionSelected ? 'var(--accent)' : 'var(--text)'};">
            <p><strong>${companion.name} Lv ${companion.stats.level}</strong></p>
            <p>${formatHpDisplay(companion)}</p>
            <p>MP: ${companion.stats.mp}/${companion.stats.maxMp}</p>
            <p class="select-hint">é»æ“Šé¸æ“‡è‡ªå·±</p>
          </div>
        `;
        
        // é¡¯ç¤ºè‹±é›„é¸é …
        const isHeroSelected = battle.selectedEnemyIndex === -2;
        heroTargetHtml += `
          <div class="enemy-info ${isHeroSelected ? 'selected' : ''} selectable" 
               data-enemy-index="-2" style="background: rgba(100, 200, 100, 0.3); border: 2px solid ${isHeroSelected ? 'var(--accent)' : 'var(--text)'};">
            <p><strong>å‹‡è€… Lv ${hero.stats.level}</strong></p>
            <p>${formatHpDisplay(hero)}</p>
            <p>MP: ${hero.stats.mp}/${hero.stats.maxMp}</p>
            <p class="select-hint">é»æ“Šé¸æ“‡å‹‡è€…</p>
          </div>
        `;
      }
    }
    
    dom.battleEnemies.innerHTML = `
      <div class="battle-stat-box">
        <p class="battle-stat-label">${isSelectingForHeal ? 'ç›®æ¨™é¸æ“‡' : 'æ•µäºº'}</p>
        ${heroTargetHtml}
        ${!isSelectingForHeal ? enemyGroups.map((group, groupIndex) => {
          const enemy = group.enemy;
          const aliveCount = battle.enemies.filter(e => e.name === enemy.name && e.stats.hp > 0).length;
          const isAlive = aliveCount > 0;
          const firstAliveIndex = battle.enemies.findIndex(e => e.name === enemy.name && e.stats.hp > 0);
          const isSelected = battle.selectedEnemyIndex === firstAliveIndex;
          
          if (!isAlive) {
            return `
              <div class="enemy-info defeated">
                <p>${enemy.name} (å·²æ“Šå€’)</p>
              </div>
            `;
          }
          
          // æ‰¾åˆ°é€™å€‹æ•µäººç¾¤çµ„ä¸­æ‰€æœ‰æ´»è‘—çš„æ•µäºº
          const aliveEnemiesInGroup = battle.enemies
            .map((e, idx) => ({ enemy: e, index: idx }))
            .filter(({ enemy: e }) => e.name === enemy.name && e.stats.hp > 0);
          
          return aliveEnemiesInGroup.map(({ enemy: e, index: enemyIndex }) => {
            const hpPercent = Math.round((e.stats.hp / e.stats.maxHp) * 100);
            const isThisSelected = battle.selectedEnemyIndex === enemyIndex;
            // åªæœ‰è‹±é›„å›åˆä¸”æ­£åœ¨é€‰æ‹©ç›®æ ‡æ—¶æ‰èƒ½é€‰æ‹©
            const isHeroTurn = battle.turn === 'hero';
            const canSelect = isSelectingTarget && isAlive && isHeroTurn && !battle.isExecutingActions;
            
            // æª¢æŸ¥æ˜¯å¦æœ‰ä¸­æ¯’ç‹€æ…‹
            const hasPoison = battle.enemyDebuffs && battle.enemyDebuffs[enemyIndex] && battle.enemyDebuffs[enemyIndex].poison;
            const poisonDuration = hasPoison ? battle.enemyDebuffs[enemyIndex].poison.duration : 0;
            const poisonStatus = hasPoison ? `<p style="color: #8b4513; font-weight: bold;">ä¸­æ¯’: ${poisonDuration}å›åˆ</p>` : '';
            
            // æª¢æŸ¥æ˜¯å¦æœ‰æ¸›é€Ÿç‹€æ…‹
            const hasSlow = battle.enemyDebuffs && battle.enemyDebuffs[enemyIndex] && battle.enemyDebuffs[enemyIndex].slow;
            const slowDuration = hasSlow ? battle.enemyDebuffs[enemyIndex].slow.duration : 0;
            const slowStatus = hasSlow ? `<p style="color: #4169e1; font-weight: bold;">æ¸›é€Ÿ: ${slowDuration}å›åˆ</p>` : '';
            
            // æª¢æŸ¥æ˜¯å¦æœ‰é˜²å®ˆå€¼æ¸›å°‘ç‹€æ…‹
            const hasDefenseDown = battle.enemyDebuffs && battle.enemyDebuffs[enemyIndex] && battle.enemyDebuffs[enemyIndex].defenseDown;
            const defenseDownDuration = hasDefenseDown ? battle.enemyDebuffs[enemyIndex].defenseDown.duration : 0;
            const defenseDownStatus = hasDefenseDown ? `<p style="color: #8b0000; font-weight: bold;">æ¸›é˜²: ${defenseDownDuration}å›åˆ</p>` : '';
            
            // æª¢æŸ¥æ˜¯å¦æœ‰æ”»æ“ŠåŠ›æ¸›å°‘ç‹€æ…‹
            const hasAttackDown = battle.enemyDebuffs && battle.enemyDebuffs[enemyIndex] && battle.enemyDebuffs[enemyIndex].attackDown;
            const attackDownDuration = hasAttackDown ? battle.enemyDebuffs[enemyIndex].attackDown.duration : 0;
            const attackDownStatus = hasAttackDown ? `<p style="color: #8b0000; font-weight: bold;">æ¸›æ”»: ${attackDownDuration}å›åˆ</p>` : '';
            
            // è¨ˆç®—å¯¦éš›é¡¯ç¤ºçš„æ”»æ“ŠåŠ›å’Œé˜²å®ˆåŠ›ï¼ˆè€ƒæ…®debuffï¼‰
            let displayAttack = e.attributes.attack || 0;
            let displayDefense = e.attributes.defense || 0;
            const originalAttack = displayAttack;
            const originalDefense = displayDefense;
            
            if (hasAttackDown) {
              const attackDown = battle.enemyDebuffs[enemyIndex].attackDown;
              displayAttack = Math.max(0, Math.floor(displayAttack * (1 - attackDown.ratio)));
            }
            
            if (hasDefenseDown) {
              const defenseDown = battle.enemyDebuffs[enemyIndex].defenseDown;
              displayDefense = Math.max(0, Math.floor(displayDefense * (1 - defenseDown.ratio)));
            }
            
            // æ ¹æ“šæ˜¯å¦æ¸›å°‘æˆ–å¢åŠ ä¾†æ±ºå®šé¡è‰²ï¼ˆæ¸›å°‘ç”¨ç´…è‰²ï¼Œå¢åŠ ç”¨äº®è—è‰²ï¼Œæ­£å¸¸ç”¨ç™½è‰²ï¼‰
            const attackColor = displayAttack < originalAttack ? '#ff4444' : (displayAttack > originalAttack ? '#00bfff' : '#ffffff');
            const defenseColor = displayDefense < originalDefense ? '#ff4444' : (displayDefense > originalDefense ? '#00bfff' : '#ffffff');
            
            return `
              <div class="enemy-info ${isThisSelected ? 'selected' : ''} ${canSelect ? 'selectable' : ''}" 
                   data-enemy-index="${enemyIndex}">
                <div class="enemy-info-left">
                  <p><strong>${e.name}${e.isElite ? ' (èè‹±)' : ''} Lv ${e.stats.level}</strong></p>
                  <p>HP: ${e.stats.hp}/${e.stats.maxHp} (${hpPercent}%)</p>
                  <p>MP: ${e.stats.mp}/${e.stats.maxMp}</p>
                  ${poisonStatus}
                  ${slowStatus}
                  ${defenseDownStatus}
                  ${attackDownStatus}
                  ${canSelect ? '<p class="select-hint">é»æ“Šé¸æ“‡</p>' : ''}
                </div>
                <div class="enemy-info-right">
                  <p><strong>æ”»æ“Š: <span style="color: ${attackColor}">${displayAttack}</span>${displayAttack < originalAttack ? ` (${originalAttack})` : (displayAttack > originalAttack ? ` (${originalAttack})` : '')}</strong></p>
                  <p><strong>é˜²å®ˆ: <span style="color: ${defenseColor}">${displayDefense}</span>${displayDefense < originalDefense ? ` (${originalDefense})` : (displayDefense > originalDefense ? ` (${originalDefense})` : '')}</strong></p>
                  <p><strong>é­”é˜²: ${calculateMagicDefense(e, 'enemy')}</strong></p>
                </div>
              </div>
            `;
          }).join('');
        }).join('') : ''}
      </div>
    `;
  }
  
  // å³å´ï¼šæˆ°é¬¥ç´€éŒ„
  if (dom.battleLog) {
    renderBattleLog();
  }

  // Mobile: Battle tab bar
  if (getDeviceType() === 'mobile') {
    const battleBottomPanel = document.querySelector('.battle-bottom-panel');
    if (battleBottomPanel) {
      // Insert tab bar if not already present
      let tabBar = battleBottomPanel.querySelector('.battle-tab-bar');
      if (!tabBar) {
        tabBar = document.createElement('div');
        tabBar.className = 'battle-tab-bar';
        battleBottomPanel.insertBefore(tabBar, battleBottomPanel.firstChild);
      }
      const activeTab = state.ui.battleTab || 'commands';
      tabBar.innerHTML = `
        <button class="battle-tab-btn ${activeTab === 'commands' ? 'active' : ''}" onclick="switchBattleTab('commands')">æŒ‡ä»¤</button>
        <button class="battle-tab-btn ${activeTab === 'enemies' ? 'active' : ''}" onclick="switchBattleTab('enemies')">æ•µäºº</button>
        <button class="battle-tab-btn ${activeTab === 'log' ? 'active' : ''}" onclick="switchBattleTab('log')">ç´€éŒ„</button>
      `;
      // Toggle visibility
      if (dom.battleCommands) dom.battleCommands.classList.toggle('hidden-panel', activeTab !== 'commands');
      if (dom.battleEnemies) dom.battleEnemies.classList.toggle('hidden-panel', activeTab !== 'enemies');
      if (dom.battleLog) dom.battleLog.classList.toggle('hidden-panel', activeTab !== 'log');
    }
  } else {
    // Desktop: ensure no tab bar and no hidden panels
    const tabBar = document.querySelector('.battle-tab-bar');
    if (tabBar) tabBar.remove();
    if (dom.battleCommands) dom.battleCommands.classList.remove('hidden-panel');
    if (dom.battleEnemies) dom.battleEnemies.classList.remove('hidden-panel');
    if (dom.battleLog) dom.battleLog.classList.remove('hidden-panel');
  }
}

// ç²å–æ€ªç‰©SVGåœ–æ¡ˆ
function getEnemySpriteSVG(enemyId, isElite = false) {
  const sprites = {
    slime: `
      <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
        <ellipse cx="50" cy="70" rx="35" ry="25" fill="#4A90E2" stroke="#2E5C8A" stroke-width="2"/>
        <ellipse cx="50" cy="50" rx="30" ry="30" fill="#5BA3F5" stroke="#2E5C8A" stroke-width="2"/>
        <circle cx="45" cy="45" r="4" fill="#1A3A5C"/>
        <circle cx="55" cy="45" r="4" fill="#1A3A5C"/>
        <path d="M 45 55 Q 50 60 55 55" stroke="#1A3A5C" stroke-width="2" fill="none"/>
        ${isElite ? '<circle cx="50" cy="30" r="8" fill="#FFD700" stroke="#FFA500" stroke-width="2"/>' : ''}
      </svg>
    `,
    mushroom: `
      <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
        <ellipse cx="50" cy="75" rx="8" ry="15" fill="#8B4513" stroke="#654321" stroke-width="2"/>
        <ellipse cx="50" cy="50" rx="25" ry="20" fill="#FF6B6B" stroke="#CC5555" stroke-width="2"/>
        <circle cx="45" cy="45" r="3" fill="#FFFFFF"/>
        <circle cx="55" cy="45" r="3" fill="#FFFFFF"/>
        <circle cx="48" cy="50" r="2" fill="#FFFFFF"/>
        <circle cx="52" cy="52" r="2" fill="#FFFFFF"/>
        ${isElite ? '<circle cx="50" cy="30" r="8" fill="#FFD700" stroke="#FFA500" stroke-width="2"/>' : ''}
      </svg>
    `,
    rogue: `
      <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
        <circle cx="50" cy="35" r="12" fill="#D4A574" stroke="#8B6F47" stroke-width="2"/>
        <rect x="42" y="47" width="16" height="20" fill="#4A4A4A" stroke="#2A2A2A" stroke-width="2"/>
        <line x1="35" y1="50" x2="25" y2="65" stroke="#8B6F47" stroke-width="3" stroke-linecap="round"/>
        <line x1="65" y1="50" x2="75" y2="65" stroke="#8B6F47" stroke-width="3" stroke-linecap="round"/>
        <line x1="42" y1="67" x2="32" y2="85" stroke="#2A2A2A" stroke-width="3" stroke-linecap="round"/>
        <line x1="58" y1="67" x2="68" y2="85" stroke="#2A2A2A" stroke-width="3" stroke-linecap="round"/>
        <path d="M 30 50 L 40 45 L 35 55 Z" fill="#C0C0C0" stroke="#808080" stroke-width="1"/>
        ${isElite ? '<circle cx="50" cy="20" r="8" fill="#FFD700" stroke="#FFA500" stroke-width="2"/>' : ''}
      </svg>
    `,
    golem: `
      <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
        <rect x="30" y="40" width="40" height="50" rx="5" fill="#808080" stroke="#555555" stroke-width="3"/>
        <rect x="35" y="45" width="30" height="40" fill="#A0A0A0" stroke="#666666" stroke-width="2"/>
        <circle cx="50" cy="30" r="15" fill="#808080" stroke="#555555" stroke-width="3"/>
        <rect x="45" y="25" width="10" height="10" fill="#A0A0A0" stroke="#666666" stroke-width="2"/>
        <circle cx="48" cy="28" r="2" fill="#000000"/>
        <circle cx="52" cy="28" r="2" fill="#000000"/>
        <line x1="48" y1="32" x2="52" y2="32" stroke="#000000" stroke-width="1"/>
        <rect x="20" y="50" width="15" height="25" rx="3" fill="#808080" stroke="#555555" stroke-width="2"/>
        <rect x="65" y="50" width="15" height="25" rx="3" fill="#808080" stroke="#555555" stroke-width="2"/>
        ${isElite ? '<circle cx="50" cy="15" r="8" fill="#FFD700" stroke="#FFA500" stroke-width="2"/>' : ''}
      </svg>
    `,
    demon_king: `
      <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
        <circle cx="50" cy="35" r="18" fill="#8B0000" stroke="#4B0000" stroke-width="3"/>
        <circle cx="50" cy="35" r="12" fill="#FF0000" stroke="#8B0000" stroke-width="2"/>
        <circle cx="47" cy="33" r="3" fill="#FFD700"/>
        <circle cx="53" cy="33" r="3" fill="#FFD700"/>
        <path d="M 45 38 Q 50 42 55 38" stroke="#000000" stroke-width="2" fill="none"/>
        <path d="M 35 35 L 30 25 L 40 30 Z" fill="#FFD700" stroke="#FFA500" stroke-width="2"/>
        <path d="M 65 35 L 70 25 L 60 30 Z" fill="#FFD700" stroke="#FFA500" stroke-width="2"/>
        <rect x="40" y="50" width="20" height="35" fill="#4B0000" stroke="#2B0000" stroke-width="3"/>
        <rect x="42" y="52" width="16" height="30" fill="#8B0000" stroke="#4B0000" stroke-width="2"/>
        <rect x="25" y="55" width="12" height="30" rx="2" fill="#4B0000" stroke="#2B0000" stroke-width="2"/>
        <rect x="63" y="55" width="12" height="30" rx="2" fill="#4B0000" stroke="#2B0000" stroke-width="2"/>
      </svg>
    `,
    green_dragon: `
      <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
        <!-- é¾é ­ -->
        <ellipse cx="50" cy="40" rx="20" ry="18" fill="#228B22" stroke="#006400" stroke-width="2"/>
        <ellipse cx="50" cy="35" rx="15" ry="12" fill="#32CD32" stroke="#228B22" stroke-width="2"/>
        <!-- çœ¼ç› -->
        <circle cx="45" cy="32" r="3" fill="#FF0000"/>
        <circle cx="55" cy="32" r="3" fill="#FF0000"/>
        <circle cx="45" cy="32" r="1.5" fill="#FFFFFF"/>
        <circle cx="55" cy="32" r="1.5" fill="#FFFFFF"/>
        <!-- å˜´å·´ -->
        <path d="M 45 38 Q 50 42 55 38" stroke="#006400" stroke-width="2" fill="none"/>
        <!-- è§’ -->
        <path d="M 35 30 L 30 15 L 38 22 Z" fill="#006400" stroke="#003300" stroke-width="1"/>
        <path d="M 65 30 L 70 15 L 62 22 Z" fill="#006400" stroke="#003300" stroke-width="1"/>
        <!-- èº«é«” -->
        <ellipse cx="50" cy="60" rx="25" ry="20" fill="#228B22" stroke="#006400" stroke-width="2"/>
        <!-- ç¿…è†€ -->
        <path d="M 25 55 Q 10 45 10 60 Q 10 75 25 70" fill="#32CD32" stroke="#228B22" stroke-width="2"/>
        <path d="M 75 55 Q 90 45 90 60 Q 90 75 75 70" fill="#32CD32" stroke="#228B22" stroke-width="2"/>
        <!-- å°¾å·´ -->
        <path d="M 30 75 Q 20 85 15 90 Q 10 95 5 90" fill="#228B22" stroke="#006400" stroke-width="2"/>
        <!-- è…¿ -->
        <rect x="35" y="75" width="8" height="15" rx="2" fill="#228B22" stroke="#006400" stroke-width="1"/>
        <rect x="57" y="75" width="8" height="15" rx="2" fill="#228B22" stroke="#006400" stroke-width="1"/>
      </svg>
    `,
  };
  
  return sprites[enemyId] || sprites.slime;
}

  // æ¸²æŸ“æ€ªç‰©åœ–ç‰‡
function renderEnemySprites(battle) {
  if (!dom.battleEnemySprites || !battle) return;
  
  const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
  const isSelectingTarget = battle.menu === 'select-enemy' || battle.menu === 'select-target' || (battle.menu === 'skills' && battle.pendingSkill);
  
  if (aliveEnemies.length === 0) {
    dom.battleEnemySprites.innerHTML = '';
    return;
  }
  
  // é¡¯ç¤ºæ‰€æœ‰æ´»è‘—çš„æ€ªç‰©ï¼Œæ¯éš»æ€ªç‰©éƒ½é¡¯ç¤ºä¸€å€‹åœ–ç‰‡
  let html = '';
  battle.enemies.forEach((enemy, enemyIndex) => {
    const isAlive = enemy.stats.hp > 0;
    if (!isAlive) return; // è·³éå·²æ­»çš„æ€ªç‰©
    
    const isSelected = battle.selectedEnemyIndex === enemyIndex;
    const canSelect = isSelectingTarget && isAlive;
    
    const spriteClass = `enemy-sprite ${isSelected ? 'selected' : ''}`;
    const enemyId = enemy.id || 'slime';
    // æ·»åŠ æ—¶é—´æˆ³å‚æ•°ä»¥å¼ºåˆ¶é‡æ–°åŠ è½½å›¾ç‰‡ï¼ˆé¿å…ç¼“å­˜ï¼‰
    const imagePath = `src/assets/enemy/${enemyId}.png?t=${Date.now()}`;
    
    // æ ¹æ“š sizeLevel è¨ˆç®—ç¸®æ”¾æ¯”ä¾‹ï¼ˆéŸ¿æ‡‰å¼åŸºç¤å°ºå¯¸ï¼‰
    // sizeLevel: 1=100%, 2=120%, 3=140%, 4=160%
    const sizeLevel = enemy.sizeLevel || 3;
    const scaleMap = { 1: 1.0, 2: 1.2, 3: 1.4, 4: 1.6 };
    const scale = scaleMap[sizeLevel] || 1.0;
    const deviceType = getDeviceType();
    const baseSize = deviceType === 'mobile' ? 100 : (deviceType === 'tablet' ? 160 : 200);
    const sizeStyle = `width: ${baseSize * scale}px; height: ${baseSize * scale}px;`;
    
    html += `
      <div class="${spriteClass}" 
           data-enemy-sprite-index="${enemyIndex}"
           ${canSelect ? `data-enemy-index="${enemyIndex}" style="cursor: pointer;"` : ''}
           ${canSelect ? 'onclick="selectEnemySprite(' + enemyIndex + ')"' : ''}>
        <img src="${imagePath}" alt="${enemyId}" style="${sizeStyle}" />
      </div>
    `;
  });
  
  dom.battleEnemySprites.innerHTML = html;
}

// é¸æ“‡æ€ªç‰©ï¼ˆå¾åœ–ç‰‡é»æ“Šï¼‰
function selectEnemySprite(enemyIndex) {
  const battle = state.ui.battle;
  if (!battle) return;
  
  // åªæœ‰è‹±é›„å›åˆæ‰èƒ½é¸æ“‡ç›®æ¨™
  const isHeroTurn = battle.turn === 'hero';
  if (!isHeroTurn) return;
  
  const isSelectingTarget = battle.menu === 'select-enemy' || (battle.menu === 'skills' && battle.pendingSkill);
  if (!isSelectingTarget) return;
  
  battle.selectedEnemyIndex = enemyIndex;
  renderBattleDialog();
  
  if (battle.pendingSkill) {
    performSkill(battle.pendingSkill);
  } else {
    performBasicAttack();
  }
}

// å°‡å‡½æ•¸æš´éœ²åˆ°å…¨å±€ï¼Œä»¥ä¾¿onclickä½¿ç”¨
window.selectEnemySprite = selectEnemySprite;

function hideBattleDialog() {
  if (dom.battleUI) {
    dom.battleUI.classList.add('hidden');
  }
  // æ¸…ç©ºæˆ°é¬¥UIå…ƒç´ çš„å…§å®¹ï¼ˆä½†ä¿ç•™ battle-hero-statsï¼Œå› ç‚ºéæˆ°é¬¥æ™‚ä¹Ÿè¦é¡¯ç¤ºï¼‰
  if (dom.battleEnemySprites) {
    dom.battleEnemySprites.innerHTML = '';
  }
  if (dom.battleCommands) {
    dom.battleCommands.innerHTML = '';
  }
  if (dom.battleEnemies) {
    dom.battleEnemies.innerHTML = '';
  }
  if (dom.battleLog) {
    dom.battleLog.innerHTML = '';
  }
  // battle-hero-stats åœ¨éæˆ°é¬¥æ™‚ä¹Ÿè¦é¡¯ç¤ºï¼Œæ‰€ä»¥ä¸æ¸…ç©ºä¹Ÿä¸éš±è—
}

function renderHeroPanel() {
  const hero = state.hero;
  if (!hero) {
    const heroStatusSection = document.getElementById('hero-status-section');
    if (heroStatusSection) {
      heroStatusSection.innerHTML = `
      <div class="hero-info">
        <p>è«‹å¾é–‹å§‹é¸å–®é¸æ“‡ã€Œæ–°å†’éšªã€æˆ–ã€Œç¹¼çºŒå†’éšªã€ã€‚</p>
      </div>
    `;
    }
    return;
  }
  
  const currentView = state.ui.characterView || 'hero';
  const companions = state.companions || [];
  const companionViewIndex = state.ui.companionViewIndex || 0;
  const currentCompanion = currentView === 'companion' && companions.length > 0 
    ? companions[companionViewIndex] 
    : null;
  const showCompanion = currentView === 'companion' && currentCompanion;
  
  // å¦‚æœæœ‰åŒä¼´ï¼Œæ·»åŠ åˆ‡æ¢æŒ‰é’®
  let switchButtons = '';
  if (companions.length > 0) {
    const companionButtons = companions.map((comp, index) => {
      const isActive = currentView === 'companion' && companionViewIndex === index;
      return `
        <button class="character-switch-btn ${isActive ? 'active' : ''}" 
                onclick="switchCharacterView('companion', ${index})">${comp.name}</button>
      `;
    }).join('');
    
    switchButtons = `
      <div class="character-switch">
        <button class="character-switch-btn ${currentView === 'hero' ? 'active' : ''}" 
                onclick="switchCharacterView('hero')">å‹‡è€…</button>
        ${companionButtons}
      </div>
    `;
  }
  
  if (showCompanion && currentCompanion) {
    // é¡¯ç¤ºåŒä¼´ä¿¡æ¯
    const { stats, attributes } = currentCompanion;
    const totalAttrs = getCompanionTotalAttributes(currentCompanion);
    
    const attrList = ATTRIBUTES.map((attr) => {
      const total = totalAttrs[attr.id];
      return `<li>
        <span>${attr.name}</span>
        <span>${total}</span>
      </li>`;
    }).join('');

    // è¨ˆç®—åŒä¼´çš„å„ç¨®æ¯”ç‡
    const companionCritChance = calculateCritChance(currentCompanion);
    const companionHitRate = calculateHitRate(currentCompanion);
    const companionDodgeRate = calculateDodgeRate(currentCompanion);
    const companionMagicDefense = calculateMagicDefense(currentCompanion, 'companion');
    
    // è¨ˆç®—åŒä¼´çš„å‚¾å‘å€¼
    const healTendency = getCompanionHealTendency(currentCompanion);
    const supportTendency = getCompanionSupportTendency(currentCompanion);
    const defenseTendency = getCompanionDefenseTendency(currentCompanion);
    const attackTendency = getCompanionAttackTendency(currentCompanion);
    const aoeTendency = getCompanionAoeTendency(currentCompanion);
    
    // ç”Ÿæˆå‚¾å‘å€¼æ¢å½¢åœ–HTML
    const renderTendencyBars = (heal, support, defense, attack, aoe) => {
      const maxValue = 100;
      const createBar = (label, value, color) => {
        const width = (value / maxValue) * 100;
        return `
          <div style="display: flex; align-items: center; margin-bottom: 4px;">
            <span style="width: 50px; font-size: 12px; color: #888;">${label}</span>
            <div style="flex: 1; height: 16px; background: #333; border-radius: 2px; margin: 0 8px; position: relative; overflow: hidden;">
              <div style="width: ${width}%; height: 100%; background: ${color}; transition: width 0.3s;"></div>
            </div>
            <span style="width: 55px; text-align: right; font-size: 12px; color: #888; flex-shrink: 0;">${value}/100</span>
          </div>
        `;
      };
      return `
        <div style="margin-top: 8px; padding: 8px; background: #1a1a1a; border-radius: 4px;">
          <div style="font-size: 12px; color: #aaa; margin-bottom: 6px; font-weight: bold;">å‚¾å‘å€¼</div>
          ${createBar('æ²»ç™‚', heal, '#4CAF50')}
          ${createBar('è¼”åŠ©', support, '#2196F3')}
          ${createBar('é˜²å®ˆ', defense, '#FF9800')}
          ${createBar('æ”»æ“Š', attack, '#F44336')}
          ${createBar('å…¨é«”', aoe, '#9C27B0')}
        </div>
      `;
    };
    
    // è¨ˆç®—è¢«æ”»æ“Šç‡ï¼ˆéœ€è¦è€ƒæ…®å‹‡è€…å’Œå…¶ä»–åŒä¼´ï¼Œç¢ºä¿ç¸½å’Œç‚º100%ï¼‰
    // è¢«æ”»æ“Šæ©Ÿç‡åŠ æ¬Šå€¼ = æ”»æ“Š/2 + é«”åŠ›Ã—2 + é˜²ç¦¦
    const currentCompanionWeight = Math.floor(totalAttrs.attack / 2) + totalAttrs.vitality * 2 + totalAttrs.defense;
    const heroAttrs = getHeroTotalAttributes(hero);
    const heroWeight = Math.floor(heroAttrs.attack / 2) + heroAttrs.vitality * 2 + heroAttrs.defense;
    
    // è¨ˆç®—æ‰€æœ‰å…¶ä»–æ´»è‘—åŒä¼´çš„æ¬Šé‡ç¸½å’Œ
    const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0 && c !== currentCompanion);
    let otherCompanionsWeight = 0;
    activeCompanions.forEach(comp => {
      const compAttrs = getCompanionTotalAttributes(comp);
      otherCompanionsWeight += Math.floor(compAttrs.attack / 2) + compAttrs.vitality * 2 + compAttrs.defense;
    });
    
    // ç¸½æ¬Šé‡ = å‹‡è€…åŠ æ¬Š + ç•¶å‰åŒä¼´åŠ æ¬Š + å…¶ä»–åŒä¼´åŠ æ¬Šç¸½å’Œ
    const totalWeight = heroWeight + currentCompanionWeight + otherCompanionsWeight;
    
    // è¨ˆç®—ç™¾åˆ†æ¯”ï¼šç•¶å‰åŒä¼´è¢«æ”»æ“Šæ©Ÿç‡ = (ç•¶å‰åŒä¼´åŠ æ¬Š / ç¸½æ¬Šé‡) Ã— 100%
    let companionAttackRate = totalWeight > 0 ? Math.round((currentCompanionWeight / totalWeight) * 100) : 0;
    let heroAttackRate = totalWeight > 0 ? Math.round((heroWeight / totalWeight) * 100) : 0;
    let otherCompanionsAttackRate = totalWeight > 0 ? Math.round((otherCompanionsWeight / totalWeight) * 100) : 0;
    
    // ç¢ºä¿ç¸½å’Œç‚º100%ï¼ˆè™•ç†å››èˆäº”å…¥èª¤å·®ï¼‰
    const totalRate = companionAttackRate + heroAttackRate + otherCompanionsAttackRate;
    if (totalRate !== 100 && totalWeight > 0) {
      const diff = 100 - totalRate;
      companionAttackRate += diff; // å°‡èª¤å·®åŠ åˆ°ç•¶å‰åŒä¼´ä¸Š
    }
    
    const heroStatusSection = document.getElementById('hero-status-section');
    if (heroStatusSection) {
      const skillsHtml = renderSkillsPanel();
      const innerContent = `
      ${switchButtons}
      <div class="hero-info">
        <div>
          <p>ç­‰ç´šï¼š${stats.level}</p>
          <p>${formatHpDisplay(hero)}</p>
          <p>MPï¼š${stats.mp}/${stats.maxMp}</p>
        </div>
        <div>
          <p>é¡å‹ï¼š${COMPANION_TYPES[currentCompanion.companionTypeId]?.name || 'æœªçŸ¥'}</p>
          ${currentCompanion.personalityId ? (() => {
            const personality = COMPANION_PERSONALITIES[currentCompanion.personalityId];
            return personality ? `<p>å€‹æ€§ï¼š${personality.name}ï¼ˆ${personality.description}ï¼‰</p>` : '';
          })() : ''}
        </div>
      </div>
      <div class="attribute-panel">
        <h3>å±¬æ€§</h3>
        <ul>${attrList}</ul>
        ${currentCompanion.heroType ? (() => {
          const heroTypeId = currentCompanion.heroType;
          const advancedGrowthMap = {
            sage: ['mage', 'healer'],
            paladin: ['defender', 'healer'],
            weaponmaster: ['attacker', 'agile'],
          };
          let label = '';
          if (advancedGrowthMap[heroTypeId]) {
            const baseNames = advancedGrowthMap[heroTypeId]
              .map(id => HERO_TYPES[id]?.name || id)
              .join(' / ');
            label = `${baseNames}`;
          } else {
            label = HERO_TYPES[heroTypeId]?.name || 'æœªçŸ¥';
          }
          return `<p class="hero-type-badge">æˆé•·ï¼š${label}</p>`;
        })() : ''}
      </div>
      <div class="battle-stats-panel">
        <h3>æˆ°é¬¥èƒ½åŠ›</h3>
        <p>å‘½ä¸­ç‡ï¼š${companionHitRate}%</p>
        <p>é–ƒé¿ç‡ï¼š${companionDodgeRate}%</p>
        <p>æœƒå¿ƒä¸€æ“Šç‡ï¼š${companionCritChance}%</p>
        <p>è¢«æ”»æ“Šç‡ï¼š${companionAttackRate}%</p>
        <p>é­”é˜²ï¼š${companionMagicDefense}</p>
        ${renderTendencyBars(healTendency, supportTendency, defenseTendency, attackTendency, aoeTendency)}
      </div>
        ${skillsHtml}
      `;
      if (getDeviceType() === 'mobile') {
        const isExpanded = state.ui.accordionState.hero;
        heroStatusSection.innerHTML = `
          <div class="accordion-header" onclick="toggleAccordion('hero')">
            <h4>å‹‡è€…è³‡è¨Š</h4>
            <span class="accordion-arrow ${isExpanded ? 'expanded' : ''}">â–¶</span>
          </div>
          <div class="accordion-body ${isExpanded ? 'expanded' : ''}">
            ${innerContent}
          </div>
        `;
      } else {
        heroStatusSection.innerHTML = innerContent;
      }
    }
  } else {
    // é¡¯ç¤ºè‹±é›„ä¿¡æ¯
    const { stats, attributes } = hero;
    const totalAttrs = getHeroTotalAttributes(hero);
    const equipmentAttack = getEquipmentAttack(hero);
    const equipmentDefense = getEquipmentDefense(hero);
    
    // ç²å–é˜²å®ˆå‹è¢«å‹•æŠ€èƒ½çš„HPåŠ æˆï¼ˆæ³¨æ„ï¼šstats.maxHp æ‡‰è©²å·²ç¶“åŒ…å«äº†è¢«å‹•æŠ€èƒ½çš„HPåŠ æˆï¼‰
    const defenderEffects = getDefenderPassiveEffects(hero);
    // å¦‚æœ stats.maxHp é‚„æ²’æœ‰åŒ…å«è¢«å‹•æŠ€èƒ½çš„HPåŠ æˆï¼Œéœ€è¦æ‡‰ç”¨
    // ä½†é€šå¸¸ learnSkill å·²ç¶“æ‡‰ç”¨äº†ï¼Œé€™è£¡åªæ˜¯ç”¨æ–¼é¡¯ç¤º
    const effectiveMaxHp = stats.maxHp;
    
    // é¡¯ç¤ºç¸½å±¬æ€§ï¼ˆåŸºç¤ + è£å‚™åŠ æˆ + è£å‚™æ”»æ“ŠåŠ›/é˜²ç¦¦åŠ› + è¢«å‹•é˜²ç¦¦ï¼‰
    // æ³¨æ„ï¼štotalAttrs å·²ç¶“åŒ…å«äº†è¢«å‹•é˜²ç¦¦çš„é˜²ç¦¦åŠ æˆï¼Œä½†è£å‚™çš„ attack å’Œ defense å±¬æ€§éœ€è¦å–®ç¨åŠ ä¸Š
    const attrList = ATTRIBUTES.map((attr) => {
      const base = attributes[attr.id];
      let total = totalAttrs[attr.id];
      let diff = total - base;
      
      // å¦‚æœæ˜¯æ”»æ“Šå±¬æ€§ï¼ŒåŠ ä¸Šè£å‚™çš„æ”»æ“ŠåŠ›ï¼ˆè£å‚™çš„ attack å±¬æ€§ä¸åœ¨ totalAttrs ä¸­ï¼‰
      if (attr.id === 'attack' && equipmentAttack > 0) {
        total += equipmentAttack;
        diff += equipmentAttack;
      }
      // å¦‚æœæ˜¯é˜²ç¦¦å±¬æ€§ï¼ŒåŠ ä¸Šè£å‚™çš„é˜²ç¦¦åŠ›ï¼ˆè£å‚™çš„ defense å±¬æ€§ä¸åœ¨ totalAttrs ä¸­ï¼‰
      // æ³¨æ„ï¼šè¢«å‹•é˜²ç¦¦å·²ç¶“åŒ…å«åœ¨ totalAttrs ä¸­äº†ï¼Œä¸éœ€è¦å†åŠ 
      if (attr.id === 'defense' && equipmentDefense > 0) {
        total += equipmentDefense;
        diff += equipmentDefense;
      }
      
      return `<li>
        <span>${attr.name}</span>
        <span>${total}</span>
      </li>`;
    }).join('');

    // è¨ˆç®—å„ç¨®æ¯”ç‡
    const critChance = calculateCritChance(hero);
    const hitRate = calculateHitRate(hero);
    const dodgeRate = calculateDodgeRate(hero);
    const magicDefense = calculateMagicDefense(hero, 'hero');
    
    // è¨ˆç®—è¢«æ”»æ“Šç‡ï¼ˆéœ€è¦è€ƒæ…®åŒä¼´ï¼Œç¢ºä¿ç¸½å’Œç‚º100%ï¼‰
    // è¢«æ”»æ“Šæ©Ÿç‡åŠ æ¬Šå€¼ = æ”»æ“Š/2 + é«”åŠ›Ã—2 + é˜²ç¦¦
    const heroWeight = Math.floor(totalAttrs.attack / 2) + totalAttrs.vitality * 2 + totalAttrs.defense;
    
    // æ‡‰ç”¨é˜²å®ˆå‹è¢«å‹•æŠ€èƒ½ï¼šå¢åŠ è¢«æ”»æ“Šæ©Ÿç‡ï¼ˆåŒ…æ‹¬è£å‚™æŠ€èƒ½ï¼‰
    let finalHeroWeight = heroWeight;
    let aggroMultiplier = 1.0;
    if (defenderEffects.aggroBoost > 0) {
      aggroMultiplier += defenderEffects.aggroBoost;
    }
    
    finalHeroWeight = Math.round(heroWeight * aggroMultiplier);
    
    let totalWeight = finalHeroWeight;
    let companionWeight = 0;
    
    // è¨ˆç®—æ‰€æœ‰æ´»è‘—åŒä¼´çš„ç¸½æ¬Šé‡
    const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
    activeCompanions.forEach(comp => {
      const companionAttrs = getCompanionTotalAttributes(comp);
      // è¢«æ”»æ“Šæ©Ÿç‡åŠ æ¬Šå€¼ = æ”»æ“Š/2 + é«”åŠ›Ã—2 + é˜²ç¦¦
      companionWeight += Math.floor(companionAttrs.attack / 2) + companionAttrs.vitality * 2 + companionAttrs.defense;
    });
    totalWeight += companionWeight;
    
    // è¨ˆç®—ç™¾åˆ†æ¯”ï¼šå‹‡è€…è¢«æ”»æ“Šæ©Ÿç‡ = (å‹‡è€…åŠ æ¬Š / (å‹‡è€…åŠ æ¬Š + æ‰€æœ‰åŒä¼´åŠ æ¬Šä¹‹å’Œ)) Ã— 100%
    let attackRate = totalWeight > 0 ? Math.round((finalHeroWeight / totalWeight) * 100) : 100;
    let companionAttackRate = totalWeight > 0 ? Math.round((companionWeight / totalWeight) * 100) : 0;
    
    // å¦‚æœæœ‰åŒä¼´ï¼Œç¢ºä¿ç¸½å’Œç‚º100%
    if (activeCompanions.length > 0 && attackRate + companionAttackRate !== 100) {
      if (attackRate > companionAttackRate) {
        attackRate = 100 - companionAttackRate;
      } else {
        companionAttackRate = 100 - attackRate;
      }
    }
    
    const heroStatusSection = document.getElementById('hero-status-section');
    if (heroStatusSection) {
      const skillsHtml = renderSkillsPanel();
      const innerContent = `
      ${switchButtons}
      <div class="hero-info">
        <div>
          <p>ç­‰ç´šï¼š${stats.level}</p>
            <p>${formatHpDisplay(hero)}</p>
          <p>MPï¼š${stats.mp}/${stats.maxMp}</p>
        </div>
        <div>
          <p>EXPï¼š${stats.xp} / ${stats.nextLevelXp}</p>
          <p>é‡‘å¹£ï¼š${stats.gold}</p>
          <p>å ´æ™¯ï¼š${AREA_CONFIG[state.world.currentArea]?.name || 'æœªçŸ¥'}</p>
        </div>
      </div>
      <div class="attribute-panel">
        <h3>å±¬æ€§</h3>
        <ul>${attrList}</ul>
        ${hero.heroType ? (() => {
          const heroTypeId = hero.heroType;
          const advancedGrowthMap = {
            sage: ['mage', 'healer'],
            paladin: ['defender', 'healer'],
            weaponmaster: ['attacker', 'agile'],
          };
          let label = '';
          if (advancedGrowthMap[heroTypeId]) {
            const baseNames = advancedGrowthMap[heroTypeId]
              .map(id => HERO_TYPES[id]?.name || id)
              .join(' / ');
            label = `${HERO_TYPES[heroTypeId]?.name || heroTypeId}ï¼ˆ${baseNames}ï¼‰`;
          } else {
            label = HERO_TYPES[heroTypeId]?.name || 'æœªçŸ¥';
          }
          return `<p class="hero-type-badge">é¡å‹ï¼š${label}</p>`;
        })() : ''}
      </div>
      <div class="battle-stats-panel">
        <h3>æˆ°é¬¥èƒ½åŠ›</h3>
        <p>å‘½ä¸­ç‡ï¼š${hitRate}%</p>
        <p>é–ƒé¿ç‡ï¼š${dodgeRate}%</p>
        <p>æœƒå¿ƒä¸€æ“Šç‡ï¼š${critChance}%</p>
        <p>è¢«æ”»æ“Šç‡ï¼š${attackRate}%</p>
        <p>é­”é˜²ï¼š${magicDefense}</p>
      </div>
        ${skillsHtml}
      `;
      if (getDeviceType() === 'mobile') {
        const isExpanded = state.ui.accordionState.hero;
        heroStatusSection.innerHTML = `
          <div class="accordion-header" onclick="toggleAccordion('hero')">
            <h4>å‹‡è€…è³‡è¨Š</h4>
            <span class="accordion-arrow ${isExpanded ? 'expanded' : ''}">â–¶</span>
          </div>
          <div class="accordion-body ${isExpanded ? 'expanded' : ''}">
            ${innerContent}
          </div>
        `;
      } else {
        heroStatusSection.innerHTML = innerContent;
      }
    }
  }
}

// åˆ‡æ¢è§’è‰²è§†å›¾
function switchCharacterView(view, companionIndex = 0) {
  state.ui.characterView = view;
  if (view === 'companion') {
    // ç¡®ä¿ç´¢å¼•æœ‰æ•ˆ
    const validIndex = Math.max(0, Math.min(companionIndex, (state.companions || []).length - 1));
    state.ui.companionViewIndex = validIndex;
  }
  renderHeroPanel();
  renderSkillsPanel();
  renderStatusTabs();
}

// å°†å‡½æ•°æš´éœ²åˆ°å…¨å±€
window.switchCharacterView = switchCharacterView;

// åˆ‡æ›ç‹€æ…‹é¢æ¿æ¨™ç±¤é 
function switchStatusTab(tabName) {
  state.ui.statusTab = tabName;
  renderStatusTabs();
}

// æ¸²æŸ“ç‹€æ…‹é¢æ¿ï¼ˆç¾åœ¨åªæ¸²æŸ“å³å´çš„é“å…·+è£å‚™ï¼‰
function renderStatusTabs() {
  const hero = state.hero;
  const currentView = state.ui.characterView || 'hero';
  const companions = state.companions || [];
  const companionViewIndex = state.ui.companionViewIndex || 0;
  const currentCompanion = currentView === 'companion' && companions.length > 0 
    ? companions[companionViewIndex] 
    : null;
  const showCompanion = currentView === 'companion' && currentCompanion;
  
  // ç›´æ¥æ¸²æŸ“é“å…·+è£å‚™åˆ°å³å´ï¼ˆåªæœ‰è‹±é›„æœ‰é“å…·è¢‹ï¼‰
  if (!showCompanion && hero) {
    renderInventoryPanel();
  }
  // è£…å¤‡é¢æ¿å§‹ç»ˆæ¸²æŸ“ï¼ˆè‹±é›„å’ŒåŒä¼´éƒ½éœ€è¦æ˜¾ç¤ºè£…å¤‡ï¼‰
    renderEquipmentPanel();
}

// æ¸²æŸ“æŠ€èƒ½é¢æ¿ï¼ˆè¿”å›æŠ€èƒ½HTMLå­—ç¬¦ä¸²ï¼‰
function renderSkillsPanel() {
  const currentView = state.ui.characterView || 'hero';
  const companions = state.companions || [];
  const companionViewIndex = state.ui.companionViewIndex || 0;
  const currentCompanion = currentView === 'companion' && companions.length > 0 
    ? companions[companionViewIndex] 
    : null;
  const showCompanion = currentView === 'companion' && currentCompanion;
  
  // æ ¹æ®å½“å‰è§†å›¾æ˜¾ç¤ºè‹±é›„æˆ–åŒä¼´çš„æŠ€èƒ½
  const character = showCompanion ? currentCompanion : state.hero;
  if (!character) {
    return '<p>å°šæœªé–‹å§‹å†’éšª</p>';
  }
  
  const skills = character.skills.map(id => SKILL_LOOKUP.get(id)).filter(Boolean);
  const activeSkills = skills.filter(skill => skill.kind && skill.kind !== 'passive');
  const passiveSkills = skills.filter(skill => skill.kind === 'passive');
  
  // æ¸²æŸ“ä¸»å‹•æŠ€èƒ½
  let activeHtml = '<h4>ä¸»å‹•æŠ€èƒ½</h4>';
  if (activeSkills.length > 0) {
    activeHtml += '<ul class="skill-list">';
    activeSkills.forEach(skill => {
      const mpCost = skill.mpCost || 0;
      const canUse = character.stats.mp >= mpCost;
      // éæˆ°é¬¥ç‹€æ…‹ä¸‹ï¼Œåªæœ‰å›å¾©å‹æŠ€èƒ½å¯ä»¥ä½¿ç”¨
      const isHealSkill = skill.kind === 'heal';
      const canUseInField = !state.ui.battle && isHealSkill;
      
      // å¦‚æœæ˜¯åŒä¼´ï¼Œä¸”éæˆ°é¬¥ç‹€æ…‹ä¸‹ï¼Œæª¢æŸ¥æŠ€èƒ½å•Ÿç”¨ç‹€æ…‹ä¸¦æ·»åŠ å¤é€‰æ¡†
      let skillEnabledCheckbox = '';
      if (showCompanion && currentCompanion && !state.ui.battle) {
        const isEnabled = isSkillEnabled(skill.id, currentCompanion);
        const companionIndex = companions.indexOf(currentCompanion);
        skillEnabledCheckbox = `
          <label class="skill-enabled-checkbox" style="display: flex; align-items: center; gap: 5px; margin-top: 5px;">
            <input type="checkbox" 
                   data-skill-id="${skill.id}" 
                   data-companion-index="${companionIndex}"
                   ${isEnabled ? 'checked' : ''}
                   style="cursor: pointer;">
            <span style="font-size: 0.9em; color: #9fc5e8;">å•Ÿç”¨ï¼ˆæˆ°é¬¥ä¸­å¯ä½¿ç”¨ï¼‰</span>
          </label>
        `;
      }
      
      activeHtml += `
        <li>
          <strong>${skill.name}</strong>
          <p>${skill.description}</p>
          ${mpCost > 0 ? `<p>MPæ¶ˆè€—ï¼š${mpCost}</p>` : ''}
          <span class="badge" style="background:${FLOW_PALETTE[skill.flow] || '#fff'}">
            ${FLOWS[skill.flow]?.label || 'ä¸€èˆ¬'}
          </span>
          ${skillEnabledCheckbox}
          ${canUseInField ? `
            <button class="use-skill-btn" data-skill="${skill.id}" data-character="${showCompanion ? 'companion' : 'hero'}" ${!canUse ? 'disabled' : ''}>
              ${canUse ? 'ä½¿ç”¨' : 'MPä¸è¶³'}
            </button>
          ` : ''}
        </li>
      `;
    });
    activeHtml += '</ul>';
  } else {
    activeHtml += '<p>å°šæœªå­¸æœƒä¸»å‹•æŠ€èƒ½</p>';
  }
  
  // æ¸²æŸ“è¢«å‹•æŠ€èƒ½ï¼ˆåŒ…æ‹¬åœ£ç‰©æä¾›çš„è¢«åŠ¨æŠ€èƒ½ï¼‰
  let passiveHtml = '<h4>è¢«å‹•æŠ€èƒ½</h4>';
  
  // å¦‚æœæ˜¯åŒä¼´ï¼Œæ£€æŸ¥åœ£ç‰©æä¾›çš„è¢«åŠ¨æŠ€èƒ½
  let relicPassiveSkill = null;
  if (showCompanion && currentCompanion.equippedRelic) {
    const relic = state.relics.find(r => r.id === currentCompanion.equippedRelic);
    if (relic && relic.passiveSkill) {
      relicPassiveSkill = relic.passiveSkill;
    }
  }
  
  const allPassiveSkills = [...passiveSkills];
  if (relicPassiveSkill) {
    allPassiveSkills.push(relicPassiveSkill);
  }
  
  if (allPassiveSkills.length > 0) {
    passiveHtml += '<ul class="skill-list">';
    allPassiveSkills.forEach(skill => {
      const isFromRelic = relicPassiveSkill && skill.id === relicPassiveSkill.id;
      passiveHtml += `
        <li>
          <strong>${skill.name}${isFromRelic ? ' <span style="color: #ffd700; font-size: 0.9em;">(åœ£ç‰©)</span>' : ''}</strong>
          <p>${skill.description}</p>
          <span class="badge" style="background:${FLOW_PALETTE[skill.flow] || '#fff'}">
            ${FLOWS[skill.flow]?.label || 'ä¸€èˆ¬'}
          </span>
        </li>
      `;
    });
    passiveHtml += '</ul>';
  } else {
    passiveHtml += '<p>å°šæœªå­¸æœƒè¢«å‹•æŠ€èƒ½</p>';
  }
  
  // è¿”å›æŠ€èƒ½HTMLï¼Œä½¿ç”¨gridå¸ƒå±€æ˜¾ç¤ºä¸»åŠ¨å’Œè¢«åŠ¨æŠ€èƒ½
  return `
    <div class="skills-content">
      <div class="skills-column">${activeHtml}</div>
      <div class="skills-column">${passiveHtml}</div>
    </div>
  `;
}

// é™åˆ¶é“å…·æ•¸é‡ï¼ˆæœ€å¤š8å€‹ä¸åŒçš„é“å…·ï¼‰
function limitInventorySize() {
  const hero = state.hero;
  if (!hero) return;
  
  const maxItems = 8;
  const validItems = hero.items.filter(item => item.qty > 0);
  
  // å¦‚æœè¶…é8å€‹ï¼Œåªä¿ç•™å‰8å€‹
  if (validItems.length > maxItems) {
    hero.items = validItems.slice(0, maxItems);
    pushLog('é“å…·æ¬„å·²æ»¿ï¼Œéƒ¨åˆ†é“å…·è¢«ä¸Ÿæ£„ã€‚');
  }
}

// æ¸²æŸ“é“å…·æ¬„
function renderInventoryPanel() {
  const hero = state.hero;
  if (!hero) {
    if (dom.inventoryPanel) {
      dom.inventoryPanel.innerHTML = `
        <div class="inventory-panel-header">
          <h4>é“å…·æ¬„</h4>
        </div>
        <div class="inventory-panel-content">
          <p>å°šæœªé–‹å§‹å†’éšª</p>
        </div>
      `;
    }
    return;
  }
  
  // é™åˆ¶é“å…·æ•¸é‡æœ€å¤š8å€‹
  limitInventorySize();
  
  const maxItems = 8;
  const items = hero.items.filter(item => item.qty > 0).slice(0, maxItems);
  
  let headerHtml = '<h4>é“å…·æ¬„</h4>';
  headerHtml += `<p>é“å…·æ•¸é‡ï¼š${items.length}/${maxItems}</p>`;
  
  let contentHtml = '';
  if (items.length === 0) {
    contentHtml = '<p>é“å…·æ¬„ç‚ºç©º</p>';
  } else {
    contentHtml = '<div class="inventory-grid">';
    items.forEach(entry => {
      // æª¢æŸ¥æ˜¯å¦ç‚ºè£å‚™ï¼ˆequipment_å‰ç¶´ï¼‰
      if (entry.id.startsWith('equipment_')) {
        const equipmentId = entry.id.replace('equipment_', '');
        const equipment = getEquipmentData(equipmentId);
        if (!equipment) return;
        
        // é¡¯ç¤ºè£å‚™
        const stats = [];
        // é¡¯ç¤ºæ”»æ“ŠåŠ›ï¼ˆæ­¦å™¨ï¼‰
        if (equipment.attack !== undefined) {
          stats.push(`æ”»æ“Š+${equipment.attack}`);
        }
        // é¡¯ç¤ºé˜²ç¦¦åŠ›ï¼ˆé˜²å…·å’Œç›¾ç‰Œï¼Œé£¾å“ä¸é¡¯ç¤ºé˜²ç¦¦åŠ›ï¼‰
        if (equipment.defense !== undefined && equipment.type !== 'accessory') {
          stats.push(`é˜²ç¦¦+${equipment.defense}`);
        }
        // é¡¯ç¤ºé–ƒé¿ç‡ï¼ˆç›¾ç‰Œï¼‰
        if (equipment.dodge) stats.push(`é–ƒé¿+${(equipment.dodge * 100).toFixed(0)}%`);
        // é¡¯ç¤ºå±¬æ€§åŠ æˆ
        if (equipment.attributes) {
          Object.keys(equipment.attributes).forEach(attr => {
            const attrName = ATTRIBUTES.find(a => a.id === attr)?.name || attr;
            stats.push(`${attrName}+${equipment.attributes[attr]}`);
          });
        }
        
        contentHtml += `
          <div class="inventory-item">
            <div class="item-name">${equipment.name}</div>
            <div class="item-desc">${equipment.description || 'è£å‚™'}</div>
            ${stats.length > 0 ? `<div class="item-desc">${stats.join(' ')}</div>` : ''}
            <div class="item-qty">æ•¸é‡ï¼š${entry.qty}</div>
            <button class="equip-from-bag-btn" data-equipment="${equipmentId}" data-item="${entry.id}" ${state.ui.battle ? 'disabled' : ''}>è£å‚™</button>
            <button class="drop-item-btn" data-item="${entry.id}" ${state.ui.battle ? 'disabled' : ''}>ä¸Ÿæ£„</button>
          </div>
        `;
        return;
      }
      
      // æ™®é€šé“å…·
      const item = ITEM_LOOKUP.get(entry.id);
      if (!item) return;
      // æª¢æŸ¥æ˜¯å¦ç‚ºæ¢å¾©é¡é“å…·ï¼ˆåœ¨éæˆ°é¬¥ç‹€æ…‹å¯ä»¥ä½¿ç”¨ï¼‰
      const isHealingItem = item.type === 'heal' || item.type === 'mp' || item.type === 'full';
      const canUseInField = !state.ui.battle && isHealingItem;
      contentHtml += `
        <div class="inventory-item">
          <div class="item-name">${item.name}</div>
          <div class="item-desc">${item.description}</div>
          <div class="item-qty">æ•¸é‡ï¼š${entry.qty}</div>
          ${canUseInField ? `<button class="use-item-btn" data-item="${entry.id}">ä½¿ç”¨</button>` : ''}
          <button class="drop-item-btn" data-item="${entry.id}">ä¸Ÿæ£„</button>
        </div>
      `;
    });
    contentHtml += '</div>';
  }
  
  if (dom.inventoryPanel) {
    const invInnerContent = `
      <div class="inventory-panel-content">
        ${contentHtml}
      </div>
    `;
    if (getDeviceType() === 'mobile') {
      const isExpanded = state.ui.accordionState.inventory;
      dom.inventoryPanel.innerHTML = `
        <div class="accordion-header" onclick="toggleAccordion('inventory')">
          <h4>é“å…·æ¬„ (${items.length}/${maxItems})</h4>
          <span class="accordion-arrow ${isExpanded ? 'expanded' : ''}">â–¶</span>
        </div>
        <div class="accordion-body ${isExpanded ? 'expanded' : ''}">
          ${invInnerContent}
        </div>
      `;
    } else {
      dom.inventoryPanel.innerHTML = `
        <div class="inventory-panel-header">
          ${headerHtml}
        </div>
        ${invInnerContent}
      `;
    }
  }
}

// ä¸Ÿæ£„é“å…·
function dropItem(itemId) {
  const hero = state.hero;
  if (!hero) return;
  
  // æˆ°é¬¥ä¸­ä¸èƒ½ä¸Ÿæ£„ç‰©å“
  if (state.ui.battle) {
    pushLog('æˆ°é¬¥ä¸­ç„¡æ³•ä¸Ÿæ£„ç‰©å“ï¼');
    return;
  }
  
  const itemEntry = hero.items.find(entry => entry.id === itemId);
  if (!itemEntry || itemEntry.qty <= 0) return;
  
  // æª¢æŸ¥æ˜¯å¦ç‚ºè£å‚™ï¼ˆequipment_å‰ç¶´ï¼‰
  let itemName = '';
  if (itemId.startsWith('equipment_')) {
    const equipmentId = itemId.replace('equipment_', '');
    const equipment = getEquipmentData(equipmentId);
    if (!equipment) {
      pushLog('ç„¡æ³•æ‰¾åˆ°è©²è£å‚™ï¼');
      return;
    }
    itemName = equipment.name;
  } else {
    // æ™®é€šé“å…·
  const item = ITEM_LOOKUP.get(itemId);
    if (!item) {
      pushLog('ç„¡æ³•æ‰¾åˆ°è©²é“å…·ï¼');
      return;
    }
    itemName = item.name;
  }
  
  itemEntry.qty -= 1;
  if (itemEntry.qty <= 0) {
    // å¦‚æœæ•¸é‡ç‚º0ï¼Œå¾åˆ—è¡¨ä¸­ç§»é™¤
    hero.items = hero.items.filter(entry => entry.qty > 0);
  }
  
  pushLog(`ä¸Ÿæ£„äº†${itemName}ã€‚`);
  renderAll();
}

// éæˆ°é¬¥ç‹€æ…‹ä½¿ç”¨å›å¾©æŠ€èƒ½ï¼ˆæ”¯æŒé¸æ“‡ç›®æ¨™ï¼‰
function useSkillInField(skillId, characterType = 'hero', companionIndex = 0) {
  // å¦‚æœæ­£åœ¨æˆ°é¬¥ï¼Œä¸èƒ½ä½¿ç”¨
  if (state.ui.battle) return;
  
  const hero = state.hero;
  if (!hero) return;
  
  // ç¢ºå®šä½¿ç”¨æŠ€èƒ½çš„å°è±¡
  let caster = hero;
  if (characterType === 'companion') {
    const companions = state.companions || [];
    if (companionIndex >= 0 && companionIndex < companions.length) {
      caster = companions[companionIndex];
    } else {
    const companion = getActiveCompanion();
    if (!companion) return;
    caster = companion;
    }
    if (!caster) return;
  }
  
  const skill = SKILL_LOOKUP.get(skillId);
  if (!skill) return;
  
  // åªå…è¨±ä½¿ç”¨å›å¾©å‹æŠ€èƒ½
  if (skill.kind !== 'heal') {
    pushLog('è©²æŠ€èƒ½ç„¡æ³•åœ¨éæˆ°é¬¥ç‹€æ…‹ä¸‹ä½¿ç”¨ã€‚');
    return;
  }
  
  // æª¢æŸ¥ MP æ¶ˆè€—
  const mpCost = skill.mpCost || 0;
  if (caster.stats.mp < mpCost) {
    const casterName = characterType === 'companion' ? caster.name : 'ä½ ';
    pushLog(`${casterName} MP ä¸è¶³ï¼Œç„¡æ³•ä½¿ç”¨æ­¤æŠ€èƒ½ï¼`);
    renderAll();
    return;
  }
  
  // å¦‚æœæœ‰åŒä¼´ï¼Œéœ€è¦é¸æ“‡ç›®æ¨™
  const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
  if (activeCompanions.length > 0) {
    // é€²å…¥é¸æ“‡ç›®æ¨™æ¨¡å¼
    if (!state.ui.fieldSkillSelection || state.ui.fieldSkillSelection.skillId !== skillId || state.ui.fieldSkillSelection.characterType !== characterType || state.ui.fieldSkillSelection.companionIndex !== companionIndex) {
      state.ui.fieldSkillSelection = {
        skillId: skillId,
        characterType: characterType,
        companionIndex: companionIndex,
      };
      renderAll();
      return;
    }
    
    // å¦‚æœå·²ç¶“åœ¨é¸æ“‡ç›®æ¨™æ¨¡å¼ï¼Œä½†æ˜¯é‚„æ²’æœ‰é¸æ“‡ï¼Œéœ€è¦ç­‰å¾…ç”¨æˆ¶é¸æ“‡
    // é€™è£¡æœƒé€šéUIä¾†é¸æ“‡ç›®æ¨™ï¼Œé¸æ“‡å¾Œæœƒèª¿ç”¨ selectFieldSkillTarget
    return;
  }
  
  // æ²’æœ‰åŒä¼´ï¼Œç›´æ¥å°è‡ªå·±ä½¿ç”¨
  useSkillInFieldDirectly(skillId, characterType, 'hero', 0, companionIndex);
}

// éæˆ°é¬¥ç‹€æ…‹ç›´æ¥ä½¿ç”¨å›å¾©æŠ€èƒ½ï¼ˆå·²é¸æ“‡ç›®æ¨™ï¼‰
function useSkillInFieldDirectly(skillId, characterType, targetType, companionIndex = 0, casterCompanionIndex = 0) {
  const hero = state.hero;
  if (!hero) return;
  
  // ç¢ºå®šä½¿ç”¨æŠ€èƒ½çš„å°è±¡
  let caster = hero;
  let casterName = 'ä½ ';
  if (characterType === 'companion') {
    const companions = state.companions || [];
    if (companionIndex >= 0 && companionIndex < companions.length) {
      caster = companions[companionIndex];
      casterName = caster.name;
    } else {
    const companion = getActiveCompanion();
    if (!companion) return;
    caster = companion;
    casterName = companion.name;
    }
    if (!caster) return;
  }
  
  const skill = SKILL_LOOKUP.get(skillId);
  if (!skill || (skill.kind !== 'heal' && skill.kind !== 'support')) return;
  
  // æª¢æŸ¥ MP æ¶ˆè€—
  const mpCost = skill.mpCost || 0;
  if (caster.stats.mp < mpCost) {
    pushLog(`${casterName} MP ä¸è¶³ï¼Œç„¡æ³•ä½¿ç”¨æ­¤æŠ€èƒ½ï¼`);
    state.ui.fieldSkillSelection = null;
    renderAll();
    return;
  }
  
  // ç¢ºå®šç›®æ¨™
  let targetCharacter = hero;
  let targetName = 'ä½ ';
  
  if (targetType === 'companion') {
    const companions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
    const companion = companions[companionIndex] || null;
    if (companion) {
      targetCharacter = companion;
      targetName = companion.name;
    } else {
      state.ui.fieldSkillSelection = null;
      renderAll();
      return;
    }
  }
  
  // æ¶ˆè€—MP
  caster.stats.mp -= mpCost;
  
  if (skill.kind === 'support') {
    // è¼”åŠ©æŠ€èƒ½ï¼ˆè­·ç›¾ï¼‰
    const isHero = caster === state.hero;
    const totalAttrs = isHero 
      ? getHeroTotalAttributes(caster)
      : getCompanionTotalAttributes(caster);
    const recovery = totalAttrs.recovery;
    const shieldAmount = skill.power + Math.floor(recovery / 2);
    
    if (skill.aoe) {
      // å…¨é«”è­·ç›¾
      if (caster.stats.hp > 0) {
        caster.stats.shield = (caster.stats.shield || 0) + shieldAmount;
        pushLog(`${casterName}å°è‡ªå·±æ–½åŠ  ${shieldAmount} è­·ç›¾ï¼`);
      }
      
      if (state.hero && state.hero.stats.hp > 0 && caster !== state.hero) {
        state.hero.stats.shield = (state.hero.stats.shield || 0) + shieldAmount;
        pushLog(`${casterName}å°å‹‡è€…æ–½åŠ  ${shieldAmount} è­·ç›¾ï¼`);
      }
      
      const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0 && c !== caster);
      activeCompanions.forEach(comp => {
        comp.stats.shield = (comp.stats.shield || 0) + shieldAmount;
        pushLog(`${casterName}å°${comp.name}æ–½åŠ  ${shieldAmount} è­·ç›¾ï¼`);
      });
    } else {
      // å–®é«”è­·ç›¾
      targetCharacter.stats.shield = (targetCharacter.stats.shield || 0) + shieldAmount;
      pushLog(`${casterName}å°${targetName}æ–½åŠ  ${shieldAmount} è­·ç›¾ï¼`);
    }
  } else {
    // æ²»ç™‚æŠ€èƒ½
  // è¨ˆç®—æ²»ç™‚æ•ˆæœ
  const healAmount = calculateHealingFor(skill, caster);
  
  // æ‡‰ç”¨æ²»ç™‚æ•ˆæœ
  const oldHp = targetCharacter.stats.hp;
  targetCharacter.stats.hp = Math.min(targetCharacter.stats.maxHp, targetCharacter.stats.hp + healAmount);
  const actualHealed = targetCharacter.stats.hp - oldHp;
  
  // é¡¯ç¤ºè¨Šæ¯
  if (skill.aoe) {
    // å…¨é«”å›å¾©
    const allCharacters = [hero, ...(state.companions || []).filter(c => c && c.stats && c.stats.hp > 0)];
    allCharacters.forEach(char => {
      const oldHp = char.stats.hp;
      char.stats.hp = Math.min(char.stats.maxHp, char.stats.hp + healAmount);
      const actualHealed = char.stats.hp - oldHp;
      if (actualHealed > 0) {
        const charName = char === hero ? 'ä½ ' : char.name;
        pushLog(`å°${charName}å›å¾©äº† ${actualHealed} HPã€‚`);
        // è§¸ç™¼ç¥è–è­·ç›¾æ•ˆæœï¼ˆå¦‚æœæ˜¯ç¥è–è­·ç›¾æŠ€èƒ½ï¼‰
        applySacredShieldEffect(skill, caster, char);
        // è§¸ç™¼é˜²æ­»è­·ç›¾æ•ˆæœï¼ˆå¦‚æœæ˜¯é˜²æ­»è­·ç›¾æŠ€èƒ½ï¼‰
        applyDeathWardEffect(skill, caster, char);
        // è§¸ç™¼ç¥è–å›éŸ¿æ•ˆæœ
        applyHealingEchoEffect(skill, caster, char, actualHealed);
      }
    });
  } else {
    // å–®é«”å›å¾©
    pushLog(`${casterName}å°${targetName}ä½¿ç”¨ã€Œ${skill.name}ã€ï¼Œå›å¾©äº† ${actualHealed} HPã€‚`);
    // è§¸ç™¼ç¥è–è­·ç›¾æ•ˆæœï¼ˆå¦‚æœæ˜¯ç¥è–è­·ç›¾æŠ€èƒ½ï¼‰
    applySacredShieldEffect(skill, caster, targetCharacter);
    // è§¸ç™¼é˜²æ­»è­·ç›¾æ•ˆæœï¼ˆå¦‚æœæ˜¯é˜²æ­»è­·ç›¾æŠ€èƒ½ï¼‰
    applyDeathWardEffect(skill, caster, targetCharacter);
    // è§¸ç™¼ç¥è–å›éŸ¿æ•ˆæœ
    applyHealingEchoEffect(skill, caster, targetCharacter, actualHealed);
  }
  }
  
  // æ¸…é™¤é¸æ“‡ç‹€æ…‹
  state.ui.fieldSkillSelection = null;
  renderAll();
}

// éæˆ°é¬¥ç‹€æ…‹é¸æ“‡æŠ€èƒ½ä½¿ç”¨ç›®æ¨™
function selectFieldSkillTarget(targetType, companionIndex = 0) {
  if (!state.ui.fieldSkillSelection) return;
  
  const { skillId, characterType, companionIndex: casterCompanionIndex = 0 } = state.ui.fieldSkillSelection;
  
  // è™•ç†å…¨é«”å›å¾©
  if (targetType === 'all') {
    const hero = state.hero;
    if (!hero) {
      state.ui.fieldSkillSelection = null;
      renderAll();
      return;
    }
    
    // ç¢ºå®šä½¿ç”¨æŠ€èƒ½çš„å°è±¡
    let caster = hero;
    let casterName = 'ä½ ';
    if (characterType === 'companion') {
      const companion = getActiveCompanion();
      if (!companion) {
        state.ui.fieldSkillSelection = null;
        renderAll();
        return;
      }
      const companions = state.companions || [];
      caster = (casterCompanionIndex >= 0 && casterCompanionIndex < companions.length) 
        ? companions[casterCompanionIndex] 
        : companion;
      casterName = caster.name;
    }
    
    const skill = SKILL_LOOKUP.get(skillId);
    if (!skill || skill.kind !== 'heal' || !skill.aoe) {
      state.ui.fieldSkillSelection = null;
      renderAll();
      return;
    }
    
    // æª¢æŸ¥ MP æ¶ˆè€—
    const mpCost = skill.mpCost || 0;
    if (caster.stats.mp < mpCost) {
      pushLog(`${casterName} MP ä¸è¶³ï¼Œç„¡æ³•ä½¿ç”¨æ­¤æŠ€èƒ½ï¼`);
      state.ui.fieldSkillSelection = null;
      renderAll();
      return;
    }
    
    // æ¶ˆè€—MP
    caster.stats.mp -= mpCost;
    
    // è¨ˆç®—æ²»ç™‚æ•ˆæœ
    const healAmount = calculateHealingFor(skill, caster);
    
    // å°æ‰€æœ‰è§’è‰²æ‡‰ç”¨æ²»ç™‚
    const allCharacters = [hero, ...(state.companions || []).filter(c => c && c.stats && c.stats.hp > 0)];
    allCharacters.forEach(char => {
      const oldHp = char.stats.hp;
      char.stats.hp = Math.min(char.stats.maxHp, char.stats.hp + healAmount);
      const actualHealed = char.stats.hp - oldHp;
      if (actualHealed > 0) {
        const charName = char === hero ? 'ä½ ' : char.name;
        pushLog(`å°${charName}å›å¾©äº† ${actualHealed} HPã€‚`);
      }
    });
    
    pushLog(`${casterName}ä½¿ç”¨ã€Œ${skill.name}ã€ï¼Œå°æˆ‘æ–¹å…¨é«”å›å¾©äº† ${healAmount} HPã€‚`);
    
    // æ¸…é™¤é¸æ“‡ç‹€æ…‹
    state.ui.fieldSkillSelection = null;
    renderAll();
    return;
  }
  
  useSkillInFieldDirectly(skillId, characterType, targetType, companionIndex, casterCompanionIndex);
}

// éæˆ°é¬¥ç‹€æ…‹ä½¿ç”¨é“å…·ï¼ˆæ”¯æŒé¸æ“‡ç›®æ¨™ï¼‰
function useItemInField(itemId) {
  const hero = state.hero;
  if (!hero) return;
  
  // å¦‚æœæ­£åœ¨æˆ°é¬¥ï¼Œä¸èƒ½ä½¿ç”¨
  if (state.ui.battle) return;
  
  const itemEntry = hero.items.find(entry => entry.id === itemId);
  if (!itemEntry || itemEntry.qty <= 0) return;
  
  const item = ITEM_LOOKUP.get(itemId);
  if (!item) return;
  
  // åªå…è¨±ä½¿ç”¨æ¢å¾©é¡é“å…·
  if (item.type !== 'heal' && item.type !== 'mp' && item.type !== 'full') {
    pushLog('è©²é“å…·ç„¡æ³•åœ¨æ­¤ä½¿ç”¨ã€‚');
    return;
  }
  
  // å¦‚æœæœ‰åŒä¼´ï¼Œæ‰€æœ‰æ¢å¾©é¡é“å…·éƒ½éœ€è¦é¸æ“‡ç›®æ¨™
  const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
  if (activeCompanions.length > 0 && (item.type === 'heal' || item.type === 'full' || item.type === 'mp')) {
    if (!state.ui.fieldItemSelection || state.ui.fieldItemSelection !== itemId) {
      // é€²å…¥é¸æ“‡ç›®æ¨™æ¨¡å¼
      state.ui.fieldItemSelection = itemId;
      renderAll();
      return;
    }
    
    // å¦‚æœå·²ç¶“åœ¨é¸æ“‡ç›®æ¨™æ¨¡å¼ï¼Œä½†æ˜¯é‚„æ²’æœ‰é¸æ“‡ï¼Œéœ€è¦ç­‰å¾…ç”¨æˆ¶é¸æ“‡
    // é€™è£¡æœƒé€šéUIä¾†é¸æ“‡ç›®æ¨™ï¼Œé¸æ“‡å¾Œæœƒèª¿ç”¨ selectFieldItemTarget
    return;
  }
  
  // æ²’æœ‰åŒä¼´ï¼Œç›´æ¥å°è‡ªå·±ä½¿ç”¨
  let targetCharacter = hero;
  
  // æ‡‰ç”¨æ•ˆæœ
  if (item.type === 'heal') {
    targetCharacter.stats.hp = Math.min(targetCharacter.stats.maxHp, targetCharacter.stats.hp + item.value);
    pushLog(`ä½¿ç”¨ ${item.name}ï¼Œå›å¾© ${item.value} HPã€‚`);
  } else if (item.type === 'mp') {
    targetCharacter.stats.mp = Math.min(targetCharacter.stats.maxMp, targetCharacter.stats.mp + item.value);
    pushLog(`ä½¿ç”¨ ${item.name}ï¼Œå›å¾© ${item.value} MPã€‚`);
  } else if (item.type === 'full') {
    targetCharacter.stats.hp = targetCharacter.stats.maxHp;
    targetCharacter.stats.mp = targetCharacter.stats.maxMp;
    pushLog(`ä½¿ç”¨ ${item.name}ï¼Œå®Œå…¨æ¢å¾©ã€‚`);
  }
  
  // æ¶ˆè€—é“å…·
  itemEntry.qty -= 1;
  if (itemEntry.qty <= 0) {
    hero.items = hero.items.filter(entry => entry.qty > 0);
  }
  
  renderAll();
}

// éæˆ°é¬¥ç‹€æ…‹é¸æ“‡é“å…·ä½¿ç”¨ç›®æ¨™
function selectFieldItemTarget(targetType, companionIndex = 0) {
  if (!state.ui.fieldItemSelection) return;
  
  const hero = state.hero;
  const itemId = state.ui.fieldItemSelection;
  const itemEntry = hero.items.find(entry => entry.id === itemId);
  if (!itemEntry || itemEntry.qty <= 0) {
    state.ui.fieldItemSelection = null;
    renderAll();
    return;
  }
  
  const item = ITEM_LOOKUP.get(itemId);
  if (!item) {
    state.ui.fieldItemSelection = null;
    renderAll();
    return;
  }
  
  let targetCharacter = hero;
  let targetName = 'ä½ ';
  
  if (targetType === 'companion') {
    // ä½¿ç”¨ä¼ å…¥çš„åŒä¼´ç´¢å¼•æ¥é€‰æ‹©åŒä¼´
    const companions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
    const companion = companions[companionIndex] || null;
    if (companion) {
      targetCharacter = companion;
      targetName = companion.name;
    } else {
      // å¦‚æœæŒ‡å®šçš„åŒä¼´ä¸å­˜åœ¨ï¼Œå–æ¶ˆé€‰æ‹©
      state.ui.fieldItemSelection = null;
      renderAll();
      return;
    }
  }
  
  // æ‡‰ç”¨é“å…·æ•ˆæœ
  if (item.type === 'heal') {
    const oldHp = targetCharacter.stats.hp;
    targetCharacter.stats.hp = Math.min(targetCharacter.stats.maxHp, targetCharacter.stats.hp + item.value);
    const actualHealed = targetCharacter.stats.hp - oldHp;
    pushLog(`å°${targetName}ä½¿ç”¨ ${item.name}ï¼Œå›å¾© ${actualHealed} HPã€‚`);
  } else if (item.type === 'mp') {
    const oldMp = targetCharacter.stats.mp;
    targetCharacter.stats.mp = Math.min(targetCharacter.stats.maxMp, targetCharacter.stats.mp + item.value);
    const actualRecovered = targetCharacter.stats.mp - oldMp;
    pushLog(`å°${targetName}ä½¿ç”¨ ${item.name}ï¼Œå›å¾© ${actualRecovered} MPã€‚`);
  } else if (item.type === 'full') {
    targetCharacter.stats.hp = targetCharacter.stats.maxHp;
    targetCharacter.stats.mp = targetCharacter.stats.maxMp;
    pushLog(`å°${targetName}ä½¿ç”¨ ${item.name}ï¼Œå®Œå…¨æ¢å¾©ã€‚`);
  }
  
  // æ¶ˆè€—é“å…·
  itemEntry.qty -= 1;
  if (itemEntry.qty <= 0) {
    hero.items = hero.items.filter(entry => entry.qty > 0);
  }
  
  // æ¸…é™¤é¸æ“‡ç‹€æ…‹
  state.ui.fieldItemSelection = null;
  renderAll();
}

// å°‡å‡½æ•¸æš´éœ²åˆ°å…¨å±€
window.selectFieldItemTarget = selectFieldItemTarget;
window.selectFieldSkillTarget = selectFieldSkillTarget;

function renderEquipmentPanel() {
  const hero = state.hero;
  if (!hero) {
    if (dom.equipmentPanel) {
      dom.equipmentPanel.innerHTML = `
        <div class="equipment-panel-header">
          <h4>è£å‚™</h4>
        </div>
        <div class="equipment-panel-content">
          <p>å°šæœªé–‹å§‹å†’éšª</p>
        </div>
      `;
    }
    return;
  }
  
  // (1) å‹‡è€…è£å‚™éƒ¨åˆ†
  const equipment = hero.equipment || {
    weapon: null,
    shield: null,
    armor: null,
    accessory: null,
  };
  
  const slotLabels = {
    weapon: 'æ­¦å™¨',
    shield: 'ç›¾',
    armor: 'é˜²å…·',
    accessory: 'é£¾å“',
  };
  
  // ç²å–åº«å­˜ä¸­çš„è£å‚™ï¼ˆæŒ‰é¡å‹åˆ†çµ„ï¼‰
  const inventory = hero.equipmentInventory || [];
  const inventoryByType = {
    weapon: [],
    shield: [],
    armor: [],
    accessory: [],
  };
  
  inventory.forEach(eqId => {
    const eq = getEquipmentData(eqId);
    if (eq && inventoryByType[eq.type]) {
      inventoryByType[eq.type].push(eq);
    }
  });
  
  const slots = ['weapon', 'shield', 'armor', 'accessory'].map(slot => {
    const equipmentId = equipment[slot];
    let html = `<div class="equipment-slot" data-slot="${slot}">`;
    html += `<div class="slot-label">${slotLabels[slot]}</div>`;
    
    if (equipmentId) {
      const eq = getEquipmentData(equipmentId);
      if (eq) {
        const stats = [];
        // é¡¯ç¤ºæ”»æ“ŠåŠ›ï¼ˆæ­¦å™¨ï¼‰
        if (eq.attack !== undefined) {
          stats.push(`æ”»æ“Š+${eq.attack}`);
        }
        // é¡¯ç¤ºé˜²ç¦¦åŠ›ï¼ˆé˜²å…·å’Œç›¾ç‰Œï¼Œé£¾å“ä¸é¡¯ç¤ºé˜²ç¦¦åŠ›ï¼‰
        if (eq.defense !== undefined && eq.type !== 'accessory') {
          stats.push(`é˜²ç¦¦+${eq.defense}`);
        }
        // é¡¯ç¤ºé–ƒé¿ç‡ï¼ˆç›¾ç‰Œï¼‰
        if (eq.dodge) stats.push(`é–ƒé¿+${(eq.dodge * 100).toFixed(0)}%`);
        // é¡¯ç¤ºå±¬æ€§åŠ æˆ
        if (eq.attributes) {
          Object.keys(eq.attributes).forEach(attr => {
            const attrName = ATTRIBUTES.find(a => a.id === attr)?.name || attr;
            stats.push(`${attrName}+${eq.attributes[attr]}`);
          });
        }
        
        const isInBattle = state.ui.battle ? 'disabled' : '';
        html += `<div class="equipment-item">
          <div class="equipment-name">${eq.name}</div>
          <div class="equipment-desc">${eq.description}</div>
          ${stats.length > 0 ? `<div class="equipment-stats">${stats.join(' ')}</div>` : ''}
          <button class="unequip-btn" data-slot="${slot}" data-equipment="${equipmentId}" ${isInBattle}>å¸ä¸‹</button>
          <button class="equipment-to-bag-btn" data-slot="${slot}" data-equipment="${equipmentId}" ${isInBattle}>æ”¾å…¥é“å…·è¢‹</button>
        </div>`;
      }
    } else {
      html += `<div class="equipment-empty">æœªè£å‚™</div>`;
      // é¡¯ç¤ºå¯ç”¨çš„åº«å­˜è£å‚™
      const available = inventoryByType[slot] || [];
      if (available.length > 0) {
        html += `<div class="equipment-inventory-list">`;
        available.forEach(eq => {
          const stats = [];
          // é¡¯ç¤ºæ”»æ“ŠåŠ›ï¼ˆæ­¦å™¨ï¼‰
          if (eq.attack !== undefined) {
            stats.push(`æ”»æ“Š+${eq.attack}`);
          }
          // é¡¯ç¤ºé˜²ç¦¦åŠ›ï¼ˆé˜²å…·å’Œç›¾ç‰Œï¼Œé£¾å“ä¸é¡¯ç¤ºé˜²ç¦¦åŠ›ï¼‰
          if (eq.defense !== undefined && eq.type !== 'accessory') {
            stats.push(`é˜²ç¦¦+${eq.defense}`);
          }
          // é¡¯ç¤ºé–ƒé¿ç‡ï¼ˆç›¾ç‰Œï¼‰
          if (eq.dodge) stats.push(`é–ƒé¿+${(eq.dodge * 100).toFixed(0)}%`);
          // é¡¯ç¤ºå±¬æ€§åŠ æˆ
          if (eq.attributes) {
            Object.keys(eq.attributes).forEach(attr => {
              const attrName = ATTRIBUTES.find(a => a.id === attr)?.name || attr;
              stats.push(`${attrName}+${eq.attributes[attr]}`);
            });
          }
          const isInBattle = state.ui.battle ? 'disabled' : '';
          html += `<button class="equip-from-inventory-btn" data-slot="${slot}" data-equipment="${eq.id}" ${isInBattle}>
            ${eq.name} ${stats.length > 0 ? `(${stats.join(' ')})` : ''}
          </button>`;
          html += `<button class="equipment-to-bag-btn" data-equipment="${eq.id}" ${isInBattle}>æ”¾å…¥é“å…·è¢‹</button>`;
        });
        html += `</div>`;
      }
    }
    
    html += `</div>`;
    return html;
  }).join('');
  
  // (2) ä¼™ä¼´åœ£ç‰©è£å‚™éƒ¨åˆ†
  const companions = state.companions || [];
  const obtainedRelicIds = state.obtainedRelics || [];
  
  const companionRelicHtml = companions.map((companion, index) => {
    const equippedRelicId = companion.equippedRelic;
    const equippedRelic = equippedRelicId ? state.relics.find(r => r.id === equippedRelicId) : null;
    
    let html = `<div class="companion-relic-slot" data-companion-index="${index}" style="margin-bottom: 16px; padding: 12px; background: rgba(0, 0, 0, 0.2); border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 4px;">`;
    html += `<div class="slot-label" style="font-size: 13.2px; margin-bottom: 8px; padding-bottom: 6px; border-bottom: 2px solid rgba(255, 255, 255, 0.3);">
      <strong style="color: var(--accent);">${companion.name}</strong>
    </div>`;
    
    if (equippedRelic) {
      const attrName = ATTRIBUTES.find(a => a.id === equippedRelic.attributeType)?.name || equippedRelic.attributeType;
      const flowName = FLOWS[equippedRelic.flow]?.label || equippedRelic.flow;
      const flowColor = FLOW_PALETTE[equippedRelic.flow] || '#fff';
      
      html += `<div class="relic-item" style="padding: 10px; background: rgba(244, 177, 131, 0.1); border: 2px solid rgba(244, 177, 131, 0.3); border-radius: 4px;">
        <div class="equipment-name" style="font-size: 13.2px; color: #ffd700; margin-bottom: 6px;">âœ¨ ${equippedRelic.name}</div>
        <div class="equipment-desc" style="font-size: 10.8px; margin-bottom: 4px;">
          <span style="background: ${flowColor}; padding: 2px 6px; border-radius: 2px; color: #000; font-weight: bold;">éšæ®µ${equippedRelic.stage} ${flowName}</span>
        </div>
        <div class="equipment-stats" style="font-size: 11.2px; color: #9fc5e8; margin: 6px 0;">
          <strong>${attrName} +${equippedRelic.attributeBonus}</strong>
        </div>
        ${equippedRelic.passiveSkill ? `
          <div class="equipment-desc" style="font-size: 10.8px; color: #a8e6cf; margin-top: 6px; padding: 4px; background: rgba(168, 230, 207, 0.1); border-left: 3px solid #a8e6cf;">
            <strong>è¢«å‹•æŠ€èƒ½ï¼š</strong>${equippedRelic.passiveSkill.name}<br>
            <span style="font-size: 9.6px; color: rgba(255, 255, 255, 0.7);">${equippedRelic.passiveSkill.description}</span>
          </div>
        ` : ''}
        <button class="unequip-relic-btn" data-companion-index="${index}" data-relic-id="${equippedRelicId}" 
                style="margin-top: 8px; width: 100%; padding: 6px; font-size: 9.6px;" ${state.ui.battle ? 'disabled' : ''}>å¸ä¸‹åœ£ç‰©</button>
      </div>`;
    } else {
      html += `<div class="equipment-empty" style="padding: 8px; text-align: center; color: rgba(255, 255, 255, 0.5); font-size: 10.8px; margin-bottom: 8px;">æœªè£å‚™åœ£ç‰©</div>`;
      
      // åªé¡¯ç¤ºå·²ç²å¾—çš„åœ£ç‰©
      const availableRelics = state.relics.filter(r => {
        return obtainedRelicIds.includes(r.id);
      });
      
      if (availableRelics.length > 0) {
        // æŒ‰é˜¶æ®µå’Œæµæ´¾æ’åºï¼Œæ–¹ä¾¿é€‰æ‹©
        availableRelics.sort((a, b) => {
          if (a.stage !== b.stage) return a.stage - b.stage;
          const flowOrder = ['sword', 'defender', 'recovery', 'magic', 'agility', 'hero'];
          return flowOrder.indexOf(a.flow) - flowOrder.indexOf(b.flow);
        });
        
        const isInBattle = state.ui.battle ? 'disabled' : '';
        html += `<select class="relic-select" data-companion-index="${index}" 
                style="width: 100%; padding: 10px; margin-top: 4px; background: rgba(0, 0, 0, 0.8); 
                border: 2px solid rgba(255, 255, 255, 0.3); color: #ffffff; 
                font-family: 'Press Start 2P', monospace; font-size: 12px; cursor: pointer;
                border-radius: 4px;" ${isInBattle}>
          <option value="" style="background: rgba(0, 0, 0, 0.8); color: #ffffff;">é¸æ“‡åœ£ç‰©...</option>`;
        
        // æŒ‰é˜¶æ®µåˆ†ç»„æ˜¾ç¤º
        const relicsByStage = {};
        availableRelics.forEach(relic => {
          if (!relicsByStage[relic.stage]) {
            relicsByStage[relic.stage] = [];
          }
          relicsByStage[relic.stage].push(relic);
        });
        
        Object.keys(relicsByStage).sort((a, b) => parseInt(a) - parseInt(b)).forEach(stage => {
          html += `<optgroup label="éšæ®µ ${stage}" style="background: rgba(0, 0, 0, 0.8); color: #ffffff;">`;
          relicsByStage[stage].forEach(relic => {
            const attrName = ATTRIBUTES.find(a => a.id === relic.attributeType)?.name || relic.attributeType;
            const flowName = FLOWS[relic.flow]?.label || relic.flow;
            const flowColor = FLOW_PALETTE[relic.flow] || '#fff';
            // æª¢æŸ¥æ˜¯å¦è¢«å…¶ä»–åŒä¼´è£å‚™
            const equippedBy = companions.find((c, idx) => idx !== index && c.equippedRelic === relic.id);
            const equippedByText = equippedBy ? ` [${equippedBy.name}è£å‚™ä¸­]` : '';
            const passiveSkillText = relic.passiveSkill ? ` - ${relic.passiveSkill.name}` : '';
            html += `<option value="${relic.id}" style="background: rgba(0, 0, 0, 0.8); color: #ffffff;">${relic.name} [${flowName}] ${attrName}+${relic.attributeBonus}${passiveSkillText}${equippedByText}</option>`;
          });
          html += `</optgroup>`;
        });
        
        html += `</select>`;
      } else {
        html += `<div class="equipment-empty" style="margin-top: 8px; padding: 8px; text-align: center; color: rgba(255, 255, 255, 0.4); font-size: 10.8px; background: rgba(0, 0, 0, 0.2); border-radius: 4px;">
          <span style="display: block; margin-bottom: 4px;">å°šæœªç²å¾—ä»»ä½•åœ£ç‰©</span>
          <span style="font-size: 9.6px; color: rgba(255, 255, 255, 0.3);">æ“Šæ•—é­”ç‹å¾Œå¯ç²å¾—åœ£ç‰©</span>
        </div>`;
      }
    }
    
    html += `</div>`;
    return html;
  }).join('');
  
  if (dom.equipmentPanel) {
    const equipInnerContent = `
      <div class="equipment-panel-content">
        <div class="hero-equipment-section">
          <h5 style="margin: 10px 0 5px 0; font-size: 14px;">å‹‡è€…</h5>
      <div class="equipment-slots">${slots}</div>
        </div>
        ${companions.length > 0 ? `
          <div class="companion-relic-section" style="margin-top: 20px; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 15px;">
            <h5 style="margin: 10px 0 5px 0; font-size: 14px;">ä¼™ä¼´</h5>
            ${companionRelicHtml}
          </div>
        ` : ''}
      </div>
    `;
    if (getDeviceType() === 'mobile') {
      const isExpanded = state.ui.accordionState.equipment;
      dom.equipmentPanel.innerHTML = `
        <div class="accordion-header" onclick="toggleAccordion('equipment')">
          <h4>è£å‚™</h4>
          <span class="accordion-arrow ${isExpanded ? 'expanded' : ''}">â–¶</span>
        </div>
        <div class="accordion-body ${isExpanded ? 'expanded' : ''}">
          ${equipInnerContent}
        </div>
      `;
    } else {
      dom.equipmentPanel.innerHTML = `
        <div class="equipment-panel-header">
        <h4>è£å‚™</h4>
        </div>
        ${equipInnerContent}
      `;
    }
    
    // ç¶å®šåœ£ç‰©é¸æ“‡äº‹ä»¶
    const relicSelects = dom.equipmentPanel.querySelectorAll('.relic-select');
    relicSelects.forEach(select => {
      select.addEventListener('change', (e) => {
        const companionIndex = parseInt(select.dataset.companionIndex);
        const relicId = select.value;
        if (relicId) {
          equipRelicToCompanion(companionIndex, relicId);
          // é‡ç½®ä¸‹æ‹‰æ¡†çš„å€¼ï¼Œä»¥ä¾¿ä¸‹æ¬¡é€‰æ‹©
          setTimeout(() => {
            select.value = '';
          }, 0);
        }
      });
    });
    
    // ç¶å®šå¸ä¸‹åœ£ç‰©äº‹ä»¶
    const unequipRelicBtns = dom.equipmentPanel.querySelectorAll('.unequip-relic-btn');
    unequipRelicBtns.forEach(btn => {
      btn.addEventListener('click', (e) => {
        const companionIndex = parseInt(btn.dataset.companionIndex);
        unequipRelicFromCompanion(companionIndex);
      });
    });
  }
}

// è£å‚™åœ£ç‰©çµ¦åŒä¼´
function equipRelicToCompanion(companionIndex, relicId) {
  // æˆ°é¬¥ä¸­ä¸èƒ½è£å‚™åœ£ç‰©
  if (state.ui.battle) {
    pushLog('æˆ°é¬¥ä¸­ç„¡æ³•è£å‚™åœ£ç‰©ï¼');
    return;
  }
  
  const companion = state.companions[companionIndex];
  if (!companion) {
    pushLog('ç„¡æ•ˆçš„åŒä¼´ç´¢å¼•ã€‚');
    return;
  }
  
  const relic = state.relics.find(r => r.id === relicId);
  if (!relic) {
    pushLog('æ‰¾ä¸åˆ°æŒ‡å®šçš„åœ£ç‰©ã€‚');
    return;
  }
  
  // æª¢æŸ¥æ˜¯å¦è¢«å…¶ä»–åŒä¼´è£å‚™ï¼ˆå¦‚æœè¢«è£å‚™ï¼Œå‰‡æ›¿æ›ï¼‰
  const otherCompanionIndex = state.companions.findIndex((c, idx) => idx !== companionIndex && c.equippedRelic === relicId);
  if (otherCompanionIndex >= 0) {
    const otherCompanion = state.companions[otherCompanionIndex];
    otherCompanion.equippedRelic = null;
    pushLog(`${otherCompanion.name}çš„åœ£ç‰©ã€Œ${relic.name}ã€å·²è¢«å¸ä¸‹ã€‚`);
  }
  
  // å¸ä¸‹ç•¶å‰è£å‚™çš„åœ£ç‰©ï¼ˆå¦‚æœæœ‰ï¼‰
  const oldRelicId = companion.equippedRelic;
  if (oldRelicId) {
    const oldRelic = state.relics.find(r => r.id === oldRelicId);
    if (oldRelic) {
      pushLog(`${companion.name}å¸ä¸‹äº†åœ£ç‰©ã€Œ${oldRelic.name}ã€ã€‚`);
    }
  }
  
  // è£å‚™æ–°åœ£ç‰©
  companion.equippedRelic = relicId;
  const attrName = ATTRIBUTES.find(a => a.id === relic.attributeType)?.name || relic.attributeType;
  pushLog(`${companion.name}è£å‚™äº†åœ£ç‰©ã€Œ${relic.name}ã€ï¼ˆ${attrName} +${relic.attributeBonus}ï¼‰ã€‚`);
  if (relic.passiveSkill) {
    pushLog(`â†’ ç²å¾—è¢«å‹•æŠ€èƒ½ï¼š${relic.passiveSkill.name}`);
  }
  
  // å¼ºåˆ¶åˆ·æ–°è£…å¤‡é¢æ¿å’Œæ‰€æœ‰UI
  renderEquipmentPanel();
  renderAll();
}

// å¸ä¸‹åŒä¼´çš„åœ£ç‰©
function unequipRelicFromCompanion(companionIndex) {
  // æˆ°é¬¥ä¸­ä¸èƒ½å¸ä¸‹åœ£ç‰©
  if (state.ui.battle) {
    pushLog('æˆ°é¬¥ä¸­ç„¡æ³•å¸ä¸‹åœ£ç‰©ï¼');
    return;
  }
  
  const companion = state.companions[companionIndex];
  if (!companion) {
    pushLog('ç„¡æ•ˆçš„åŒä¼´ç´¢å¼•ã€‚');
    return;
  }
  
  if (!companion.equippedRelic) {
    pushLog(`${companion.name}æ²’æœ‰è£å‚™åœ£ç‰©ã€‚`);
    return;
  }
  
  const relic = state.relics.find(r => r.id === companion.equippedRelic);
  if (relic) {
    pushLog(`${companion.name}å¸ä¸‹äº†åœ£ç‰©ã€Œ${relic.name}ã€ã€‚`);
  }
  
  companion.equippedRelic = null;
  
  // å¼ºåˆ¶åˆ·æ–°è£…å¤‡é¢æ¿å’Œæ‰€æœ‰UI
  renderEquipmentPanel();
  renderAll();
}

function renderNodes() {
  const nodes = state.world.nodes;
  const hero = state.hero;
  const mapPanel = document.getElementById('map-panel');
  
  if (!hero || state.ui.startMenu) {
    if (dom.routePath) dom.routePath.innerHTML = '<p>è«‹å…ˆé–‹å§‹å†’éšªã€‚</p>';
    if (dom.nodeOptions) dom.nodeOptions.innerHTML = '';
    if (dom.currentNodeIndex) dom.currentNodeIndex.textContent = 'ç¯€é» 0 / 15';
    if (mapPanel) mapPanel.classList.remove('hidden');
    return;
  }
  
  const currentIndex = state.world.currentNodeIndex;
  const disable = hero.stats.hp <= 0 || Boolean(state.ui.levelUp) || Boolean(state.ui.battle);
  
  // æˆ°é¬¥æ™‚éš±è—åœ°åœ–é¢æ¿
  if (mapPanel) {
    if (state.ui.battle) {
      mapPanel.classList.add('hidden');
    } else {
      mapPanel.classList.remove('hidden');
    }
  }
  
  // æ¸²æŸ“è·¯ç·šè·¯å¾‘
  if (dom.routePath) {
    dom.routePath.innerHTML = nodes
      .map((node, index) => {
        const isCurrent = index === currentIndex;
        const isPast = index < currentIndex;
        const color = FLOW_PALETTE[node.flowHint] || '#fff';
        return `
        <div class="route-node ${isCurrent ? 'current' : ''} ${isPast ? 'completed' : ''}" 
             data-node-index="${index}">
          <div class="node-icon" style="border-color:${color}">
            ${isPast ? 'âœ“' : index + 1}
          </div>
          <div class="node-label">${node.label}</div>
        </div>
      `;
      })
      .join('');
  }
  
  // æ›´æ–°ç•¶å‰ç¯€é»ç´¢å¼•é¡¯ç¤º
  if (dom.currentNodeIndex) {
    dom.currentNodeIndex.textContent = `ç¯€é» ${currentIndex + 1} / ${nodes.length}`;
  }
  
  // å¦‚æœæ²’æœ‰æˆ°é¬¥æˆ–å‡ç´šï¼Œé¡¯ç¤ºç•¶å‰ç¯€é»çš„é¸é …
  if (!disable && dom.nodeOptions && !state.ui.battle) {
    showNodeOptions(currentIndex);
  } else if (dom.nodeOptions) {
    dom.nodeOptions.innerHTML = '';
  }
}

function showNodeOptions(nodeIndex) {
  const nodes = state.world.nodes;
  const node = nodes[nodeIndex];
  if (!node || !dom.nodeOptions) return;
  
  const options = node.options || [];
  if (options.length === 0) {
    dom.nodeOptions.innerHTML = '<p>æ­¤ç¯€é»æ²’æœ‰é¸é …ã€‚</p>';
    return;
  }
  
  dom.nodeOptions.innerHTML = `
    <h3>é¸æ“‡è·¯ç·šï¼š${node.label}</h3>
    <div class="options-grid">
      ${options.map((option, optIndex) => {
        const color = FLOW_PALETTE[option.flowHint] || '#fff';
        return `
          <button class="node-option-btn" 
                  data-node-index="${nodeIndex}" 
                  data-option-index="${optIndex}">
            <span class="option-title">${option.label}</span>
            <span class="option-desc">${option.description}</span>
            <span class="option-hint" style="color:${color}">${option.hint || ''}</span>
          </button>
        `;
      }).join('')}
    </div>
  `;
}

function selectNodeOption(nodeIndex, optionIndex) {
  const nodes = state.world.nodes;
  const node = nodes[nodeIndex];
  if (!node || !node.options || !node.options[optionIndex]) return;
  
  const option = node.options[optionIndex];
  const hero = state.hero;
  if (!hero || hero.stats.hp <= 0) return;
  
  // æ ¹æ“šé¸é …é¡å‹è™•ç†
  if (option.type === 'battle' || option.type === 'elite' || option.type === 'boss') {
    startBattle(option, option.type === 'elite' ? 1.6 : option.type === 'boss' ? 2.5 : 1);
  } else if (option.type === 'event') {
    handleEvent(option);
    // äº‹ä»¶ä¸æœƒè‡ªå‹•å‰é€²ï¼Œéœ€è¦ç©å®¶ç¢ºèªå¾Œæ‰é€²å…¥ä¸‹ä¸€å€‹ç¯€é»
  } else if (option.type === 'rest') {
    handleRest(option);
    advanceToNextNode();
  } else if (option.type === 'town') {
    handleTown(option);
    // å•†åº—ä¸æœƒè‡ªå‹•å‰é€²ï¼Œéœ€è¦ç©å®¶æ‰‹å‹•é—œé–‰
  }
  
  renderAll();
}

function advanceToNextNode() {
  state.world.currentNodeIndex += 1;
  if (state.world.currentNodeIndex >= state.world.nodes.length) {
    // å®Œæˆç•¶å‰éšæ®µï¼Œé€²å…¥ä¸‹ä¸€éšæ®µ
    const TOTAL_STAGES = 6;
    if (state.world.stage < TOTAL_STAGES) {
      // é€²å…¥ä¸‹ä¸€éšæ®µ
      state.world.stage += 1;
      state.world.currentNodeIndex = 0;
      state.world.nodes = generateRoute(state.world.stage);
      // renderBackground æœƒæ ¹æ“š stage è‡ªå‹•è¨­ç½®æ­£ç¢ºçš„ currentArea
      renderBackground();
      
      // è£œæ»¿æ‰€æœ‰äººçš„HP/MP
      if (state.hero && state.hero.stats) {
        state.hero.stats.hp = state.hero.stats.maxHp;
        state.hero.stats.mp = state.hero.stats.maxMp;
      }
      if (state.companions && state.companions.length > 0) {
        state.companions.forEach(companion => {
          if (companion && companion.stats) {
            companion.stats.hp = companion.stats.maxHp;
            companion.stats.mp = companion.stats.maxMp;
          }
        });
      }
      
      const prevAreaName = AREA_CONFIG[getAreaKeyByStage(state.world.stage - 1)]?.name || `ç¬¬${state.world.stage - 1}éšæ®µ`;
      const currentAreaName = AREA_CONFIG[state.world.currentArea]?.name || `ç¬¬${state.world.stage}éšæ®µ`;
      pushLog(`æ­å–œï¼ä½ å®Œæˆäº†${prevAreaName}ï¼Œé€²å…¥äº†${currentAreaName}ï¼`);
      pushLog('æ‰€æœ‰äººçš„HPå’ŒMPéƒ½å·²è£œæ»¿ï¼');
      renderBackground();
      
      // é¡¯ç¤ºæ–°ç« ç¯€çš„æ•…äº‹
      showStageStory(state.world.stage);
      
      // ä¿å­˜éšæ®µå‚™ä»½ï¼ˆé€²å…¥æ–°éšæ®µçš„ç¬¬ä¸€å€‹ç¯€é»æ™‚ï¼‰
      saveStageBackup();
    } else {
      // å®Œæˆæ‰€æœ‰éšæ®µï¼ŒéŠæˆ²çµæŸ
      pushLog('æ­å–œï¼ä½ æ“Šæ•—äº†æ‰€æœ‰é­”ç‹ï¼Œå®Œæˆäº†å†’éšªï¼');
      handleGameOver();
    }
  } else {
    // å¦‚æœé€²å…¥çš„æ˜¯ç•¶å‰éšæ®µçš„ç¬¬ä¸€å€‹ç¯€é»ï¼Œä¹Ÿä¿å­˜å‚™ä»½
    if (state.world.currentNodeIndex === 0) {
      saveStageBackup();
    }
  }
}

function renderLog() {
  if (!dom.logList || !dom.logPanelHeader) return;
  
  const isExpanded = state.ui.logExpanded || false;
  const logEntries = state.log.slice(-12);
  
  // æ›´æ–°æ¨™é¡Œå’Œåœ–æ¨™
  dom.logPanelHeader.textContent = `å†’éšªæ—¥èªŒ ${isExpanded ? 'â–¼' : 'â–¶'}`;
  
  // æ›´æ–°åˆ—è¡¨å…§å®¹
  dom.logList.innerHTML = logEntries
    .map((entry) => `<li>${entry}</li>`)
    .join('');
  
  // æ ¹æ“šå±•é–‹ç‹€æ…‹è¨­ç½®æ¨£å¼
  if (isExpanded) {
    dom.logList.classList.remove('log-list-collapsed');
  } else {
    dom.logList.classList.add('log-list-collapsed');
  }
}

// åˆ‡æ›å†’éšªæ—¥èªŒå±•é–‹/æ”¶èµ·
function toggleLogPanel() {
  state.ui.logExpanded = !state.ui.logExpanded;
  renderLog();
}

// å°‡å‡½æ•¸æš´éœ²åˆ°å…¨å±€
window.toggleLogPanel = toggleLogPanel;

function renderBattlePanel() {
  const battle = state.ui.battle;
  if (!battle) {
    dom.battlePanel.classList.add('hidden');
    if (dom.battleHeroStatus) dom.battleHeroStatus.innerHTML = '';
    if (dom.enemyList) dom.enemyList.innerHTML = '';
    if (dom.commandButtons) dom.commandButtons.innerHTML = '';
    if (dom.commandOptions) dom.commandOptions.innerHTML = '';
    return;
  }
  dom.battlePanel.classList.remove('hidden');
  const hero = state.hero;
  if (!hero) {
    if (dom.battleHeroStatus) dom.battleHeroStatus.innerHTML = '<p>å°šæœªé–‹å§‹å†’éšª</p>';
    if (dom.enemyList) dom.enemyList.innerHTML = '';
    return;
  }
  
  // æ›´æ–°æˆ‘æ–¹ç‹€æ…‹ï¼ˆä¸Šæ–¹ï¼‰
  if (dom.battleHeroStatus) {
    dom.battleHeroStatus.innerHTML = `
      <div class="hero-stat-line">
        <span>${formatHpDisplay(hero)}</span>
        <span>MPï¼š${hero.stats.mp}/${hero.stats.maxMp}</span>
      </div>
      <div class="hero-stat-line">
        <span>Lv ${hero.stats.level}</span>
      </div>
    `;
  }
  
  // æ›´æ–°æ•µäººåˆ—è¡¨ï¼ˆå³å´ï¼‰
  if (dom.enemyList) {
    const enemyGroups = groupEnemiesByName(battle.enemies);
    dom.enemyList.innerHTML = enemyGroups.map((group) => {
      const count = group.count;
      const enemy = group.enemy;
      // æ‰¾åˆ°é€™å€‹åç¨±çš„ç¬¬ä¸€å€‹æ´»è‘—çš„æ•µäººç´¢å¼•
      const firstAliveIndex = battle.enemies.findIndex(e => e.name === enemy.name && e.hp > 0);
      const aliveCount = battle.enemies.filter(e => e.name === enemy.name && e.hp > 0).length;
      const isSelected = battle.selectedEnemyIndex !== null && 
        battle.enemies[battle.selectedEnemyIndex]?.name === enemy.name;
      const isAlive = aliveCount > 0;
      return `
        <div class="enemy-entry ${isSelected ? 'selected' : ''} ${!isAlive ? 'defeated' : ''}" 
             data-enemy-name="${enemy.name}"
             data-enemy-index="${firstAliveIndex >= 0 ? firstAliveIndex : ''}"
             ${!isAlive ? 'style="opacity: 0.4;"' : ''}>
          <span class="enemy-name">${enemy.name}</span>
          ${count > 1 ? `<span class="enemy-count">${aliveCount > 0 ? aliveCount : count}éš»</span>` : ''}
          ${!isAlive ? '<span class="enemy-status">(æ“Šå€’)</span>' : ''}
        </div>
      `;
    }).join('');
  }
  
  // æ›´æ–°æŒ‡ä»¤æŒ‰éˆ•ï¼ˆä¸‹æ–¹ï¼‰
  if (dom.commandButtons) {
    dom.commandButtons.innerHTML = COMMANDS.map(
      (cmd) => `
        <button data-command="${cmd.id}" ${battle.turn !== 'hero' ? 'disabled' : ''}>
          ${cmd.label}
        </button>
      `,
    ).join('');
  }
  
  // æ›´æ–°æŒ‡ä»¤é¸é …
  if (dom.commandOptions) {
    dom.commandOptions.innerHTML = renderCommandOptions(battle);
  }
}

function groupEnemiesByName(enemies) {
  const groups = [];
  const nameMap = new Map();
  
  enemies.forEach((enemy) => {
    if (!nameMap.has(enemy.name)) {
      nameMap.set(enemy.name, { enemy, count: 0, index: groups.length });
      groups.push({ enemy, count: 0 });
    }
    groups[nameMap.get(enemy.name).index].count += 1;
  });
  
  return groups;
}

function getFirstAliveEnemyIndex(enemies, enemyName) {
  return enemies.findIndex(e => e.name === enemyName && e.hp > 0);
}

function renderCommandOptions(battle) {
  // å¦‚æœæ­£åœ¨åŸ·è¡Œè¡Œå‹•ï¼Œé¡¯ç¤ºã€Œè¡Œå‹•ä¸­ã€è€Œä¸æ˜¯æŒ‡ä»¤é¸é …
  if (battle.isExecutingActions) {
    return '<p style="text-align: center; color: #9fc5e8; font-weight: bold;">è¡Œå‹•ä¸­...</p>';
  }
  
  if (battle.menu === 'skills') {
    const allSkills = getActiveSkills();
    if (allSkills.length === 0) {
      return `<p>å°šæœªå­¸æœƒå¯ç”¨æŠ€èƒ½ã€‚</p><button data-command="back">è¿”å›</button>`;
    }
    const hero = state.hero;
    // éæ¿¾æ‰MPä¸è¶³çš„æŠ€èƒ½
    const skills = allSkills.filter(skill => {
      const mpCost = skill.mpCost || 0;
      return hero.stats.mp >= mpCost;
    });
    if (skills.length === 0) {
      return `<p>æ²’æœ‰å¯ç”¨çš„æŠ€èƒ½ï¼ˆMPä¸è¶³ï¼‰ã€‚</p><button data-command="back">è¿”å›</button>`;
    }
    const options = skills
      .map(
        (skill) => {
          const mpCost = skill.mpCost || 0;
          return `
          <button data-skill="${skill.id}">
            <strong>${skill.name}</strong>
            <small>${skill.description}</small>
            ${mpCost > 0 ? `<small style="color:#9fc5e8">MP: ${mpCost}</small>` : ''}
          </button>
        `;
        },
      )
      .join('');
    return `${options}<button data-command="back">è¿”å›</button>`;
  }
  if (battle.menu === 'items') {
    const items = state.hero.items.filter((item) => item.qty > 0);
    if (items.length === 0) {
      return `<p>æ²’æœ‰å¯ç”¨é“å…·ã€‚</p><button data-command="back">è¿”å›</button>`;
    }
    const options = items
      .map((entry) => {
        const item = ITEM_LOOKUP.get(entry.id);
        if (!item) return '';
        return `
          <button data-item="${entry.id}">
            <strong>${item.name} Ã—${entry.qty}</strong>
            <small>${item.description}</small>
          </button>
        `;
      })
      .join('');
    return `${options}<button data-command="back">è¿”å›</button>`;
  }
  if (battle.menu === 'select-enemy') {
    return '<p>é»æ“Šå³å´æ•µäººåˆ—è¡¨é¸æ“‡ç›®æ¨™ï¼Œæˆ–é»æ“Šã€Œè¿”å›ã€å–æ¶ˆã€‚</p><button data-command="back">è¿”å›</button>';
  }
  if (battle.menu === 'select-aoe-heal') {
    const skill = battle.pendingSkill ? SKILL_LOOKUP.get(battle.pendingSkill) : null;
    const skillName = skill ? skill.name : 'æŠ€èƒ½';
    return `
      <p>é¸æ“‡ã€Œ${skillName}ã€çš„ç›®æ¨™ï¼š</p>
      <button data-aoe-confirm="allies">æˆ‘æ–¹å…¨é«”</button>
      <button data-command="back">å–æ¶ˆ</button>
    `;
  }
  if (battle.menu === 'select-aoe-support') {
    const skill = battle.pendingSkill ? SKILL_LOOKUP.get(battle.pendingSkill) : null;
    const skillName = skill ? skill.name : 'æŠ€èƒ½';
    return `
      <p>é¸æ“‡ã€Œ${skillName}ã€çš„ç›®æ¨™ï¼š</p>
      <button data-aoe-confirm="allies">æˆ‘æ–¹å…¨é«”</button>
      <button data-command="back">å–æ¶ˆ</button>
    `;
  }
  if (battle.menu === 'select-aoe-attack') {
    const skill = battle.pendingSkill ? SKILL_LOOKUP.get(battle.pendingSkill) : null;
    const skillName = skill ? skill.name : 'æŠ€èƒ½';
    return `
      <p>é¸æ“‡ã€Œ${skillName}ã€çš„ç›®æ¨™ï¼š</p>
      <button data-aoe-confirm="enemies">æ•µæ–¹å…¨é«”</button>
      <button data-command="back">å–æ¶ˆ</button>
    `;
  }
  if (battle.menu === 'select-target') {
    const pendingSkill = battle.pendingSkill ? SKILL_LOOKUP.get(battle.pendingSkill) : null;
    const isSupportSkill = pendingSkill && pendingSkill.kind === 'support';
    if (isSupportSkill) {
      return '<p>é»æ“Šå³å´åˆ—è¡¨é¸æ“‡ç›®æ¨™ï¼ˆè‡ªå·±æˆ–åŒä¼´ï¼‰ï¼Œæˆ–é»æ“Šã€Œè¿”å›ã€å–æ¶ˆã€‚</p><button data-command="back">è¿”å›</button>';
    }
    return '<p>é»æ“Šå³å´åˆ—è¡¨é¸æ“‡ç›®æ¨™ï¼ˆè‡ªå·±æˆ–æ•µäººï¼‰ï¼Œæˆ–é»æ“Šã€Œè¿”å›ã€å–æ¶ˆã€‚</p><button data-command="back">è¿”å›</button>';
  }
  return '<p>é¸æ“‡æŒ‡ä»¤ä»¥è¡Œå‹•ã€‚</p>';
}

function renderLevelModal() {
  // å¦‚æœè¨­å®šå°è©±æ¡†é–‹å•Ÿï¼Œå„ªå…ˆé¡¯ç¤º
  if (state.ui.settings) {
    dom.modalLayer.classList.remove('hidden');
    dom.levelModal.innerHTML = renderSettingsDialog();
    return;
  }
  
  // å¦‚æœæœ‰ç« ç¯€æ•…äº‹ï¼Œå„ªå…ˆé¡¯ç¤ºï¼ˆæœ€é«˜å„ªå…ˆç´šï¼‰
  if (state.ui.stageStory) {
    dom.modalLayer.classList.remove('hidden');
    dom.levelModal.innerHTML = renderStageStoryDialog(state.ui.stageStory);
    return;
  }
  
  // å¦‚æœæ­£åœ¨é€²è¡Œæ¸¬è©¦æ¨¡å¼è·æ¥­é€²éšé¸æ“‡ï¼Œå„ªå…ˆé¡¯ç¤ºï¼ˆé¿å…è¢«åŒä¼´é¸æ“‡ç•«é¢è¦†è“‹ï¼‰
  if (state.ui.testModeAdvancement) {
    dom.modalLayer.classList.remove('hidden');
    dom.levelModal.innerHTML = renderTestModeAdvancementDialog(state.ui.testModeAdvancement);
    return;
  }
  
  // å¦‚æœæ­£åœ¨é¸æ“‡åœ£ç‰©ï¼Œé¡¯ç¤ºåœ£ç‰©é¸æ“‡è¦–çª—
  if (state.ui.relicSelection) {
    dom.modalLayer.classList.remove('hidden');
    dom.levelModal.innerHTML = renderRelicSelection();
    return;
  }

  // å¦‚æœæ­£åœ¨é¸æ“‡åŒä¼´ï¼Œé¡¯ç¤ºåŒä¼´é¸æ“‡è¦–çª—
  if (state.ui.companionSelection) {
    dom.modalLayer.classList.remove('hidden');
    dom.levelModal.innerHTML = renderCompanionSelection();
    return;
  }
  
  // å¦‚æœæ­£åœ¨é¸æ“‡é¡å‹ï¼Œé¡¯ç¤ºé¡å‹é¸æ“‡è¦–çª—
  if (state.ui.heroTypeSelection) {
    dom.modalLayer.classList.remove('hidden');
    dom.levelModal.innerHTML = renderHeroTypeSelection();
    return;
  }
  
  // å¦‚æœæœ‰å‡ç´šç‹€æ…‹ï¼Œé¡¯ç¤ºå‡ç´šè¦–çª—
  const modalState = state.ui.levelUp;
  if (modalState) {
    dom.modalLayer.classList.remove('hidden');
    if (modalState.step === 'attribute-selection') {
      dom.levelModal.innerHTML = renderAttributeSelectionStep(modalState);
    } else if (modalState.step === 'stats') {
      dom.levelModal.innerHTML = renderStatsStep(modalState);
    } else if (modalState.step === 'skills') {
      dom.levelModal.innerHTML = renderSkillStep(modalState);
    } else if (modalState.step === 'companion-upgrade') {
      dom.levelModal.innerHTML = renderCompanionUpgradeStep(modalState);
    }
    return;
  }
  
  // å¦‚æœå•†åº—é–‹å•Ÿï¼Œé¡¯ç¤ºå•†åº—
  if (state.ui.shop && state.ui.shop.open) {
    renderShop();
    return;
  }
  
  // å¦‚æœæœ‰äº‹ä»¶çµæœï¼Œé¡¯ç¤ºäº‹ä»¶å°è©±æ¡†
  if (state.ui.eventResult) {
    dom.modalLayer.classList.remove('hidden');
    dom.levelModal.innerHTML = renderEventDialog(state.ui.eventResult);
    return;
  }
  
  // å¦‚æœæœ‰æˆ°é¬¥çµæœï¼Œé¡¯ç¤ºæ‰è½ç‰©å“å°è©±æ¡†
  if (state.ui.battleResult) {
    dom.modalLayer.classList.remove('hidden');
    dom.levelModal.innerHTML = renderBattleResultDialog(state.ui.battleResult);
    return;
  }
  
  // å¦‚æœé“å…·æ¬„å·²æ»¿éœ€è¦é¸æ“‡ä¸Ÿæ£„
  if (state.ui.itemChoice) {
    dom.modalLayer.classList.remove('hidden');
    dom.levelModal.innerHTML = renderItemChoiceDialog(state.ui.itemChoice);
    return;
  }
  
  // å¦‚æœæ­£åœ¨é¸æ“‡éæˆ°é¬¥é“å…·ä½¿ç”¨ç›®æ¨™
  if (state.ui.fieldItemSelection) {
    dom.modalLayer.classList.remove('hidden');
    dom.levelModal.innerHTML = renderFieldItemTargetSelection(state.ui.fieldItemSelection);
    return;
  }
  
  // å¦‚æœæ­£åœ¨é¸æ“‡éæˆ°é¬¥æŠ€èƒ½ä½¿ç”¨ç›®æ¨™
  if (state.ui.fieldSkillSelection) {
    dom.modalLayer.classList.remove('hidden');
    dom.levelModal.innerHTML = renderFieldSkillTargetSelection(state.ui.fieldSkillSelection);
    return;
  }
  
  // å¦‚æœæ­£åœ¨é€²è¡ŒæŠ€èƒ½è¨“ç·´å¸«äº‹ä»¶
  if (state.ui.skillTrainer) {
    dom.modalLayer.classList.remove('hidden');
    dom.levelModal.innerHTML = renderSkillTrainerDialog(state.ui.skillTrainer);
    return;
  }
  
  // å¦‚æœæ­£åœ¨é€²è¡Œå¿ƒç†æ²»ç™‚æ‰€äº‹ä»¶
  if (state.ui.personalityTherapy) {
    dom.modalLayer.classList.remove('hidden');
    dom.levelModal.innerHTML = renderPersonalityTherapyDialog(state.ui.personalityTherapy);
    return;
  }
  
  // å¦‚æœæ­£åœ¨é€²è¡Œå‹‡è€…ä¹‹è¡€äº‹ä»¶
  if (state.ui.heroBlood) {
    dom.modalLayer.classList.remove('hidden');
    dom.levelModal.innerHTML = renderHeroBloodDialog(state.ui.heroBlood);
    return;
  }
  
  // å¦‚æœæ­£åœ¨é€²è¡Œç¾…å¾·è£å‚™äº‹ä»¶
  if (state.ui.rodEquipment) {
    dom.modalLayer.classList.remove('hidden');
    dom.levelModal.innerHTML = renderRodEquipmentDialog(state.ui.rodEquipment);
    return;
  }
  
  // å¦‚æœæ­£åœ¨é¡¯ç¤ºæŠ€èƒ½å­¸ç¿’ç¢ºèªè¦–çª—ï¼ˆåœ¨è·æ¥­é€²éšä¹‹å¾Œï¼‰
  if (state.ui.skillLearnDialog) {
    dom.modalLayer.classList.remove('hidden');
    dom.levelModal.innerHTML = renderSkillLearnDialog(state.ui.skillLearnDialog);
    return;
  }
  
  // å¦‚æœæ­£åœ¨é€²è¡Œè·æ¥­é€²éšäº‹ä»¶
  if (state.ui.classAdvancement) {
    dom.modalLayer.classList.remove('hidden');
    dom.levelModal.innerHTML = renderClassAdvancementDialog(state.ui.classAdvancement);
    return;
  }
  
  // å¦‚æœæ­£åœ¨é€²è¡Œæ¸¬è©¦æ¨¡å¼è·æ¥­é€²éšé¸æ“‡
  if (state.ui.testModeAdvancement) {
    dom.modalLayer.classList.remove('hidden');
    dom.levelModal.innerHTML = renderTestModeAdvancementDialog(state.ui.testModeAdvancement);
    return;
  }
  
  // å¦‚æœæœ‰æ­»äº¡çµ±è¨ˆä¿¡æ¯ï¼Œé¡¯ç¤ºæ­»äº¡çµ±è¨ˆç•Œé¢
  if (state.ui.deathInfo || state.ui.gameStats) {
    dom.modalLayer.classList.remove('hidden');
    // ä½¿ç”¨ handleGameOver ä¾†æ¸²æŸ“æ­»äº¡çµ±è¨ˆç•Œé¢
    const deathInfo = state.ui.deathInfo || {
      cause: 'unknown',
      attacker: 'æœªçŸ¥',
      damage: 0,
      skill: null,
      isCrit: false,
    };
    
    const gameStats = state.ui.gameStats || {
      level: state.hero ? state.hero.stats.level : 1,
      stage: state.world ? state.world.stage : 1,
      currentNodeIndex: state.world ? state.world.currentNodeIndex : 0,
      gold: state.hero ? state.hero.stats.gold : 0,
      companionsCount: (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0).length,
      skillsCount: state.hero && state.hero.skills ? state.hero.skills.length : 0,
      equipmentCount: state.hero && state.hero.equipmentInventory ? state.hero.equipmentInventory.length : 0,
    };
    
    // æ§‹å»ºæ­»äº¡åŸå› æè¿°
    let deathCause = '';
    if (deathInfo.cause === 'skill') {
      deathCause = `${deathInfo.attacker} ä½¿ç”¨ã€Œ${deathInfo.skill}ã€${deathInfo.isCrit ? 'ï¼ˆæœƒå¿ƒä¸€æ“Šï¼‰' : ''}é€ æˆ ${deathInfo.damage} å‚·å®³`;
    } else if (deathInfo.cause === 'attack') {
      deathCause = `${deathInfo.attacker} çš„æ™®é€šæ”»æ“Šé€ æˆ ${deathInfo.damage} å‚·å®³`;
    } else {
      deathCause = `è¢« ${deathInfo.attacker} æ“Šæ•—`;
    }
    
    dom.levelModal.innerHTML = `
      <h2>å†’éšªçµæŸ</h2>
      <div style="margin: 20px 0;">
        <h3 style="color: #d32f2f; margin-bottom: 10px;">æ­»äº¡åŸå› </h3>
        <p style="font-size: 16px; margin: 10px 0;">${deathCause}</p>
      </div>
      <div style="margin: 20px 0;">
        <h3 style="margin-bottom: 10px;">éŠæˆ²æ­·ç¨‹çµ±è¨ˆ</h3>
        <div style="line-height: 1.8;">
          <p><strong>ç­‰ç´šï¼š</strong> ${gameStats.level}</p>
          <p><strong>å ´æ™¯ï¼š</strong> ${AREA_CONFIG[getAreaKeyByStage(gameStats.stage)]?.name || `ç¬¬${gameStats.stage}éšæ®µ`}</p>
          <p><strong>ç¯€é»ï¼š</strong> ç¬¬ ${gameStats.currentNodeIndex + 1} å€‹ç¯€é»</p>
          <p><strong>é‡‘å¹£ï¼š</strong> ${gameStats.gold}</p>
          <p><strong>åŒä¼´æ•¸é‡ï¼š</strong> ${gameStats.companionsCount}</p>
          <p><strong>æŠ€èƒ½æ•¸é‡ï¼š</strong> ${gameStats.skillsCount}</p>
          <p><strong>è£å‚™æ•¸é‡ï¼š</strong> ${gameStats.equipmentCount}</p>
        </div>
      </div>
      <div style="margin-top: 30px; display: flex; gap: 12px; justify-content: center;">
        <button class="primary-btn" data-action="restart-game" style="padding: 10px 20px; font-size: 14px;">
          é‡æ–°é–‹å§‹
        </button>
        ${loadStageBackup() ? `
        <button class="primary-btn" data-action="restart-from-stage-start" style="padding: 10px 20px; font-size: 14px; background: rgba(159, 197, 232, 0.8);">
          å¾éšæ®µé–‹å§‹
        </button>
        ` : ''}
      </div>
    `;
    return;
  }

  // å¦å‰‡éš±è—æ¨¡æ…‹è¦–çª—
  dom.modalLayer.classList.add('hidden');
  dom.levelModal.innerHTML = '';
}

function renderHeroTypeSelection() {
  // å®šç¾©æ¯å€‹é¡å‹çš„åœ–æ¨™
  const typeIcons = {
    attacker: 'âš”ï¸',
    mage: 'ğŸ”®',
    healer: 'ğŸ’š',
    defender: 'ğŸ›¡ï¸',
    agile: 'âš¡',
  };
  
  const typeCards = Object.values(HERO_TYPES).map((type) => {
    // æ‰¾å‡ºå‡ç´šæ™‚æˆé•·è¼ƒé«˜çš„å±¬æ€§ï¼ˆå€¼ >= 2.0 çš„å±¬æ€§ï¼‰
    const highGrowthAttrs = Object.entries(type.levelUpBonus)
      .filter(([key, val]) => val >= 2.0)
      .map(([key, val]) => ATTRIBUTES.find(a => a.id === key)?.name || key)
      .sort();
    
    // ç”Ÿæˆæˆé•·æ–¹å‘æè¿°
    let growthDirection = '';
    if (highGrowthAttrs.length > 0) {
      growthDirection = highGrowthAttrs.join('ã€') + 'è¼ƒé«˜';
    } else {
      // å¦‚æœæ²’æœ‰ç‰¹åˆ¥é«˜çš„ï¼Œæ‰¾å‡ºæœ€é«˜çš„å¹¾å€‹
      const sortedAttrs = Object.entries(type.levelUpBonus)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 2)
        .map(([key, val]) => ATTRIBUTES.find(a => a.id === key)?.name || key);
      growthDirection = sortedAttrs.join('ã€') + 'è¼ƒé«˜';
    }
    
    const icon = typeIcons[type.id] || 'âš”ï¸';
    
    return `
      <button class="hero-type-card" data-action="select-hero-type" data-hero-type="${type.id}">
        <div class="type-icon">${icon}</div>
        <h3>${type.name}</h3>
        <p class="type-description">${type.description}</p>
        <div class="type-bonus">
          <p><strong>æˆé•·æ–¹å‘ï¼š</strong>${growthDirection}</p>
        </div>
      </button>
    `;
  }).join('');

  return `
    <h2>é¸æ“‡å‹‡è€…é¡å‹</h2>
    <p>é¸æ“‡ä½ çš„å‹‡è€…é¡å‹ï¼Œå°‡å½±éŸ¿åˆå§‹èƒ½åŠ›èˆ‡å‡ç´šæˆé•·ã€‚</p>
    <p style="color: #9fc5e8; margin: 10px 0; padding: 8px; background: rgba(159, 197, 232, 0.1); border-radius: 4px;">
      <strong>âœ¨ ç‰¹æ®Šèªªæ˜ï¼š</strong>å»ºç«‹è§’è‰²æ™‚æœƒéš¨æ©Ÿç²å¾—ä¸€å€‹å°æ‡‰æµæ´¾çš„è¢«å‹•æŠ€èƒ½ï¼ˆä¸€éšï¼Œéœ€æ±‚ç­‰ç´š0ï¼‰ã€‚
    </p>
    <div class="hero-type-grid">${typeCards}</div>
  `;
}

function renderCompanionSelection() {
  // ç²å–å·²é¸æ“‡çš„åŒä¼´è·æ¥­é¡å‹
  const selectedHeroTypes = new Set();
  state.companions.forEach(companion => {
    if (companion.companionTypeId) {
      const companionType = COMPANION_TYPES[companion.companionTypeId];
      if (companionType) {
        selectedHeroTypes.add(companionType.heroType);
      }
    }
  });
  
  // è¨ˆç®—é‚„éœ€è¦é¸æ“‡å¤šå°‘å€‹åŒä¼´
  // ä½¿ç”¨ ?? è€Œä¸æ˜¯ ||ï¼Œè¿™æ · 0 ä¸ä¼šè¢«æ›¿æ¢
  const initialCount = (typeof GAME_CONFIG.initialCompanionCount !== 'undefined') 
    ? GAME_CONFIG.initialCompanionCount 
    : 1;
  const remainingCount = Math.max(0, initialCount - state.companions.length);
  const isNewCompanionAfterBoss = state.ui.companionSelection === 'boss-reward';
  
  
  const companionCards = Object.values(COMPANION_TYPES)
    .filter((companionType) => {
      // éæ¿¾æ‰é€²éšè·æ¥­ï¼ˆä¸èƒ½ç›´æ¥é¸æ“‡ï¼‰
      if (companionType.isAdvanced) return false;
      // éæ¿¾æ‰å·²é¸æ“‡çš„è·æ¥­é¡å‹
      return !selectedHeroTypes.has(companionType.heroType);
    })
    .map((companionType) => {
      // æ‰¾å‡ºå‡ç´šæ™‚æˆé•·è¼ƒé«˜çš„å±¬æ€§ï¼ˆå€¼ >= 2.0 çš„å±¬æ€§ï¼‰
      const highGrowthAttrs = companionType.levelUpBonus
        ? Object.entries(companionType.levelUpBonus)
            .filter(([key, val]) => val >= 2.0)
            .map(([key, val]) => ATTRIBUTES.find(a => a.id === key)?.name || key)
            .sort()
        : [];
      
      // ç”Ÿæˆæˆé•·æ–¹å‘æè¿°
      let growthDirection = '';
      if (highGrowthAttrs.length > 0) {
        growthDirection = highGrowthAttrs.join('ã€') + 'è¼ƒé«˜';
      } else if (companionType.levelUpBonus) {
        // å¦‚æœæ²’æœ‰ç‰¹åˆ¥é«˜çš„ï¼Œæ‰¾å‡ºæœ€é«˜çš„å¹¾å€‹
        const sortedAttrs = Object.entries(companionType.levelUpBonus)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 2)
          .map(([key, val]) => ATTRIBUTES.find(a => a.id === key)?.name || key);
        growthDirection = sortedAttrs.join('ã€') + 'è¼ƒé«˜';
      } else {
        growthDirection = 'å¹³è¡¡æˆé•·';
      }
      
      return `
        <button class="hero-type-card" data-action="select-companion" data-companion-type="${companionType.id}">
          <div class="type-icon">${companionType.icon}</div>
          <h3>${companionType.name}</h3>
          <p class="type-description">${companionType.description}</p>
          <div class="type-bonus">
            <p><strong>æˆé•·æ–¹å‘ï¼š</strong>${growthDirection}</p>
          </div>
        </button>
      `;
    }).join('');

  const maxCompanionCount = GAME_CONFIG.maxCompanionCount || 4;
  const currentCount = state.companions.length;
  const title = isNewCompanionAfterBoss ? 'é¸æ“‡æ–°åŒä¼´' : 'é¸æ“‡åŒä¼´';
  
  let description = '';
  if (isNewCompanionAfterBoss) {
    if (currentCount >= maxCompanionCount) {
      description = `éšŠä¼å·²é”åˆ°æœ€å¤§åŒä¼´æ•¸é‡ä¸Šé™ï¼ˆ${maxCompanionCount}å€‹ï¼‰ï¼Œç„¡æ³•å†é¸æ“‡æ–°åŒä¼´ã€‚`;
    } else {
      description = `æ“Šæ•—é­”ç‹å¾Œï¼Œä½ å¯ä»¥é¸æ“‡ä¸€ä½æ–°åŒä¼´åŠ å…¥éšŠä¼ï¼ˆä¸èƒ½é¸æ“‡èˆ‡å·²é¸æ“‡çš„åŒä¼´ç›¸åŒè·æ¥­ï¼Œå‹‡è€…ä¸åœ¨æ­¤é™åˆ¶å…§ï¼‰ã€‚ç•¶å‰éšŠä¼ï¼š${currentCount}/${maxCompanionCount}ã€‚`;
    }
  } else {
    // åˆå§‹é¸æ“‡éšæ®µ
    if (remainingCount > 0) {
      description = `è«‹é¸æ“‡ ${remainingCount} ä½åŒä¼´åŠ å…¥ä½ çš„å†’éšªï¼ˆä¸èƒ½é¸æ“‡èˆ‡å·²é¸æ“‡çš„åŒä¼´ç›¸åŒè·æ¥­ï¼Œå‹‡è€…ä¸åœ¨æ­¤é™åˆ¶å…§ï¼‰ã€‚ç•¶å‰å·²é¸æ“‡ï¼š${currentCount}/${initialCount}ï¼Œæœ€å¤§ä¸Šé™ï¼š${maxCompanionCount}ã€‚åŒä¼´çš„ç­‰ç´šæœƒè·Ÿéš¨ä½ å‡ç´šï¼Œæ¯ä¸‰ç´šè‡ªå‹•ç²å¾—ä¸€å€‹æŠ€èƒ½ã€‚`;
    } else {
      description = `è«‹é¸æ“‡ä¸€ä½åŒä¼´åŠ å…¥ä½ çš„å†’éšªï¼ˆä¸èƒ½é¸æ“‡èˆ‡å·²é¸æ“‡çš„åŒä¼´ç›¸åŒè·æ¥­ï¼Œå‹‡è€…ä¸åœ¨æ­¤é™åˆ¶å…§ï¼‰ã€‚ç•¶å‰å·²é¸æ“‡ï¼š${currentCount}/${initialCount}ï¼Œæœ€å¤§ä¸Šé™ï¼š${maxCompanionCount}ã€‚åŒä¼´çš„ç­‰ç´šæœƒè·Ÿéš¨ä½ å‡ç´šï¼Œæ¯ä¸‰ç´šè‡ªå‹•ç²å¾—ä¸€å€‹æŠ€èƒ½ã€‚`;
    }
  }

  // é¡¯ç¤ºå·²é¸æ“‡çš„åŒä¼´åˆ—è¡¨
  let selectedCompanionsList = '';
  if (state.companions.length > 0 && !isNewCompanionAfterBoss) {
    const selectedNames = state.companions.map(companion => {
      const type = COMPANION_TYPES[companion.companionTypeId];
      return type ? type.name : companion.name;
    }).join('ã€');
    selectedCompanionsList = `
      <div style="margin: 15px 0; padding: 10px; background: rgba(159, 197, 232, 0.2); border-radius: 8px; border: 1px solid rgba(159, 197, 232, 0.5);">
        <strong>å·²é¸æ“‡çš„åŒä¼´ï¼š</strong>${selectedNames}
      </div>
    `;
  }

  // å¦‚æœæ˜¯åˆå§‹é¸æ“‡ä¸”å·²é¸æ“‡äº†è‡³å°‘1å€‹åŒä¼´ï¼Œå…è¨±æå‰å®Œæˆï¼ˆé¸æ“‡å°‘æ–¼åˆå§‹æ•¸é‡ï¼‰
  let completeButton = '';
  if (!isNewCompanionAfterBoss && state.companions.length > 0 && remainingCount > 0) {
    completeButton = `
      <div style="margin-top: 20px; text-align: center; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.2);">
        <p style="margin-bottom: 10px; color: #9fc5e8;">æç¤ºï¼šä½ ä¹Ÿå¯ä»¥æå‰å®Œæˆé¸æ“‡ï¼Œä½†å°‡åªæœ‰ ${currentCount} ä½åŒä¼´ã€‚</p>
        <button class="dialog-option" data-action="complete-companion-selection" style="padding: 10px 20px; font-size: 16px; background: rgba(159, 197, 232, 0.3);">
          å®Œæˆé¸æ“‡ï¼ˆå·²é¸æ“‡ ${currentCount} ä½ï¼Œé‚„éœ€è¦ ${remainingCount} ä½ï¼‰
        </button>
      </div>
    `;
  }

  return `
    <h2>${title}</h2>
    <p>${description}</p>
    ${selectedCompanionsList}
    ${companionCards ? `<div class="hero-type-grid">${companionCards}</div>` : '<p>æ²’æœ‰å¯é¸æ“‡çš„åŒä¼´ï¼ˆæ‰€æœ‰è·æ¥­éƒ½å·²é¸æ“‡æˆ–å·²é”åˆ°ä¸Šé™ï¼‰ã€‚</p>'}
    ${completeButton}
  `;
}

// æ¸²æŸ“åœ£ç‰©é€‰æ‹©ç•Œé¢
function renderRelicSelection() {
  const relicSelection = state.ui.relicSelection;
  if (!relicSelection || !relicSelection.relics || relicSelection.relics.length === 0) {
    return '<h2>é¸æ“‡åœ£ç‰©</h2><p>æ²’æœ‰å¯é¸æ“‡çš„åœ£ç‰©ã€‚</p>';
  }
  
  const relics = relicSelection.relics;
  const stage = relicSelection.stage;
  
  const relicCards = relics.map((relic, index) => {
    const attrName = ATTRIBUTES.find(a => a.id === relic.attributeType)?.name || relic.attributeType;
    const flowName = FLOWS[relic.flow]?.label || relic.flow;
    const passiveDesc = relic.passiveSkill ? relic.passiveSkill.description : 'ç„¡è¢«å‹•æŠ€èƒ½';
    
    return `
      <button class="hero-type-card" data-action="select-relic" data-relic-index="${index}">
        <div class="type-icon">âœ¨</div>
        <h3>${relic.name}</h3>
        <p class="type-description">éšæ®µ ${stage} - ${flowName}</p>
        <div class="type-bonus">
          <p><strong>${attrName} +${relic.attributeBonus}</strong></p>
          <p>è¢«å‹•æŠ€èƒ½ï¼š${relic.passiveSkill ? relic.passiveSkill.name : 'ç„¡'}</p>
          <p style="font-size: 0.9em; color: #ccc;">${passiveDesc}</p>
        </div>
      </button>
    `;
  }).join('');
  
  return `
    <h2>é¸æ“‡åœ£ç‰©</h2>
    <p>æ“Šæ•—é­”ç‹å¾Œï¼Œä½ å¯ä»¥é¸æ“‡ä¸€å€‹åœ£ç‰©ã€‚åœ£ç‰©å¯ä»¥è£å‚™çµ¦åŒä¼´ï¼Œæä¾›å±¬æ€§åŠ æˆå’Œè¢«å‹•æŠ€èƒ½ã€‚</p>
    <div class="hero-type-grid">${relicCards}</div>
  `;
}

// æ¸²æŸ“èƒ½åŠ›æå‡ç•«é¢
// æ¸²æŸ“å±¬æ€§é¸æ“‡æ­¥é©Ÿ
function renderAttributeSelectionStep(modalState) {
  const hero = state.hero;
  if (!hero) return '';
  
  const currentSelection = modalState.attributeSelections[modalState.currentAttributeSelectionIndex];
  if (!currentSelection) return '';
  
  const attributeBonus = currentSelection.bonus;
  const currentLevel = currentSelection.level;
  const totalSelections = modalState.attributeSelections.length;
  const currentIndex = modalState.currentAttributeSelectionIndex + 1;
  
  // å±¬æ€§èªªæ˜å°æ‡‰è¡¨
  const attributeDescriptions = {
    attack: 'ç‰©ç†å‚·å®³',
    vitality: 'HPçš„æˆé•·è·Ÿå¸å¼•æ€ªæ”»æ“Šçš„èƒ½åŠ›',
    defense: 'æ¸›å°‘ç‰©ç†å‚·å®³',
    recovery: 'å›å¾©é­”æ³•çš„æ•ˆèƒ½è·ŸMPæˆé•·',
    magic: 'æ”»æ“Šé­”æ³•çš„æ•ˆèƒ½èˆ‡MPå¢é•·',
    agility: 'æœƒå¿ƒä¸€æ“Šç‡èˆ‡å‘½ä¸­ç‡èˆ‡é–ƒé¿ç‡',
  };
  
  // ç”Ÿæˆ6å€‹å±¬æ€§é¸æ“‡æŒ‰éˆ•
  const attributeButtons = ATTRIBUTES.map(attr => {
    const currentValue = Math.floor(hero.attributes[attr.id] || 0);
    const newValue = currentValue + attributeBonus;
    const description = attributeDescriptions[attr.id] || attr.description;
    return `
      <button class="dialog-option attribute-selection-btn" 
              data-action="select-attribute" 
              data-attribute="${attr.id}"
              style="text-align: left; padding: 16px; margin-bottom: 12px;">
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <div>
            <strong style="font-size: 16px;">${attr.name}</strong>
            <p style="margin: 4px 0; font-size: 12px; color: #aaa;">${description}</p>
          </div>
          <div style="text-align: right;">
            <p style="margin: 0; font-size: 14px;">${currentValue} â†’ <span style="color: var(--accent);">${newValue}</span></p>
            <p style="margin: 4px 0 0 0; font-size: 11px; color: #aaa;">+${attributeBonus}</p>
          </div>
        </div>
      </button>
    `;
  }).join('');
  
  return `
    <h2>ç­‰ç´šæå‡ï¼</h2>
    <p class="level-up-title">Lv ${modalState.oldLevel} â†’ Lv ${hero.stats.level}</p>
    <p style="margin: 16px 0; font-size: 14px; color: #aaa;">
      è«‹é¸æ“‡ä¸€å€‹å±¬æ€§æå‡ï¼ˆ${currentIndex}/${totalSelections}ï¼‰
    </p>
    <p style="margin-bottom: 20px; font-size: 12px; color: #888;">
      ç•¶å‰ç­‰ç´šï¼šLv ${currentLevel}ï¼Œæå‡å€¼ï¼š+${attributeBonus}
    </p>
    <div class="attribute-selection-list">
      ${attributeButtons}
    </div>
  `;
}

function renderStatsStep(modalState) {
  const hero = state.hero;
  if (!hero) return '';
  
  const oldAttrs = modalState.oldAttributes;
  const newAttrs = hero.attributes;
  
  // HPå’ŒMPè®ŠåŒ–ï¼ˆé¡¯ç¤ºæ™‚ä½¿ç”¨ç„¡æ¢ä»¶æ¨å»ï¼‰
  const hpChange = `${Math.floor(modalState.oldMaxHp)} â†’ ${Math.floor(hero.stats.maxHp)}`;
  const mpChange = `${Math.floor(modalState.oldMaxMp)} â†’ ${Math.floor(hero.stats.maxMp)}`;
  
  // å±¬æ€§è®ŠåŒ–åˆ—è¡¨ï¼ˆé¡¯ç¤ºæ™‚ä½¿ç”¨ç„¡æ¢ä»¶æ¨å»ï¼‰
  const attrChanges = ATTRIBUTES.map(attr => {
    const oldVal = Math.floor(oldAttrs[attr.id] || 0);
    const newVal = Math.floor(newAttrs[attr.id] || 0);
    if (newVal > oldVal) {
      return `<div class="stat-change-item">
        <span class="stat-name">${attr.name}</span>
        <span class="stat-change">${oldVal} â†’ ${newVal}</span>
      </div>`;
    }
    return '';
  }).filter(Boolean).join('');
  
  return `
    <h2>ç­‰ç´šæå‡ï¼</h2>
    <p class="level-up-title">Lv ${modalState.oldLevel} â†’ Lv ${hero.stats.level}</p>
    <div class="stats-upgrade-list">
      <div class="stat-change-item">
        <span class="stat-name">HP</span>
        <span class="stat-change">${hpChange}</span>
      </div>
      <div class="stat-change-item">
        <span class="stat-name">MP</span>
        <span class="stat-change">${mpChange}</span>
      </div>
      ${attrChanges}
    </div>
    <button class="continue-btn" data-action="continue-levelup">ç¹¼çºŒ</button>
  `;
}

function renderSkillStep(modalState) {
  const hero = state.hero;
  const heroLevel = hero ? hero.stats.level : 0;
  
  const cards = modalState.skillOptions.map(
    (skill) => {
      // æª¢æŸ¥æ˜¯å¦å¯ä»¥å­¸ç¿’ï¼ˆç­‰ç´šè¦æ±‚ï¼‰
      const canLearn = heroLevel >= (skill.requiredLevel || 0);
      // æª¢æŸ¥æ˜¯å¦éœ€è¦å‰ä¸€éš
      let needsPrevTier = false;
      if (skill.tier > 1 && skill.chainId) {
        const chain = SKILL_CHAINS.find(c => c.id === skill.chainId);
        if (chain) {
          const prevStep = chain.steps.find(s => s.tier === skill.tier - 1);
          if (prevStep && !hero.skills.includes(prevStep.id)) {
            needsPrevTier = true;
          }
        }
      }
      const isAvailable = canLearn && !needsPrevTier;
      
      // é¡¯ç¤ºç­‰ç´šè¦æ±‚
      let levelInfo = '';
      if (skill.requiredLevel !== undefined) {
        levelInfo = `Lv${skill.requiredLevel}`;
      }
      
      // æŠ€èƒ½é¡å‹æ¨™ç±¤
      const skillTypeLabel = skill.kind === 'passive' ? 'è¢«å‹•' : 'ä¸»å‹•';
      const skillTypeColor = skill.kind === 'passive' ? '#d4a5f5' : '#9fc5e8';
      
      // æµæ´¾æ¨™ç±¤
      const flowLabel = FLOWS[skill.flow]?.label || skill.flow;
      const flowColor = FLOW_PALETTE[skill.flow] || '#fff';
      
      return `
      <button class="skill-card ${!isAvailable ? 'disabled' : ''}" 
              data-action="pick-skill" 
              data-skill="${skill.id}"
              ${!isAvailable ? 'disabled' : ''}>
        <div class="skill-badges">
          <span class="badge" style="background:${flowColor}">
            ${flowLabel}
          </span>
          <span class="badge" style="background:${skillTypeColor}">
            ${skillTypeLabel}
          </span>
        </div>
        <h3>${skill.name}</h3>
        <p>${skill.description}</p>
        ${levelInfo ? `<p class="tier">éœ€æ±‚ç­‰ç´šï¼š${levelInfo}</p>` : ''}
        ${skill.tier ? `<p class="tier">éšæ®µ ${skill.tier}</p>` : ''}
        ${!isAvailable ? '<p style="color: #ff4444;">æ¢ä»¶æœªæ»¿è¶³</p>' : ''}
      </button>
    `;
    },
  );
  
  return `
    <h2>æŠ€èƒ½é¸æ“‡</h2>
    <p>å¾æŠ€èƒ½ä¸­æ“‡ä¸€å­¸ç¿’ã€‚å‡éšæœƒå–ä»£å‰ä¸€éšçš„æŠ€èƒ½ã€‚</p>
    <div class="skill-grid">${cards.join('')}</div>
    <button class="ghost-btn" data-action="skip-skill">ç•¥éæŠ€èƒ½ï¼ˆä¸å»ºè­°ï¼‰</button>
  `;
}

// æ¸²æŸ“ä¼™ä¼´å‡ç´šç•«é¢
function renderCompanionUpgradeStep(modalState) {
  if (!modalState.companionUpgrades || modalState.companionUpgrades.length === 0) {
    return '';
  }
  
  const currentIndex = modalState.currentCompanionIndex || 0;
  const compUpgrade = modalState.companionUpgrades[currentIndex];
  if (!compUpgrade || !compUpgrade.companion) {
    return '';
  }
  
  const companion = compUpgrade.companion;
  const step = compUpgrade.step || 'stats';
  
  // æ ¹æ“šæ­¥é©Ÿæ¸²æŸ“ä¸åŒçš„ç•Œé¢
  if (step === 'stats') {
    return renderCompanionStatsStep(compUpgrade, companion);
  } else if (step === 'attribute-selection') {
    return renderCompanionAttributeSelectionStep(compUpgrade, companion);
  } else if (step === 'skill-selection') {
    return renderCompanionSkillSelectionStep(compUpgrade, companion);
  }
  
  return '';
}

// æ¸²æŸ“ä¼™ä¼´èƒ½åŠ›æå‡ç•«é¢
function renderCompanionStatsStep(compUpgrade, companion) {
  const compOldAttrs = compUpgrade.oldAttributes;
  const compNewAttrs = companion.attributes;
  
  // ä¼™ä¼´HPå’ŒMPè®ŠåŒ–ï¼ˆé¡¯ç¤ºæ™‚ä½¿ç”¨ç„¡æ¢ä»¶æ¨å»ï¼‰
  const compHpChange = `${Math.floor(compUpgrade.oldMaxHp)} â†’ ${Math.floor(companion.stats.maxHp)}`;
  const compMpChange = `${Math.floor(compUpgrade.oldMaxMp)} â†’ ${Math.floor(companion.stats.maxMp)}`;
  
  // ä¼™ä¼´å±¬æ€§è®ŠåŒ–åˆ—è¡¨ï¼ˆé¡¯ç¤ºæ™‚ä½¿ç”¨ç„¡æ¢ä»¶æ¨å»ï¼‰- åªé¡¯ç¤ºè·æ¥­åŠ æˆå’Œå€‹æ€§ä¿®æ­£
  const compAttrChanges = ATTRIBUTES.map(attr => {
    const oldVal = Math.floor(compOldAttrs[attr.id] || 0);
    const newVal = Math.floor(compNewAttrs[attr.id] || 0);
    if (newVal > oldVal) {
      return `<div class="stat-change-item">
        <span class="stat-name">${attr.name}</span>
        <span class="stat-change">${oldVal} â†’ ${newVal}</span>
      </div>`;
    }
    return '';
  }).filter(Boolean).join('');
  
  return `
    <h2>${companion.name} ç­‰ç´šæå‡ï¼</h2>
    <p class="level-up-title">Lv ${compUpgrade.oldLevel} â†’ Lv ${companion.stats.level}</p>
    <div class="stats-upgrade-list">
      <div class="stat-change-item">
        <span class="stat-name">HP</span>
        <span class="stat-change">${compHpChange}</span>
      </div>
      <div class="stat-change-item">
        <span class="stat-name">MP</span>
        <span class="stat-change">${compMpChange}</span>
      </div>
      ${compAttrChanges}
    </div>
    <button class="continue-btn" data-action="continue-companion-levelup">ç¹¼çºŒ</button>
  `;
}

// æ¸²æŸ“ä¼™ä¼´å±¬æ€§é¸æ“‡ç•«é¢
function renderCompanionAttributeSelectionStep(compUpgrade, companion) {
  const currentSelection = compUpgrade.attributeSelections[compUpgrade.currentAttributeSelectionIndex];
  if (!currentSelection || currentSelection.selected) {
    return '';
  }
  
  const attributeBonus = currentSelection.bonus;
  const currentLevel = currentSelection.level;
  const totalSelections = compUpgrade.attributeSelections.length;
  const currentIndex = compUpgrade.currentAttributeSelectionIndex + 1;
  
  // å±¬æ€§èªªæ˜å°æ‡‰è¡¨
  const attributeDescriptions = {
    attack: 'ç‰©ç†å‚·å®³',
    vitality: 'HPçš„æˆé•·è·Ÿå¸å¼•æ€ªæ”»æ“Šçš„èƒ½åŠ›',
    defense: 'æ¸›å°‘ç‰©ç†å‚·å®³',
    recovery: 'å›å¾©é­”æ³•çš„æ•ˆèƒ½è·ŸMPæˆé•·',
    magic: 'æ”»æ“Šé­”æ³•çš„æ•ˆèƒ½èˆ‡MPå¢é•·',
    agility: 'æœƒå¿ƒä¸€æ“Šç‡èˆ‡å‘½ä¸­ç‡èˆ‡é–ƒé¿ç‡',
  };
  
  // ç”Ÿæˆ6å€‹å±¬æ€§é¸æ“‡æŒ‰éˆ•ï¼ˆèˆ‡å‹‡è€…ç›¸åŒæ¨£å¼ï¼‰
  const attributeButtons = ATTRIBUTES.map(attr => {
    const currentValue = Math.floor(companion.attributes[attr.id] || 0);
    const newValue = currentValue + attributeBonus;
    const description = attributeDescriptions[attr.id] || attr.description;
    return `
      <button class="dialog-option attribute-selection-btn" 
              data-action="select-companion-attribute" 
              data-attribute="${attr.id}"
              style="text-align: left; padding: 16px; margin-bottom: 12px;">
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <div>
            <strong style="font-size: 16px;">${attr.name}</strong>
            <p style="margin: 4px 0; font-size: 12px; color: #aaa;">${description}</p>
          </div>
          <div style="text-align: right;">
            <p style="margin: 0; font-size: 14px;">${currentValue} â†’ <span style="color: var(--accent);">${newValue}</span></p>
            <p style="margin: 4px 0 0 0; font-size: 11px; color: #aaa;">+${attributeBonus}</p>
          </div>
        </div>
      </button>
    `;
  }).join('');
  
  return `
    <h2>${companion.name} å±¬æ€§é¸æ“‡</h2>
    <p class="level-up-title">Lv ${currentLevel}ï¼šé¸æ“‡ä¸€å€‹å±¬æ€§æå‡ï¼ˆ${currentIndex}/${totalSelections}ï¼‰</p>
    <div style="margin-top: 20px;">
      ${attributeButtons}
    </div>
  `;
}

// æ¸²æŸ“ä¼™ä¼´æŠ€èƒ½é¸æ“‡ç•«é¢
function renderCompanionSkillSelectionStep(compUpgrade, companion) {
  const currentSelection = compUpgrade.skillSelections[compUpgrade.currentSkillSelectionIndex];
  if (!currentSelection || currentSelection.selected) {
    return '';
  }
  
  const skillOptions = currentSelection.options;
  const skillTypeLabel = currentSelection.type === 'other-class' ? 'å…¶ä»–è·æ¥­è¢«å‹•æŠ€èƒ½' : 'æœ¬è·æ¥­æŠ€èƒ½';
  
  const cards = skillOptions.map((skill) => {
    const heroLevel = companion.stats.level;
    const canLearn = heroLevel >= (skill.requiredLevel || 0);
    let needsPrevTier = false;
    if (skill.tier > 1 && skill.chainId) {
      const chain = SKILL_CHAINS.find(c => c.id === skill.chainId);
      if (chain) {
        const prevStep = chain.steps.find(s => s.tier === skill.tier - 1);
        if (prevStep && !companion.skills.includes(prevStep.id)) {
          needsPrevTier = true;
        }
      }
    }
    const isAvailable = canLearn && !needsPrevTier;
    
    let levelInfo = '';
    if (skill.requiredLevel !== undefined) {
      levelInfo = `Lv${skill.requiredLevel}`;
    }
    
    const skillTypeLabel2 = skill.kind === 'passive' ? 'è¢«å‹•' : 'ä¸»å‹•';
    const skillTypeColor = skill.kind === 'passive' ? '#d4a5f5' : '#9fc5e8';
    const flowLabel = FLOWS[skill.flow]?.label || skill.flow;
    const flowColor = FLOW_PALETTE[skill.flow] || '#fff';
    
    return `
      <button class="skill-card ${!isAvailable ? 'disabled' : ''}" 
              data-action="pick-companion-skill" 
              data-skill="${skill.id}"
              ${!isAvailable ? 'disabled' : ''}>
        <div class="skill-badges">
          <span class="badge" style="background:${flowColor}">
            ${flowLabel}
          </span>
          <span class="badge" style="background:${skillTypeColor}">
            ${skillTypeLabel2}
          </span>
        </div>
        <h3>${skill.name}</h3>
        <p>${skill.description}</p>
        ${levelInfo ? `<p class="tier">éœ€æ±‚ç­‰ç´šï¼š${levelInfo}</p>` : ''}
        ${skill.tier ? `<p class="tier">éšæ®µ ${skill.tier}</p>` : ''}
        ${!isAvailable ? '<p style="color: #ff4444;">æ¢ä»¶æœªæ»¿è¶³</p>' : ''}
      </button>
    `;
  }).join('');
  
  return `
    <h2>${companion.name} æŠ€èƒ½é¸æ“‡</h2>
    <p class="level-up-title">Lv ${currentSelection.level}ï¼šé¸æ“‡ä¸€å€‹${skillTypeLabel}å­¸ç¿’</p>
    <p>å¾æŠ€èƒ½ä¸­æ“‡ä¸€å­¸ç¿’ã€‚å‡éšæœƒå–ä»£å‰ä¸€éšçš„æŠ€èƒ½ã€‚</p>
    <div class="skill-grid">${cards}</div>
    <button class="ghost-btn" data-action="skip-companion-skill">æ”¾æ£„æŠ€èƒ½ï¼ˆä¸å»ºè­°ï¼‰</button>
  `;
}

// é¡¯ç¤ºç« ç¯€æ•…äº‹
function showStageStory(stage) {
  const storyData = STAGE_STORIES[stage];
  if (!storyData) return;
  
  state.ui.stageStory = {
    stage: stage,
    title: storyData.title,
    story: storyData.story
  };
  renderAll();
}

// æ¸²æŸ“ç« ç¯€æ•…äº‹å°è©±æ¡†
function renderStageStoryDialog(stageStory) {
  if (!stageStory) return '';
  
  return `
    <h2>ğŸ“– ${stageStory.title}</h2>
    <div class="event-message">
      <p style="white-space: pre-line; font-size: 14.4px; line-height: 1.8; margin: 20px 0;">${stageStory.story}</p>
    </div>
    <button class="continue-btn" data-action="confirm-stage-story">é–‹å§‹å†’éšª</button>
  `;
}

// æ¸²æŸ“äº‹ä»¶å°è©±æ¡†
function renderEventDialog(eventResult) {
  const iconMap = {
    treasure: 'ğŸ’°',
    heal: 'ğŸ’š',
    trap: 'âš ï¸',
    equipment: 'ğŸ',
    choice: 'ğŸ¤”',
    result: 'âœ¨',
  };
  const icon = iconMap[eventResult.type] || 'ğŸ“‹';
  
  // å¦‚æœæ˜¾ç¤ºé€‰æ‹©ç»“æœ
  if (eventResult.showResult) {
    return `
      <h2>${icon} ${eventResult.resultTitle || 'çµæœ'}</h2>
      <div class="event-message">
        <p style="white-space: pre-line; font-size: 14.4px; line-height: 1.8; margin: 20px 0;">${eventResult.resultMessage}</p>
      </div>
      <button class="continue-btn" data-action="confirm-event">ç¢ºèª</button>
    `;
  }
  
  // å¦‚æœæœ‰å¤šä¸ªé€‰æ‹©
  if (eventResult.choices && eventResult.choices.length > 0) {
    const choicesHtml = eventResult.choices.map((choice, index) => {
      return `
        <button class="continue-btn" data-action="select-event-choice" data-choice="${index}" style="width: 100%;">
          ${choice.hint || choice.label}
        </button>
      `;
    }).join('');
    
    return `
      <h2>${icon} ${eventResult.title}</h2>
      <div class="event-message">
        <p style="white-space: pre-line; font-size: 14.4px; line-height: 1.8; margin: 20px 0;">${eventResult.message}</p>
      </div>
      <div class="event-choices" style="display: flex; flex-direction: column; gap: 10px; margin-top: 20px;">
        ${choicesHtml}
      </div>
    `;
  }
  
  // å•ä¸ªé€‰æ‹©ï¼ˆåŸæœ‰é€»è¾‘ï¼‰
  return `
    <h2>${icon} ${eventResult.title}</h2>
    <div class="event-message">
      <p style="white-space: pre-line; font-size: 14.4px; line-height: 1.8; margin: 20px 0;">${eventResult.message}</p>
    </div>
    <button class="continue-btn" data-action="confirm-event">ç¢ºèª</button>
  `;
}

// æ¸²æŸ“æˆ°é¬¥çµæœå°è©±æ¡†ï¼ˆæ‰è½ç‰©å“ï¼‰
function renderBattleResultDialog(battleResult) {
  if (!battleResult.victory) return '';
  
  const itemsList = battleResult.droppedItems.map(item => {
    return `<div class="drop-item">${item.name}${item.qty > 1 ? ` Ã—${item.qty}` : ''}</div>`;
  }).join('');
  
  const equipmentList = battleResult.droppedEquipment.map(eq => {
    return `<div class="drop-item ${eq.isOwned ? 'owned' : ''}">${eq.name}${eq.isOwned ? 'ï¼ˆå·²æ“æœ‰ï¼‰' : ''}</div>`;
  }).join('');
  
  const hasDrops = battleResult.droppedItems.length > 0 || battleResult.droppedEquipment.length > 0;
  
  return `
    <h2>ğŸ‰ æˆ°é¬¥å‹åˆ©ï¼</h2>
    <div class="battle-result-content">
      <div class="battle-reward-item">
        <span class="reward-label">ç¶“é©—å€¼ï¼š</span>
        <span class="reward-value">+${battleResult.xpGain}</span>
      </div>
      <div class="battle-reward-item">
        <span class="reward-label">é‡‘å¹£ï¼š</span>
        <span class="reward-value">+${battleResult.goldGain}</span>
      </div>
      ${hasDrops ? `
        <div class="battle-drops">
          <div class="drops-title">ç²å¾—ç‰©å“ï¼š</div>
          ${itemsList}
          ${equipmentList}
        </div>
      ` : '<div class="battle-drops">æ²’æœ‰æ‰è½ç‰©å“</div>'}
    </div>
    <button class="continue-btn" data-action="confirm-battle-result">ç¢ºèª</button>
  `;
}

function renderItemChoiceDialog(itemChoice) {
  const hero = state.hero;
  if (!hero || !itemChoice) return '';
  
  // ç¢ºå®šæ–°é“å…·æˆ–è£å‚™çš„é¡¯ç¤ºåç¨±
  let newItemName = '';
  let newItemQty = '';
  if (itemChoice.newEquipment) {
    const equipment = itemChoice.newEquipment;
    newItemName = equipment.name;
    newItemQty = '';
  } else if (itemChoice.newItem) {
    if (itemChoice.newItem.id && itemChoice.newItem.id.startsWith('equipment_')) {
      const equipmentId = itemChoice.newItem.id.replace('equipment_', '');
      const equipment = getEquipmentData(equipmentId);
      newItemName = equipment ? equipment.name : itemChoice.newItem.name;
    } else {
      const item = ITEM_LOOKUP.get(itemChoice.newItem.id);
      newItemName = item ? item.name : itemChoice.newItem.name;
    }
    newItemQty = itemChoice.newItem.qty > 1 ? ` Ã—${itemChoice.newItem.qty}` : '';
  }
  
  const itemsList = itemChoice.items.map(entry => {
    let itemName = '';
    if (entry.id.startsWith('equipment_')) {
      const equipmentId = entry.id.replace('equipment_', '');
      const equipment = EQUIPMENT_LOOKUP.get(equipmentId);
      itemName = equipment ? equipment.name : entry.id;
    } else {
      const item = ITEM_LOOKUP.get(entry.id);
      itemName = item ? item.name : entry.id;
    }
    
    return `
      <div class="shop-item">
        <div class="shop-item-name">${itemName}</div>
        <div class="shop-item-stats">æ•¸é‡ï¼š${entry.qty}</div>
        <button class="shop-buy-btn" data-action="drop-item-for-new" data-item="${entry.id}">
          ä¸Ÿæ£„æ­¤é“å…·
        </button>
      </div>
    `;
  }).join('');
  
  return `
    <h2>é“å…·æ¬„å·²æ»¿</h2>
    <p>${itemChoice.message}</p>
    <p>æ–°${itemChoice.newEquipment ? 'è£å‚™' : 'é“å…·'}ï¼š${newItemName}${newItemQty}</p>
    <div class="shop-content">
      ${itemsList}
    </div>
    <button class="continue-btn" data-action="cancel-item-choice">å–æ¶ˆï¼ˆä¸ç²å¾—æ­¤${itemChoice.newEquipment ? 'è£å‚™' : 'é“å…·'}ï¼‰</button>
  `;
}

// æ¸²æŸ“éæˆ°é¬¥é“å…·ä½¿ç”¨ç›®æ¨™é¸æ“‡ç•Œé¢
function renderFieldItemTargetSelection(itemId) {
  const hero = state.hero;
  const companions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
  const item = ITEM_LOOKUP.get(itemId);
  
  if (!hero || !item) {
    state.ui.fieldItemSelection = null;
    return '';
  }
  
  let companionButtons = '';
  if (companions.length > 0) {
    companionButtons = companions.map((companion, index) => `
      <button class="dialog-option" onclick="selectFieldItemTarget('companion', ${index});">
        <strong>${companion.name}</strong>
        <small>${formatHpDisplay(companion)} | MP: ${companion.stats.mp}/${companion.stats.maxMp}</small>
      </button>
    `).join('');
  }
  
  return `
    <h2>é¸æ“‡ä½¿ç”¨ç›®æ¨™</h2>
    <p>è«‹é¸æ“‡è¦å°èª°ä½¿ç”¨ ${item.name}ï¼š</p>
    <div class="dialog-options">
      <button class="dialog-option" onclick="selectFieldItemTarget('hero');">
        <strong>å‹‡è€…</strong>
        <small>${formatHpDisplay(hero)} | MP: ${hero.stats.mp}/${hero.stats.maxMp}</small>
      </button>
      ${companionButtons}
      <button class="dialog-option" onclick="state.ui.fieldItemSelection = null; renderAll();">
        <strong>å–æ¶ˆ</strong>
      </button>
    </div>
  `;
}

function renderFieldSkillTargetSelection(skillSelection) {
  const hero = state.hero;
  const companions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
  const skill = SKILL_LOOKUP.get(skillSelection.skillId);
  
  if (!hero || !skill) {
    state.ui.fieldSkillSelection = null;
    return '';
  }
  
  // ç¢ºå®šä½¿ç”¨æŠ€èƒ½çš„å°è±¡
  let caster = hero;
  let casterName = 'å‹‡è€…';
  if (skillSelection.characterType === 'companion') {
    const companion = getActiveCompanion();
    if (!companion) {
      state.ui.fieldSkillSelection = null;
      return '';
    }
    caster = companion;
    casterName = companion.name;
  }
  
  let companionButtons = '';
  if (companions.length > 0) {
    companionButtons = companions.map((companion, index) => `
      <button class="dialog-option" onclick="selectFieldSkillTarget('companion', ${index});">
        <strong>${companion.name}</strong>
        <small>${formatHpDisplay(companion)} | MP: ${companion.stats.mp}/${companion.stats.maxMp}</small>
      </button>
    `).join('');
  }
  
  const mpCost = skill.mpCost || 0;
  const canUse = caster.stats.mp >= mpCost;
  
  // å¦‚æœæ˜¯ç¾¤é«”æ²»ç™‚æŠ€èƒ½ï¼ˆAOE + healï¼‰ï¼Œåªé¡¯ç¤º"æˆ‘æ–¹å…¨é«”"é¸é …
  const isAoeHeal = skill.aoe && skill.kind === 'heal';
  
  return `
    <h2>é¸æ“‡ä½¿ç”¨ç›®æ¨™</h2>
    <p>${casterName} è¦ä½¿ç”¨ã€Œ${skill.name}ã€${mpCost > 0 ? `ï¼ˆæ¶ˆè€— ${mpCost} MPï¼‰` : ''}ï¼Œè«‹é¸æ“‡ç›®æ¨™ï¼š</p>
    <div class="dialog-options">
      ${isAoeHeal ? '' : `
      <button class="dialog-option" onclick="selectFieldSkillTarget('hero');" ${!canUse ? 'disabled' : ''}>
        <strong>å‹‡è€…</strong>
          <small>${formatHpDisplay(hero)} | MP: ${hero.stats.mp}/${hero.stats.maxMp}</small>
      </button>
      ${companionButtons}
      `}
      ${skill.aoe ? `
        <button class="dialog-option" onclick="selectFieldSkillTarget('all');" ${!canUse ? 'disabled' : ''}>
          <strong>æˆ‘æ–¹å…¨é«”</strong>
        </button>
      ` : ''}
      <button class="dialog-option" onclick="state.ui.fieldSkillSelection = null; renderAll();">
        <strong>å–æ¶ˆ</strong>
      </button>
    </div>
  `;
}

function selectHeroType(heroTypeId) {
  if (!HERO_TYPES[heroTypeId]) return;
  
  // å‰µå»ºæ–°è‹±é›„å’Œä¸–ç•Œï¼ˆå¾è¨­å®šä¸­çš„èµ·å§‹éšæ®µå’Œç¯€é»é–‹å§‹ï¼‰
  const heroResult = createHero('male', heroTypeId);
  state.hero = heroResult.hero;
  // å¾state.settingsè®€å–ï¼Œå¦‚æœæ²’æœ‰å‰‡å¾GAME_CONFIGè®€å–
  // å¾GAME_CONFIGè®€å–èµ·å§‹éšæ®µå’Œç¯€é»
  const startStage = GAME_CONFIG.startStage || 1;
  const startNodeIndex = Math.min(19, Math.max(0, GAME_CONFIG.startNodeIndex || 0));
  state.world = {
    stage: startStage,
    nodes: generateRoute(startStage),
    currentNodeIndex: startNodeIndex,
    currentArea: 'field', // renderBackground æœƒæ ¹æ“š stage è‡ªå‹•è¨­ç½®æ­£ç¢ºçš„ currentArea
  };
  state.log = [];
  
  // æ¸…ç©ºåŒä¼´è³‡æ–™ï¼ˆé‡æ–°é–‹å§‹å†’éšªæ™‚ï¼‰
  state.companions = [];
  state.ui.companionViewIndex = 0;
  state.ui.characterView = 'hero';
  
  // æ¸…é™¤è‹±é›„é¡å‹é¸æ“‡ç‹€æ…‹ï¼Œæ ¹æ“šåˆå§‹åŒä¼´æ•¸é‡æ±ºå®šæ˜¯å¦é¡¯ç¤ºåŒä¼´é¸æ“‡
  state.ui.heroTypeSelection = null;
  // ä½¿ç”¨æ˜ç¢ºæª¢æŸ¥ï¼Œé€™æ¨£ 0 ä¸æœƒè¢«æ›¿æ›
  const initialCompanionCount = (typeof GAME_CONFIG.initialCompanionCount !== 'undefined') 
    ? GAME_CONFIG.initialCompanionCount 
    : 1;
  if (initialCompanionCount > 0) {
    state.ui.companionSelection = true;
  }
  
  state.ui.startMenu = false;
  
  // å¼·åˆ¶éš±è—é–‹å§‹é¸å–®
  if (dom.startScreen) {
    dom.startScreen.classList.add('hidden');
    dom.startScreen.style.display = 'none';
  }
  
  pushLog(`é¸æ“‡äº†ã€Œ${HERO_TYPES[heroTypeId].name}ã€`);
  pushLog(`ä½ çš„åå­—æ˜¯ã€Œ${state.hero.name}ã€`);
  
  // å¦‚æœç²å¾—äº†è¢«å‹•æŠ€èƒ½ï¼Œè¨˜éŒ„åˆ°æ—¥èªŒ
  if (heroResult.passiveSkill) {
    pushLog(`âœ¨ ç²å¾—è¢«å‹•æŠ€èƒ½ï¼šã€Œ${heroResult.passiveSkill.name}ã€ï¼${heroResult.passiveSkill.description}`);
  }
  
  // æ˜¾ç¤ºè‡ªåŠ¨è·å¾—çš„åœ£ç‰©ï¼ˆå¦‚æœä»startStage > 1å¼€å§‹ï¼‰
  if (state.ui.autoObtainedRelics && state.ui.autoObtainedRelics.length > 0) {
    pushLog(`âœ¨ æ ¹æ“šèµ·å§‹éšæ®µï¼Œè‡ªå‹•ç²å¾—ä»¥ä¸‹åœ£ç‰©ï¼š`);
    state.ui.autoObtainedRelics.forEach(({ stage, relic }) => {
      const attrName = ATTRIBUTES.find(a => a.id === relic.attributeType)?.name || relic.attributeType;
      const flowName = FLOWS[relic.flow]?.label || relic.flow;
      const passiveSkillText = relic.passiveSkill ? `ï¼ˆè¢«å‹•ï¼š${relic.passiveSkill.name}ï¼‰` : '';
      pushLog(`  â€¢ éšæ®µ${stage}ï¼š${relic.name} [${flowName}] ${attrName}+${relic.attributeBonus}${passiveSkillText}`);
    });
    // æ¸…é™¤ä¸´æ—¶å­˜å‚¨
    state.ui.autoObtainedRelics = null;
  }
  
  // è‡ªå‹•å‡ç´šåˆ°è¨­å®šç­‰ç´š
  const targetLevel = GAME_CONFIG.defaultTargetLevel || 15;
  if (targetLevel > 1 && state.hero) {
    autoLevelUpToTarget(targetLevel);
  }
  
  // å¦‚æœåˆå§‹åŒä¼´æ•¸é‡ç‚º0ï¼Œç›´æ¥é–‹å§‹éŠæˆ²ï¼Œä¸é¡¯ç¤ºé¸æ“‡ç•Œé¢
  if (initialCompanionCount === 0) {
    state.ui.companionSelection = null;
    pushLog(`é–‹å§‹å†’éšªï¼`);
    
    // å¦‚æœå¾ç¬¬ä¸€éšæ®µé–‹å§‹ï¼Œé¡¯ç¤ºç¬¬ä¸€ç« æ•…äº‹
    if (startStage === 1) {
      showStageStory(1);
    } else {
      // å¦‚æœä¸æ˜¯ç¬¬ä¸€éšæ®µï¼Œç›´æ¥é—œé–‰æ¨¡æ…‹è¦–çª—
    dom.modalLayer.classList.add('hidden');
    dom.levelModal.innerHTML = '';
    }
    
    setTimeout(() => {
      renderAll();
    }, 0);
    return; // æå‰è¿”å›ï¼Œä¸å†åŸ·è¡Œå¾Œé¢çš„ä»£ç¢¼
  }
  
  // é¡¯ç¤ºåŒä¼´é¸æ“‡ç•Œé¢
  setTimeout(() => {
    renderAll();
  }, 0);
}

function selectCompanion(companionTypeId) {
  if (!COMPANION_TYPES[companionTypeId]) return;
  
  const companionType = COMPANION_TYPES[companionTypeId];
  const maxCompanionCount = GAME_CONFIG.maxCompanionCount || 4;
  
  // æª¢æŸ¥æ˜¯å¦å·²é”åˆ°æœ€å¤§åŒä¼´æ•¸é‡ä¸Šé™
  if (state.companions.length >= maxCompanionCount) {
    pushLog(`ç„¡æ³•é¸æ“‡ï¼šéšŠä¼å·²é”åˆ°æœ€å¤§åŒä¼´æ•¸é‡ä¸Šé™ï¼ˆ${maxCompanionCount}å€‹ï¼‰ã€‚`);
    return;
  }
  
  // æª¢æŸ¥æ˜¯å¦å·²ç¶“æœ‰ç›¸åŒè·æ¥­çš„åŒä¼´
  const hasSameHeroType = state.companions.some(companion => {
    if (companion.companionTypeId) {
      const existingType = COMPANION_TYPES[companion.companionTypeId];
      return existingType && existingType.heroType === companionType.heroType;
    }
    return false;
  });
  
  if (hasSameHeroType) {
    pushLog(`ç„¡æ³•é¸æ“‡ï¼šéšŠä¼ä¸­å·²æœ‰ç›¸åŒè·æ¥­ã€Œ${companionType.name}ã€çš„åŒä¼´ï¼ˆå‹‡è€…ä¸åœ¨æ­¤é™åˆ¶å…§ï¼‰ã€‚`);
    return;
  }
  
  // å‰µå»ºåŒä¼´
  const newCompanion = createCompanion(companionTypeId);
  state.companions.push(newCompanion);
  
  pushLog(`${newCompanion.name}åŠ å…¥äº†ä½ çš„éšŠä¼ï¼`);
  
  // æ¸¬è©¦æ¨¡å¼ï¼šå‡ç´šåˆ°æŒ‡å®šç­‰ç´šä¸¦å…è¨±è·æ¥­é€²éš
  if (GAME_CONFIG.testMode && GAME_CONFIG.testModeCompanionLevel > 1) {
    const targetLevel = GAME_CONFIG.testModeCompanionLevel;
    if (newCompanion.stats.level < targetLevel) {
      const levelsToGain = targetLevel - newCompanion.stats.level;
      const upgradeInfo = levelUpCompanion(newCompanion, levelsToGain);
      // è‡ªå‹•è™•ç†å±¬æ€§é¸æ“‡å’ŒæŠ€èƒ½é¸æ“‡ï¼ˆè‡ªå‹•å‡ç´šæ™‚è‡ªå‹•é¸æ“‡ï¼‰
      if (upgradeInfo) {
        autoProcessCompanionUpgrade(upgradeInfo);
      }
      newCompanion.stats.hp = newCompanion.stats.maxHp;
      newCompanion.stats.mp = newCompanion.stats.maxMp;
    }
    
    // å¦‚æœå…è¨±è·æ¥­é€²éšï¼Œä¸”åŒä¼´ä¸æ˜¯é€²éšè·æ¥­ï¼Œå‰‡é¡¯ç¤ºé€²éšé¸æ“‡
    if (GAME_CONFIG.testModeAllowAdvancement) {
      const companionType = COMPANION_TYPES[newCompanion.companionTypeId];
      if (companionType && !companionType.isAdvanced) {
        // æª¢æŸ¥æ˜¯å¦æœ‰å¯é€²éšçš„è·æ¥­
        const advancementOptions = CLASS_ADVANCEMENT_MAP[newCompanion.companionTypeId] || CLASS_ADVANCEMENT_MAP[companionType.heroType] || [];
        if (advancementOptions.length > 0) {
          // è¨­ç½®æ¸¬è©¦æ¨¡å¼é€²éšç‹€æ…‹
          state.ui.testModeAdvancement = {
            companionIndex: state.companions.length - 1,
            companion: newCompanion,
          };
          // ä¸ç¹¼çºŒåŸ·è¡Œå¾ŒçºŒé‚è¼¯ï¼Œç­‰å¾…ç©å®¶é¸æ“‡æ˜¯å¦é€²éš
          renderAll();
          return;
        }
      }
    }
  } else {
    // éæ¸¬è©¦æ¨¡å¼ï¼šè‡ªå‹•å‡ç´šæ–°å‰µå»ºçš„åŒä¼´åˆ°å‹‡è€…çš„ç•¶å‰ç­‰ç´š
  if (state.hero && state.hero.stats && newCompanion && newCompanion.stats) {
    const heroLevel = state.hero.stats.level;
    if (heroLevel > 1 && newCompanion.stats.level < heroLevel) {
      // ä½¿ç”¨ levelUpCompanion æœƒè‡ªå‹•å°‡åŒä¼´ç­‰ç´šè¨­ç½®ç‚ºå‹‡è€…ç­‰ç´š
      const upgradeInfo = levelUpCompanion(newCompanion, heroLevel - newCompanion.stats.level);
      // è‡ªå‹•è™•ç†å±¬æ€§é¸æ“‡å’ŒæŠ€èƒ½é¸æ“‡ï¼ˆåˆå§‹å‡ç´šæ™‚è‡ªå‹•é¸æ“‡ï¼‰
      if (upgradeInfo) {
        autoProcessCompanionUpgrade(upgradeInfo);
      }
      // åŒä¼´çš„HP/MPä¹Ÿè£œæ»¿
      newCompanion.stats.hp = newCompanion.stats.maxHp;
      newCompanion.stats.mp = newCompanion.stats.maxMp;
      }
    }
  }
  
  // æª¢æŸ¥æ˜¯å¦é‚„éœ€è¦é¸æ“‡æ›´å¤šåŒä¼´
  // ä½¿ç”¨æ˜ç¢ºçš„æª¢æŸ¥ï¼Œé€™æ¨£ 0 ä¸æœƒè¢«æ›¿æ›
  const initialCount = (typeof GAME_CONFIG.initialCompanionCount !== 'undefined') 
    ? GAME_CONFIG.initialCompanionCount 
    : 1;
  const isNewCompanionAfterBoss = state.ui.companionSelection === 'boss-reward';
  
  if (isNewCompanionAfterBoss) {
    // æ‰“å€’é­”ç‹å¾Œé¸æ“‡æ–°åŒä¼´ï¼Œé¸æ“‡å®Œç•¢å¾Œé¡¯ç¤ºåœ£ç‰©é¸æ“‡
    state.ui.companionSelection = null;
    
    // é¸æ“‡å®ŒåŒä¼´å¾Œï¼Œå¼·åˆ¶é¡¯ç¤ºåœ£ç‰©é¸æ“‡ç•Œé¢ï¼ˆä¸å†å…è¨±é¸æ“‡æ›´å¤šåŒä¼´ï¼‰
    handleBossReward(true);
    return;
  } else if (initialCount <= 0 || state.companions.length >= initialCount || state.companions.length >= maxCompanionCount) {
    // å¦‚æœåˆå§‹æ•¸é‡ç‚º0ã€å·²é¸æ“‡è¶³å¤ çš„åˆå§‹åŒä¼´ã€æˆ–é”åˆ°æœ€å¤§åŒä¼´æ•¸é‡ä¸Šé™ï¼Œé–‹å§‹éŠæˆ²
    // ç¢ºä¿æ‰€æœ‰åŒä¼´éƒ½å‡ç´šåˆ°ç›®æ¨™ç­‰ç´š
    const targetLevel = GAME_CONFIG.defaultTargetLevel || 15;
    if (targetLevel > 1) {
      const activeCompanions = (state.companions || []).filter(c => c && c.stats);
      activeCompanions.forEach(companion => {
        if (companion.stats.level < targetLevel) {
          const companionLevelsToGain = targetLevel - companion.stats.level;
          const upgradeInfo = levelUpCompanion(companion, companionLevelsToGain);
          // è‡ªå‹•è™•ç†å±¬æ€§é¸æ“‡å’ŒæŠ€èƒ½é¸æ“‡ï¼ˆè‡ªå‹•å‡ç´šæ™‚è‡ªå‹•é¸æ“‡ï¼‰
          if (upgradeInfo) {
            autoProcessCompanionUpgrade(upgradeInfo);
          }
          // åŒä¼´çš„HP/MPä¹Ÿè£œæ»¿
          companion.stats.hp = companion.stats.maxHp;
          companion.stats.mp = companion.stats.maxMp;
        }
      });
    }
    
    state.ui.companionSelection = null;
    dom.modalLayer.classList.add('hidden');
    dom.levelModal.innerHTML = '';
    setTimeout(() => {
      renderAll();
    }, 0);
  } else {
    // é‚„éœ€è¦é¸æ“‡æ›´å¤šåŒä¼´ï¼Œç¹¼çºŒé¡¯ç¤ºé¸æ“‡ç•Œé¢
    // ç¢ºä¿æ¨¡æ…‹è¦–çª—ä¿æŒæ‰“é–‹ï¼Œä¸¦ä¿æŒé¸æ“‡ç‹€æ…‹
    state.ui.companionSelection = true; // ç¢ºä¿ç‹€æ…‹ä¿æŒç‚º true
    // ç›´æ¥èª¿ç”¨ renderAll è®“å®ƒè™•ç†ç•Œé¢æ¸²æŸ“
    setTimeout(() => {
      renderAll();
    }, 50); // ç¨å¾®å»¶é²ä»¥ç¢ºä¿ç‹€æ…‹æ›´æ–°å®Œæˆ
  }
}

// é€‰æ‹©åœ£ç‰©
function selectRelic(relicIndex) {
  const relicSelection = state.ui.relicSelection;
  if (!relicSelection || !relicSelection.relics || relicIndex < 0 || relicIndex >= relicSelection.relics.length) {
    return;
  }
  
  const selectedRelic = relicSelection.relics[relicIndex];
  
  // å°†åœ£ç‰©æ·»åŠ åˆ°å·²è·å¾—çš„åœ£ç‰©åˆ—è¡¨
  if (!state.obtainedRelics) {
    state.obtainedRelics = [];
  }
  if (!state.obtainedRelics.includes(selectedRelic.id)) {
    state.obtainedRelics.push(selectedRelic.id);
  }
  
  pushLog(`ç²å¾—äº†åœ£ç‰©ï¼š${selectedRelic.name}ï¼ˆ${ATTRIBUTES.find(a => a.id === selectedRelic.attributeType)?.name || selectedRelic.attributeType} +${selectedRelic.attributeBonus}ï¼‰`);
  if (selectedRelic.passiveSkill) {
    pushLog(`â†’ è¢«å‹•æŠ€èƒ½ï¼š${selectedRelic.passiveSkill.name}`);
  }
  
  // æ¸…é™¤åœ£ç‰©é€‰æ‹©çŠ¶æ€
  state.ui.relicSelection = null;
  dom.modalLayer.classList.add('hidden');
  dom.levelModal.innerHTML = '';
  
  // è¿›å…¥ä¸‹ä¸€é˜¶æ®µ
  advanceToNextStage();
  
  setTimeout(() => {
    renderAll();
  }, 0);
}

// è™•ç†å±¬æ€§é¸æ“‡
function selectAttribute(attributeId) {
  const modalState = state.ui.levelUp;
  if (!modalState || modalState.step !== 'attribute-selection') return;
  
  const hero = state.hero;
  if (!hero) return;
  
  const currentSelection = modalState.attributeSelections[modalState.currentAttributeSelectionIndex];
  if (!currentSelection || currentSelection.selected) return;
  
  // æª¢æŸ¥å±¬æ€§IDæ˜¯å¦æœ‰æ•ˆ
  const attr = ATTRIBUTES.find(a => a.id === attributeId);
  if (!attr) return;
  
  // æå‡é¸ä¸­çš„å±¬æ€§
  const attributeBonus = currentSelection.bonus;
  hero.attributes[attributeId] = (hero.attributes[attributeId] || 0) + attributeBonus;
  
  // æ¨™è¨˜ç‚ºå·²é¸æ“‡
  currentSelection.selected = true;
  currentSelection.selectedAttribute = attributeId;
  
  pushLog(`Lv ${currentSelection.level}ï¼š${attr.name} +${attributeBonus}`);
  
  // æª¢æŸ¥æ˜¯å¦é‚„æœ‰æœªé¸æ“‡çš„å±¬æ€§
  modalState.currentAttributeSelectionIndex += 1;
  
  if (modalState.currentAttributeSelectionIndex >= modalState.attributeSelections.length) {
    // æ‰€æœ‰å±¬æ€§éƒ½é¸æ“‡å®Œç•¢ï¼Œæª¢æŸ¥æ˜¯å¦æœ‰æŠ€èƒ½é¸æ“‡
    if (modalState.shouldGetSkill && modalState.skillOptions.length > 0) {
      // æœ‰æŠ€èƒ½é¸æ“‡ï¼Œé€²å…¥æŠ€èƒ½é¸æ“‡æ­¥é©Ÿ
      modalState.step = 'skills';
      // æˆ°é¬¥å¾Œçš„å‡ç´šç¸½æ˜¯æ‰‹å‹•é¸æ“‡æŠ€èƒ½ï¼ˆå››é¸ä¸€ï¼‰ï¼Œä¸å—è‡ªå‹•é¸æ“‡è¨­ç½®å½±éŸ¿
      // åªæœ‰åœ¨åˆå§‹è‡ªå‹•å‡ç´šæ™‚æ‰ä½¿ç”¨è‡ªå‹•é¸æ“‡è¨­ç½®
      const isInitialAutoLevel = modalState.isInitialAutoLevel || false;
      if (isInitialAutoLevel && modalState.skillOptions.length > 0) {
        // è‡ªå‹•å‡ç´šæ™‚ï¼Œ70%æ©Ÿç‡é¸æ“‡è©²æµæ´¾çš„æŠ€èƒ½
        const hero = state.hero;
        const initialFlowMap = {
          attacker: 'sword',
          mage: 'magic',
          healer: 'recovery',
          defender: 'defender',
          agile: 'agility',
        };
        const initialFlow = hero.heroType ? (initialFlowMap[hero.heroType] || 'sword') : 'sword';
        
        // ä¸»è¦æµæ´¾å°±æ˜¯ä¸€é–‹å§‹å†’éšªæ‰€é¸çš„æµæ´¾
        const primaryFlow = initialFlow;
        
        // 70%æ©Ÿç‡é¸æ“‡è©²æµæ´¾çš„æŠ€èƒ½
        let selectedSkill = null;
        if (Math.random() < 0.7) {
          // å„ªå…ˆé¸æ“‡è©²æµæ´¾çš„æŠ€èƒ½
          const primaryFlowSkills = modalState.skillOptions.filter(skill => {
            const skillObj = SKILL_LOOKUP.get(skill.id);
            return skillObj && skillObj.flow === primaryFlow;
          });
          if (primaryFlowSkills.length > 0) {
            selectedSkill = primaryFlowSkills[Math.floor(Math.random() * primaryFlowSkills.length)];
          }
        }
        
        // å¦‚æœæ²’æœ‰æ‰¾åˆ°è©²æµæ´¾çš„æŠ€èƒ½ï¼Œæˆ–30%æ©Ÿç‡ï¼Œéš¨æ©Ÿé¸æ“‡
        if (!selectedSkill) {
          const availableSkills = modalState.skillOptions.filter(skill => {
            const heroLevel = state.hero ? state.hero.stats.level : 1;
            return heroLevel >= (skill.requiredLevel || 0);
          });
          if (availableSkills.length > 0) {
            selectedSkill = availableSkills[Math.floor(Math.random() * availableSkills.length)];
          }
        }
        
        if (selectedSkill) {
          confirmSkillSelection(selectedSkill.id);
          return;
        }
      }
    } else {
      // æ²’æœ‰æŠ€èƒ½é¸æ“‡ï¼Œæª¢æŸ¥æ˜¯å¦æœ‰ä¼™ä¼´å‡ç´šä¿¡æ¯
      if (modalState.companionUpgrades && modalState.companionUpgrades.length > 0) {
        // æœ‰ä¼™ä¼´å‡ç´šä¿¡æ¯ï¼Œé–‹å§‹è™•ç†ç¬¬ä¸€å€‹ä¼™ä¼´çš„å‡ç´š
        startCompanionUpgrade(modalState);
      } else {
        // æ²’æœ‰ä¼™ä¼´å‡ç´šä¿¡æ¯ï¼Œç›´æ¥çµæŸå‡ç´š
        concludeLevelUp();
        return;
      }
    }
  }
  
  renderAll();
}

function confirmSkillSelection(skillId) {
  const modalState = state.ui.levelUp;
  if (!modalState || modalState.step !== 'skills') return;
  const skill = SKILL_LOOKUP.get(skillId);
  if (!skill) return;
  learnSkill(skill);
  pushLog(`ä½ å­¸æœƒäº†ã€Œ${skill.name}ã€ï¼`);
  
  // æª¢æŸ¥æ˜¯å¦æœ‰ä¼™ä¼´å‡ç´šä¿¡æ¯ï¼Œå¦‚æœæœ‰å‰‡é¡¯ç¤ºä¼™ä¼´å‡ç´šé é¢
  if (modalState.companionUpgrades && modalState.companionUpgrades.length > 0) {
    startCompanionUpgrade(modalState);
  } else {
    concludeLevelUp();
  }
}

// é–‹å§‹è™•ç†ä¼™ä¼´å‡ç´š
function startCompanionUpgrade(modalState) {
  if (!modalState.companionUpgrades || modalState.companionUpgrades.length === 0) {
    concludeLevelUp();
    return;
  }
  
  const currentIndex = modalState.currentCompanionIndex || 0;
  const compUpgrade = modalState.companionUpgrades[currentIndex];
  if (!compUpgrade) {
    concludeLevelUp();
    return;
  }
  
  const companion = compUpgrade.companion;
  const requiredLevel = GAME_CONFIG.companionAdvancementLevel || 40;
  
  // å¦‚æœåŒä¼´ç­‰ç´šå°æ–¼40ç´šï¼Œè‡ªå‹•è™•ç†æ‰€æœ‰é¸æ“‡
  if (companion && companion.stats && companion.stats.level < requiredLevel) {
    autoProcessCompanionUpgrade(compUpgrade);
    // è™•ç†ä¸‹ä¸€å€‹åŒä¼´æˆ–çµæŸ
    processNextCompanionUpgrade(modalState);
    return;
  }
  
  // è¨­ç½®æ­¥é©Ÿç‚º statsï¼ˆå…ˆé¡¯ç¤ºèƒ½åŠ›æå‡ï¼‰
  compUpgrade.step = 'stats';
    modalState.step = 'companion-upgrade';
    renderLevelModal();
}

// è™•ç†ä¼™ä¼´å±¬æ€§é¸æ“‡
function selectCompanionAttribute(attributeId) {
  const modalState = state.ui.levelUp;
  if (!modalState || modalState.step !== 'companion-upgrade') return;
  
  if (!modalState.companionUpgrades || modalState.companionUpgrades.length === 0) return;
  
  const currentIndex = modalState.currentCompanionIndex || 0;
  const compUpgrade = modalState.companionUpgrades[currentIndex];
  if (!compUpgrade || compUpgrade.step !== 'attribute-selection') return;
  
  const companion = compUpgrade.companion;
  if (!companion) return;
  
  const currentSelection = compUpgrade.attributeSelections[compUpgrade.currentAttributeSelectionIndex];
  if (!currentSelection || currentSelection.selected) return;
  
  // æª¢æŸ¥å±¬æ€§IDæ˜¯å¦æœ‰æ•ˆ
  const attr = ATTRIBUTES.find(a => a.id === attributeId);
  if (!attr) return;
  
  // æå‡é¸ä¸­çš„å±¬æ€§
  const attributeBonus = currentSelection.bonus;
  companion.attributes[attributeId] = (companion.attributes[attributeId] || 0) + attributeBonus;
  
  // æ¨™è¨˜ç‚ºå·²é¸æ“‡
  currentSelection.selected = true;
  currentSelection.selectedAttribute = attributeId;
  
  pushLog(`${companion.name} Lv ${currentSelection.level}ï¼š${attr.name} +${attributeBonus}`);
  
  // æª¢æŸ¥æ˜¯å¦é‚„æœ‰æœªé¸æ“‡çš„å±¬æ€§
  compUpgrade.currentAttributeSelectionIndex += 1;
  
  if (compUpgrade.currentAttributeSelectionIndex >= compUpgrade.attributeSelections.length) {
    // æ‰€æœ‰å±¬æ€§éƒ½é¸æ“‡å®Œç•¢ï¼Œæª¢æŸ¥æ˜¯å¦æœ‰æŠ€èƒ½é¸æ“‡
    if (compUpgrade.skillSelections && compUpgrade.skillSelections.length > 0) {
      // æœ‰æŠ€èƒ½é¸æ“‡ï¼Œé€²å…¥æŠ€èƒ½é¸æ“‡æ­¥é©Ÿ
      compUpgrade.step = 'skill-selection';
      compUpgrade.currentSkillSelectionIndex = 0;
  } else {
      // æ²’æœ‰æŠ€èƒ½é¸æ“‡ï¼Œè™•ç†ä¸‹ä¸€å€‹ä¼™ä¼´æˆ–çµæŸ
      processNextCompanionUpgrade(modalState);
      return;
    }
  }
  
  renderAll();
}

// è™•ç†ä¼™ä¼´æŠ€èƒ½é¸æ“‡
function confirmCompanionSkillSelection(skillId) {
  const modalState = state.ui.levelUp;
  if (!modalState || modalState.step !== 'companion-upgrade') return;
  
  if (!modalState.companionUpgrades || modalState.companionUpgrades.length === 0) return;
  
  const currentIndex = modalState.currentCompanionIndex || 0;
  const compUpgrade = modalState.companionUpgrades[currentIndex];
  if (!compUpgrade || compUpgrade.step !== 'skill-selection') return;
  
  const companion = compUpgrade.companion;
  if (!companion) return;
  
  const currentSelection = compUpgrade.skillSelections[compUpgrade.currentSkillSelectionIndex];
  if (!currentSelection || currentSelection.selected) return;
  
  // æ‰¾åˆ°é¸ä¸­çš„æŠ€èƒ½
  const selectedSkill = currentSelection.options.find(s => s.id === skillId);
  if (!selectedSkill) return;
  
  // å­¸ç¿’æŠ€èƒ½
  learnCompanionSkill(companion, selectedSkill);
  
  // æ¨™è¨˜ç‚ºå·²é¸æ“‡
  currentSelection.selected = true;
  currentSelection.selectedSkillId = skillId;
  
  pushLog(`${companion.name} Lv ${currentSelection.level}ï¼šç¿’å¾—ã€Œ${selectedSkill.name}ã€ï¼`);
  
  // æª¢æŸ¥æ˜¯å¦é‚„æœ‰æœªé¸æ“‡çš„æŠ€èƒ½
  compUpgrade.currentSkillSelectionIndex += 1;
  
  if (compUpgrade.currentSkillSelectionIndex >= compUpgrade.skillSelections.length) {
    // æ‰€æœ‰æŠ€èƒ½éƒ½é¸æ“‡å®Œç•¢ï¼Œè™•ç†ä¸‹ä¸€å€‹ä¼™ä¼´æˆ–çµæŸ
    processNextCompanionUpgrade(modalState);
    return;
  }
  
  renderAll();
}

// è·³éä¼™ä¼´æŠ€èƒ½é¸æ“‡
function skipCompanionSkill() {
  const modalState = state.ui.levelUp;
  if (!modalState || modalState.step !== 'companion-upgrade') return;
  
  if (!modalState.companionUpgrades || modalState.companionUpgrades.length === 0) return;
  
  const currentIndex = modalState.currentCompanionIndex || 0;
  const compUpgrade = modalState.companionUpgrades[currentIndex];
  if (!compUpgrade || compUpgrade.step !== 'skill-selection') return;
  
  const currentSelection = compUpgrade.skillSelections[compUpgrade.currentSkillSelectionIndex];
  if (currentSelection && !currentSelection.selected) {
    // æ¨™è¨˜ç‚ºå·²è·³é
    currentSelection.selected = true;
    currentSelection.selectedSkillId = null;
    
    // æª¢æŸ¥æ˜¯å¦é‚„æœ‰æœªé¸æ“‡çš„æŠ€èƒ½
    compUpgrade.currentSkillSelectionIndex += 1;
    
    if (compUpgrade.currentSkillSelectionIndex >= compUpgrade.skillSelections.length) {
      // æ‰€æœ‰æŠ€èƒ½éƒ½è™•ç†å®Œç•¢ï¼Œè™•ç†ä¸‹ä¸€å€‹ä¼™ä¼´æˆ–çµæŸ
      processNextCompanionUpgrade(modalState);
      return;
    }
  }
  
  renderAll();
}

// è™•ç†ä¸‹ä¸€å€‹ä¼™ä¼´çš„å‡ç´š
function processNextCompanionUpgrade(modalState) {
  const currentIndex = modalState.currentCompanionIndex || 0;
  const nextIndex = currentIndex + 1;
  
  if (nextIndex >= modalState.companionUpgrades.length) {
    // æ‰€æœ‰ä¼™ä¼´éƒ½è™•ç†å®Œç•¢ï¼ŒçµæŸå‡ç´š
    concludeLevelUp();
    return;
  }
  
  // è™•ç†ä¸‹ä¸€å€‹ä¼™ä¼´
  modalState.currentCompanionIndex = nextIndex;
  const nextCompUpgrade = modalState.companionUpgrades[nextIndex];
  if (nextCompUpgrade) {
    nextCompUpgrade.step = 'stats';
    renderLevelModal();
  } else {
    concludeLevelUp();
  }
}

// ç¹¼çºŒä¼™ä¼´å‡ç´šï¼ˆå¾ stats æ­¥é©Ÿé€²å…¥å±¬æ€§é¸æ“‡ï¼‰
function continueCompanionLevelUp() {
  const modalState = state.ui.levelUp;
  if (!modalState || modalState.step !== 'companion-upgrade') return;
  
  if (!modalState.companionUpgrades || modalState.companionUpgrades.length === 0) return;
  
  const currentIndex = modalState.currentCompanionIndex || 0;
  const compUpgrade = modalState.companionUpgrades[currentIndex];
  if (!compUpgrade || compUpgrade.step !== 'stats') return;
  
  // å¦‚æœæ˜¯åˆå§‹è‡ªå‹•å‡ç´šï¼Œè‡ªå‹•è™•ç†æ‰€æœ‰é¸æ“‡
  const isInitialAutoLevel = modalState.isInitialAutoLevel || false;
  if (isInitialAutoLevel) {
    autoProcessCompanionUpgrade(compUpgrade);
    processNextCompanionUpgrade(modalState);
    return;
  }
  
  // æª¢æŸ¥æ˜¯å¦æœ‰å±¬æ€§é¸æ“‡
  if (compUpgrade.attributeSelections && compUpgrade.attributeSelections.length > 0) {
    // æœ‰å±¬æ€§é¸æ“‡ï¼Œé€²å…¥å±¬æ€§é¸æ“‡æ­¥é©Ÿ
    compUpgrade.step = 'attribute-selection';
    compUpgrade.currentAttributeSelectionIndex = 0;
  } else if (compUpgrade.skillSelections && compUpgrade.skillSelections.length > 0) {
    // æ²’æœ‰å±¬æ€§é¸æ“‡ï¼Œä½†æœ‰æŠ€èƒ½é¸æ“‡ï¼Œé€²å…¥æŠ€èƒ½é¸æ“‡æ­¥é©Ÿ
    compUpgrade.step = 'skill-selection';
    compUpgrade.currentSkillSelectionIndex = 0;
  } else {
    // æ²’æœ‰å±¬æ€§é¸æ“‡ä¹Ÿæ²’æœ‰æŠ€èƒ½é¸æ“‡ï¼Œè™•ç†ä¸‹ä¸€å€‹ä¼™ä¼´æˆ–çµæŸ
    processNextCompanionUpgrade(modalState);
    return;
  }
  
  renderAll();
}

function concludeLevelUp() {
  const wasBossRewardPending = state.ui.bossRewardPending;
  state.ui.levelUp = null;
  
  // å¦‚æœæ˜¯åœ¨æ‰“è´¥é­”ç‹åç­‰å¾…å‡çº§å®Œæˆï¼Œç°åœ¨å¤„ç†é­”ç‹å¥–åŠ±
  if (wasBossRewardPending) {
    state.ui.bossRewardPending = false;
    handleBossReward();
  }
  
  renderAll();
}

// è™•ç†æ‰“æ•—é­”ç‹å¾Œçš„çå‹µï¼ˆé¸æ“‡åœ£ç‰©ï¼Œ3é€‰1ï¼‰
function handleBossReward(forceRelicSelection = false) {
  const currentStage = state.world.stage;
  const maxCompanionCount = GAME_CONFIG.maxCompanionCount || 4;
  
  // å¦‚æœå¼·åˆ¶é¡¯ç¤ºåœ£ç‰©é¸æ“‡ï¼ˆå·²ç¶“é¸æ“‡äº†ä¸€å€‹åŒä¼´ï¼‰ï¼Œæˆ–è€…å·²ç¶“é”åˆ°æœ€å¤§åŒä¼´æ•¸é‡ï¼Œç›´æ¥é¡¯ç¤ºåœ£ç‰©é¸æ“‡
  if (forceRelicSelection || state.companions.length >= maxCompanionCount) {
    // ç›´æ¥é¡¯ç¤ºåœ£ç‰©é¸æ“‡ï¼Œè·³éåŒä¼´é¸æ“‡
  } else {
    // æª¢æŸ¥æ˜¯å¦é‚„å¯ä»¥é¸æ“‡æ–°åŒä¼´ï¼ˆç¬¬ä¸€æ¬¡èª¿ç”¨æ™‚ï¼‰
    // å¯ä»¥é¸æ“‡æ–°åŒä¼´ï¼Œå…ˆé¡¯ç¤ºåŒä¼´é¸æ“‡ç•Œé¢
      state.ui.companionSelection = 'boss-reward';
      dom.modalLayer.classList.remove('hidden');
      dom.levelModal.innerHTML = renderCompanionSelection();
      renderLevelModal();
    return;
  }
  
  // ç¢ºå®šå¯é¸æ“‡çš„åœ£ç‰©éšæ®µç¯„åœ
  let availableStages = [currentStage];
  
  // å¦‚æœæ˜¯testModeï¼Œå…è®¸éšæœºé€‰æ‹©æ›´é«˜é˜¶æ®µçš„åœ£ç‰©
  if (GAME_CONFIG.testMode) {
    // å¯ä»¥éšæœºé€‰æ‹©å½“å‰é˜¶æ®µæˆ–æ›´é«˜é˜¶æ®µçš„åœ£ç‰©ï¼ˆæœ€é«˜åˆ°é˜¶æ®µ6ï¼‰
    const maxStage = 6;
    const minStage = currentStage;
    // éšæœºå†³å®šæ˜¯å¦è·³è¿‡é˜¶æ®µï¼ˆ50%æ¦‚ç‡ï¼‰
    if (Math.random() < 0.5) {
      // è·³è¿‡é˜¶æ®µï¼šéšæœºé€‰æ‹©æ¯”å½“å‰é˜¶æ®µé«˜1-3ä¸ªé˜¶æ®µçš„åœ£ç‰©
      const skipAmount = Math.floor(Math.random() * 3) + 1; // 1-3
      const targetStage = Math.min(maxStage, currentStage + skipAmount);
      availableStages = [targetStage];
      pushLog(`[æ¸¬è©¦æ¨¡å¼] è·³ééšæ®µï¼Œå¯é¸æ“‡éšæ®µ ${targetStage} çš„åœ£ç‰©ï¼`);
    } else {
      // ä¸è·³è¿‡ï¼šåªé€‰æ‹©å½“å‰é˜¶æ®µ
      availableStages = [currentStage];
    }
  }
  
  // ä»å¯ç”¨é˜¶æ®µçš„åœ£ç‰©ä¸­éšæœºé€‰æ‹©3ä¸ª
  const stageRelics = state.relics.filter(relic => availableStages.includes(relic.stage));
  if (stageRelics.length === 0) {
    pushLog(`æ²’æœ‰å¯é¸æ“‡çš„åœ£ç‰©ã€‚`);
      advanceToNextStage();
    return;
  }
  
  // éšæœºé€‰æ‹©3ä¸ªåœ£ç‰©
  const selectedRelics = [];
  const availableRelics = [...stageRelics];
  for (let i = 0; i < 3 && availableRelics.length > 0; i++) {
    const randomIndex = Math.floor(Math.random() * availableRelics.length);
    selectedRelics.push(availableRelics.splice(randomIndex, 1)[0]);
  }
  
  // æ˜¾ç¤ºåœ£ç‰©é€‰æ‹©ç•Œé¢
  state.ui.relicSelection = {
    relics: selectedRelics,
    stage: currentStage,
  };
  dom.modalLayer.classList.remove('hidden');
  dom.levelModal.innerHTML = renderRelicSelection();
  renderLevelModal();
}

// é€²å…¥ä¸‹ä¸€éšæ®µçš„ç¬¬ä¸€ç¯€é»
function advanceToNextStage() {
  const TOTAL_STAGES = 6;
  if (state.world.stage < TOTAL_STAGES) {
    // é€²å…¥ä¸‹ä¸€éšæ®µ
    state.world.stage += 1;
    state.world.currentNodeIndex = 0; // è¨­ç½®ç‚ºç¬¬ä¸€ç¯€é»
    state.world.nodes = generateRoute(state.world.stage);
    // ç¬¬ä¸‰éšæ®µä»¥å¾Œéƒ½è¨­ç½®ç‚º castle
    // renderBackground æœƒæ ¹æ“š stage è‡ªå‹•è¨­ç½®æ­£ç¢ºçš„ currentArea
    renderBackground();
    
    // è£œæ»¿æ‰€æœ‰äººçš„HP/MP
    if (state.hero && state.hero.stats) {
      state.hero.stats.hp = state.hero.stats.maxHp;
      state.hero.stats.mp = state.hero.stats.maxMp;
    }
    if (state.companions && state.companions.length > 0) {
      state.companions.forEach(companion => {
        if (companion && companion.stats) {
          companion.stats.hp = companion.stats.maxHp;
          companion.stats.mp = companion.stats.maxMp;
        }
      });
    }
    
    const prevAreaName = AREA_CONFIG[getAreaKeyByStage(state.world.stage - 1)]?.name || `ç¬¬${state.world.stage - 1}éšæ®µ`;
    const currentAreaName = AREA_CONFIG[state.world.currentArea]?.name || `ç¬¬${state.world.stage}éšæ®µ`;
    pushLog(`æ­å–œï¼ä½ å®Œæˆäº†${prevAreaName}ï¼Œé€²å…¥äº†${currentAreaName}ï¼`);
    pushLog('æ‰€æœ‰äººçš„HPå’ŒMPéƒ½å·²è£œæ»¿ï¼');
    renderBackground();
    
    // é¡¯ç¤ºæ–°ç« ç¯€çš„æ•…äº‹
    showStageStory(state.world.stage);
    
    // ä¿å­˜éšæ®µå‚™ä»½ï¼ˆé€²å…¥æ–°éšæ®µçš„ç¬¬ä¸€å€‹ç¯€é»æ™‚ï¼‰
    saveStageBackup();
  } else {
    // å®Œæˆæ‰€æœ‰éšæ®µï¼ŒéŠæˆ²çµæŸ
    pushLog('æ­å–œï¼ä½ æ“Šæ•—äº†æ‰€æœ‰é­”ç‹ï¼Œå®Œæˆäº†å†’éšªï¼');
    handleGameOver();
  }
}

function learnSkill(skill) {
  const hero = state.hero;
  const chain = SKILL_CHAINS.find((c) => c.id === skill.chainId);
  
  // å¦‚æœæ˜¯é˜²å®ˆå‹è¢«å‹•æŠ€èƒ½ï¼Œå…ˆè¨ˆç®—èˆŠçš„HPåŠ æˆ
  let oldHpBonus = 0;
  if (skill.kind === 'passive' && skill.flow === 'defender' && skill.hpBonus !== undefined) {
    const oldDefenderEffects = getDefenderPassiveEffects(hero);
    oldHpBonus = oldDefenderEffects.hpBonus;
  }
  
  // å¦‚æœæ˜¯é­”æ³•å‹è¢«å‹•æŠ€èƒ½ï¼Œå…ˆè¨ˆç®—èˆŠçš„MPåŠ æˆ
  let oldMpBonus = 0;
  if (skill.kind === 'passive' && skill.flow === 'magic' && skill.mpBonus !== undefined) {
    const oldMagicEffects = getMagicPassiveEffects(hero);
    oldMpBonus = oldMagicEffects.mpBonus || 0;
  }
  
  // å¦‚æœæ˜¯å‹‡è€…ä¹‹è¡€è¢«å‹•æŠ€èƒ½ï¼Œå…ˆè¨ˆç®—èˆŠçš„MPåŠ æˆ
  let oldHeroBloodMpBonus = 0;
  if (skill.kind === 'passive' && skill.flow === 'hero' && skill.mpBonus !== undefined) {
    const oldHeroBloodEffects = getHeroBloodPassiveEffects(hero);
    oldHeroBloodMpBonus = oldHeroBloodEffects.mpBonus || 0;
  }
  
  if (chain) {
    // æ£€æŸ¥æ˜¯å¦å·²ç»å­¦ä¹ äº†åŒä¸€æŠ€èƒ½é“¾ä¸­çš„æ›´é«˜é˜¶æŠ€èƒ½
    const hasHigherTier = chain.steps.some((step) => {
      if (step.tier > skill.tier && hero.skills.includes(step.id)) {
        return true;
      }
      return false;
    });
    
    if (hasHigherTier) {
      // å¦‚æœå·²ç»å­¦ä¹ äº†æ›´é«˜é˜¶çš„æŠ€èƒ½ï¼Œä¸å­¦ä¹ è¿™ä¸ªè¾ƒä½é˜¶çš„æŠ€èƒ½
      return;
    }
    
    // æ‰¾åˆ°åŒä¸€æŠ€èƒ½é“¾ä¸­æ‰€æœ‰è¾ƒä½é˜¶çš„æŠ€èƒ½å¹¶ç§»é™¤ï¼ˆå‡é˜¶æ›¿æ¢ï¼‰
    chain.steps.forEach((step) => {
      if (step.tier < skill.tier && hero.skills.includes(step.id)) {
        hero.skills = hero.skills.filter((id) => id !== step.id);
      }
    });
  }
  // æ·»åŠ æ–°æŠ€èƒ½ï¼ˆå¦‚æœè¿˜æ²¡æœ‰ï¼‰
  if (!hero.skills.includes(skill.id)) {
    hero.skills.push(skill.id);
  }
  
  // å¦‚æœæ˜¯é˜²å®ˆå‹è¢«å‹•æŠ€èƒ½ï¼Œæ‡‰ç”¨HPåŠ æˆ
  if (skill.kind === 'passive' && skill.flow === 'defender' && skill.hpBonus !== undefined) {
    const newDefenderEffects = getDefenderPassiveEffects(hero);
    const newHpBonus = newDefenderEffects.hpBonus;
    const hpGain = newHpBonus - oldHpBonus;
    
    if (hpGain !== 0) {
      const oldMaxHp = hero.stats.maxHp;
      hero.stats.maxHp = Math.ceil(hero.stats.maxHp + hpGain);
      // å¦‚æœç•¶å‰HPæœªæ»¿ï¼ŒæŒ‰æ¯”ä¾‹å¢åŠ 
      if (hero.stats.hp < oldMaxHp) {
        const hpPercent = hero.stats.hp / oldMaxHp;
        hero.stats.hp = Math.ceil(hero.stats.maxHp * hpPercent);
      } else {
        // å¦‚æœHPå·²æ»¿ï¼Œç›´æ¥å¢åŠ åˆ°æ–°çš„æœ€å¤§å€¼
        hero.stats.hp = hero.stats.maxHp;
      }
    }
  }
  
  // å¦‚æœæ˜¯é­”æ³•å‹è¢«å‹•æŠ€èƒ½ï¼Œæ‡‰ç”¨MPåŠ æˆ
  if (skill.kind === 'passive' && skill.flow === 'magic' && skill.mpBonus !== undefined) {
    const newMagicEffects = getMagicPassiveEffects(hero);
    const newMpBonus = newMagicEffects.mpBonus || 0;
    const mpGain = newMpBonus - oldMpBonus;
    
    if (mpGain !== 0) {
      const oldMaxMp = hero.stats.maxMp;
      hero.stats.maxMp = Math.ceil(hero.stats.maxMp + mpGain);
      // å¦‚æœç•¶å‰MPæœªæ»¿ï¼ŒæŒ‰æ¯”ä¾‹å¢åŠ 
      if (hero.stats.mp < oldMaxMp) {
        const mpPercent = hero.stats.mp / oldMaxMp;
        hero.stats.mp = Math.ceil(hero.stats.maxMp * mpPercent);
      } else {
        // å¦‚æœMPå·²æ»¿ï¼Œç›´æ¥å¢åŠ åˆ°æ–°çš„æœ€å¤§å€¼
        hero.stats.mp = hero.stats.maxMp;
      }
    }
  }
  
  // å¦‚æœæ˜¯å‹‡è€…ä¹‹è¡€è¢«å‹•æŠ€èƒ½ï¼Œæ‡‰ç”¨MPåŠ æˆï¼ˆå›å¾©ä¹‹è¡€å’Œæ³•å¸«ä¹‹è¡€éƒ½æœ‰MP+100ï¼‰
  if (skill.kind === 'passive' && skill.flow === 'hero' && skill.mpBonus !== undefined) {
    const newHeroBloodEffects = getHeroBloodPassiveEffects(hero);
    const newMpBonus = newHeroBloodEffects.mpBonus || 0;
    const mpGain = newMpBonus - oldHeroBloodMpBonus;
    
    if (mpGain !== 0) {
      const oldMaxMp = hero.stats.maxMp;
      hero.stats.maxMp = Math.ceil(hero.stats.maxMp + mpGain);
      // å¦‚æœç•¶å‰MPæœªæ»¿ï¼ŒæŒ‰æ¯”ä¾‹å¢åŠ 
      if (hero.stats.mp < oldMaxMp) {
        const mpPercent = hero.stats.mp / oldMaxMp;
        hero.stats.mp = Math.ceil(hero.stats.maxMp * mpPercent);
      } else {
        // å¦‚æœMPå·²æ»¿ï¼Œç›´æ¥å¢åŠ åˆ°æ–°çš„æœ€å¤§å€¼
        hero.stats.mp = hero.stats.maxMp;
      }
    }
  }
}

// åŒä¼´å­¸ç¿’æŠ€èƒ½ï¼ˆèˆ‡å‹‡è€…å­¸ç¿’æŠ€èƒ½é‚è¼¯ç›¸åŒï¼Œæœƒè‡ªå‹•æ›¿æ›ä½éšæŠ€èƒ½ï¼‰
function learnCompanionSkill(companion, skill) {
  if (!companion || !skill) return;
  
  const chain = SKILL_CHAINS.find((c) => c.id === skill.chainId);
  
  // å¦‚æœæ˜¯é˜²å®ˆå‹è¢«å‹•æŠ€èƒ½ï¼Œå…ˆè¨ˆç®—èˆŠçš„HPåŠ æˆ
  let oldHpBonus = 0;
  if (skill.kind === 'passive' && skill.flow === 'defender' && skill.hpBonus !== undefined) {
    const oldDefenderEffects = getDefenderPassiveEffects(companion);
    oldHpBonus = oldDefenderEffects.hpBonus;
  }
  
  // å¦‚æœæ˜¯é­”æ³•å‹è¢«å‹•æŠ€èƒ½ï¼Œå…ˆè¨ˆç®—èˆŠçš„MPåŠ æˆ
  let oldMpBonus = 0;
  if (skill.kind === 'passive' && skill.flow === 'magic' && skill.mpBonus !== undefined) {
    const oldMagicEffects = getMagicPassiveEffects(companion);
    oldMpBonus = oldMagicEffects.mpBonus || 0;
  }
  
  // å¦‚æœæ˜¯å‹‡è€…ä¹‹è¡€è¢«å‹•æŠ€èƒ½ï¼Œå…ˆè¨ˆç®—èˆŠçš„MPåŠ æˆ
  let oldHeroBloodMpBonus = 0;
  if (skill.kind === 'passive' && skill.flow === 'hero' && skill.mpBonus !== undefined) {
    const oldHeroBloodEffects = getHeroBloodPassiveEffects(companion);
    oldHeroBloodMpBonus = oldHeroBloodEffects.mpBonus || 0;
  }
  
  if (chain) {
    // æ£€æŸ¥æ˜¯å¦å·²ç»å­¦ä¹ äº†åŒä¸€æŠ€èƒ½é“¾ä¸­çš„æ›´é«˜é˜¶æŠ€èƒ½
    const hasHigherTier = chain.steps.some((step) => {
      if (step.tier > skill.tier && companion.skills.includes(step.id)) {
        return true;
      }
      return false;
    });
    
    if (hasHigherTier) {
      // å¦‚æœå·²ç»å­¦ä¹ äº†æ›´é«˜é˜¶çš„æŠ€èƒ½ï¼Œä¸å­¦ä¹ è¿™ä¸ªè¾ƒä½é˜¶çš„æŠ€èƒ½
      return;
    }
    
    // æ‰¾åˆ°åŒä¸€æŠ€èƒ½é“¾ä¸­æ‰€æœ‰è¾ƒä½é˜¶çš„æŠ€èƒ½å¹¶ç§»é™¤ï¼ˆå‡é˜¶æ›¿æ¢ï¼‰
    chain.steps.forEach((step) => {
      if (step.tier < skill.tier && companion.skills.includes(step.id)) {
        companion.skills = companion.skills.filter((id) => id !== step.id);
      }
    });
  }
  
  // æ·»åŠ æ–°æŠ€èƒ½ï¼ˆå¦‚æœè¿˜æ²¡æœ‰ï¼‰
  if (!companion.skills.includes(skill.id)) {
    companion.skills.push(skill.id);
  }
  
  // å¦‚æœæ˜¯é˜²å®ˆå‹è¢«å‹•æŠ€èƒ½ï¼Œæ‡‰ç”¨HPåŠ æˆ
  if (skill.kind === 'passive' && skill.flow === 'defender' && skill.hpBonus !== undefined) {
    const newDefenderEffects = getDefenderPassiveEffects(companion);
    const newHpBonus = newDefenderEffects.hpBonus;
    const hpGain = newHpBonus - oldHpBonus;
    
    if (hpGain !== 0) {
      const oldMaxHp = companion.stats.maxHp;
      companion.stats.maxHp = Math.ceil(companion.stats.maxHp + hpGain);
      // å¦‚æœç•¶å‰HPæœªæ»¿ï¼ŒæŒ‰æ¯”ä¾‹å¢åŠ 
      if (companion.stats.hp < oldMaxHp) {
        const hpPercent = companion.stats.hp / oldMaxHp;
        companion.stats.hp = Math.ceil(companion.stats.maxHp * hpPercent);
      } else {
        // å¦‚æœHPå·²æ»¿ï¼Œç›´æ¥å¢åŠ åˆ°æ–°çš„æœ€å¤§å€¼
        companion.stats.hp = companion.stats.maxHp;
      }
    }
  }
  
  // å¦‚æœæ˜¯é­”æ³•å‹è¢«å‹•æŠ€èƒ½ï¼Œæ‡‰ç”¨MPåŠ æˆ
  if (skill.kind === 'passive' && skill.flow === 'magic' && skill.mpBonus !== undefined) {
    const newMagicEffects = getMagicPassiveEffects(companion);
    const newMpBonus = newMagicEffects.mpBonus || 0;
    const mpGain = newMpBonus - oldMpBonus;
    
    if (mpGain !== 0) {
      const oldMaxMp = companion.stats.maxMp;
      companion.stats.maxMp = Math.ceil(companion.stats.maxMp + mpGain);
      // å¦‚æœç•¶å‰MPæœªæ»¿ï¼ŒæŒ‰æ¯”ä¾‹å¢åŠ 
      if (companion.stats.mp < oldMaxMp) {
        const mpPercent = companion.stats.mp / oldMaxMp;
        companion.stats.mp = Math.ceil(companion.stats.maxMp * mpPercent);
      } else {
        // å¦‚æœMPå·²æ»¿ï¼Œç›´æ¥å¢åŠ åˆ°æ–°çš„æœ€å¤§å€¼
        companion.stats.mp = companion.stats.maxMp;
      }
    }
  }
  
  // å¦‚æœæ˜¯å‹‡è€…ä¹‹è¡€è¢«å‹•æŠ€èƒ½ï¼Œæ‡‰ç”¨MPåŠ æˆï¼ˆå›å¾©ä¹‹è¡€å’Œæ³•å¸«ä¹‹è¡€éƒ½æœ‰MP+100ï¼‰
  if (skill.kind === 'passive' && skill.flow === 'hero' && skill.mpBonus !== undefined) {
    const newHeroBloodEffects = getHeroBloodPassiveEffects(companion);
    const newMpBonus = newHeroBloodEffects.mpBonus || 0;
    const mpGain = newMpBonus - oldHeroBloodMpBonus;
    
    if (mpGain !== 0) {
      const oldMaxMp = companion.stats.maxMp;
      companion.stats.maxMp = Math.ceil(companion.stats.maxMp + mpGain);
      // å¦‚æœç•¶å‰MPæœªæ»¿ï¼ŒæŒ‰æ¯”ä¾‹å¢åŠ 
      if (companion.stats.mp < oldMaxMp) {
        const mpPercent = companion.stats.mp / oldMaxMp;
        companion.stats.mp = Math.ceil(companion.stats.maxMp * mpPercent);
      } else {
        // å¦‚æœMPå·²æ»¿ï¼Œç›´æ¥å¢åŠ åˆ°æ–°çš„æœ€å¤§å€¼
        companion.stats.mp = companion.stats.maxMp;
      }
    }
  }
}

function resolveNode(nodeId) {
  if (state.ui.levelUp || state.ui.battle || state.ui.startMenu) return;
  if (!state.hero) return;
  const node = state.world.nodes.find((n) => n.id === nodeId);
  if (!node || state.hero.stats.hp <= 0) return;
  switch (node.type) {
    case 'battle':
      startBattle(node, 1);
      break;
    case 'elite':
      startBattle(node, 1.6);
      break;
    case 'event':
      handleEvent(node);
      break;
    case 'rest':
      handleRest(node);
      break;
    case 'town':
      handleTown(node);
      break;
    default:
      break;
  }
  renderAll();
}

function startBattle(option, multiplier = 1) {
  let enemies = [];
  
  // å¦‚æœé¸é …ä¸­æœ‰é ç”Ÿæˆçš„æ€ªç‰©ï¼Œä½¿ç”¨å®ƒå€‘çš„é¡å‹ä½†æ ¹æ“šç•¶å‰è‹±é›„ç­‰ç´šé‡æ–°ç”Ÿæˆ
  if (option.preGeneratedEnemies && option.preGeneratedEnemies.length > 0) {
    const hero = state.hero;
    const heroLevel = (hero && hero.stats && typeof hero.stats.level === 'number') ? hero.stats.level : 1;
    const isElite = multiplier >= 1.5;
    const isBossBattle = multiplier >= 2.5;
    
    // ç²å–ç•¶å‰éšæ®µçš„ tierï¼ˆç”¨æ–¼é©—è­‰æ€ªç‰©æ˜¯å¦å±¬æ–¼æ­£ç¢ºçš„ tierï¼‰
    const currentStage = state.world && state.world.stage ? state.world.stage : 1;
    const currentTier = Math.min(6, Math.max(1, currentStage));
    
    // ä½¿ç”¨é ç”Ÿæˆæ€ªç‰©çš„æ¨¡æ¿ä¿¡æ¯ï¼Œä½†æ ¹æ“šç•¶å‰è‹±é›„ç­‰ç´šé‡æ–°ç”Ÿæˆ
    // ç¢ºä¿ä½¿ç”¨ç›¸åŒçš„æ€ªç‰©é¡å‹ï¼ˆä¿æŒèˆ‡è·¯ç·šé¡¯ç¤ºä¸€è‡´ï¼‰
    option.preGeneratedEnemies.forEach(preGenEnemy => {
      // å¾é ç”Ÿæˆçš„æ€ªç‰©ä¸­ç²å–æ¨¡æ¿ä¿¡æ¯ï¼ˆä½¿ç”¨idåŒ¹é…ï¼‰
      // preGenEnemy å¯èƒ½æ˜¯å®Œæ•´å°è±¡æˆ–åªæœ‰ id å’Œ name çš„å°è±¡
      const enemyId = preGenEnemy.id || preGenEnemy;
      const enemyTemplate = ENEMY_DECK.find(e => e.id === enemyId);
      if (enemyTemplate) {
        // å¦‚æœæ˜¯bossæˆ°ï¼Œç›´æ¥ä½¿ç”¨é ç”Ÿæˆçš„bosså’Œéƒ¨ä¸‹ï¼ˆä¸é©—è­‰tierï¼Œå› ç‚ºbosså’Œéƒ¨ä¸‹å¯èƒ½åœ¨ä¸åŒéšæ®µï¼‰
        if (isBossBattle) {
          if (enemyTemplate.monsterType === 'boss') {
            // é­”ç‹ä½¿ç”¨ç²¾è‹±ç­‰ç´š
            const regeneratedEnemy = createEnemy(enemyTemplate, heroLevel, true, currentStage);
            enemies.push(regeneratedEnemy);
          } else {
            // éƒ¨ä¸‹ä½¿ç”¨æ™®é€šç­‰ç´šï¼ˆé­”ç‹æˆ°ä¸­çš„éƒ¨ä¸‹ä¸æ˜¯ç²¾è‹±ï¼‰
            const regeneratedEnemy = createEnemy(enemyTemplate, heroLevel, false, currentStage);
            enemies.push(regeneratedEnemy);
          }
        } else {
        // é©—è­‰æ¨¡æ¿æ˜¯å¦å±¬æ–¼ç•¶å‰ tierï¼ˆç¢ºä¿ç²¾è‹±æˆ°é¬¥ä¹Ÿä½¿ç”¨æ­£ç¢º tier çš„æ€ªç‰©ï¼‰
        if (enemyTemplate.tier !== currentTier) {
          // é‡æ–°é¸æ“‡æ­£ç¢º tier çš„æ€ªç‰©ï¼ˆä½†ä¿æŒç²¾è‹±æ¨™è¨˜ï¼‰
          // ç¢ºä¿ä¸æ˜¯bossæˆ°ï¼ˆæ™®é€šæˆ°é¬¥å’Œç²¾è‹±æˆ°é¬¥éƒ½ä¸æœƒé¸æ“‡bossï¼‰
          const correctEnemy = pickEnemy(currentStage, multiplier, state.world.currentNodeIndex, false);
          enemies.push(correctEnemy);
        } else {
          // ä½¿ç”¨ç›¸åŒçš„æ€ªç‰©æ¨¡æ¿ï¼Œæ ¹æ“šç•¶å‰è‹±é›„ç­‰ç´šé‡æ–°ç”Ÿæˆï¼ˆä¿æŒèˆ‡è·¯ç·šé¡¯ç¤ºä¸€è‡´ï¼‰
        const regeneratedEnemy = createEnemy(enemyTemplate, heroLevel, isElite, currentStage);
        enemies.push(regeneratedEnemy);
          }
        }
      } else {
        // å¦‚æœæ‰¾ä¸åˆ°æ¨¡æ¿ï¼Œé‡æ–°é¸æ“‡æ­£ç¢º tier çš„æ€ªç‰©
        // å¦‚æœæ˜¯bossæˆ°ï¼Œå…è¨±é¸æ“‡bossï¼›å¦å‰‡ä¸å…è¨±
        const correctEnemy = pickEnemy(currentStage, multiplier, state.world.currentNodeIndex, isBossBattle);
        enemies.push(correctEnemy);
      }
    });
  } else {
    // æ²’æœ‰é ç”Ÿæˆçš„æ€ªç‰©ï¼Œä½¿ç”¨åŸæœ‰é‚è¼¯ç”Ÿæˆ
    const hero = state.hero;
    const heroLevel = (hero && hero.stats && typeof hero.stats.level === 'number') ? hero.stats.level : 1;
    
    // è¨ˆç®—ç•¶å‰é—œå¡æ•¸ï¼ˆåŸºæ–¼ç¯€é»ç´¢å¼•ï¼Œå¾1é–‹å§‹ï¼‰
    const currentFloor = (state.world.currentNodeIndex || 0) + 1;
    
    // è¨ˆç®—ç•¶å‰éšå±¤ï¼ˆæ¯20é—œä¸€å€‹éšå±¤ï¼Œ1-20æ˜¯ç¬¬ä¸€éšå±¤ï¼Œ21-40æ˜¯ç¬¬äºŒéšå±¤ï¼Œä¾æ­¤é¡æ¨ï¼‰
    const tier = Math.min(6, Math.max(1, Math.ceil(currentFloor / 20)));
    
    // åˆ¤æ–·æ˜¯å¦ç‚ºBOSSæˆ°ï¼ˆåªæœ‰åœ¨æœ€å¾Œä¸€å€‹ç¯€é»ä¸”multiplier >= 2.5æ™‚æ‰æ˜¯bossæˆ°ï¼‰
    // æ™®é€šæˆ°é¬¥å’Œç²¾è‹±æˆ°é¬¥éƒ½ä¸æœƒé¸æ“‡boss
    const isBossBattle = multiplier >= 2.5;
    
    const isElite = multiplier >= 1.5;
    
    // å¦‚æœæ˜¯BOSSæˆ°ï¼Œåªç”Ÿæˆä¸€å€‹BOSSï¼ˆåªæœ‰åœ¨æœ€å¾Œä¸€å€‹ç¯€é»æ‰æœƒï¼‰
    if (isBossBattle) {
      // å¦‚æœæŒ‡å®šäº†bossIdï¼ˆä¾‹å¦‚å¾äº‹ä»¶ä¸­é¸æ“‡ä¹‹å‰çš„é­”ç‹ï¼‰ï¼Œä½¿ç”¨æŒ‡å®šçš„boss
      if (option.bossId) {
        const bossTemplate = ENEMY_DECK.find(e => e.id === option.bossId && e.monsterType === 'boss');
        if (bossTemplate) {
          const bossEnemy = createEnemy(bossTemplate, heroLevel, true, tier);
          enemies.push(bossEnemy);
        } else {
          // å¦‚æœæ‰¾ä¸åˆ°æŒ‡å®šçš„bossï¼Œå›é€€åˆ°éšæœºé€‰æ‹©
      const enemy = pickEnemy(state.world.stage, multiplier, state.world.currentNodeIndex, true);
      enemies.push(enemy);
        }
    } else {
        const enemy = pickEnemy(state.world.stage, multiplier, state.world.currentNodeIndex, true);
        enemies.push(enemy);
      }
    } else {
      // æ™®é€šæˆ°é¬¥æˆ–ç²¾è‹±æˆ°é¬¥ï¼šæ ¹æ“šé…ç½®æ±ºå®šæ•µäººæ•¸é‡ç¯„åœ
      const stageConfig = GAME_CONFIG.stageMonsterCounts[tier] || GAME_CONFIG.stageMonsterCounts[6];
      const minEnemies = stageConfig.min;
      const maxEnemies = stageConfig.max;
      
      // ç²¾è‹±æˆ°é¬¥ä½¿ç”¨æœ€å¤§å€¼ï¼Œæ™®é€šæˆ°é¬¥ä½¿ç”¨éš¨æ©Ÿå€¼
      const enemyCount = isElite ? maxEnemies : randomRange(minEnemies, maxEnemies);
      
      for (let i = 0; i < enemyCount; i++) {
        // ç¢ºä¿ä¸æ˜¯bossæˆ°ï¼ˆæ™®é€šæˆ°é¬¥å’Œç²¾è‹±æˆ°é¬¥éƒ½ä¸æœƒé¸æ“‡bossï¼‰
        const enemy = pickEnemy(state.world.stage, multiplier, state.world.currentNodeIndex, false);
        // æ€ªç‰©ç­‰ç´šå·²ç¶“åœ¨createEnemyä¸­æ ¹æ“šå‹‡è€…ç­‰ç´šè¨ˆç®—å¥½äº†ï¼Œä¸éœ€è¦å†å‡ç´š
        enemies.push(enemy);
      }
    }
  }
  
  state.ui.battle = {
    option,
    multiplier,
    enemies,
    selectedEnemyIndex: null,
    turn: 'hero',
    menu: 'root',
    heroBuffs: { guard: 0, swordIntent: null, deathWard: false, healingEcho: 0 }, // swordIntent: { attackBoost, critBoost, duration }, deathWard: é˜²æ­»è­·ç›¾, healingEcho: ç·©æ…¢æ¢å¾©å€¼
    companionBuffs: {}, // { companionIndex: { guard: 0, swordIntent: null, deathWard: false, healingEcho: 0 } }
    actionQueue: [], // è¡Œå‹•éšŠåˆ—ï¼ˆæŒ‰æ•æ·æ’åºï¼‰
    heroAction: null, // å‹‡è€…é¸æ“‡çš„è¡Œå‹•ï¼ˆå¾…åŸ·è¡Œï¼‰
    defenseWaveUsers: [], // æœ¬å›åˆä½¿ç”¨é˜²å®ˆè¡æ“ŠæŠ€èƒ½çš„ä½¿ç”¨è€…åˆ—è¡¨
    isExecutingActions: false, // æ˜¯å¦æ­£åœ¨åŸ·è¡Œè¡Œå‹•éšŠåˆ—
    battleLog: [], // æˆ°é¬¥æ—¥èªŒï¼ˆåªè¨˜éŒ„æˆ°é¬¥å…§çš„æ¶ˆæ¯ï¼‰
    pendingItem: null, // å¾…ä½¿ç”¨çš„é“å…·
    stolenEnemies: new Set(), // è¿½è¹¤å·²è¢«å·å–çš„æ€ªç‰©ç´¢å¼•
    enemyDebuffs: {}, // æ•µäººdebuffç‹€æ…‹ï¼Œæ ¼å¼ï¼š{ enemyIndex: { poison: { duration: 3, damage: 10, casterAgility: 30 } } }
    friendlyDebuffs: { hero: {}, companions: {} }, // å‹æ–¹debuffç‹€æ…‹ï¼Œæ ¼å¼ï¼š{ hero: { poison: {...}, slow: {...}, defenseDown: {...} }, companions: { companionIndex: { ... } } }
    aura: null, // ç•¶å‰å…‰ç’°ç‹€æ…‹ { type: 'attack'|'defense'|'hpRegen'|'mpRegen', caster: character, duration: number, value: number }
    turnCount: 0, // æˆ°é¬¥å›åˆæ•¸
    healingEchoUsed: false, // ç¥è–å›éŸ¿æ˜¯å¦å·²åœ¨æœ¬æ¬¡æˆ°é¬¥ä¸­ä½¿ç”¨é
  };
  
  const enemyNames = enemies.map(e => `${e.name}${e.isElite ? ' (èè‹±)' : ''} Lv${e.stats.level}`).join('ã€');
  pushBattleLog(`é­é‡ ${enemyNames}ï¼`); // åªè¨˜éŒ„åˆ°æˆ°é¬¥æ—¥èªŒ
  pushLog(`${option.label}ï¼šé­é‡ ${enemyNames}ï¼`); // ä¹Ÿè¨˜éŒ„åˆ°å†’éšªæ—¥èªŒ
  
  // æª¢æŸ¥åˆºå®¢ä¹‹è·¯è¢«å‹•æŠ€ï¼šé€²å…¥æˆ°é¬¥å¾Œç²å¾—buffï¼Œç‰©ç†æ”»æ“Šç„¡è¦–é˜²ç¦¦
  // ç›´æ¥æª¢æŸ¥æŠ€èƒ½IDï¼Œå› ç‚ºç ´ç”²ä¹‹åˆƒæ˜¯é€²éšè·æ¥­ç‰¹æ®ŠæŠ€èƒ½
  if (state.hero && state.hero.skills && state.hero.skills.includes('weaponmaster_armor_pierce_1')) {
    state.ui.battle.heroBuffs.ignoreDefense = true;
    pushBattleLog(`å‹‡è€…ç ´ç”²ä¹‹åˆƒï¼šç‰©ç†æ”»æ“Šç„¡è¦–æ•µæ–¹é˜²ç¦¦ï¼`);
  }
  
  // æª¢æŸ¥æ‰€æœ‰åŒä¼´çš„åˆºå®¢ä¹‹è·¯è¢«å‹•æŠ€
  const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
  activeCompanions.forEach((companion, index) => {
    if (companion && companion.skills && companion.skills.includes('weaponmaster_armor_pierce_1')) {
      if (!state.ui.battle.companionBuffs[index]) {
        state.ui.battle.companionBuffs[index] = {};
      }
      state.ui.battle.companionBuffs[index].ignoreDefense = true;
      pushBattleLog(`${companion.name}ç ´ç”²ä¹‹åˆƒï¼šç‰©ç†æ”»æ“Šç„¡è¦–æ•µæ–¹é˜²ç¦¦ï¼`);
    }
  });
  
  renderAll();
}

// æª¢æŸ¥ä¸¦ä½¿ç”¨å¢å¼·æŠ€èƒ½ï¼ˆç¬¬ä¸€å›åˆï¼Œ40%æ©Ÿç‡ï¼Œå—å€‹æ€§å½±éŸ¿ï¼‰
function checkAndUseEnhanceSkills() {
  const battle = state.ui.battle;
  if (!battle) return;
  
  // ç²å–æ‰€æœ‰æœ‰å¢å¼·æŠ€èƒ½çš„è§’è‰²ï¼ˆå‹‡è€…å’ŒåŒä¼´ï¼‰
  const allCharacters = [];
  
  // æª¢æŸ¥å‹‡è€…
  if (state.hero && state.hero.stats.hp > 0 && state.hero.skills) {
    const enhanceSkills = state.hero.skills
      .map(id => SKILL_LOOKUP.get(id))
      .filter(skill => skill && skill.kind === 'enhance');
    if (enhanceSkills.length > 0) {
      allCharacters.push({
        character: state.hero,
        name: 'å‹‡è€…',
        isHero: true,
        enhanceSkills: enhanceSkills,
      });
    }
  }
  
  // æª¢æŸ¥åŒä¼´
  const companions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
  companions.forEach(companion => {
    if (companion.skills) {
      const enhanceSkills = companion.skills
        .map(id => SKILL_LOOKUP.get(id))
        .filter(skill => skill && skill.kind === 'enhance');
      if (enhanceSkills.length > 0) {
        const personalityId = companion.personalityId || 'balanced';
        const personality = COMPANION_PERSONALITIES[personalityId] || COMPANION_PERSONALITIES.balanced;
        allCharacters.push({
          character: companion,
          name: companion.name,
          isHero: false,
          enhanceSkills: enhanceSkills,
          personality: personality,
        });
      }
    }
  });
  
  // å°æ¯å€‹æœ‰å¢å¼·æŠ€èƒ½çš„è§’è‰²ï¼Œ40%æ©Ÿç‡ä½¿ç”¨ï¼ˆå—å€‹æ€§å½±éŸ¿ï¼‰
  allCharacters.forEach(charData => {
    let useChance = 0.4; // åŸºç¤40%æ©Ÿç‡
    
    // å—å€‹æ€§å½±éŸ¿ï¼ˆå¦‚æœæœ‰å€‹æ€§é…ç½®ï¼‰
    if (charData.personality && charData.personality.aiBehavior) {
      const aiBehavior = charData.personality.aiBehavior;
      // å¯ä»¥æ ¹æ“šå€‹æ€§èª¿æ•´æ©Ÿç‡ï¼Œé€™è£¡å…ˆä½¿ç”¨åŸºç¤æ©Ÿç‡
      // ä¾‹å¦‚ï¼šaggressiveå€‹æ€§å¯èƒ½æ›´å‚¾å‘ä½¿ç”¨æ”»æ“Šå…‰ç’°
    }
    
    const roll = Math.random();
    if (roll < useChance && charData.enhanceSkills.length > 0) {
      // éš¨æ©Ÿé¸æ“‡ä¸€å€‹å¢å¼·æŠ€èƒ½ä½¿ç”¨
      const selectedSkill = charData.enhanceSkills[Math.floor(Math.random() * charData.enhanceSkills.length)];
      useAuraSkill(charData.character, selectedSkill, charData.name, charData.isHero);
    }
  });
}

// ä½¿ç”¨å…‰ç’°æŠ€èƒ½
function useAuraSkill(caster, skill, casterName, isHero) {
  const battle = state.ui.battle;
  if (!battle || !caster || !skill || skill.kind !== 'enhance') return;
  
  // é˜²æ­»è­·ç›¾ä¸æ˜¯å…‰ç’°æŠ€èƒ½ï¼Œæ‡‰è©²é€šéperformSkillè™•ç†
  if (skill.deathWard) return;
  
  // è¨ˆç®—å…‰ç’°æ•ˆæœå€¼ï¼ˆæ ¹æ“šæ–½æ³•è€…çš„é«”åŠ›ï¼‰
  const totalAttrs = isHero 
    ? getHeroTotalAttributes(caster)
    : getCompanionTotalAttributes(caster);
  const vitality = totalAttrs.vitality;
  
  let auraValue = 0;
  const auraType = skill.auraType;
  
  if (auraType === 'attack' || auraType === 'defense' || auraType === 'hpRegen') {
    auraValue = Math.floor(vitality / 10);
  } else if (auraType === 'mpRegen') {
    auraValue = Math.floor(vitality / 20);
  }
  
  
  // å¦‚æœå·²ç¶“æœ‰å…‰ç’°ï¼Œæ›¿æ›æ‰å‰ä¸€å€‹
  if (battle.aura) {
    const oldAuraType = battle.aura.type;
    const oldAuraName = getAuraName(oldAuraType);
    pushBattleLog(`ã€Œ${oldAuraName}ã€è¢«ã€Œ${skill.name}ã€å–ä»£ã€‚`);
  }
  
  // è¨­ç½®æ–°å…‰ç’°
  battle.aura = {
    type: auraType,
    caster: caster,
    duration: skill.duration || 3,
    value: auraValue,
    skillName: skill.name,
  };
  
  const auraName = getAuraName(auraType);
  pushBattleLog(`${casterName}æ–½æ”¾ã€Œ${skill.name}ã€ï¼`);
  pushBattleLog(`â†’ å…¨é«”ç²å¾—${auraName}æ•ˆæœï¼ˆ${auraValue}é»ï¼ŒæŒçºŒ${battle.aura.duration}å›åˆï¼‰ã€‚`);
  
  // ç«‹å³åˆ·æ–°UIä»¥æ˜¾ç¤ºå…‰ç¯çŠ¶æ€
  renderBattleDialog();
}

// ç²å–å…‰ç’°åç¨±
function getAuraName(auraType) {
  const names = {
    'attack': 'æ”»æ“Šå…‰ç’°',
    'defense': 'é˜²ç¦¦å…‰ç’°',
    'hpRegen': 'ç”Ÿå‘½å…‰ç’°',
    'mpRegen': 'é­”åŠ›å…‰ç’°',
  };
  return names[auraType] || 'å…‰ç’°æ•ˆæœ';
}

// æ‡‰ç”¨å…‰ç’°æ•ˆæœ
// è§¸ç™¼ç¥è–å›éŸ¿çš„ç·©æ…¢æ¢å¾©æ•ˆæœ
function triggerHealingEchoEffects() {
  const battle = state.ui.battle;
  if (!battle) return;
  
  // è™•ç†å‹‡è€…çš„ç¥è–å›éŸ¿
  if (battle.heroBuffs.healingEcho && battle.heroBuffs.healingEcho > 0) {
    const echoAmount = battle.heroBuffs.healingEcho;
    const oldHp = state.hero.stats.hp;
    state.hero.stats.hp = Math.min(state.hero.stats.maxHp, state.hero.stats.hp + echoAmount);
    const actualHealed = state.hero.stats.hp - oldHp;
    if (actualHealed > 0) {
      pushBattleLog(`â†’ ç¥è–å›éŸ¿ï¼šå‹‡è€…å›å¾© ${actualHealed} HPï¼ˆ${oldHp} â†’ ${state.hero.stats.hp}ï¼‰ï¼`);
    }
    battle.heroBuffs.healingEcho = 0; // æ¸…é™¤ç·©æ…¢æ¢å¾©å€¼
  }
  
  // è™•ç†åŒä¼´çš„ç¥è–å›éŸ¿
  if (state.companions) {
    state.companions.forEach((companion, index) => {
      if (companion && companion.stats && companion.stats.hp > 0) {
        if (battle.companionBuffs[index] && battle.companionBuffs[index].healingEcho && battle.companionBuffs[index].healingEcho > 0) {
          const echoAmount = battle.companionBuffs[index].healingEcho;
          const oldHp = companion.stats.hp;
          companion.stats.hp = Math.min(companion.stats.maxHp, companion.stats.hp + echoAmount);
          const actualHealed = companion.stats.hp - oldHp;
          if (actualHealed > 0) {
            pushBattleLog(`â†’ ç¥è–å›éŸ¿ï¼š${companion.name}å›å¾© ${actualHealed} HPï¼ˆ${oldHp} â†’ ${companion.stats.hp}ï¼‰ï¼`);
          }
          battle.companionBuffs[index].healingEcho = 0; // æ¸…é™¤ç·©æ…¢æ¢å¾©å€¼
        }
      }
    });
  }
}

function applyAuraEffects() {
  const battle = state.ui.battle;
  if (!battle || !battle.aura) return;
  
  const aura = battle.aura;
  const auraValue = aura.value;
  
  if (aura.type === 'attack') {
    // æ”»æ“ŠåŠ›æå‡ï¼šåœ¨è¨ˆç®—å‚·å®³æ™‚æ‡‰ç”¨ï¼ˆé€šéè‡¨æ™‚å±¬æ€§åŠ æˆï¼‰
    // é€™è£¡åªè¨˜éŒ„ï¼Œå¯¦éš›æ‡‰ç”¨åœ¨è¨ˆç®—å‚·å®³æ™‚
    // æ‰€æœ‰å‹æ–¹ï¼ˆå‹‡è€…å’ŒåŒä¼´ï¼‰éƒ½æœƒç²å¾—æ”»æ“ŠåŠ›åŠ æˆ
  } else if (aura.type === 'defense') {
    // é˜²ç¦¦åŠ›æå‡ï¼šåœ¨è¨ˆç®—å‚·å®³æ™‚æ‡‰ç”¨ï¼ˆé€šéè‡¨æ™‚å±¬æ€§åŠ æˆï¼‰
    // æ‰€æœ‰å‹æ–¹ï¼ˆå‹‡è€…å’ŒåŒä¼´ï¼‰éƒ½æœƒç²å¾—é˜²ç¦¦åŠ›åŠ æˆ
  } else if (aura.type === 'hpRegen') {
    // æ¯å›åˆHPæ¢å¾©
    const allCharacters = [];
    if (state.hero && state.hero.stats.hp > 0) {
      allCharacters.push({ char: state.hero, name: 'å‹‡è€…' });
    }
    const companions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
    companions.forEach(companion => {
      allCharacters.push({ char: companion, name: companion.name });
    });
    
    allCharacters.forEach(charData => {
      const oldHp = charData.char.stats.hp;
      charData.char.stats.hp = Math.min(charData.char.stats.maxHp, charData.char.stats.hp + auraValue);
      const actualHeal = charData.char.stats.hp - oldHp;
      if (actualHeal > 0) {
        pushBattleLog(`â†’ ${charData.name}å—åˆ°ã€Œ${getAuraName(aura.type)}ã€æ•ˆæœï¼Œæ¢å¾© ${actualHeal} HPã€‚`);
      }
    });
  } else if (aura.type === 'mpRegen') {
    // æ¯å›åˆMPæ¢å¾©
    const allCharacters = [];
    if (state.hero && state.hero.stats.hp > 0) {
      allCharacters.push({ char: state.hero, name: 'å‹‡è€…' });
    }
    const companions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
    companions.forEach(companion => {
      allCharacters.push({ char: companion, name: companion.name });
    });
    
    allCharacters.forEach(charData => {
      const oldMp = charData.char.stats.mp;
      charData.char.stats.mp = Math.min(charData.char.stats.maxMp, charData.char.stats.mp + auraValue);
      const actualMpRegen = charData.char.stats.mp - oldMp;
      if (actualMpRegen > 0) {
        pushBattleLog(`â†’ ${charData.name}å—åˆ°ã€Œ${getAuraName(aura.type)}ã€æ•ˆæœï¼Œæ¢å¾© ${actualMpRegen} MPã€‚`);
      }
    });
  }
}

function levelUpEnemy(enemy, levels = 1) {
  const originalLevel = enemy.stats.level;
  enemy.stats.level += levels;
  
  // æ¯ç´šå¢åŠ å±¬æ€§ï¼ˆæ ¹æ“šæˆé•·ç‡ï¼‰
  ATTRIBUTES.forEach(attr => {
    const growth = enemy.growthPerLevel?.[attr.id] || 0.5;
    enemy.attributes[attr.id] = Math.round(enemy.attributes[attr.id] + growth * levels);
  });
  
  // é‡æ–°è¨ˆç®—HPå’ŒMPï¼ˆåŸºæ–¼æ–°çš„å±¬æ€§å’Œç­‰ç´šï¼‰
  // HP = baseHp + vitality
  const baseHp = Math.ceil(enemy.baseHp || 50);
  const baseMp = Math.ceil(enemy.baseMp || 0);
  
  // è¨ˆç®—å‡ç´šå‰çš„å±¬æ€§å€¼ï¼ˆç”¨æ–¼è¨ˆç®—å¢ç›Šï¼‰
  const oldVitality = enemy.attributes.vitality - (enemy.growthPerLevel?.vitality || 0.5) * levels;
  const oldHp = Math.ceil(baseHp + oldVitality);
  const oldRecovery = enemy.attributes.recovery - (enemy.growthPerLevel?.recovery || 0.5) * levels;
  const oldMagic = enemy.attributes.magic - (enemy.growthPerLevel?.magic || 0.5) * levels;
  
  // è¨ˆç®—æ–°çš„HPå’ŒMP
  enemy.stats.maxHp = Math.ceil(baseHp + enemy.attributes.vitality);
  // MPä¸éš¨ç­‰ç´šä¸Šå‡è€Œå¢åŠ ï¼Œä¿æŒåŸä¾†çš„maxMp
  // enemy.stats.maxMp ä¿æŒä¸è®Š
  
  // è¨ˆç®—å¢ç›Šï¼ˆç”¨æ–¼é¡¯ç¤ºï¼‰
  const hpGain = enemy.stats.maxHp - oldHp;
  // MPä¸å¢åŠ ï¼Œæ‰€ä»¥mpGainç‚º0
  const mpGain = 0;
  
  // å‡ç´šæ™‚HPå…¨æ»¿ï¼ŒMPä¿æŒä¸è®Šï¼ˆä¸æœƒæ¢å¾©æˆ–å¢åŠ ï¼‰
  enemy.stats.hp = Math.ceil(enemy.stats.maxHp);
  // MPä¿æŒä¸è®Šï¼Œä¸æœƒæ¢å¾©åˆ°æœ€å¤§å€¼
  
  // å­¸ç¿’æ–°æŠ€èƒ½ï¼ˆæ¯3ç´šä¸€å€‹ï¼‰- å·²ç§»é™¤ï¼Œå› ç‚ºç¾åœ¨æŠ€èƒ½åœ¨å‰µå»ºæ™‚å°±å…¨éƒ¨å¯ç”¨
}

// æ ¹æ“šé›£åº¦ç²å–éšå±¤å±¬æ€§åŠ æˆ
function getStageAttributeBonus(tier) {
  const difficulty = state.settings.difficulty || 'normal';
  const difficultyBonuses = {
    normal: { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0 },
    hard: { 1: 1, 2: 5, 3: 15, 4: 25, 5: 40, 6: 60 },
    hell: { 1: 2, 2: 10, 3: 20, 4: 30, 5: 45, 6: 70 },
  };
  
  const bonuses = difficultyBonuses[difficulty] || difficultyBonuses.normal;
  const difficultyBonus = bonuses[tier] || 0;
  
  // é¡å¤–åŠ ä¸Š config.js ä¸­çš„ stageAttributeBonus
  const configBonus = (GAME_CONFIG.stageAttributeBonus && GAME_CONFIG.stageAttributeBonus[tier]) || 0;
  
  return difficultyBonus + configBonus;
}

function createEnemy(enemyTemplate, heroLevel, isElite = false, stage = null) {
  // æ€ªç‰©ç­‰ç´šæ ¹æ“šå‹‡è€…ç­‰ç´šèª¿æ•´
  // ä¸€èˆ¬æ€ªç‰©ï¼šç­‰ç´š = å‹‡è€…ç­‰ç´š
  // èè‹±æ€ªç‰©ï¼šç­‰ç´š = å‹‡è€…ç­‰ç´š + 2
  const enemyLevel = isElite ? (heroLevel + 2) : heroLevel;
  
  // ç²å–éšå±¤ï¼ˆå„ªå…ˆä½¿ç”¨å‚³å…¥çš„ stageï¼Œå¦å‰‡ä½¿ç”¨ enemyTemplate.tierï¼Œæœ€å¾Œä½¿ç”¨ç•¶å‰ä¸–ç•Œéšå±¤ï¼‰
  const currentStage = stage !== null ? stage : (enemyTemplate.tier || (state.world ? state.world.stage : 1));
  const tier = Math.min(6, Math.max(1, currentStage));
  
  // ç²å–éšå±¤å±¬æ€§åŠ æˆï¼ˆæ ¹æ“šé›£åº¦ï¼‰
  const stageBonus = getStageAttributeBonus(tier);
  
  // è¨ˆç®—å±¬æ€§ï¼ˆåŸºç¤å±¬æ€§ + æˆé•· * (ç­‰ç´š-1) + éšå±¤åŠ æˆï¼‰
  const attributes = {};
  ATTRIBUTES.forEach(attr => {
    const base = Math.round(enemyTemplate.baseAttributes[attr.id] || 5);
    const growth = Math.round(enemyTemplate.growthPerLevel[attr.id] || 0);
    attributes[attr.id] = Math.round(base + growth * (enemyLevel - 1) + stageBonus);
  });
  
  // è¨ˆç®—HPå’ŒMP
  // HP = baseHp + vitality
  const baseHp = Math.ceil(enemyTemplate.baseHp || 50);
  const baseMp = Math.ceil(enemyTemplate.baseMp || 0);
  
  // å¤šå½¢æ…‹bossè™•ç†ï¼šå¦‚æœæœ‰formså±¬æ€§ï¼Œä½¿ç”¨ç¬¬ä¸€å½¢æ…‹
  let currentForm = null;
  let formIndex = 0;
  if (enemyTemplate.forms && enemyTemplate.forms.length > 0) {
    currentForm = enemyTemplate.forms[0];
    formIndex = 0;
    // ä½¿ç”¨ç¬¬ä¸€å½¢æ…‹çš„å±¬æ€§
    Object.keys(currentForm.baseAttributes || {}).forEach(attr => {
      if (currentForm.baseAttributes[attr] !== undefined) {
        attributes[attr] = Math.round(currentForm.baseAttributes[attr] + (currentForm.growthPerLevel[attr] || 0) * (enemyLevel - 1) + stageBonus);
      }
    });
  }
  
  // è¨ˆç®—HPï¼ˆä½¿ç”¨ç•¶å‰vitalityï¼‰
  const vitalityValue = attributes.vitality || 1;
  let maxHp = Math.ceil(baseHp + vitalityValue);
  // MP = baseMpï¼ˆä¸å—ç­‰ç´šã€æ¢å¾©åŠ›ã€é­”åŠ›å½±éŸ¿ï¼‰
  const maxMp = Math.ceil(baseMp);
  
  // æŠ€èƒ½ç³»çµ±ï¼šç›´æ¥ä½¿ç”¨ skills æ•¸çµ„ï¼ˆæ¯å€‹æŠ€èƒ½åŒ…å« id å’Œ probabilityï¼‰
  // å…¼å®¹èˆŠæ ¼å¼ï¼šå¦‚æœ skills æ˜¯å­—ç¬¦ä¸²æ•¸çµ„ï¼Œè½‰æ›ç‚ºæ–°æ ¼å¼
  let skills = [];
  // å¤šå½¢æ…‹bossä½¿ç”¨ç•¶å‰å½¢æ…‹çš„æŠ€èƒ½ï¼Œå¦å‰‡ä½¿ç”¨æ¨¡æ¿çš„æŠ€èƒ½
  const skillsSource = currentForm ? currentForm.skills : enemyTemplate.skills;
  if (skillsSource && skillsSource.length > 0) {
    // æ–°æ ¼å¼ï¼šskills æ˜¯å°è±¡æ•¸çµ„ [{id: 'skill_id', probability: 0.2}, ...]
    if (typeof skillsSource[0] === 'object' && skillsSource[0].id) {
      skills = skillsSource.map(s => ({ id: s.id, probability: s.probability || 0.2 }));
    } else {
      // èˆŠæ ¼å¼ï¼šskills æ˜¯å­—ç¬¦ä¸²æ•¸çµ„ï¼Œè½‰æ›ç‚ºæ–°æ ¼å¼
      skills = skillsSource.map(id => ({ id, probability: 0.2 }));
    }
  }
  
  // å…¼å®¹èˆŠçš„ skillPool æ ¼å¼ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
  if (enemyTemplate.skillPool && enemyTemplate.skillPool.length > 0) {
    enemyTemplate.skillPool.forEach(skillId => {
      if (!skills.find(s => s.id === skillId)) {
        skills.push({ id: skillId, probability: 0.2 });
      }
    });
  }
  
  // è¨ˆç®—ç¶“é©—å€¼ï¼šåŸºç¤ç¶“é©—å€¼ * (1.2 ^ (ç­‰ç´š - 1))
  const baseXp = enemyTemplate.baseXp || 10;
  const xpValue = Math.round(baseXp * Math.pow(1.2, enemyLevel - 1));
  
  // å¤šå½¢æ…‹bossï¼šä½¿ç”¨ç•¶å‰å½¢æ…‹çš„åç¨±å’Œemoji
  const displayName = currentForm ? currentForm.name : enemyTemplate.name;
  const displayEmoji = currentForm ? currentForm.emoji : enemyTemplate.emoji;
  const displayActionsPerTurn = currentForm && currentForm.actionsPerTurn ? currentForm.actionsPerTurn : (enemyTemplate.actionsPerTurn || 1);
  
  return {
    id: enemyTemplate.id,
    tier: enemyTemplate.tier,
    monsterType: enemyTemplate.monsterType || 'normal', // è¤‡è£½æ€ªç‰©é¡å‹ï¼ˆboss/normalç­‰ï¼‰
    name: displayName,
    flavor: enemyTemplate.flavor,
    emoji: displayEmoji,
    level: enemyLevel,
    xp: xpValue,
    goldDrop: enemyTemplate.goldDrop || 0, // ä¿å­˜é‡‘å¹£æ‰è½å€¼
    actionsPerTurn: displayActionsPerTurn, // Bossæ¯å›åˆè¡Œå‹•æ¬¡æ•¸
    sizeLevel: enemyTemplate.sizeLevel || 3, // æ€ªç‰©å¤§å°ç­‰ç´šï¼ˆ1=100%, 2=120%, 3=140%, 4=160%ï¼‰
    stats: {
      level: enemyLevel,
      hp: Math.ceil(maxHp),
      maxHp: Math.ceil(maxHp),
      mp: Math.ceil(maxMp),
      maxMp: Math.ceil(maxMp),
    },
    attributes,
    skills, // skills ç¾åœ¨æ˜¯ [{id: 'skill_id', probability: 0.2}, ...] æ ¼å¼
    isElite,
    // ä¿å­˜æ¨¡æ¿è³‡è¨Šä»¥ä¾¿å‡ç´šæ™‚ä½¿ç”¨
    baseAttributes: enemyTemplate.baseAttributes,
    growthPerLevel: enemyTemplate.growthPerLevel,
    baseHp: enemyTemplate.baseHp,
    baseMp: enemyTemplate.baseMp,
    baseXp: enemyTemplate.baseXp,
    // å¤šå½¢æ…‹bossç›¸é—œè³‡è¨Š
    forms: enemyTemplate.forms || null,
    transformHpThreshold: enemyTemplate.transformHpThreshold || null,
    currentFormIndex: formIndex, // ç•¶å‰å½¢æ…‹ç´¢å¼•
    hasTransformed: false, // æ˜¯å¦å·²ç¶“è®Šèº«é
  };
}

function rollEnemyHpGrowth(vitality, level) {
  const base = 10;
  const chance = Math.min(0.9, 0.2 + vitality * 0.02);
  const bonus = Math.random() < chance ? randomRange(10, 20) : 0;
  return base + bonus + (level - 1) * 8;
}

function rollEnemyMpGrowth(magic, level) {
  const base = 5;
  const chance = Math.min(0.95, 0.25 + magic * 0.025);
  const bonus = Math.random() < chance ? randomRange(8, 15) : 0;
  return base + bonus + (level - 1) * 4;
}

function pickEnemy(stage, multiplier, nodeIndex, allowBoss = false) {
  const hero = state.hero;
  // ç¢ºä¿ç¸½æ˜¯ä½¿ç”¨ç•¶å‰çš„è‹±é›„ç­‰ç´šï¼Œå¦‚æœè‹±é›„ä¸å­˜åœ¨æˆ–ç­‰ç´šæœªå®šç¾©ï¼Œé»˜èªç‚º1
  const heroLevel = (hero && hero.stats && typeof hero.stats.level === 'number') ? hero.stats.level : 1;
  const isElite = multiplier >= 1.5;
  
  // ä½¿ç”¨ç•¶å‰éšæ®µçš„stageä½œç‚ºtierï¼ˆæ¯å€‹éšæ®µå°æ‡‰ä¸€å€‹tierï¼‰
  // å„ªå…ˆä½¿ç”¨å‚³å…¥çš„stageåƒæ•¸ï¼Œå¦‚æœæ²’æœ‰å‰‡ä½¿ç”¨state.world.stage
  const currentStage = stage || (state.world && state.world.stage ? state.world.stage : 1);
  const tier = Math.min(6, Math.max(1, currentStage));
  
  // åˆ¤æ–·æ˜¯å¦ç‚ºBOSSæˆ°
  // åªæœ‰åœ¨å…è¨±bossä¸”multiplier >= 2.5æ™‚æ‰æ˜¯bossæˆ°
  // æ™®é€šæˆ°é¬¥å’Œç²¾è‹±æˆ°é¬¥éƒ½ä¸æœƒé¸æ“‡bossï¼ˆåªæœ‰æœ€å¾Œä¸€å€‹ç¯€é»çš„bossé¸é …æ‰æœƒï¼‰
  const isBossBattle = allowBoss && multiplier >= 2.5;
  
  // å¦‚æœæ˜¯BOSSæˆ°ï¼Œé¸æ“‡å°æ‡‰éšå±¤çš„BOSS
  if (isBossBattle) {
    const bossPool = ENEMY_DECK.filter(
      (enemy) => enemy.tier === tier && enemy.monsterType === 'boss'
    );
    
    
    if (bossPool.length > 0) {
      const bossTemplate = bossPool[0]; // æ¯å€‹éšå±¤åªæœ‰ä¸€å€‹BOSS
      return createEnemy(bossTemplate, heroLevel, true, tier);
    } else {
      // å¦‚æœæ²’æœ‰æ‰¾åˆ°å°æ‡‰éšå±¤çš„BOSSï¼Œè¨˜éŒ„éŒ¯èª¤ä¸¦ä½¿ç”¨é»˜èªBOSS
      // å˜—è©¦å°‹æ‰¾å°æ‡‰ tier çš„ bossï¼ˆä¸æ‡‰è©²ç™¼ç”Ÿï¼Œä½†ä½œç‚ºå‚™ç”¨ï¼‰
      const defaultBoss = ENEMY_DECK.find((enemy) => enemy.monsterType === 'boss' && enemy.tier === tier);
      if (!defaultBoss) {
        // å¦‚æœé‚„æ˜¯æ‰¾ä¸åˆ°ï¼Œé™éšå°‹æ‰¾
        for (let fallbackTier = tier - 1; fallbackTier >= 1; fallbackTier--) {
          const fallbackBoss = ENEMY_DECK.find((enemy) => enemy.monsterType === 'boss' && enemy.tier === fallbackTier);
          if (fallbackBoss) {
            return createEnemy(fallbackBoss, heroLevel, true, fallbackTier);
          }
        }
        // å¦‚æœé€£é™éšBOSSéƒ½æ²’æœ‰ï¼Œä½¿ç”¨ç¬¬ä¸€å€‹BOSS
      const anyBoss = ENEMY_DECK.find((enemy) => enemy.monsterType === 'boss');
      if (anyBoss) {
        return createEnemy(anyBoss, heroLevel, true);
        }
      } else {
        return createEnemy(defaultBoss, heroLevel, true, tier);
      }
    }
  }
  
  // æ™®é€šæˆ°é¬¥ï¼šå¾å°æ‡‰éšå±¤çš„æ™®é€šæ€ªç‰©ä¸­é¸æ“‡ï¼ˆä¸åŒ…å«BOSSï¼‰
  // ç¢ºä¿æ¯å€‹éšæ®µåªå‡ºç¾è©²éšæ®µçš„æ€ªç‰©ï¼ˆåŒ…æ‹¬ç²¾è‹±æˆ°é¬¥ï¼‰
  const normalPool = ENEMY_DECK.filter(
    (enemy) => enemy.tier === tier && enemy.monsterType !== 'boss'
  );
  
  if (normalPool.length === 0) {
    // å¦‚æœæ²’æœ‰å°æ‡‰éšå±¤çš„æ€ªç‰©ï¼Œè¨˜éŒ„éŒ¯èª¤
    // ä¸å†å›é€€åˆ°å…¶ä»– tier çš„æ€ªç‰©ï¼Œç¢ºä¿åªä½¿ç”¨è©² tier çš„æ€ªç‰©
    // å¦‚æœç¢ºå¯¦æ²’æœ‰æ€ªç‰©ï¼Œå˜—è©¦ä½¿ç”¨ tier 1 çš„æ€ªç‰©ä½œç‚ºæœ€å¾Œæ‰‹æ®µï¼ˆä½†é€™ä¸æ‡‰è©²ç™¼ç”Ÿï¼‰
    const fallbackMonster = ENEMY_DECK.find((enemy) => enemy.monsterType !== 'boss' && enemy.tier === 1);
    if (fallbackMonster) {
      return createEnemy(fallbackMonster, heroLevel, isElite, tier);
    }
    // å¦‚æœé€£ tier 1 çš„æ€ªç‰©éƒ½æ²’æœ‰ï¼Œé€™æ˜¯ä¸€å€‹åš´é‡çš„é…ç½®éŒ¯èª¤
    throw new Error(`éšæ®µ ${tier} æ²’æœ‰å¯ç”¨çš„æ€ªç‰©ï¼Œä¸”æ²’æœ‰å¯ç”¨çš„å›é€€æ€ªç‰©`);
  }
  
  // éš¨æ©Ÿé¸æ“‡ä¸€å€‹è©²éšæ®µçš„æ€ªç‰©é¡å‹ï¼ˆåŒ…æ‹¬ç²¾è‹±æˆ°é¬¥ï¼Œéƒ½åªå¾è©² tier é¸æ“‡ï¼‰
  const chosen = normalPool[Math.floor(Math.random() * normalPool.length)];
  return createEnemy(chosen, heroLevel, isElite, tier);
}

function handleBattleCommand(command) {
  const battle = state.ui.battle;
  if (!battle) return;
  if (command === 'back') {
    battle.menu = 'root';
    battle.pendingSkill = null;
    battle.pendingItem = null; // é‡ç½®å¾…ä½¿ç”¨é“å…·
    battle.selectedEnemyIndex = null; // é‡ç½®é¸æ“‡ç‹€æ…‹
    renderBattleDialog();
    return;
  }
  
  // åªæœ‰ä¸»è§’å¯ä»¥é¸æ“‡è¡Œå‹•ï¼ŒåŒä¼´å’Œæ•µäººçš„è¡Œå‹•ç”±AIè‡ªå‹•æ±ºå®š
  const isHeroTurn = battle.turn === 'hero';
  
  if (!isHeroTurn) return;
  
  // å¦‚æœå‹‡è€…æ­»äº¡ï¼Œåªèƒ½é¸æ“‡éˆé­‚è§€æˆ°
  if (isHeroTurn && state.hero && state.hero.stats.hp <= 0) {
    if (command === 'spectate') {
      // éˆé­‚è§€æˆ°ï¼šè·³éå‹‡è€…å›åˆï¼Œç›´æ¥çµæŸ
      pushBattleLog('å‹‡è€…ä»¥éˆé­‚ç‹€æ…‹è§€æˆ°...');
      battle.heroAction = null;
      endHeroTurn();
      return;
    }
    // å…¶ä»–æŒ‡ä»¤åœ¨å‹‡è€…æ­»äº¡æ™‚ä¸æ‡‰è©²å‡ºç¾ï¼Œä½†ç‚ºäº†å®‰å…¨èµ·è¦‹ï¼Œç›´æ¥è¿”å›
    return;
  }
  
  switch (command) {
    case 'attack':
      // ä¸è®¾ç½® menuï¼Œè®© performBasicAttack è‡ªå·±å¤„ç†
      performBasicAttack();
      break;
    case 'skill':
      battle.menu = 'skills';
      renderBattleDialog();
      break;
    case 'guard':
      battle.menu = 'root';
      performGuard();
      break;
    case 'item':
      if (isHeroTurn) {
        battle.menu = 'items';
        renderBattleDialog();
      }
      break;
    case 'spectate':
      // éˆé­‚è§€æˆ°ï¼ˆæ­£å¸¸æƒ…æ³ä¸‹ä¸æ‡‰è©²å‡ºç¾ï¼Œä½†ç‚ºäº†å®‰å…¨èµ·è¦‹ï¼‰
      pushBattleLog('å‹‡è€…ä»¥éˆé­‚ç‹€æ…‹è§€æˆ°...');
      battle.heroAction = null;
      endHeroTurn();
      break;
    default:
      break;
  }
}

function performBasicAttack() {
  const battle = state.ui.battle;
  if (!battle || battle.turn !== 'hero') return;
  
  // å¦‚æœæœ‰å¤šå€‹æ´»è‘—çš„æ•µäººï¼Œéœ€è¦é¸æ“‡ç›®æ¨™
  const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
  if (aliveEnemies.length > 1 && battle.selectedEnemyIndex === null) {
    battle.menu = 'select-enemy';
    renderBattleDialog();
    return;
  }
  
  // ç¢ºå®šç›®æ¨™æ•µäºº
  let targetIndex = battle.selectedEnemyIndex !== null 
    ? battle.selectedEnemyIndex 
    : battle.enemies.findIndex(e => e.stats.hp > 0);
  
  if (targetIndex < 0) {
    // æ²’æœ‰æ´»è‘—çš„æ•µäºº
    concludeBattle(true);
    return;
  }
  
  const targetEnemy = battle.enemies[targetIndex];
  if (!targetEnemy || targetEnemy.stats.hp <= 0) {
    // ç›®æ¨™å·²æ­»ï¼Œé¸æ“‡ç¬¬ä¸€å€‹æ´»è‘—çš„æ•µäºº
    targetIndex = battle.enemies.findIndex(e => e.stats.hp > 0);
    if (targetIndex >= 0) {
      battle.selectedEnemyIndex = targetIndex;
      performBasicAttack();
      return;
    }
  }
  
  // ä¿å­˜å‹‡è€…çš„è¡Œå‹•ï¼Œä¸ç«‹å³åŸ·è¡Œ
  battle.heroAction = {
    type: 'attack',
    targetEnemyIndex: targetIndex,
  };
  
  battle.selectedEnemyIndex = null;
  battle.menu = 'root';
  
  // è§¸ç™¼è¡Œå‹•éšŠåˆ—åŸ·è¡Œ
  endHeroTurn();
}

function performGuard() {
  const battle = state.ui.battle;
  if (!battle || battle.turn !== 'hero') return;
  
  // ä¿å­˜å‹‡è€…çš„è¡Œå‹•
  battle.heroAction = {
    type: 'guard',
  };
  
  // è§¸ç™¼è¡Œå‹•éšŠåˆ—åŸ·è¡Œ
  endHeroTurn();
}

// åŒä¼´æˆ°é¬¥å‡½æ•¸
function performCompanionBasicAttack() {
  const battle = state.ui.battle;
  const companion = state.companion;
  if (!battle || !companion || battle.turn !== 'companion') return;
  
  // åŒä¼´æ”»æ“Šæ™‚è‡ªå‹•é¸æ“‡ç›®æ¨™ï¼Œä¸è®“ç©å®¶é¸æ“‡
  const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
  if (aliveEnemies.length === 0) {
    concludeBattle(true);
    return;
  }
  
  // éš¨æ©Ÿé¸æ“‡ä¸€å€‹æ´»è‘—çš„æ•µäººä½œç‚ºç›®æ¨™
  const targetEnemy = aliveEnemies[Math.floor(Math.random() * aliveEnemies.length)];
  const targetIndex = battle.enemies.indexOf(targetEnemy);
  
  // è¨ˆç®—å‚·å®³
  const totalAttrs = getCompanionTotalAttributes(companion);
  const attack = totalAttrs.attack;
  const defense = targetEnemy.attributes ? targetEnemy.attributes.defense : (targetEnemy.defense || 0);
  let damage = Math.max(1, Math.round(attack - defense));
  
  // æª¢æŸ¥æœƒå¿ƒä¸€æ“Š
  const critChance = Math.min(5, Math.floor(totalAttrs.attack / 5));
  const isCrit = Math.random() * 100 < (10 + Math.floor(attack / 10) + Math.floor(totalAttrs.agility / 5));
  if (isCrit) {
    damage = Math.round(damage * 2);
  }
  
  damage = applyDamageToEnemyUnified(targetEnemy, damage, companion);
  const critMsg = isCrit ? 'ï¼ˆæœƒå¿ƒä¸€æ“Šï¼ï¼‰' : '';
  pushLog(`${companion.name}æ”»æ“Š${targetEnemy.name}ï¼Œé€ æˆ ${damage} å‚·å®³ï¼${critMsg}`);

  battle.selectedEnemyIndex = null;
  battle.menu = 'root';
  renderBattleDialog();
  
  if (targetEnemy.stats.hp <= 0) {
    pushLog(`${targetEnemy.name} è¢«æ“Šå€’ï¼`);
    const allDefeated = battle.enemies.every(e => e.stats.hp <= 0);
    if (allDefeated) {
      setTimeout(() => concludeBattle(true), 800);
      return;
    }
  }
  
  endCompanionTurn();
}

function performCompanionGuard() {
  const battle = state.ui.battle;
  const companion = state.companion;
  if (!battle || !companion || battle.turn !== 'companion') return;
  
  if (!battle.companionBuffs) {
    battle.companionBuffs = {};
  }
  // ä¿ç•™ç°æœ‰çš„ç´¢å¼•æ ¼å¼buffï¼ˆå¦‚ignoreDefenseï¼‰
  const existingIndexBuffs = {};
  Object.keys(battle.companionBuffs).forEach(key => {
    const index = parseInt(key);
    if (!isNaN(index) && battle.companionBuffs[index]) {
      existingIndexBuffs[index] = { ...battle.companionBuffs[index] };
    }
  });
  battle.companionBuffs = { ...existingIndexBuffs };
  battle.companionBuffs.guard = Math.max(battle.companionBuffs.guard || 0, 0.45);
  
  pushBattleLog(`${companion.name}æ“ºå‡ºé˜²å®ˆå§¿æ…‹ï¼Œä¸‹ä¸€æ¬¡å—åˆ°çš„å‚·å®³å¤§å¹…é™ä½ã€‚`);
  endCompanionTurn();
}

// åŒä¼´å›åˆçµæŸ
function endCompanionTurn() {
  const battle = state.ui.battle;
  if (!battle) return;
  battle.turn = 'enemy';
  battle.menu = 'root';
  battle.selectedEnemyIndex = null;
  battle.pendingSkill = null;
  renderBattleDialog();
  setTimeout(enemyAct, 400);
}

function performSkill(skillId) {
  const battle = state.ui.battle;
  if (!battle) return;
  
  const isHeroTurn = battle.turn === 'hero';
  const isCompanionTurn = battle.turn === 'companion';
  if (!isHeroTurn && !isCompanionTurn) return;
  
  const skill = SKILL_LOOKUP.get(skillId);
  if (!skill || skill.kind === 'passive') return;
  
  const attacker = isCompanionTurn ? getActiveCompanion() : state.hero;
  if (!attacker) return;
  
  // æª¢æŸ¥ MP æ¶ˆè€—ï¼ˆå…‰ç’°æŠ€èƒ½ä¸è€—MPï¼‰
  let { mpCost, tempMpCost } = calculateDynamicMpCost(skill, attacker);
  battle.tempMpCost = tempMpCost;

  if (skill.kind !== 'enhance' && attacker.stats.mp < mpCost) {
    const attackerName = isCompanionTurn ? attacker.name : 'ä½ ';
    pushLog(`${attackerName} MP ä¸è¶³ï¼Œç„¡æ³•ä½¿ç”¨æ­¤æŠ€èƒ½ï¼`);
    renderBattleDialog();
    return;
  }
  
  // å¢å¼·æŠ€èƒ½ï¼ˆå…‰ç’°ã€è‡ªèº«buffæˆ–é˜²æ­»è­·ç›¾ï¼‰è™•ç†
  if (skill.kind === 'enhance') {
    const attackerName = isCompanionTurn ? attacker.name : 'ä½ ';
    
    // æª¢æŸ¥æ˜¯å¦ç‚ºé˜²æ­»è­·ç›¾æŠ€èƒ½
    const isDeathWardSkill = skill.deathWard || skill.id === 'sage_death_ward_1';
    if (isDeathWardSkill) {
      if (!applyDeathWardToAllAllies(skill, attacker, attackerName)) {
        renderBattleDialog();
        return;
      }

      // å‹‡è€…å›åˆï¼šä¿å­˜è¡Œå‹•åˆ°éšŠåˆ—ï¼›åŒä¼´å›åˆï¼šç«‹å³åŸ·è¡Œ
      if (isHeroTurn) {
        battle.heroAction = {
          type: 'skill',
          skillId: skillId,
          targetEnemyIndex: null,
          target: null,
        };
        battle.menu = 'root';
        battle.pendingSkill = null;
        endHeroTurn();
      } else {
        setTimeout(() => {
          battle.turn = 'enemy';
          setTimeout(enemyAct, 800);
        }, 800);
      }
      return;
    }
    
    // æª¢æŸ¥æ˜¯å¦ç‚ºè‡ªèº«buffï¼ˆåŠæ„ï¼‰é‚„æ˜¯å…‰ç’°
    if (skill.selfBuff) {
      // è‡ªèº«buffæŠ€èƒ½ï¼ˆåŠæ„ï¼‰ï¼šæ¶ˆè€—MPï¼Œæå‡è‡ªèº«èƒ½åŠ›
      const mpCost = skill.mpCost || 0;
      if (attacker.stats.mp < mpCost) {
        pushLog(`${attackerName} MP ä¸è¶³ï¼Œç„¡æ³•ä½¿ç”¨æ­¤æŠ€èƒ½ï¼`);
        renderBattleDialog();
        return;
      }
      
      attacker.stats.mp -= mpCost;
      
      // æ‡‰ç”¨åŠæ„buff
      const attackBoost = skill.attackBoost || 0;
      const critBoost = skill.critBoost || 0;
      const duration = skill.duration || 3;
      
      if (isHeroTurn) {
        battle.heroBuffs.swordIntent = {
          attackBoost: attackBoost,
          critBoost: critBoost,
          duration: duration,
        };
        pushBattleLog(`${attackerName}æ–½æ”¾ã€Œ${skill.name}ã€ï¼`);
        pushBattleLog(`â†’ æ”»æ“ŠåŠ›æå‡ ${Math.round(attackBoost * 100)}%ï¼Œæš´æ“Šç‡æå‡ ${critBoost}%ï¼ŒæŒçºŒ ${duration} å›åˆã€‚`);
      } else {
        // åŒä¼´ä½¿ç”¨
        const companionIndex = state.companions.indexOf(attacker);
        if (companionIndex >= 0) {
          if (!battle.companionBuffs[companionIndex]) {
            battle.companionBuffs[companionIndex] = {};
          }
          battle.companionBuffs[companionIndex].swordIntent = {
            attackBoost: attackBoost,
            critBoost: critBoost,
            duration: duration,
          };
          pushBattleLog(`${attackerName}æ–½æ”¾ã€Œ${skill.name}ã€ï¼`);
          pushBattleLog(`â†’ æ”»æ“ŠåŠ›æå‡ ${Math.round(attackBoost * 100)}%ï¼Œæš´æ“Šç‡æå‡ ${critBoost}%ï¼ŒæŒçºŒ ${duration} å›åˆã€‚`);
        }
      }
      
      // å‹‡è€…å›åˆï¼šä¿å­˜è¡Œå‹•åˆ°éšŠåˆ—ï¼›åŒä¼´å›åˆï¼šç«‹å³åŸ·è¡Œ
      if (isHeroTurn) {
        battle.heroAction = {
          type: 'skill',
          skillId: skillId,
          targetEnemyIndex: null,
          target: null,
        };
        battle.menu = 'root';
        battle.pendingSkill = null;
        endHeroTurn();
      } else {
        renderBattleDialog();
        setTimeout(() => {
          battle.turn = 'enemy';
          setTimeout(enemyAct, 800);
        }, 800);
      }
      return;
    } else {
      // å…‰ç’°æŠ€èƒ½ä¸è€—MPï¼Œç›´æ¥ä½¿ç”¨
      useAuraSkill(attacker, skill, attackerName, isHeroTurn);
      
      // å‹‡è€…å›åˆï¼šä¿å­˜è¡Œå‹•åˆ°éšŠåˆ—ï¼›åŒä¼´å›åˆï¼šç«‹å³åŸ·è¡Œ
      if (isHeroTurn) {
        battle.heroAction = {
          type: 'skill',
          skillId: skillId,
          targetEnemyIndex: null,
          target: null,
        };
        battle.menu = 'root';
        battle.pendingSkill = null;
        endHeroTurn();
      } else {
        renderBattleDialog();
        setTimeout(() => {
          battle.turn = 'enemy';
          setTimeout(enemyAct, 800);
        }, 800);
      }
      return;
    }
  }
  
  if (skill.kind === 'attack') {
    // å…¨ä½“æ”»å‡»æŠ€èƒ½ç›´æ¥æ‰§è¡Œï¼Œä¸éœ€è¦é€‰æ‹©ç›®æ ‡
    if (skill.aoe) {
      // å…¨é«”æ”»æ“Šè™•ç†åœ¨å¾Œé¢
    } else {
      // å–®é«”æ”»æ“ŠæŠ€èƒ½éœ€è¦é¸æ“‡ç›®æ¨™ï¼ˆé™¤éæ˜¯éš¨æ©Ÿæ”»æ“Šå¤šæ¬¡ï¼‰
    const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
    const isMultiHit = skill.hitCount && skill.hitCount > 1;
    // é€£æ“ŠæŠ€èƒ½ï¼ˆagility_comboï¼‰éœ€è¦é¸æ“‡ç›®æ¨™ï¼Œå°åŒä¸€å€‹ç›®æ¨™é€²è¡Œå¤šæ¬¡æ”»æ“Š
    const isComboSkill = skill.id && (skill.id.startsWith('combo_strike_') || skill.id === 'agility_combo');
    const isRandomMultiHit = isMultiHit && !isComboSkill; // éš¨æ©Ÿå¤šæ®µæ”»æ“Šï¼ˆå¦‚å¤šé‡æ–¬æ“Šï¼‰
      
      // å¦‚æœæœ‰å¤šå€‹æ´»è‘—çš„æ•µäººä¸”æŠ€èƒ½ä¸æ˜¯å…¨é«”ï¼Œéœ€è¦é¸æ“‡ç›®æ¨™ï¼ˆé™¤éæ˜¯éš¨æ©Ÿæ”»æ“Šå¤šæ¬¡ï¼‰
      // ä½†æ˜¯åŒä¼´å›åˆæ™‚è‡ªå‹•é¸æ“‡ç›®æ¨™ï¼Œä¸è®“ç©å®¶é¸æ“‡
      // é€£æ“ŠæŠ€èƒ½éœ€è¦é¸æ“‡ç›®æ¨™ï¼Œæ‰€ä»¥ä¸ç®—åœ¨ !isMultiHit ä¸­
      if (aliveEnemies.length > 1 && !isRandomMultiHit && battle.selectedEnemyIndex === null && !isCompanionTurn) {
      battle.menu = 'select-enemy';
      battle.pendingSkill = skillId;
      renderBattleDialog();
      return;
    }
    
    // åŒä¼´å›åˆæ™‚è‡ªå‹•é¸æ“‡ç›®æ¨™ï¼ˆé€£æ“ŠæŠ€èƒ½ä¹Ÿéœ€è¦é¸æ“‡ç›®æ¨™ï¼‰
      if (isCompanionTurn && !isRandomMultiHit && battle.selectedEnemyIndex === null && aliveEnemies.length > 0) {
      battle.selectedEnemyIndex = battle.enemies.indexOf(aliveEnemies[Math.floor(Math.random() * aliveEnemies.length)]);
      }
    }
    
    // æ¶ˆè€—MP
    // æ³¨æ„ï¼šå¯¹äºè‹±é›„å›åˆçš„æ”»å‡»æŠ€èƒ½ï¼ŒMPå·²ç»åœ¨æ‰§è¡Œæ—¶æ¶ˆè€—ï¼ˆåœ¨performSkillDirectlyä¸­ï¼‰ï¼Œ
    // ä½†ä¸ºäº†ç¡®ä¿MPæ£€æŸ¥æ­£ç¡®ï¼Œè¿™é‡Œä¹Ÿéœ€è¦æ£€æŸ¥MPæ˜¯å¦è¶³å¤Ÿ
    // å¦‚æœæ˜¯è‹±é›„å›åˆä¸”æ˜¯æ”»å‡»æŠ€èƒ½ï¼ŒMPåœ¨æ‰§è¡Œæ—¶æ¶ˆè€—ï¼›å¦åˆ™ç«‹å³æ¶ˆè€—
    const shouldDeferMpCost = isHeroTurn && skill.kind === 'attack';
    if (!shouldDeferMpCost) {
      // æª¢æŸ¥å…ƒç´ å…±é³´ï¼š20%æ©Ÿç‡ä½¿ç”¨é­”æ³•æˆ–æ¢å¾©æ™‚ä¸æ¶ˆè€—MP
      let actualMpCost = mpCost;
      if (mpCost > 0 && (skill.flow === 'magic' || skill.kind === 'heal')) {
        const magicEffects = getMagicPassiveEffects(attacker);
        if (magicEffects.freeSpellChance > 0) {
          const triggerChance = Math.random();
          if (triggerChance < magicEffects.freeSpellChance) {
            actualMpCost = 0;
            pushBattleLog(`å…ƒç´ å…±é³´ï¼š${isCompanionTurn ? attacker.name : 'ä½ '}ä½¿ç”¨ã€Œ${skill.name}ã€æ™‚ä¸æ¶ˆè€—MPï¼`);
          }
        }
      }
      attacker.stats.mp -= actualMpCost;
    }
    
    // è™•ç†æ¨èº«æ–¬æŠ€èƒ½ï¼šæ‰£HPä¸¦è¨˜éŒ„æ‰£æ‰çš„HPå€¼ï¼ˆåªæœ‰è‹±é›„èƒ½ä½¿ç”¨æ¨èº«æ–¬ï¼‰
    let hpCostAmount = 0;
    if (skill.hpCostPercent && skill.hpCostPercent > 0 && isHeroTurn) {
      const maxHp = attacker.stats.maxHp;
      const currentHp = attacker.stats.hp;
      // åŸºæ–¼æœ€å¤§HPçš„æ¯”ä¾‹è¨ˆç®—ï¼Œä½†ç¢ºä¿è‡³å°‘æ‰£1ï¼Œä¸”ä¸æœƒè®“HPé™åˆ°0ä»¥ä¸‹ï¼ˆæœ€å¤šæ¸›åˆ°HP=1ï¼‰
      hpCostAmount = Math.max(1, Math.floor(maxHp * skill.hpCostPercent));
      // ç¢ºä¿æ‰£é™¤å¾ŒHPä¸æœƒé™åˆ°0ä»¥ä¸‹ï¼ˆæœ€å¤šæ¸›åˆ°HP=1ï¼‰
      hpCostAmount = Math.min(hpCostAmount, currentHp - 1);
      attacker.stats.hp = Math.max(1, attacker.stats.hp - hpCostAmount);
      battle.tempHpCost = hpCostAmount; // å­˜å„²åˆ°battleå°è±¡ä¸­ï¼Œä¾›calculateSkillDamageä½¿ç”¨
      if (hpCostAmount > 0) {
        pushLog(`æ¨èº«æ–¬æ¶ˆè€—äº† ${hpCostAmount} HPï¼`);
      }
    } else {
      battle.tempHpCost = 0; // æ¸…é™¤è‡¨æ™‚å€¼
    }
    
    // æ‡‰ç”¨åŠå£«å‹è¢«å‹•æŠ€èƒ½ï¼šä½¿ç”¨åŠæŠ€å¾Œè¿”å›MPï¼ˆåªæœ‰è‹±é›„æœ‰è¢«å‹•æŠ€èƒ½ï¼‰
    if (isHeroTurn) {
      const passiveEffects = getSwordPassiveEffects(attacker);
      if (skill.flow === 'sword' && passiveEffects.mpReturnRate > 0) {
        const mpReturn = Math.round(mpCost * passiveEffects.mpReturnRate);
        if (mpReturn > 0) {
          attacker.stats.mp = Math.min(attacker.stats.maxMp, attacker.stats.mp + mpReturn);
          pushBattleLog(`å‹‡è€…åŠæ°£å›æ¹§å›å¾©äº† ${mpReturn} MPï¼`);
        }
      }
    }
    
    // å…¨é«”æ”»æ“Š
    if (skill.aoe) {
      const attackerName = isCompanionTurn ? attacker.name : 'ä½ ';
      pushBattleLog(`${attackerName}æ–½æ”¾ã€Œ${skill.name}ã€ï¼`);
      
      battle.enemies.forEach((enemy, index) => {
        if (enemy.stats.hp > 0) {
          let { damage, isCrit } = calculateSkillDamage(skill, attacker, enemy);
          // çµ±ä¸€æ‡‰ç”¨å‚·å®³ï¼ˆåŒ…å«å¾©ä»‡æ„å¿—æ•ˆæœï¼‰
          damage = applyDamageToEnemyUnified(enemy, damage, attacker);
          const critMsg = isCrit ? 'ï¼ˆæœƒå¿ƒä¸€æ“Šï¼ï¼‰' : '';
          // å¦‚æœæ˜¯æ¨èº«æ–¬ï¼Œé¡¯ç¤ºè©³ç´°ä¿¡æ¯
          if (skill.hpCostPercent && skill.attackBoostMultiplier && battle.tempHpCost > 0) {
            const hpCost = battle.tempHpCost;
            const multiplier = skill.attackBoostMultiplier;
            pushBattleLog(`â†’ å°${enemy.name}é€ æˆ ${damage} å‚·å®³ï¼ˆæ¶ˆè€— ${hpCost} HP Ã— ${multiplier}å€ï¼‰${critMsg}`);
          } else {
          pushBattleLog(`â†’ å°${enemy.name}é€ æˆ ${damage} å‚·å®³${critMsg}`);
          }
          
          if (enemy.stats.hp <= 0) {
            pushBattleLog(`â†’ ${enemy.name} è¢«æ“Šå€’ï¼`);
          }
          
          // æ‡‰ç”¨å¸è¡€è¢«å‹•ï¼ˆåªæœ‰è‹±é›„æœ‰è¢«å‹•æŠ€èƒ½ï¼‰
          if (isHeroTurn && skill.flow === 'sword') {
            const passiveEffects = getSwordPassiveEffects(attacker);
            if (passiveEffects.lifestealRate > 0 && damage > 0) {
              const lifestealAmount = Math.max(1, Math.round(damage * passiveEffects.lifestealRate));
              attacker.stats.hp = Math.min(attacker.stats.maxHp, attacker.stats.hp + lifestealAmount);
            }
          }
        }
      });
      battle.menu = 'root';
      // æ¸…é™¤è‡¨æ™‚HPæ¶ˆè€—å€¼
      battle.tempHpCost = 0;
      
      // å‹‡è€…å›åˆï¼šä¿å­˜è¡Œå‹•ï¼›åŒä¼´å›åˆï¼šç«‹å³åŸ·è¡Œ
      if (isHeroTurn) {
        battle.heroAction = {
          type: 'skill',
          skillId: skillId,
          targetEnemyIndex: null, // AOEæŠ€èƒ½ä¸éœ€è¦ç›®æ¨™
        };
        endHeroTurn();
      } else {
        endCompanionTurn();
      }
    } 
    // å¤šæ®µæ”»æ“Šï¼ˆé€£æ“Šæˆ–éš¨æ©Ÿï¼‰
    else if (isMultiHit) {
      const attackerName = isCompanionTurn ? attacker.name : 'ä½ ';
      // é€£æ“ŠæŠ€èƒ½ï¼ˆagility_comboï¼‰éœ€è¦é¸æ“‡ç›®æ¨™ï¼Œå°åŒä¸€å€‹ç›®æ¨™é€²è¡Œå¤šæ¬¡æ”»æ“Š
      const isComboSkill = skill.id && (skill.id.startsWith('combo_strike_') || skill.id === 'agility_combo');
      
      // å‹‡è€…å›åˆï¼šä¿å­˜è¡Œå‹•åˆ°éšŠåˆ—ä¸­ï¼Œç¨å¾ŒåŸ·è¡Œ
      if (isHeroTurn) {
        battle.heroAction = {
          type: 'skill',
          skillId: skillId,
          targetEnemyIndex: isComboSkill ? battle.selectedEnemyIndex : null, // é€£æ“ŠæŠ€èƒ½éœ€è¦ç›®æ¨™ï¼Œéš¨æ©Ÿå¤šæ®µä¸éœ€è¦
        };
        battle.menu = 'root';
        battle.selectedEnemyIndex = null;
        battle.pendingSkill = null;
        battle.tempHpCost = 0;
        endHeroTurn();
      } else {
        // åŒä¼´å›åˆï¼šç«‹å³åŸ·è¡Œ
      const hitCount = skill.hitCount || 2;
      let totalDamage = 0;
        
        pushBattleLog(`${attackerName}æ–½æ”¾ã€Œ${skill.name}ã€ï¼`);
      
      // å¦‚æœæ˜¯é€£æ“ŠæŠ€èƒ½ï¼Œå…ˆé¸æ“‡ç›®æ¨™
      let fixedTarget = null;
      if (isComboSkill) {
        // é€£æ“ŠæŠ€èƒ½ï¼šå°åŒä¸€å€‹ç›®æ¨™é€²è¡Œå¤šæ¬¡æ”»æ“Š
        if (battle.selectedEnemyIndex !== null && battle.selectedEnemyIndex >= 0) {
          fixedTarget = battle.enemies[battle.selectedEnemyIndex];
        } else {
          // å¦‚æœæ²’æœ‰é¸æ“‡ç›®æ¨™ï¼Œè‡ªå‹•é¸æ“‡ç¬¬ä¸€å€‹æ´»è‘—çš„æ•µäºº
          const aliveEnemiesList = battle.enemies.filter(e => e.stats.hp > 0);
          if (aliveEnemiesList.length > 0) {
            fixedTarget = aliveEnemiesList[0];
            battle.selectedEnemyIndex = battle.enemies.indexOf(fixedTarget);
          }
        }
      }
      
      for (let i = 0; i < hitCount; i++) {
        const aliveEnemiesList = battle.enemies.filter(e => e.stats.hp > 0);
        if (aliveEnemiesList.length === 0) break;
        
        // é€£æ“ŠæŠ€èƒ½ï¼šå°åŒä¸€å€‹ç›®æ¨™æ”»æ“Šï¼›éš¨æ©Ÿå¤šæ®µï¼šéš¨æ©Ÿé¸æ“‡ç›®æ¨™
        const target = isComboSkill && fixedTarget && fixedTarget.stats.hp > 0 
          ? fixedTarget 
          : aliveEnemiesList[Math.floor(Math.random() * aliveEnemiesList.length)];
        const targetIndex = battle.enemies.indexOf(target);
        let { damage, isCrit } = calculateSkillDamage(skill, attacker, target);
        // çµ±ä¸€æ‡‰ç”¨å‚·å®³ï¼ˆåŒ…å«å¾©ä»‡æ„å¿—æ•ˆæœï¼‰
        damage = applyDamageToEnemyUnified(target, damage, attacker);
        totalDamage += damage;
        const critMsg = isCrit ? 'ï¼ˆæœƒå¿ƒä¸€æ“Šï¼ï¼‰' : '';
        
        // è§¸ç™¼å…ƒç´ å‹•ç•«
        triggerAttackAnimation(targetIndex, isCrit, skill);
          
          // é¡¯ç¤ºæ¯ä¸€ä¸‹æ”»æ“Š
          // å¦‚æœæ˜¯æ¨èº«æ–¬ï¼Œé¡¯ç¤ºè©³ç´°ä¿¡æ¯
          if (skill.hpCostPercent && skill.attackBoostMultiplier && battle.tempHpCost > 0) {
            const hpCost = battle.tempHpCost;
            const multiplier = skill.attackBoostMultiplier;
            pushBattleLog(`â†’ ç¬¬${i + 1}æ“Šï¼šå°${target.name}é€ æˆ ${damage} å‚·å®³ï¼ˆæ¶ˆè€— ${hpCost} HP Ã— ${multiplier}å€ï¼‰${critMsg}`);
          } else {
            pushBattleLog(`â†’ ç¬¬${i + 1}æ“Šï¼šå°${target.name}é€ æˆ ${damage} å‚·å®³${critMsg}`);
          }
          
          // æ‡‰ç”¨å¸è¡€è¢«å‹•
          if (skill.flow === 'sword') {
          const passiveEffects = getSwordPassiveEffects(attacker);
          if (passiveEffects.lifestealRate > 0 && damage > 0) {
            const lifestealAmount = Math.max(1, Math.round(damage * passiveEffects.lifestealRate));
            attacker.stats.hp = Math.min(attacker.stats.maxHp, attacker.stats.hp + lifestealAmount);
          }
        }
        
        // æª¢æŸ¥æ˜¯å¦æ“Šå€’
        if (target.stats.hp <= 0) {
            pushBattleLog(`â†’ ${target.name} è¢«æ“Šå€’ï¼`);
          const allDefeated = battle.enemies.every(e => e.stats.hp <= 0);
          if (allDefeated) {
            setTimeout(() => {
              concludeBattle(true);
            }, 800);
            return;
          }
        }
      }
      
        // é¡¯ç¤ºç¸½å‚·å®³
        pushBattleLog(`ç¸½å…±é€ æˆ ${totalDamage} å‚·å®³ï¼`);
        
        // æ‡‰ç”¨æ¢å¾©å‹è¢«å‹•æŠ€èƒ½ï¼šæ”»æ“Šæ•µäººå›å¾©MPï¼ˆå¤šæ®µæ”»æ“Šåªå›å¾©ä¸€æ¬¡ï¼‰
        if (totalDamage > 0) {
          const recoveryEffects = getRecoveryPassiveEffects(attacker);
          if (recoveryEffects.attackMpReturn > 0) {
            const oldMp = attacker.stats.mp;
            attacker.stats.mp = Math.min(attacker.stats.maxMp, attacker.stats.mp + recoveryEffects.attackMpReturn);
            const actualReturn = attacker.stats.mp - oldMp;
            if (actualReturn > 0) {
              pushBattleLog(`æ¢å¾©å‹è¢«å‹•æŠ€èƒ½ï¼šæ”»æ“Šå›å¾© ${actualReturn} MPã€‚`);
            }
          }
        }
        
        // æ‡‰ç”¨é­”æ³•å‹è¢«å‹•æŠ€èƒ½ï¼šæ³•è¡“æ”»æ“Šå›å¾©MPï¼ˆå¤šæ®µæ³•è¡“æ”»æ“Šåªå›å¾©ä¸€æ¬¡ï¼‰
        if (skill.flow === 'magic' && totalDamage > 0) {
          const magicEffects = getMagicPassiveEffects(attacker);
          if (magicEffects.spellMpReturn > 0) {
            const oldMp = attacker.stats.mp;
            attacker.stats.mp = Math.min(attacker.stats.maxMp, attacker.stats.mp + magicEffects.spellMpReturn);
            const actualReturn = attacker.stats.mp - oldMp;
            if (actualReturn > 0) {
              pushBattleLog(`é­”æ³•å‹è¢«å‹•æŠ€èƒ½ï¼šæ³•è¡“æ”»æ“Šå›å¾© ${actualReturn} MPã€‚`);
            }
          }
        }
        
      battle.menu = 'root';
      battle.tempHpCost = 0;
        endCompanionTurn();
      }
    }
    // å–®é«”æ”»æ“Š
    else {
      // ç¢ºå®šç›®æ¨™ç´¢å¼•
      let targetIndex = battle.selectedEnemyIndex;
      
      // å¦‚æœç›®æ¨™ç„¡æ•ˆæˆ–å·²æ­»äº¡ï¼Œè‡ªå‹•é¸æ“‡ç¬¬ä¸€å€‹æ´»è‘—çš„æ•µäºº
      if (targetIndex === null || targetIndex === undefined || 
          targetIndex < 0 || !battle.enemies[targetIndex] || 
          battle.enemies[targetIndex].stats.hp <= 0) {
        const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
        if (aliveEnemies.length === 0) {
          const attackerName = isCompanionTurn ? attacker.name : 'ä½ ';
          pushLog(`${attackerName}è©¦åœ–ä½¿ç”¨ã€Œ${skill.name}ã€ï¼Œä½†æ²’æœ‰å¯æ”»æ“Šçš„ç›®æ¨™ã€‚`);
          renderBattleDialog();
          return;
        }
        targetIndex = battle.enemies.indexOf(aliveEnemies[0]);
      }
      
      const targetEnemy = battle.enemies[targetIndex];
      
      // å‹‡è€…å›åˆï¼šä¿å­˜è¡Œå‹•åˆ°éšŠåˆ—ä¸­
      if (isHeroTurn && targetEnemy && targetEnemy.stats.hp > 0) {
        battle.heroAction = {
          type: 'skill',
          skillId: skillId,
          targetEnemyIndex: targetIndex,
        };
        battle.selectedEnemyIndex = null;
        battle.pendingSkill = null;
        battle.menu = 'root';
        battle.tempHpCost = 0;
        endHeroTurn();
      } else if (!isHeroTurn && targetEnemy && targetEnemy.stats.hp > 0) {
        // åŒä¼´å›åˆï¼šç«‹å³åŸ·è¡Œ
        const attackerName = isCompanionTurn ? attacker.name : 'ä½ ';
        const { damage, isCrit } = calculateSkillDamage(skill, attacker, targetEnemy);
        // å¦‚æœæ˜¯æ¨èº«æ–¬ï¼Œé¡¯ç¤ºè©³ç´°ä¿¡æ¯
        let damageMsg = `${attackerName}æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œé€ æˆ %d å‚·å®³ï¼`;
        if (skill.hpCostPercent && skill.attackBoostMultiplier && battle.tempHpCost > 0) {
          const hpCost = battle.tempHpCost;
          const multiplier = skill.attackBoostMultiplier;
          damageMsg = `${attackerName}æ–½æ”¾ã€Œ${skill.name}ã€ï¼ˆæ¶ˆè€— ${hpCost} HP Ã— ${multiplier}å€ï¼‰ï¼Œé€ æˆ %d å‚·å®³ï¼`;
        }
        applyDamageToEnemy(targetIndex, damage, damageMsg, false, skill, isCrit, attacker);
        
        // è–æ“Šï¼šå°æ•µäººé€ æˆå‚·å®³å¾Œï¼Œå›å¾©è‡ªå·±1/2æ²»ç™‚èƒ½åŠ›çš„HP
        const isEnhancedHeal = skill.id && skill.id.startsWith('enhanced_heal_');
        if (isEnhancedHeal && damage > 0) {
          const isHero = attacker === state.hero;
          const totalAttrs = isHero 
            ? getHeroTotalAttributes(attacker)
            : getCompanionTotalAttributes(attacker);
          const recovery = totalAttrs.recovery;
          const healAmount = Math.floor(recovery / 2);
          const oldHp = attacker.stats.hp;
          attacker.stats.hp = Math.min(attacker.stats.maxHp, attacker.stats.hp + healAmount);
          const actualHealed = attacker.stats.hp - oldHp;
          if (actualHealed > 0) {
            pushBattleLog(`â†’ ${attackerName}å›å¾©äº† ${actualHealed} HPï¼ˆ${oldHp} â†’ ${attacker.stats.hp}ï¼‰`);
          }
        }
        
        // é–ƒé›»éˆï¼šå°ç¬¬ä¸€å€‹ç›®æ¨™é€ æˆå‚·å®³å¾Œï¼Œå½ˆè·³åˆ°å¦ä¸€å€‹éš¨æ©Ÿæ•µäºº
        if (skill.chainDamage && skill.chainRatio) {
          const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0 && e !== targetEnemy);
          if (aliveEnemies.length > 0) {
            // éš¨æ©Ÿé¸æ“‡å¦ä¸€å€‹æ•µäºº
            const chainTarget = aliveEnemies[Math.floor(Math.random() * aliveEnemies.length)];
            const chainTargetIndex = battle.enemies.indexOf(chainTarget);
            
            // è¨ˆç®—é€£é–å‚·å®³ï¼ˆåŸæœ¬å‚·å®³çš„80%ï¼‰
            const chainDamage = Math.max(1, Math.floor(damage * skill.chainRatio));
            const oldChainHp = chainTarget.stats.hp;
            chainTarget.stats.hp = Math.max(0, chainTarget.stats.hp - chainDamage);
            
            // è§¸ç™¼å…ƒç´ å‹•ç•«
            triggerAttackAnimation(chainTargetIndex, false, skill);
            
            pushBattleLog(`â†’ é–ƒé›»éˆå½ˆè·³åˆ°${chainTarget.name}ï¼Œé€ æˆ ${chainDamage} å‚·å®³ï¼`);
            
            // æª¢æŸ¥é€£é–ç›®æ¨™æ˜¯å¦è¢«æ“Šå€’
            if (chainTarget.stats.hp <= 0) {
              pushBattleLog(`â†’ ${chainTarget.name} è¢«æ“Šå€’ï¼`);
              const allDefeated = battle.enemies.every(e => e.stats.hp <= 0);
              if (allDefeated) {
                setTimeout(() => {
                  concludeBattle(true);
                }, 800);
                return;
              }
            }
            
            renderBattleDialog();
          }
        }
        
        // å†°å‡é­”æ³•ï¼šé€ æˆæ¸›é€Ÿæ•ˆæœï¼ˆå…©å›åˆï¼Œæ¸›å°‘1/3é€Ÿåº¦ï¼‰
        if (skill.id && skill.id.startsWith('iceball_') && skill.slowDuration && skill.slowRatio) {
          // åˆå§‹åŒ– enemyDebuffs
          if (!battle.enemyDebuffs) {
            battle.enemyDebuffs = {};
          }
          
          // è¨­ç½®æ¸›é€Ÿç‹€æ…‹ï¼ˆå¦‚æœå·²ç¶“æœ‰æ¸›é€Ÿç‹€æ…‹ï¼Œé‡ç½®æŒçºŒæ™‚é–“ï¼‰
          if (!battle.enemyDebuffs[targetIndex]) {
            battle.enemyDebuffs[targetIndex] = {};
          }
          
          const hadSlow = battle.enemyDebuffs[targetIndex].slow ? true : false;
          battle.enemyDebuffs[targetIndex].slow = {
            duration: skill.slowDuration, // æŒçºŒ2å›åˆ
            ratio: skill.slowRatio // æ¸›å°‘1/3é€Ÿåº¦
          };
          
          if (hadSlow) {
            pushBattleLog(`â†’ ${target.name}çš„æ¸›é€Ÿæ•ˆæœè¢«åˆ·æ–°ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.slowDuration}å›åˆä¸­ï¼Œé€Ÿåº¦æ¸›å°‘ ${Math.round(skill.slowRatio * 100)}%ã€‚`);
          } else {
            pushBattleLog(`â†’ ${target.name}è¢«å†°å‡æ¸›é€Ÿï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.slowDuration}å›åˆä¸­ï¼Œé€Ÿåº¦æ¸›å°‘ ${Math.round(skill.slowRatio * 100)}%ã€‚`);
          }
        }
        
        // é…¸æ€§ç®­ï¼šé€ æˆé˜²å®ˆå€¼æ¸›å°‘æ•ˆæœï¼ˆå…©å›åˆï¼Œæ¸›å°‘1/3é˜²å®ˆå€¼ï¼‰
        if (skill.id && skill.id.startsWith('acid_arrow_') && skill.defenseDownDuration && skill.defenseDownRatio) {
          // åˆå§‹åŒ– enemyDebuffs
          if (!battle.enemyDebuffs) {
            battle.enemyDebuffs = {};
          }
          
          // è¨­ç½®é˜²å®ˆå€¼æ¸›å°‘ç‹€æ…‹ï¼ˆå¦‚æœå·²ç¶“æœ‰é˜²å®ˆå€¼æ¸›å°‘ç‹€æ…‹ï¼Œé‡ç½®æŒçºŒæ™‚é–“ï¼‰
          if (!battle.enemyDebuffs[targetIndex]) {
            battle.enemyDebuffs[targetIndex] = {};
          }
          
          const hadDefenseDown = battle.enemyDebuffs[targetIndex].defenseDown ? true : false;
          battle.enemyDebuffs[targetIndex].defenseDown = {
            duration: skill.defenseDownDuration, // æŒçºŒ2å›åˆ
            ratio: skill.defenseDownRatio // æ¸›å°‘1/3é˜²å®ˆå€¼
          };
          
          if (hadDefenseDown) {
            pushBattleLog(`â†’ ${target.name}çš„é˜²å®ˆå€¼æ¸›å°‘æ•ˆæœè¢«åˆ·æ–°ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.defenseDownDuration}å›åˆä¸­ï¼Œé˜²å®ˆå€¼æ¸›å°‘ ${Math.round(skill.defenseDownRatio * 100)}%ã€‚`);
          } else {
            pushBattleLog(`â†’ ${target.name}çš„é˜²å®ˆå€¼è¢«è…è•æ¸›å°‘ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.defenseDownDuration}å›åˆä¸­ï¼Œé˜²å®ˆå€¼æ¸›å°‘ ${Math.round(skill.defenseDownRatio * 100)}%ã€‚`);
          }
        }
        
        // è…æ“Šï¼šé™ä½æ•µäººæ”»æ“ŠåŠ›1/3ï¼ˆæŒçºŒ2å›åˆï¼‰
        if (skill.id && skill.id.startsWith('kidney_strike_') && skill.attackDownDuration && skill.attackDownRatio) {
          // åˆå§‹åŒ– enemyDebuffs
          if (!battle.enemyDebuffs) {
            battle.enemyDebuffs = {};
          }
          
          // è¨­ç½®æ”»æ“ŠåŠ›æ¸›å°‘ç‹€æ…‹ï¼ˆå¦‚æœå·²ç¶“æœ‰æ”»æ“ŠåŠ›æ¸›å°‘ç‹€æ…‹ï¼Œé‡ç½®æŒçºŒæ™‚é–“ï¼‰
          if (!battle.enemyDebuffs[targetIndex]) {
            battle.enemyDebuffs[targetIndex] = {};
          }
          
          const hadAttackDown = battle.enemyDebuffs[targetIndex].attackDown ? true : false;
          battle.enemyDebuffs[targetIndex].attackDown = {
            duration: skill.attackDownDuration, // æŒçºŒ2å›åˆ
            ratio: skill.attackDownRatio // æ¸›å°‘1/3æ”»æ“ŠåŠ›
          };
          
          if (hadAttackDown) {
            pushBattleLog(`â†’ ${target.name}çš„æ”»æ“ŠåŠ›æ¸›å°‘æ•ˆæœè¢«åˆ·æ–°ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.attackDownDuration}å›åˆä¸­ï¼Œæ”»æ“ŠåŠ›æ¸›å°‘ ${Math.round(skill.attackDownRatio * 100)}%ã€‚`);
          } else {
            pushBattleLog(`â†’ ${target.name}çš„æ”»æ“ŠåŠ›è¢«å‰Šå¼±ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.attackDownDuration}å›åˆä¸­ï¼Œæ”»æ“ŠåŠ›æ¸›å°‘ ${Math.round(skill.attackDownRatio * 100)}%ã€‚`);
          }
        }
        
        // è…æ“Šï¼šé™ä½æ•µäººæ”»æ“ŠåŠ›1/3ï¼ˆæŒçºŒ2å›åˆï¼‰
        if (skill.id && skill.id.startsWith('kidney_strike_') && skill.attackDownDuration && skill.attackDownRatio) {
          // åˆå§‹åŒ– enemyDebuffs
          if (!battle.enemyDebuffs) {
            battle.enemyDebuffs = {};
          }
          
          // è¨­ç½®æ”»æ“ŠåŠ›æ¸›å°‘ç‹€æ…‹ï¼ˆå¦‚æœå·²ç¶“æœ‰æ”»æ“ŠåŠ›æ¸›å°‘ç‹€æ…‹ï¼Œé‡ç½®æŒçºŒæ™‚é–“ï¼‰
          if (!battle.enemyDebuffs[targetIndex]) {
            battle.enemyDebuffs[targetIndex] = {};
          }
          
          const hadAttackDown = battle.enemyDebuffs[targetIndex].attackDown ? true : false;
          battle.enemyDebuffs[targetIndex].attackDown = {
            duration: skill.attackDownDuration, // æŒçºŒ2å›åˆ
            ratio: skill.attackDownRatio // æ¸›å°‘1/3æ”»æ“ŠåŠ›
          };
          
          if (hadAttackDown) {
            pushBattleLog(`â†’ ${target.name}çš„æ”»æ“ŠåŠ›æ¸›å°‘æ•ˆæœè¢«åˆ·æ–°ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.attackDownDuration}å›åˆä¸­ï¼Œæ”»æ“ŠåŠ›æ¸›å°‘ ${Math.round(skill.attackDownRatio * 100)}%ã€‚`);
          } else {
            pushBattleLog(`â†’ ${target.name}çš„æ”»æ“ŠåŠ›è¢«å‰Šå¼±ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.attackDownDuration}å›åˆä¸­ï¼Œæ”»æ“ŠåŠ›æ¸›å°‘ ${Math.round(skill.attackDownRatio * 100)}%ã€‚`);
          }
        }
      }
    }
    
    // è–æ“Šï¼šåœ¨å‹‡è€…å›åˆåŸ·è¡Œå¾Œä¹Ÿæœƒå›å¾©HPï¼ˆåœ¨executeNextActionä¸­è™•ç†ï¼‰
  } else if (skill.kind === 'enhance') {
    // å¢å¼·æŠ€èƒ½ï¼ˆå…‰ç’°ã€è‡ªèº«buffæˆ–é˜²æ­»è­·ç›¾ï¼‰
    const attackerName = isCompanionTurn ? attacker.name : 'ä½ ';
    
    // æª¢æŸ¥æ˜¯å¦ç‚ºé˜²æ­»è­·ç›¾æŠ€èƒ½ï¼ˆé€šédeathWardå±¬æ€§æˆ–æŠ€èƒ½IDï¼‰
    const isDeathWardSkill = skill.deathWard || skill.id === 'sage_death_ward_1';
    if (isDeathWardSkill) {
      applyDeathWardToAllAllies(skill, attacker, attackerName);

      // ç¹¼çºŒåŸ·è¡Œå¾ŒçºŒæµç¨‹ï¼ˆè®“å›åˆç¹¼çºŒï¼‰
      setTimeout(() => {
        if (isHeroTurn) {
          battle.turn = 'companion';
          setTimeout(companionAct, 800);
        } else {
          battle.turn = 'enemy';
          setTimeout(enemyAct, 800);
        }
      }, 800);
      return;
    } else if (skill.selfBuff) {
      // è‡ªèº«buffæŠ€èƒ½ï¼ˆåŠæ„ï¼‰ï¼šæ¶ˆè€—MPï¼Œæå‡è‡ªèº«èƒ½åŠ›
      const mpCost = skill.mpCost || 0;
      attacker.stats.mp -= mpCost;
      
      // æ‡‰ç”¨åŠæ„buff
      const attackBoost = skill.attackBoost || 0;
      const critBoost = skill.critBoost || 0;
      const duration = skill.duration || 3;
      
      if (isHeroTurn) {
        battle.heroBuffs.swordIntent = {
          attackBoost: attackBoost,
          critBoost: critBoost,
          duration: duration,
        };
        pushBattleLog(`${attackerName}æ–½æ”¾ã€Œ${skill.name}ã€ï¼`);
        pushBattleLog(`â†’ æ”»æ“ŠåŠ›æå‡ ${Math.round(attackBoost * 100)}%ï¼Œæš´æ“Šç‡æå‡ ${critBoost}%ï¼ŒæŒçºŒ ${duration} å›åˆã€‚`);
      } else {
        // åŒä¼´ä½¿ç”¨
        const companionIndex = state.companions.indexOf(attacker);
        if (companionIndex >= 0) {
          if (!battle.companionBuffs[companionIndex]) {
            battle.companionBuffs[companionIndex] = {};
          }
          battle.companionBuffs[companionIndex].swordIntent = {
            attackBoost: attackBoost,
            critBoost: critBoost,
            duration: duration,
          };
          pushBattleLog(`${attackerName}æ–½æ”¾ã€Œ${skill.name}ã€ï¼`);
          pushBattleLog(`â†’ æ”»æ“ŠåŠ›æå‡ ${Math.round(attackBoost * 100)}%ï¼Œæš´æ“Šç‡æå‡ ${critBoost}%ï¼ŒæŒçºŒ ${duration} å›åˆã€‚`);
        }
      }
    } else {
      // å…‰ç’°æŠ€èƒ½ä¸è€—MPï¼Œç›´æ¥ä½¿ç”¨
      useAuraSkill(attacker, skill, attackerName, isHeroTurn);
    }
    
    renderBattleDialog();
    setTimeout(() => {
      if (isHeroTurn) {
        battle.turn = 'companion';
        setTimeout(companionAct, 800);
      } else {
        battle.turn = 'enemy';
        setTimeout(enemyAct, 800);
      }
    }, 800);
  } else if (skill.kind === 'support') {
    // è¼”åŠ©æŠ€èƒ½ï¼ˆè­·ç›¾ã€æ·¨åŒ–ç­‰ï¼‰
    const attackerName = isCompanionTurn ? attacker.name : 'ä½ ';
    
    // æª¢æŸ¥æ˜¯å¦ç‚ºæ·¨åŒ–æŠ€èƒ½
    const isPurifySkill = skill.id && (skill.id === 'purify_1' || skill.id === 'mass_purify_1');
    
    if (isPurifySkill) {
      // æ·¨åŒ–æŠ€èƒ½ï¼šè§£é™¤å‹æ–¹debuff
      if (skill.aoe) {
        // å…¨é«”æ·¨åŒ–ï¼šè§£é™¤æ‰€æœ‰å‹æ–¹çš„æ‰€æœ‰debuff
        attacker.stats.mp -= mpCost;
        pushBattleLog(`${attackerName}æ–½æ”¾ã€Œ${skill.name}ã€ï¼`);
        let purifiedCount = 0;
        
        if (!battle.friendlyDebuffs) {
          battle.friendlyDebuffs = { hero: {}, companions: {} };
        }
        
        // è§£é™¤å‹‡è€…çš„debuff
        if (battle.friendlyDebuffs.hero && state.hero && state.hero.stats.hp > 0) {
          const heroDebuffCount = Object.keys(battle.friendlyDebuffs.hero).length;
          if (heroDebuffCount > 0) {
            battle.friendlyDebuffs.hero = {};
            purifiedCount++;
            pushBattleLog(`â†’ å‹‡è€…çš„æ‰€æœ‰debuffè¢«è§£é™¤ï¼`);
          }
        }
        
        // è§£é™¤æ‰€æœ‰åŒä¼´çš„debuff
        if (battle.friendlyDebuffs.companions) {
          const companionIndices = Object.keys(battle.friendlyDebuffs.companions).map(s => parseInt(s));
          companionIndices.forEach(companionIndex => {
            if (companionIndex >= 0 && companionIndex < state.companions.length) {
              const companion = state.companions[companionIndex];
              if (companion && companion.stats.hp > 0 && battle.friendlyDebuffs.companions[companionIndex]) {
                const debuffCount = Object.keys(battle.friendlyDebuffs.companions[companionIndex]).length;
                if (debuffCount > 0) {
                  delete battle.friendlyDebuffs.companions[companionIndex];
                  purifiedCount++;
                  pushBattleLog(`â†’ ${companion.name}çš„æ‰€æœ‰debuffè¢«è§£é™¤ï¼`);
                }
              }
            }
          });
        }
        
        if (purifiedCount === 0) {
          pushBattleLog(`â†’ æ²’æœ‰å‹æ–¹å—åˆ°debuffå½±éŸ¿ã€‚`);
        }
        
        renderBattleDialog();
        setTimeout(() => {
          if (isHeroTurn) {
            battle.turn = 'companion';
            setTimeout(companionAct, 800);
          } else {
            battle.turn = 'enemy';
            setTimeout(enemyAct, 800);
          }
        }, 800);
        return;
      } else {
        // å–®é«”æ·¨åŒ–ï¼šéœ€è¦é¸æ“‡å‹æ–¹ç›®æ¨™
        let targetCharacter = null;
        let targetName = '';
        
        if (battle.selectedEnemyIndex === -1) {
          // ç›®æ¨™æ˜¯è‡ªå·±
          targetCharacter = isHeroTurn ? state.hero : attacker;
          targetName = 'è‡ªå·±';
        } else if (battle.selectedEnemyIndex !== null && battle.selectedEnemyIndex <= -2) {
          // ç›®æ¨™æ˜¯åŒä¼´
          const companionIndex = Math.abs(battle.selectedEnemyIndex) - 2;
          const allCompanions = (state.companions || []).filter(c => c && c.stats);
          if (companionIndex >= 0 && companionIndex < allCompanions.length) {
            targetCharacter = allCompanions[companionIndex];
            targetName = targetCharacter.name;
          }
        }
        
        if (!targetCharacter || targetCharacter.stats.hp <= 0) {
          pushBattleLog(`${attackerName}ç„¡æ³•ä½¿ç”¨ã€Œ${skill.name}ã€ï¼šç›®æ¨™ç„¡æ•ˆã€‚`);
          return;
        }
        
        // å¦‚æœæ˜¯å‹‡è€…å›åˆä¸”æ²’æœ‰é¸æ“‡ç›®æ¨™ï¼Œé¡¯ç¤ºé¸æ“‡ç•Œé¢
        if (isHeroTurn && battle.selectedEnemyIndex === null) {
          battle.menu = 'select-target';
          battle.pendingSkill = skillId;
          renderBattleDialog();
          return;
        }
        
        // åŒä¼´å›åˆæ™‚è‡ªå‹•é¸æ“‡ç¬¬ä¸€å€‹æœ‰debuffçš„å‹æ–¹ï¼ˆå„ªå…ˆé¸æ“‡è‡ªå·±ï¼‰
        if (isCompanionTurn && battle.selectedEnemyIndex === null) {
          // å…ˆæª¢æŸ¥è‡ªå·±æ˜¯å¦æœ‰debuff
          if (battle.friendlyDebuffs && battle.friendlyDebuffs.companions) {
            const companionIndex = state.companions.indexOf(attacker);
            if (companionIndex >= 0 && battle.friendlyDebuffs.companions[companionIndex] && Object.keys(battle.friendlyDebuffs.companions[companionIndex]).length > 0) {
              battle.selectedEnemyIndex = -2 - companionIndex;
            } else if (battle.friendlyDebuffs.hero && Object.keys(battle.friendlyDebuffs.hero).length > 0) {
              // å¦‚æœè‡ªå·±æ²’æœ‰debuffï¼Œæª¢æŸ¥å‹‡è€…
              battle.selectedEnemyIndex = -1;
            } else {
              // å¦‚æœéƒ½æ²’æœ‰ï¼Œé¸æ“‡ç¬¬ä¸€å€‹æœ‰debuffçš„åŒä¼´
              const companionIndices = Object.keys(battle.friendlyDebuffs.companions || {}).map(s => parseInt(s));
              for (const idx of companionIndices) {
                if (idx >= 0 && idx < state.companions.length && battle.friendlyDebuffs.companions[idx] && Object.keys(battle.friendlyDebuffs.companions[idx]).length > 0) {
                  battle.selectedEnemyIndex = -2 - idx;
                  break;
                }
              }
            }
          } else if (battle.friendlyDebuffs && battle.friendlyDebuffs.hero && Object.keys(battle.friendlyDebuffs.hero).length > 0) {
            battle.selectedEnemyIndex = -1;
          }
        }
        
        // é‡æ–°ç¢ºå®šç›®æ¨™ï¼ˆå› ç‚ºå¯èƒ½å·²ç¶“è¨­ç½®äº†selectedEnemyIndexï¼‰
        if (battle.selectedEnemyIndex === -1) {
          targetCharacter = state.hero;
          targetName = 'å‹‡è€…';
        } else if (battle.selectedEnemyIndex !== null && battle.selectedEnemyIndex <= -2) {
          const companionIndex = Math.abs(battle.selectedEnemyIndex) - 2;
          const allCompanions = (state.companions || []).filter(c => c && c.stats);
          if (companionIndex >= 0 && companionIndex < allCompanions.length) {
            targetCharacter = allCompanions[companionIndex];
            targetName = targetCharacter.name;
          }
        }
        
        if (!targetCharacter || targetCharacter.stats.hp <= 0) {
          pushBattleLog(`${attackerName}ç„¡æ³•ä½¿ç”¨ã€Œ${skill.name}ã€ï¼šç›®æ¨™ç„¡æ•ˆã€‚`);
          return;
        }
        
        attacker.stats.mp -= mpCost;
        pushBattleLog(`${attackerName}å°${targetName}æ–½æ”¾ã€Œ${skill.name}ã€ï¼`);
        
        if (!battle.friendlyDebuffs) {
          battle.friendlyDebuffs = { hero: {}, companions: {} };
        }
        
        const isTargetHero = targetCharacter === state.hero;
        if (isTargetHero) {
          if (battle.friendlyDebuffs.hero) {
            const debuffCount = Object.keys(battle.friendlyDebuffs.hero).length;
            if (debuffCount > 0) {
              battle.friendlyDebuffs.hero = {};
              pushBattleLog(`â†’ ${targetName}çš„æ‰€æœ‰debuffè¢«è§£é™¤ï¼`);
            } else {
              pushBattleLog(`â†’ ${targetName}æ²’æœ‰debuffç‹€æ…‹ã€‚`);
            }
          } else {
            pushBattleLog(`â†’ ${targetName}æ²’æœ‰debuffç‹€æ…‹ã€‚`);
          }
        } else {
          const companionIndex = state.companions.indexOf(targetCharacter);
          if (companionIndex >= 0) {
            if (!battle.friendlyDebuffs.companions[companionIndex]) {
              pushBattleLog(`â†’ ${targetName}æ²’æœ‰debuffç‹€æ…‹ã€‚`);
            } else {
              const debuffCount = Object.keys(battle.friendlyDebuffs.companions[companionIndex]).length;
              if (debuffCount > 0) {
                delete battle.friendlyDebuffs.companions[companionIndex];
                pushBattleLog(`â†’ ${targetName}çš„æ‰€æœ‰debuffè¢«è§£é™¤ï¼`);
              } else {
                pushBattleLog(`â†’ ${targetName}æ²’æœ‰debuffç‹€æ…‹ã€‚`);
              }
            }
          }
        }
        
        renderBattleDialog();
        setTimeout(() => {
          if (isHeroTurn) {
            battle.turn = 'companion';
            setTimeout(companionAct, 800);
          } else {
            battle.turn = 'enemy';
            setTimeout(enemyAct, 800);
          }
        }, 800);
        return;
      }
    }
    
    // å¦‚æœæ˜¯å…¨é«”è¼”åŠ©æŠ€èƒ½ï¼ˆè­·ç›¾ç­‰ï¼‰
    if (skill.aoe) {
      attacker.stats.mp -= mpCost;
      pushBattleLog(`${attackerName}æ–½æ”¾ã€Œ${skill.name}ã€ï¼`);
      
      // è¨ˆç®—è­·ç›¾å€¼
      const isHero = attacker === state.hero;
      const totalAttrs = isHero 
        ? getHeroTotalAttributes(attacker)
        : getCompanionTotalAttributes(attacker);
      const recovery = totalAttrs.recovery;
      const shieldAmount = skill.power + Math.floor(recovery / 2);
      
      // çµ¦è‡ªå·±æ·»åŠ è­·ç›¾ï¼ˆå¦‚æœé‚„æ´»è‘—ï¼‰
      if (attacker.stats.hp > 0) {
        attacker.stats.shield = (attacker.stats.shield || 0) + shieldAmount;
        const selfTargetName = isCompanionTurn ? attacker.name : 'è‡ªå·±';
        pushBattleLog(`â†’ å°${selfTargetName}æ–½åŠ  ${shieldAmount} è­·ç›¾ï¼`);
      }
      
      // çµ¦å‹‡è€…æ·»åŠ è­·ç›¾ï¼ˆå¦‚æœæ˜¯åŒä¼´æ–½æ”¾ï¼Œä¸”å‹‡è€…é‚„æ´»è‘—ï¼‰
      if (isCompanionTurn && state.hero && state.hero.stats.hp > 0) {
        state.hero.stats.shield = (state.hero.stats.shield || 0) + shieldAmount;
        pushBattleLog(`â†’ å°å‹‡è€…æ–½åŠ  ${shieldAmount} è­·ç›¾ï¼`);
      }
      
      // çµ¦æ‰€æœ‰åŒä¼´æ·»åŠ è­·ç›¾ï¼ˆå¦‚æœæ˜¯å‹‡è€…æ–½æ”¾ï¼‰
      if (isHeroTurn) {
        const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
        activeCompanions.forEach(companion => {
          companion.stats.shield = (companion.stats.shield || 0) + shieldAmount;
          pushBattleLog(`â†’ å°${companion.name}æ–½åŠ  ${shieldAmount} è­·ç›¾ï¼`);
        });
      } else {
        // å¦‚æœæ˜¯åŒä¼´æ–½æ”¾ï¼Œçµ¦å…¶ä»–åŒä¼´æ·»åŠ è­·ç›¾
        const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0 && c !== attacker);
        activeCompanions.forEach(companion => {
          companion.stats.shield = (companion.stats.shield || 0) + shieldAmount;
          pushBattleLog(`â†’ å°${companion.name}æ–½åŠ  ${shieldAmount} è­·ç›¾ï¼`);
        });
      }
    } else {
      // å–®é«”è¼”åŠ©æŠ€èƒ½
      // éœ€è¦é¸æ“‡ç›®æ¨™ï¼ˆè‡ªå·±æˆ–åŒä¼´ï¼Œä¸èƒ½é¸æ“‡æ•µäººï¼‰
      if (battle.menu === 'select-heal-target' || battle.menu === 'select-skill-target' || battle.menu === 'select-support-target' || battle.menu === 'select-target') {
        // ç­‰å¾…é¸æ“‡ç›®æ¨™
        return;
      }
      
      // ç¢ºå®šç›®æ¨™
      let targetCharacter = null;
      let targetName = '';
      
      if (battle.selectedEnemyIndex === -1) {
        // ç›®æ¨™æ˜¯è‡ªå·±
        targetCharacter = attacker;
        targetName = isCompanionTurn ? attacker.name : 'è‡ªå·±';
      } else if (battle.selectedEnemyIndex !== null && battle.selectedEnemyIndex <= -2) {
        // ç›®æ¨™æ˜¯åŒä¼´
        const companionIndex = Math.abs(battle.selectedEnemyIndex) - 2;
        const allCompanions = (state.companions || []).filter(c => c && c.stats);
        if (companionIndex >= 0 && companionIndex < allCompanions.length) {
          targetCharacter = allCompanions[companionIndex];
          targetName = targetCharacter.name;
        }
      }
      
      if (!targetCharacter || targetCharacter.stats.hp <= 0) {
        pushBattleLog(`${attackerName}è©¦åœ–æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œä½†ç›®æ¨™ç„¡æ•ˆã€‚`);
        return;
      }
      
      attacker.stats.mp -= mpCost;
      
      // è¨ˆç®—è­·ç›¾å€¼
      const isHero = attacker === state.hero;
      const totalAttrs = isHero 
        ? getHeroTotalAttributes(attacker)
        : getCompanionTotalAttributes(attacker);
      const recovery = totalAttrs.recovery;
      const shieldAmount = skill.power + Math.floor(recovery / 2);
      
      // çµ¦ç›®æ¨™æ·»åŠ è­·ç›¾
      targetCharacter.stats.shield = (targetCharacter.stats.shield || 0) + shieldAmount;
      pushBattleLog(`${attackerName}æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œå°${targetName}æ–½åŠ  ${shieldAmount} è­·ç›¾ï¼`);
    }
    
    renderBattleDialog();
    setTimeout(() => {
      if (isHeroTurn) {
        battle.turn = 'companion';
        setTimeout(companionAct, 800);
      } else {
        battle.turn = 'enemy';
        setTimeout(enemyAct, 800);
      }
    }, 800);
    return;
  } else if (skill.kind === 'heal') {
    // å›å¾©æŠ€èƒ½å¯ä»¥é¸æ“‡ç›®æ¨™ï¼ˆè‡ªå·±ã€åŒä¼´æˆ–æ•µäººï¼‰
    const attackerName = isCompanionTurn ? attacker.name : 'ä½ ';
    
    // å¦‚æœæ˜¯å…¨ä½“å›å¤æŠ€èƒ½ï¼Œç›´æ¥å¯¹æ‰€æœ‰å‹æ–¹ç”Ÿæ•ˆï¼Œä¸éœ€è¦é€‰æ‹©ç›®æ ‡
    if (skill.aoe) {
      attacker.stats.mp -= mpCost;
      let totalHeal = 0;
      pushBattleLog(`${attackerName}æ–½æ”¾ã€Œ${skill.name}ã€ï¼`);
      
      // æ²»ç–—è‡ªå·±ï¼ˆå‹‡è€…æˆ–åŒä¼´ï¼Œå¿…é ˆé‚„æ´»è‘—ï¼‰
      // æ™®é€šå›å¾©é­”æ³•ç„¡æ³•å¾©æ´»å·²æ­»äº¡çš„è§’è‰²
      if (attacker.stats.hp > 0) {
      const selfAmount = calculateHealingFor(skill, attacker);
      const oldSelfHp = attacker.stats.hp;
      attacker.stats.hp = Math.min(attacker.stats.maxHp, attacker.stats.hp + selfAmount);
      const actualHealed = attacker.stats.hp - oldSelfHp;
      const selfTargetName = isCompanionTurn ? attacker.name : 'è‡ªå·±';
      pushBattleLog(`â†’ å°${selfTargetName}å›å¾© ${actualHealed} HPï¼ˆ${oldSelfHp} â†’ ${attacker.stats.hp}ï¼‰`);
      totalHeal += actualHealed;
      // è§¸ç™¼ç¥è–è­·ç›¾æ•ˆæœï¼ˆå¦‚æœæ˜¯ç¥è–è­·ç›¾æŠ€èƒ½ï¼‰
      applySacredShieldEffect(skill, attacker, attacker);
      // è§¸ç™¼é˜²æ­»è­·ç›¾æ•ˆæœï¼ˆå¦‚æœæ˜¯é˜²æ­»è­·ç›¾æŠ€èƒ½ï¼‰
      applyDeathWardEffect(skill, attacker, attacker);
      // è§¸ç™¼ç¥è–å›éŸ¿æ•ˆæœ
      applyHealingEchoEffect(skill, attacker, attacker, actualHealed);
      } else {
        const selfTargetName = isCompanionTurn ? attacker.name : 'è‡ªå·±';
        pushBattleLog(`â†’ ${selfTargetName}å·²æ­»äº¡ï¼Œç„¡æ³•å›å¾©ã€‚`);
      }
      
      // æ²»ç–—å‹‡è€…ï¼ˆå¦‚æœæ˜¯åŒä¼´æ–½æ”¾ï¼Œä¸”å‹‡è€…é‚„æ´»è‘—ï¼‰
      // æ™®é€šå›å¾©é­”æ³•ç„¡æ³•å¾©æ´»å·²æ­»äº¡çš„è§’è‰²
      if (isCompanionTurn && state.hero && state.hero.stats.hp > 0) {
        const heroAmount = calculateHealingFor(skill, attacker);
        const oldHeroHp = state.hero.stats.hp;
        state.hero.stats.hp = Math.min(state.hero.stats.maxHp, state.hero.stats.hp + heroAmount);
        const actualHealed = state.hero.stats.hp - oldHeroHp;
        pushBattleLog(`â†’ å°å‹‡è€…å›å¾© ${actualHealed} HPï¼ˆ${oldHeroHp} â†’ ${state.hero.stats.hp}ï¼‰`);
        totalHeal += actualHealed;
        // è§¸ç™¼ç¥è–è­·ç›¾æ•ˆæœï¼ˆå¦‚æœæ˜¯ç¥è–è­·ç›¾æŠ€èƒ½ï¼‰
        applySacredShieldEffect(skill, attacker, state.hero);
        // è§¸ç™¼é˜²æ­»è­·ç›¾æ•ˆæœï¼ˆå¦‚æœæ˜¯é˜²æ­»è­·ç›¾æŠ€èƒ½ï¼‰
        applyDeathWardEffect(skill, attacker, state.hero);
        // è§¸ç™¼ç¥è–å›éŸ¿æ•ˆæœ
        applyHealingEchoEffect(skill, attacker, state.hero, actualHealed);
      } else if (isCompanionTurn && state.hero && state.hero.stats.hp <= 0) {
        pushBattleLog(`â†’ å‹‡è€…å·²æ­»äº¡ï¼Œç„¡æ³•å›å¾©ã€‚`);
      }
      
      // æ²»ç–—åŒä¼´ï¼ˆå¦‚æœæ˜¯å‹‡è€…æ–½æ”¾ï¼‰
      if (isHeroTurn) {
        const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
        activeCompanions.forEach(companion => {
          const companionAmount = calculateHealingFor(skill, attacker);
          const oldCompanionHp = companion.stats.hp;
          companion.stats.hp = Math.min(companion.stats.maxHp, companion.stats.hp + companionAmount);
          const actualHealed = companion.stats.hp - oldCompanionHp;
          pushBattleLog(`â†’ å°${companion.name}å›å¾© ${actualHealed} HPï¼ˆ${oldCompanionHp} â†’ ${companion.stats.hp}ï¼‰`);
          totalHeal += actualHealed;
          // è§¸ç™¼ç¥è–è­·ç›¾æ•ˆæœï¼ˆå¦‚æœæ˜¯ç¥è–è­·ç›¾æŠ€èƒ½ï¼‰
          applySacredShieldEffect(skill, attacker, companion);
          // è§¸ç™¼é˜²æ­»è­·ç›¾æ•ˆæœï¼ˆå¦‚æœæ˜¯é˜²æ­»è­·ç›¾æŠ€èƒ½ï¼‰
          applyDeathWardEffect(skill, attacker, companion);
          // è§¸ç™¼ç¥è–å›éŸ¿æ•ˆæœ
          applyHealingEchoEffect(skill, attacker, companion, actualHealed);
        });
      }
      
      pushBattleLog(`ç¸½å…±å›å¾© ${totalHeal} HPï¼`);
      battle.menu = 'root';
      battle.selectedEnemyIndex = null;
      battle.pendingSkill = null;
      
      // å‹‡è€…å›åˆï¼šä¿å­˜è¡Œå‹•ï¼›åŒä¼´å›åˆï¼šç«‹å³åŸ·è¡Œ
      if (isHeroTurn) {
        battle.heroAction = {
          type: 'skill',
          skillId: skillId,
          target: null, // AOEæŠ€èƒ½ä¸éœ€è¦ç›®æ¨™
        };
        endHeroTurn();
      } else {
        renderBattleDialog();
        endCompanionTurn();
      }
      return;
    }
    
    if (battle.selectedEnemyIndex === -1) {
      // é¸æ“‡äº†è‡ªå·±ï¼ˆ-1è¡¨ç¤ºè‡ªå·±ï¼‰
      attacker.stats.mp -= mpCost;
      const amount = calculateHealingFor(skill, attacker);
      attacker.stats.hp = Math.min(attacker.stats.maxHp, attacker.stats.hp + amount);
      const targetName = isCompanionTurn ? attacker.name : 'ä½ ';
      // è§¸ç™¼ç¥è–è­·ç›¾æ•ˆæœï¼ˆå¦‚æœæ˜¯ç¥è–è­·ç›¾æŠ€èƒ½ï¼‰
      applySacredShieldEffect(skill, attacker, attacker);
      // å‹‡è€…å›åˆï¼šä¿å­˜è¡Œå‹•ï¼›åŒä¼´å›åˆï¼šç«‹å³åŸ·è¡Œ
      if (isHeroTurn) {
        battle.heroAction = {
          type: 'skill',
          skillId: skillId,
          target: 'hero', // -1è¡¨ç¤ºè‡ªå·±
        };
        battle.menu = 'root';
        battle.selectedEnemyIndex = null;
        battle.pendingSkill = null;
        endHeroTurn();
      } else {
        pushLog(`${attackerName}æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œå›å¾© ${amount} HPã€‚`);
        battle.menu = 'root';
        battle.selectedEnemyIndex = null;
        battle.pendingSkill = null;
        renderBattleDialog();
        endCompanionTurn();
      }
    } else if (battle.selectedEnemyIndex <= -2) {
      // é¸æ“‡äº†åŒä¼´ï¼ˆ-2 è¡¨ç¤ºç¬¬ä¸€å€‹åŒä¼´ï¼Œ-3 è¡¨ç¤ºç¬¬äºŒå€‹ï¼Œä»¥æ­¤é¡æ¨ï¼‰
      if (isCompanionTurn) {
        // åŒä¼´ä¸èƒ½æ²»ç™‚è‡ªå·±ï¼ˆæ‡‰è©²é¸-1ï¼‰ï¼Œä½†å¯ä»¥æ²»ç™‚è‹±é›„ï¼ˆå¿…é ˆé‚„æ´»è‘—ï¼‰
        // æ™®é€šå›å¾©é­”æ³•ç„¡æ³•å¾©æ´»å·²æ­»äº¡çš„è§’è‰²
        const target = state.hero;
        if (target && target.stats.hp > 0) {
        attacker.stats.mp -= mpCost;
        const amount = calculateHealingFor(skill, attacker);
        target.stats.hp = Math.min(target.stats.maxHp, target.stats.hp + amount);
        pushLog(`${attackerName}æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œå°å‹‡è€…å›å¾© ${amount} HPã€‚`);
        // è§¸ç™¼ç¥è–è­·ç›¾æ•ˆæœï¼ˆå¦‚æœæ˜¯ç¥è–è­·ç›¾æŠ€èƒ½ï¼‰
        applySacredShieldEffect(skill, attacker, target);
        } else {
          attacker.stats.mp -= mpCost;
          pushLog(`${attackerName}æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œä½†å‹‡è€…å·²æ­»äº¡ï¼Œç„¡æ³•å›å¾©ã€‚`);
        }
        battle.menu = 'root';
        battle.selectedEnemyIndex = null;
        battle.pendingSkill = null;
        renderBattleDialog();
        endCompanionTurn();
      } else {
        // è‹±é›„æ²»ç™‚åŒä¼´ï¼šä¿å­˜è¡Œå‹•
        // è¨ˆç®—åŒä¼´ç´¢å¼•ï¼š-2 -> 0, -3 -> 1, -4 -> 2, ...
        const companionIndex = Math.abs(battle.selectedEnemyIndex) - 2;
        const allCompanions = (state.companions || []).filter(c => c && c.stats);
        const targetCompanion = allCompanions[companionIndex];
        
        // æª¢æŸ¥æ˜¯å¦æ˜¯å¾©æ´»æŠ€èƒ½ä¸”ç›®æ¨™å·²æ­»äº¡
        const isReviveSkill = skill.id === 'revive_companion';
        if (isReviveSkill && targetCompanion && targetCompanion.stats.hp <= 0) {
          // å¾©æ´»æŠ€èƒ½ï¼šç«‹å³åŸ·è¡Œï¼ˆä¸åŠ å…¥éšŠåˆ—ï¼‰
          attacker.stats.mp -= mpCost;
          const revivePercent = skill.revivePercent || 0.3;
          const reviveHp = Math.max(1, Math.floor(targetCompanion.stats.maxHp * revivePercent));
          targetCompanion.stats.hp = reviveHp;
          pushBattleLog(`å‹‡è€…æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œå¾©æ´»äº†${targetCompanion.name}ï¼Œå›å¾© ${reviveHp} HPï¼ˆ${targetCompanion.stats.maxHp}çš„${Math.round(revivePercent * 100)}%ï¼‰ï¼`);
          battle.menu = 'root';
          battle.selectedEnemyIndex = null;
          battle.pendingSkill = null;
          renderBattleDialog();
          endHeroTurn();
        } else {
          // æ™®é€šæ²»ç™‚ï¼šä¿å­˜è¡Œå‹•
        battle.heroAction = {
          type: 'skill',
          skillId: skillId,
          target: 'companion', // è¡¨ç¤ºåŒä¼´
          companionIndex: companionIndex, // æŒ‡å®šæ˜¯å“ªå€‹åŒä¼´
        };
        battle.menu = 'root';
        battle.selectedEnemyIndex = null;
        battle.pendingSkill = null;
        endHeroTurn();
        }
      }
    } else if (battle.selectedEnemyIndex !== null && battle.selectedEnemyIndex >= 0) {
      // æ¢å¾©æŠ€èƒ½ä¸èƒ½é¸æ“‡æ•µäººï¼Œå¦‚æœé¸æ“‡äº†æ•µäººï¼Œå¿½ç•¥ä¸¦è¦æ±‚é‡æ–°é¸æ“‡
      battle.menu = 'select-target';
      battle.pendingSkill = skillId;
      renderBattleDialog();
      return;
    } else {
      // éœ€è¦é¸æ“‡ç›®æ¨™
      battle.menu = 'select-target';
      battle.pendingSkill = skillId;
      renderBattleDialog();
    }
  } else if (skill.kind === 'buff') {
    // è™•ç†å‚·å®³æ¸›å…æŠ€èƒ½
    if (skill.damageReduction !== undefined) {
      // å‚·å®³æ¸›å…æŠ€èƒ½éœ€è¦é¸æ“‡ç›®æ¨™ï¼ˆè‡ªå·±æˆ–åŒä¼´ï¼‰
      if (isHeroTurn) {
        // æª¢æŸ¥æ˜¯å¦å·²ç¶“é¸æ“‡äº†ç›®æ¨™
        if (battle.selectedEnemyIndex === null && battle.menu !== 'select-target') {
          // éœ€è¦é¸æ“‡ç›®æ¨™ï¼šè‡ªå·±æˆ–åŒä¼´
          battle.menu = 'select-target';
          battle.pendingSkill = skillId;
          renderBattleDialog();
          return;
        }
        
        // å·²ç¶“é¸æ“‡äº†ç›®æ¨™ï¼ŒåŸ·è¡ŒæŠ€èƒ½
        const targetIndex = battle.selectedEnemyIndex;
        let target = null;
        let targetName = '';
        
        if (targetIndex === -1) {
          // å°è‡ªå·±ä½¿ç”¨
          target = state.hero;
          targetName = 'è‡ªå·±';
        } else if (targetIndex === -2) {
          // å°åŒä¼´ä½¿ç”¨
          const activeCompanion = getActiveCompanion();
          if (!activeCompanion || activeCompanion.stats.hp <= 0) {
            pushLog('æ²’æœ‰å¯é¸æ“‡çš„åŒä¼´ï¼');
            renderBattleDialog();
            return;
          }
          target = activeCompanion;
          targetName = activeCompanion.name;
        } else {
          pushLog('å‚·å®³æ¸›å…æŠ€èƒ½åªèƒ½å°è‡ªå·±æˆ–åŒä¼´ä½¿ç”¨ï¼');
          renderBattleDialog();
          return;
        }
        
        // æ¶ˆè€—MP
        attacker.stats.mp -= mpCost;
        
        // è¨­ç½®å‚·å®³æ¸›å…buffå’Œå˜²è«·æ•ˆæœ
        const damageReduction = skill.damageReduction;
        if (target === state.hero) {
          battle.heroBuffs.guard = Math.max(battle.heroBuffs.guard, damageReduction);
          // è¨­ç½®å˜²è«·ç›®æ¨™ï¼š100%å¸å¼•æ‰€æœ‰å–®é«”æ”»æ“Š
          battle.tauntTarget = { type: 'hero', character: state.hero };
        } else {
          if (!battle.companionBuffs) {
            battle.companionBuffs = {};
          }
          // ä¿ç•™ç°æœ‰çš„ç´¢å¼•æ ¼å¼buffï¼ˆå¦‚ignoreDefenseï¼‰
          const existingIndexBuffs = {};
          Object.keys(battle.companionBuffs).forEach(key => {
            const index = parseInt(key);
            if (!isNaN(index) && battle.companionBuffs[index]) {
              existingIndexBuffs[index] = { ...battle.companionBuffs[index] };
            }
          });
          battle.companionBuffs = { ...existingIndexBuffs };
          battle.companionBuffs.guard = Math.max(battle.companionBuffs.guard || 0, damageReduction);
          // è¨­ç½®å˜²è«·ç›®æ¨™ï¼š100%å¸å¼•æ‰€æœ‰å–®é«”æ”»æ“Š
          battle.tauntTarget = { type: 'companion', character: target };
        }
        
        pushBattleLog(`ä½ å°${targetName}æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œ${targetName}é€™å›åˆå—åˆ°å‚·å®³æ¸›å°‘ ${Math.round(damageReduction * 100)}%ï¼Œä¸¦å¸å¼•æ‰€æœ‰æ•µäººçš„å–®é«”æ”»æ“Šï¼`);
        battle.menu = 'root';
        battle.selectedEnemyIndex = null;
        battle.pendingSkill = null;
        renderBattleDialog();
        endHeroTurn();
      } else if (isCompanionTurn) {
        // åŒä¼´å›åˆï¼šåªèƒ½å°è‡ªå·±ä½¿ç”¨
        // æ¶ˆè€—MP
        attacker.stats.mp -= mpCost;
        
        if (!battle.companionBuffs) {
          battle.companionBuffs = {};
        }
        // ä¿ç•™ç°æœ‰çš„ç´¢å¼•æ ¼å¼buffï¼ˆå¦‚ignoreDefenseï¼‰
        const existingIndexBuffs = {};
        Object.keys(battle.companionBuffs).forEach(key => {
          const index = parseInt(key);
          if (!isNaN(index) && battle.companionBuffs[index]) {
            existingIndexBuffs[index] = { ...battle.companionBuffs[index] };
          }
        });
        battle.companionBuffs = { ...existingIndexBuffs };
        const damageReduction = skill.damageReduction;
        battle.companionBuffs.guard = Math.max(battle.companionBuffs.guard || 0, damageReduction);
        // è¨­ç½®å˜²è«·ç›®æ¨™ï¼š100%å¸å¼•æ‰€æœ‰å–®é«”æ”»æ“Š
        battle.tauntTarget = { type: 'companion', character: attacker };
        pushBattleLog(`${attacker.name}å°è‡ªå·±æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œé€™å›åˆå—åˆ°å‚·å®³æ¸›å°‘ ${Math.round(damageReduction * 100)}%ï¼Œä¸¦å¸å¼•æ‰€æœ‰æ•µäººçš„å–®é«”æ”»æ“Šï¼`);
        endCompanionTurn();
      }
    } else {
      // åŸæœ‰çš„buffæŠ€èƒ½è™•ç†
    // å‹‡è€…å›åˆï¼šä¿å­˜è¡Œå‹•
    if (isHeroTurn) {
      battle.heroAction = {
        type: 'skill',
        skillId: skillId,
        targetEnemyIndex: null,
      };
      battle.menu = 'root';
      endHeroTurn();
      }
    }
  }
}

function useBattleItem(itemId) {
  const battle = state.ui.battle;
  if (!battle || battle.turn !== 'hero') return;
  const inventoryItem = state.hero.items.find((entry) => entry.id === itemId);
  if (!inventoryItem || inventoryItem.qty <= 0) return;
  const item = ITEM_LOOKUP.get(itemId);
  if (!item) return;
  
  // å¦‚æœæœ‰åŒä¼´ï¼Œæ‰€æœ‰é“å…·éƒ½å¯ä»¥é€‰æ‹©ç›®æ ‡
  const activeCompanion = getActiveCompanion();
  if (activeCompanion && activeCompanion.stats.hp > 0) {
    // å¦‚æœæœ‰åŒä¼´ï¼Œéœ€è¦é€‰æ‹©ç›®æ ‡ï¼ˆè‡ªå·±æˆ–åŒä¼´ï¼‰
    if (battle.menu === 'items') {
      battle.menu = 'select-target';
      battle.pendingItem = itemId;
      renderBattleDialog();
      return;
    } else if (battle.menu === 'select-target' && battle.pendingItem === itemId) {
      // å·²ç»é€‰æ‹©äº†ç›®æ ‡ï¼Œä¿å­˜è¡ŒåŠ¨åˆ°é˜Ÿåˆ—
      if (battle.selectedEnemyIndex === -1) {
        // å¯¹è‡ªå·±ä½¿ç”¨
        battle.heroAction = {
          type: 'item',
          itemId: itemId,
          target: 'hero',
        };
        battle.selectedEnemyIndex = null;
        battle.pendingItem = null;
        battle.menu = 'root';
        endHeroTurn();
      } else if (battle.selectedEnemyIndex === -2 && getActiveCompanion()) {
        // å¯¹åŒä¼´ä½¿ç”¨
        battle.heroAction = {
          type: 'item',
          itemId: itemId,
          target: 'companion',
        };
        battle.selectedEnemyIndex = null;
        battle.pendingItem = null;
        battle.menu = 'root';
        endHeroTurn();
      } else if (battle.selectedEnemyIndex !== null && battle.selectedEnemyIndex >= 0) {
        // ä¸èƒ½å¯¹æ•Œäººä½¿ç”¨é“å…·ï¼Œå¿½ç•¥
        battle.menu = 'select-target';
        battle.pendingItem = itemId;
        renderBattleDialog();
      }
      return;
    }
  } else {
    // æ²¡æœ‰åŒä¼´ï¼Œç›´æ¥å¯¹è‡ªå·±ä½¿ç”¨
    if (battle.menu === 'items') {
      battle.heroAction = {
        type: 'item',
        itemId: itemId,
        target: 'hero',
      };
      battle.menu = 'root';
      endHeroTurn();
    }
  }
}

function applyItemEffect(item, target = 'hero') {
  const hero = state.hero;
  const companion = state.companion;
  
  let targetCharacter = hero; // é»˜è®¤ç›®æ ‡æ˜¯å‹‡è€…
  if (target === 'companion' && companion) {
    targetCharacter = companion;
  }
  
  if (item.type === 'heal') {
    targetCharacter.stats.hp = Math.min(targetCharacter.stats.maxHp, targetCharacter.stats.hp + item.value);
  } else if (item.type === 'mp') {
    targetCharacter.stats.mp = Math.min(targetCharacter.stats.maxMp, targetCharacter.stats.mp + item.value);
  } else if (item.type === 'full') {
    targetCharacter.stats.hp = targetCharacter.stats.maxHp;
    targetCharacter.stats.mp = targetCharacter.stats.maxMp;
  }
}

// ç²å–åŠå£«å‹è¢«å‹•æŠ€èƒ½æ•ˆæœ
function getSwordPassiveEffects(hero) {
  const effects = {
    attackBoost: 0, // æ”»æ“ŠåŠ›æå‡ç™¾åˆ†æ¯”
    mpReturnRate: 0, // MPè¿”å›ç‡
    doubleAttackChance: 0, // é€£æ“Šæ©Ÿç‡
    lifestealRate: 0, // å¸è¡€ç‡
  };
  
  if (!hero || !hero.skills) return effects;
  
  // ç²å–æ‰€æœ‰æŠ€èƒ½ï¼ˆåŒ…æ‹¬åœ£ç‰©æä¾›çš„è¢«åŠ¨æŠ€èƒ½ï¼‰
  const allSkills = [...hero.skills];
  
  // å¦‚æœæ˜¯åŒä¼´ï¼Œæª¢æŸ¥åœ£ç‰©æä¾›çš„è¢«åŠ¨æŠ€èƒ½
  if (hero.equippedRelic) {
    const relic = state.relics.find(r => r.id === hero.equippedRelic);
    if (relic && relic.passiveSkill && relic.passiveSkill.id) {
      allSkills.push(relic.passiveSkill.id);
    }
  }
  
  // æŸ¥æ‰¾æœ€é«˜éšçš„åŠå£«å‹è¢«å‹•æŠ€èƒ½
  // æŒ‰æŠ€èƒ½é“¾åˆ†ç»„ï¼Œæ¯”è¾ƒtierï¼Œé€‰æ‹©æœ€é«˜çš„
  const skillChains = new Map(); // chainId -> { learnedTier, learnedSkill, relicTier, relicSkill }
  
  allSkills.forEach(skillId => {
    const skill = SKILL_LOOKUP.get(skillId);
    let actualSkill = skill;
    let isRelicSkill = false;
    
    // å¦‚æœæ˜¯åœ£ç‰©æŠ€èƒ½ï¼Œç›´æ¥ä½¿ç”¨åœ£ç‰©ä¸­çš„æŠ€èƒ½å¯¹è±¡
    if (!skill && hero.equippedRelic) {
      const relic = state.relics.find(r => r.id === hero.equippedRelic);
      if (relic && relic.passiveSkill && relic.passiveSkill.id === skillId) {
        actualSkill = relic.passiveSkill;
        isRelicSkill = true;
      }
    }
    
    if (!actualSkill || actualSkill.kind !== 'passive' || actualSkill.flow !== 'sword') return;
    
    const chainId = actualSkill.chainId || skill?.chainId;
    if (!chainId) return;
    
    const tier = actualSkill.tier || 0;
    
    if (!skillChains.has(chainId)) {
      skillChains.set(chainId, {
        learnedTier: 0,
        learnedSkill: null,
        relicTier: 0,
        relicSkill: null,
      });
    }
    
    const chainData = skillChains.get(chainId);
    if (isRelicSkill) {
      if (tier > chainData.relicTier) {
        chainData.relicTier = tier;
        chainData.relicSkill = actualSkill;
      }
    } else {
      if (tier > chainData.learnedTier) {
        chainData.learnedTier = tier;
        chainData.learnedSkill = actualSkill;
      }
    }
  });
  
  // å¯¹äºæ¯ä¸ªæŠ€èƒ½é“¾ï¼Œé€‰æ‹©tieræ›´é«˜çš„æŠ€èƒ½ï¼ˆåœ£ç‰©æˆ–å·²å­¦ä¹ ï¼‰
  skillChains.forEach((chainData, chainId) => {
    let finalSkill = null;
    
    // å¦‚æœåœ£ç‰©æŠ€èƒ½çš„tieræ›´é«˜ï¼Œä½¿ç”¨åœ£ç‰©æŠ€èƒ½ï¼›å¦åˆ™ä½¿ç”¨å·²å­¦ä¹ çš„æŠ€èƒ½
    if (chainData.relicTier > chainData.learnedTier) {
      finalSkill = chainData.relicSkill;
    } else if (chainData.learnedTier > 0) {
      finalSkill = chainData.learnedSkill;
    }
    
    if (finalSkill) {
      if (finalSkill.attackBoost !== undefined) {
        effects.attackBoost = Math.max(effects.attackBoost, finalSkill.attackBoost);
      }
      if (finalSkill.mpReturnRate !== undefined) {
        effects.mpReturnRate = Math.max(effects.mpReturnRate, finalSkill.mpReturnRate);
      }
      if (finalSkill.doubleAttackChance !== undefined) {
        effects.doubleAttackChance = Math.max(effects.doubleAttackChance, finalSkill.doubleAttackChance);
      }
      if (finalSkill.lifestealRate !== undefined) {
        effects.lifestealRate = Math.max(effects.lifestealRate, finalSkill.lifestealRate);
      }
    }
  });
  
  return effects;
}

// ç²å–é˜²å®ˆå‹è¢«å‹•æŠ€èƒ½æ•ˆæœ
function getDefenderPassiveEffects(hero) {
  const effects = {
    aggroBoost: 0, // è¢«æ”»æ“Šæ©Ÿç‡æå‡ç™¾åˆ†æ¯”
    hpBonus: 0, // å›ºå®šHPåŠ æˆ
    defenseBonus: 0, // å›ºå®šé˜²å®ˆå€¼åŠ æˆ
    postBattleHpRegen: 0, // æˆ°é¬¥å¾Œæ¢å¾©HPçš„æ¯”ç‡
    onHitHealChance: 0, // è¢«æ”»æ“Šæ™‚å›å¾©HPçš„æ©Ÿç‡
    onHitHealRatio: 0, // è¢«æ”»æ“Šæ™‚å›å¾©HPçš„æ¯”ä¾‹ï¼ˆåŸºæ–¼é«”åŠ›ï¼‰
    onHitHealAoe: false, // æ˜¯å¦å…¨é«”å›å¾©
  };
  
  if (!hero || !hero.skills) return effects;
  
  // ç²å–æ‰€æœ‰æŠ€èƒ½ï¼ˆåŒ…æ‹¬åœ£ç‰©æä¾›çš„è¢«åŠ¨æŠ€èƒ½å’Œè£å‚™æŠ€èƒ½ï¼‰
  const allSkills = [...hero.skills];
  
  // å¦‚æœæ˜¯åŒä¼´ï¼Œæª¢æŸ¥åœ£ç‰©æä¾›çš„è¢«åŠ¨æŠ€èƒ½
  if (hero.equippedRelic) {
    const relic = state.relics.find(r => r.id === hero.equippedRelic);
    if (relic && relic.passiveSkill && relic.passiveSkill.id) {
      allSkills.push(relic.passiveSkill.id);
    }
  }
  
  // å¦‚æœæ˜¯è‹±é›„ï¼Œæª¢æŸ¥è£å‚™æä¾›çš„è¢«åŠ¨æŠ€èƒ½ï¼ˆç¾…å¾·è£å‚™ï¼‰
  if (hero === state.hero && hero.equipment) {
    ['weapon', 'shield', 'armor', 'accessory'].forEach(slot => {
      const equipmentId = hero.equipment[slot];
      if (equipmentId) {
        const passiveSkillId = getEquipmentPassiveSkillId(equipmentId);
        if (passiveSkillId && !allSkills.includes(passiveSkillId)) {
          allSkills.push(passiveSkillId);
        }
      }
    });
  }
  
  // æŸ¥æ‰¾æœ€é«˜éšçš„é˜²å®ˆå‹è¢«å‹•æŠ€èƒ½ï¼ˆæ¯ç¨®æ•ˆæœå–æœ€é«˜éšï¼‰
  // æŒ‰æŠ€èƒ½é“¾åˆ†ç»„ï¼Œæ¯”è¾ƒtierï¼Œé€‰æ‹©æœ€é«˜çš„
  const skillChains = new Map(); // chainId -> { learnedTier, learnedSkill, relicTier, relicSkill }
  
  allSkills.forEach(skillId => {
    const skill = SKILL_LOOKUP.get(skillId);
    let actualSkill = skill;
    let isRelicSkill = false;
    
    // å¦‚æœæ˜¯åœ£ç‰©æŠ€èƒ½ï¼Œç›´æ¥ä½¿ç”¨åœ£ç‰©ä¸­çš„æŠ€èƒ½å¯¹è±¡
    if (!skill && hero.equippedRelic) {
      const relic = state.relics.find(r => r.id === hero.equippedRelic);
      if (relic && relic.passiveSkill && relic.passiveSkill.id === skillId) {
        actualSkill = relic.passiveSkill;
        isRelicSkill = true;
      }
    }
    
    // æ”¯æŒé˜²å®ˆå‹è¢«åŠ¨æŠ€èƒ½å’Œè£…å¤‡æŠ€èƒ½ï¼ˆç½—å¾·ä¹‹é“ ï¼‰
    if (!actualSkill || actualSkill.kind !== 'passive') return;
    if (actualSkill.flow !== 'defender' && !(actualSkill.isEquipmentSkill && actualSkill.aggroBoost !== undefined)) return;
    
    // è£…å¤‡æŠ€èƒ½å¯èƒ½æ²¡æœ‰ chainIdï¼Œä½¿ç”¨æŠ€èƒ½IDä½œä¸º chainId
    const chainId = actualSkill.chainId || skill?.chainId || (actualSkill.isEquipmentSkill ? `equipment_${skillId}` : null);
    if (!chainId) return;
    
    const tier = actualSkill.tier || 0;
    
    if (!skillChains.has(chainId)) {
      skillChains.set(chainId, {
        learnedTier: 0,
        learnedSkill: null,
        relicTier: 0,
        relicSkill: null,
      });
    }
    
    const chainData = skillChains.get(chainId);
    if (isRelicSkill) {
      if (tier > chainData.relicTier) {
        chainData.relicTier = tier;
        chainData.relicSkill = actualSkill;
      }
    } else {
      if (tier > chainData.learnedTier) {
        chainData.learnedTier = tier;
        chainData.learnedSkill = actualSkill;
      }
    }
  });
  
  // å¯¹äºæ¯ä¸ªæŠ€èƒ½é“¾ï¼Œé€‰æ‹©tieræ›´é«˜çš„æŠ€èƒ½ï¼ˆåœ£ç‰©æˆ–å·²å­¦ä¹ ï¼‰
  skillChains.forEach((chainData, chainId) => {
    let finalSkill = null;
    
    // å¦‚æœåœ£ç‰©æŠ€èƒ½çš„tieræ›´é«˜ï¼Œä½¿ç”¨åœ£ç‰©æŠ€èƒ½ï¼›å¦åˆ™ä½¿ç”¨å·²å­¦ä¹ çš„æŠ€èƒ½
    if (chainData.relicTier > chainData.learnedTier) {
      finalSkill = chainData.relicSkill;
    } else if (chainData.learnedTier > 0) {
      finalSkill = chainData.learnedSkill;
    }
    
    if (finalSkill) {
      // è¢«æ”»æ“Šç‡åŠ æˆç´¯åŠ ï¼ˆè£å‚™æŠ€èƒ½å’ŒæŠ€èƒ½å¯ä»¥ç–ŠåŠ ï¼‰
      if (finalSkill.aggroBoost !== undefined) {
        effects.aggroBoost += finalSkill.aggroBoost;
      }
      if (finalSkill.hpBonus !== undefined) {
        effects.hpBonus = Math.max(effects.hpBonus, finalSkill.hpBonus);
      }
      if (finalSkill.defenseBonus !== undefined) {
        effects.defenseBonus = Math.max(effects.defenseBonus, finalSkill.defenseBonus);
      }
      if (finalSkill.postBattleHpRegen !== undefined) {
        effects.postBattleHpRegen = Math.max(effects.postBattleHpRegen, finalSkill.postBattleHpRegen);
      }
      // å®ˆè­·æ„å¿—ï¼šè¢«æ”»æ“Šæ™‚å›å¾©HP
      if (finalSkill.onHitHealChance !== undefined) {
        effects.onHitHealChance = Math.max(effects.onHitHealChance, finalSkill.onHitHealChance);
      }
      if (finalSkill.onHitHealRatio !== undefined) {
        effects.onHitHealRatio = Math.max(effects.onHitHealRatio, finalSkill.onHitHealRatio);
      }
      if (finalSkill.onHitHealAoe !== undefined) {
        effects.onHitHealAoe = finalSkill.onHitHealAoe || effects.onHitHealAoe;
      }
    }
  });
  
  // å¤„ç†è£…å¤‡æŠ€èƒ½ï¼ˆå¦‚æœæ²¡æœ‰é€šè¿‡æŠ€èƒ½é“¾å¤„ç†ï¼Œç›´æ¥å¤„ç†ï¼‰
  allSkills.forEach(skillId => {
    const skill = SKILL_LOOKUP.get(skillId);
    if (skill && skill.isEquipmentSkill && skill.kind === 'passive') {
      // æ£€æŸ¥æ˜¯å¦å·²ç»åœ¨æŠ€èƒ½é“¾ä¸­å¤„ç†è¿‡
      const alreadyProcessed = Array.from(skillChains.values()).some(chainData => 
        (chainData.learnedSkill && chainData.learnedSkill.id === skillId) ||
        (chainData.relicSkill && chainData.relicSkill.id === skillId)
      );
      
      if (!alreadyProcessed && skill.aggroBoost !== undefined) {
        // ç›´æ¥åº”ç”¨è£…å¤‡æŠ€èƒ½æ•ˆæœ
        effects.aggroBoost += skill.aggroBoost;
      }
    }
  });
  
  return effects;
}

// === æˆ°é¬¥å·¥å…·å‡½å¼ ===

// è­·ç›¾å¸æ”¶å‚·å®³
// å›å‚³ { finalDamage, shieldAbsorbed }
// logFn: é è¨­ pushBattleLogï¼Œauto-battle å‚³å…¥ pushLog
function absorbShield(target, damage, targetName, logFn) {
  if (!target.stats.shield || target.stats.shield <= 0) return { finalDamage: damage, shieldAbsorbed: 0 };
  const log = logFn || pushBattleLog;
  const shieldAbsorbed = Math.min(damage, target.stats.shield);
  target.stats.shield = Math.max(0, target.stats.shield - shieldAbsorbed);
  const finalDamage = damage - shieldAbsorbed;
  if (shieldAbsorbed > 0 && targetName) {
    log(`${targetName}çš„è­·ç›¾å¸æ”¶äº† ${shieldAbsorbed} å‚·å®³ï¼`);
  }
  return { finalDamage, shieldAbsorbed };
}

// ç ´ç”²ä¹‹åˆƒï¼šç‰©ç†æ”»æ“ŠæˆåŠŸå¾Œç§»é™¤buff
function consumeBreakingArmor(attacker, damage, isBasicAttack, skill) {
  const battle = state.ui.battle;
  if (!battle || damage <= 0) return;
  const isPhysicalAttack = isBasicAttack || (skill && skill.flow !== 'magic' && skill.flow !== 'recovery');
  if (!isPhysicalAttack) return;
  const isHero = attacker === state.hero;
  if (isHero && battle.heroBuffs && battle.heroBuffs.ignoreDefense) {
    battle.heroBuffs.ignoreDefense = false;
    pushBattleLog(`â†’ å‹‡è€…ç ´ç”²ä¹‹åˆƒæ•ˆæœå·²æ¶ˆè€—ï¼`);
  } else if (!isHero) {
    const companionIndex = state.companions.indexOf(attacker);
    if (companionIndex >= 0 && battle.companionBuffs && battle.companionBuffs[companionIndex] && battle.companionBuffs[companionIndex].ignoreDefense) {
      battle.companionBuffs[companionIndex].ignoreDefense = false;
      pushBattleLog(`â†’ ${attacker.name}ç ´ç”²ä¹‹åˆƒæ•ˆæœå·²æ¶ˆè€—ï¼`);
    }
  }
}

// å¸è¡€è¢«å‹•ï¼šæ”»æ“Šå¾Œå›å¾©HP
function applyLifesteal(attacker, damage, passiveEffects) {
  if (!passiveEffects || passiveEffects.lifestealRate <= 0 || damage <= 0) return;
  const lifestealAmount = Math.max(1, Math.round(damage * passiveEffects.lifestealRate));
  attacker.stats.hp = Math.min(attacker.stats.maxHp, attacker.stats.hp + lifestealAmount);
  const attackerName = attacker === state.hero ? 'å‹‡è€…' : attacker.name;
  pushBattleLog(`${attackerName}å—œè¡€åŠè¡“å›å¾©äº† ${lifestealAmount} HPï¼`);
}

// åŠç¥ä¹‹è·¯å‹•æ…‹ MP æ¶ˆè€—è¨ˆç®—
// å›å‚³ { mpCost, tempMpCost }
function calculateDynamicMpCost(skill, caster) {
  let mpCost = skill.mpCost || 0;
  let tempMpCost = 0;
  if (skill.dynamicMpCost && skill.dynamicMpCost === true) {
    const maxMp = caster.stats.maxMp;
    const currentMp = caster.stats.mp;
    const maxMpCost = Math.floor(maxMp * (skill.mpCostMaxRatio || 0.5));
    mpCost = Math.min(maxMpCost, currentMp);
    tempMpCost = mpCost;
  }
  return { mpCost, tempMpCost };
}

// æ¨èº«æ–¬ HP æ¶ˆè€—
function calculateAndApplyHpCost(skill, caster, casterName) {
  const battle = state.ui.battle;
  let hpCostAmount = 0;
  if (skill.hpCostPercent && skill.hpCostPercent > 0) {
    const maxHp = caster.stats.maxHp;
    const currentHp = caster.stats.hp;
    hpCostAmount = Math.max(1, Math.floor(maxHp * skill.hpCostPercent));
    hpCostAmount = Math.min(hpCostAmount, currentHp - 1);
    caster.stats.hp = Math.max(1, caster.stats.hp - hpCostAmount);
    battle.tempHpCost = hpCostAmount;
    if (hpCostAmount > 0) {
      pushBattleLog(`${casterName}æ¨èº«æ–¬æ¶ˆè€—äº† ${hpCostAmount} HPï¼`);
    }
  } else {
    battle.tempHpCost = 0;
  }
  return hpCostAmount;
}

// é˜²æ­»è­·ç›¾ï¼šå°æ‰€æœ‰å‹æ–¹æ–½åŠ æ•ˆæœ
function applyDeathWardToAllAllies(skill, caster, casterName) {
  const mpCost = skill.mpCost || 0;
  if (caster.stats.mp < mpCost) {
    pushBattleLog(`${casterName} MP ä¸è¶³ï¼ˆéœ€è¦ ${mpCost}ï¼Œç•¶å‰ ${caster.stats.mp}ï¼‰ï¼Œç„¡æ³•æ–½æ”¾ã€Œ${skill.name}ã€ã€‚`);
    return false;
  }

  caster.stats.mp -= mpCost;
  pushBattleLog(`${casterName}æ–½æ”¾ã€Œ${skill.name}ã€ï¼`);

  if (skill.aoe) {
    let affectedCount = 0;
    const affectedNames = [];

    if (state.hero && state.hero.stats.hp > 0) {
      applyDeathWardEffect(skill, caster, state.hero, true);
      affectedCount++;
      affectedNames.push('å‹‡è€…');
    }
    const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
    activeCompanions.forEach(companion => {
      applyDeathWardEffect(skill, caster, companion, true);
      affectedCount++;
      affectedNames.push(companion.name);
    });

    if (affectedCount > 0) {
      pushBattleLog(`â†’ æ‰€æœ‰å‹æ–¹ç²å¾—é˜²æ­»è­·ç›¾æ•ˆæœï¼š${affectedNames.join('ã€')}ï¼ˆå…± ${affectedCount} äººï¼‰ï¼`);
    } else {
      pushBattleLog(`â†’ æ²’æœ‰æ´»è‘—çš„å‹æ–¹å¯ä»¥ç²å¾—é˜²æ­»è­·ç›¾æ•ˆæœã€‚`);
    }
  }

  renderBattleDialog();
  return true;
}

// çµ±ä¸€çš„å°æ•µäººé€ æˆå‚·å®³å‡½æ•¸
// åƒæ•¸ï¼šenemy - æ•µäººå°è±¡, damage - å‚·å®³å€¼, attacker - æ”»æ“Šè€…ï¼ˆå¯é¸ï¼‰
// è¿”å›ï¼šå¯¦éš›é€ æˆçš„å‚·å®³å€¼
function applyDamageToEnemyUnified(enemy, damage, attacker = null) {
  if (!enemy || damage <= 0) return 0;
  
  // æ‡‰ç”¨å‚·å®³
  const oldHp = enemy.stats.hp;
  enemy.stats.hp = Math.max(0, enemy.stats.hp - damage);
  const actualDamage = oldHp - enemy.stats.hp;
  
  // æª¢æŸ¥æ˜¯å¦éœ€è¦å½¢æ…‹åˆ‡æ›ï¼ˆå¤šå½¢æ…‹bossï¼‰
  if (enemy.forms && enemy.forms.length > 1 && !enemy.hasTransformed && enemy.transformHpThreshold) {
    const hpRatio = enemy.stats.maxHp > 0 ? enemy.stats.hp / enemy.stats.maxHp : 0;
    // ç•¶HPé™åˆ°é–¾å€¼ï¼ˆ5%ï¼‰æˆ–ä»¥ä¸‹æ™‚åˆ‡æ›å½¢æ…‹
    if (hpRatio <= enemy.transformHpThreshold) {
      transformBossForm(enemy);
    }
  }
  
  return actualDamage;
}

// å¤šå½¢æ…‹bosså½¢æ…‹åˆ‡æ›
function transformBossForm(enemy) {
  if (!enemy || !enemy.forms || enemy.forms.length < 2) return;
  if (enemy.hasTransformed) return; // å·²ç¶“è®Šèº«éï¼Œä¸å†è®Šèº«
  
  const battle = state.ui.battle;
  if (!battle) return;
  
  const currentFormIndex = enemy.currentFormIndex || 0;
  const nextFormIndex = currentFormIndex + 1;
  
  if (nextFormIndex >= enemy.forms.length) return; // æ²’æœ‰ä¸‹ä¸€å½¢æ…‹
  
  const nextForm = enemy.forms[nextFormIndex];
  const enemyIndex = battle.enemies.indexOf(enemy);
  
  if (enemyIndex < 0) return;
  
  // ä¿å­˜ç•¶å‰HPæ¯”ä¾‹ï¼ˆåœ¨æ›´æ–°maxHpä¹‹å‰ï¼‰
  const oldMaxHp = enemy.stats.maxHp;
  const oldHpRatio = oldMaxHp > 0 ? enemy.stats.hp / oldMaxHp : 0;
  
  // æ›´æ–°å½¢æ…‹è³‡è¨Š
  enemy.currentFormIndex = nextFormIndex;
  enemy.hasTransformed = true;
  enemy.name = nextForm.name;
  enemy.emoji = nextForm.emoji;
  
  // é‡æ–°è¨ˆç®—å±¬æ€§ï¼ˆä½¿ç”¨æ–°å½¢æ…‹çš„å±¬æ€§ï¼‰
  const heroLevel = state.hero ? state.hero.stats.level : 1;
  const enemyLevel = enemy.stats.level;
  const tier = enemy.tier || 1;
  const stageBonus = getStageAttributeBonus(tier);
  
  // æ›´æ–°å±¬æ€§
  Object.keys(nextForm.baseAttributes || {}).forEach(attr => {
    if (nextForm.baseAttributes[attr] !== undefined) {
      const base = nextForm.baseAttributes[attr];
      const growth = nextForm.growthPerLevel[attr] || 0;
      enemy.attributes[attr] = Math.round(base + growth * (enemyLevel - 1) + stageBonus);
    }
  });
  
  // æ›´æ–°æŠ€èƒ½
  if (nextForm.skills && nextForm.skills.length > 0) {
    enemy.skills = nextForm.skills.map(s => ({ 
      id: s.id, 
      probability: s.probability || 0.2 
    }));
  }
  
  // æ›´æ–°è¡Œå‹•æ¬¡æ•¸
  if (nextForm.actionsPerTurn) {
    enemy.actionsPerTurn = nextForm.actionsPerTurn;
  }
  
  // é‡æ–°è¨ˆç®—HPï¼ˆä½¿ç”¨æ–°å½¢æ…‹çš„vitalityï¼‰
  const newVitality = enemy.attributes.vitality || 1;
  const newMaxHp = Math.ceil(enemy.baseHp + newVitality);
  
  enemy.stats.maxHp = newMaxHp;
  
  // å¦‚æœHPé™åˆ°5%æˆ–ä»¥ä¸‹ï¼ˆåŒ…å«0ä»¥ä¸‹ï¼‰ï¼Œä»¥100% HPé€²å…¥ç¬¬äºŒå½¢æ…‹
  if (oldHpRatio <= 0.05) {
    enemy.stats.hp = newMaxHp; // 100% HP
  } else {
    // å¦å‰‡ä¿æŒHPæ¯”ä¾‹
    const newHp = Math.ceil(newMaxHp * oldHpRatio);
    enemy.stats.hp = Math.max(1, newHp); // è‡³å°‘ä¿ç•™1 HP
  }
  
  // é¡¯ç¤ºè®Šèº«è¨Šæ¯
  pushBattleLog(`â†’ ${enemy.name}å½¢æ…‹è½‰æ›ï¼èƒ½åŠ›å¤§å¹…æå‡ï¼`);
  
  // æ›´æ–°UI
  renderBattleDialog();
}

// è™•ç†å¾©ä»‡æ„å¿—æ•ˆæœï¼šç•¶æœ‰å¾©ä»‡æ„å¿—æŠ€èƒ½çš„åŒä¼´å—åˆ°å‚·å®³æ™‚ï¼ŒæŒ‰ç…§æ¯”ä¾‹å°æ‰€æœ‰æ•µäººé€ æˆå‚·å®³
function triggerVengeanceWillEffect(victim, damage) {
  if (!victim || damage <= 0) return;
  
  // åªå°åŒä¼´ç”Ÿæ•ˆ
  const isCompanion = state.companions && state.companions.some(c => c === victim);
  if (!isCompanion) return;
  
  // æª¢æŸ¥åŒä¼´æ˜¯å¦æœ‰å¾©ä»‡æ„å¿—æŠ€èƒ½
  if (!victim.skills || !victim.skills.includes('paladin_vengeance_will_1')) return;
  
  const vengeanceWillSkill = SKILL_LOOKUP.get('paladin_vengeance_will_1');
  if (!vengeanceWillSkill) return;
  
  const battle = state.ui.battle;
  if (!battle) return;
  
  // æª¢æŸ¥è§¸ç™¼æ©Ÿç‡
  const triggerChance = vengeanceWillSkill.vengeanceChance || 1.0;
  if (Math.random() >= triggerChance) return;
  
  // è¨ˆç®—åå½ˆå‚·å®³ï¼šæŒ‰ç…§å—åˆ°å‚·å®³çš„ä¸€å®šæ¯”ä¾‹
  const damageRatio = vengeanceWillSkill.vengeanceDamageRatio || 0.5;
  const vengeanceDamage = Math.max(1, Math.floor(damage * damageRatio));
  
  // å°æ‰€æœ‰æ´»è‘—çš„æ•µäººé€ æˆå‚·å®³
  const aliveEnemies = battle.enemies.filter(e => e && e.stats && e.stats.hp > 0);
  if (aliveEnemies.length === 0) return;
  
  let totalVengeanceDamage = 0;
  aliveEnemies.forEach(enemy => {
    const actualDamage = applyDamageToEnemyUnified(enemy, vengeanceDamage);
    totalVengeanceDamage += actualDamage;
  });
  
  // è¨˜éŒ„åˆ°æˆ°é¬¥æ—¥èªŒ
  if (totalVengeanceDamage > 0) {
    pushBattleLog(`â†’ ${victim.name}çš„å¾©ä»‡æ„å¿—å°æ‰€æœ‰æ•µäººé€ æˆ ${vengeanceDamage} å‚·å®³ï¼ˆç¸½è¨ˆ ${totalVengeanceDamage}ï¼‰ï¼`);
  }
}

// è™•ç†è¢«æ”»æ“Šæ™‚è§¸ç™¼çš„è¢«å‹•æŠ€èƒ½ï¼ˆå®ˆè­·æ„å¿—ã€å¾©ä»‡æ„å¿—ç­‰ï¼‰
function triggerOnHitPassiveEffects(victim, damage) {
  if (!victim || damage <= 0) return;
  
  const isHero = victim === state.hero;
  const isCompanion = state.companions && state.companions.some(c => c === victim);
  
  if (!isHero && !isCompanion) return;
  
  // å¾©ä»‡æ„å¿—ï¼šåŒä¼´å—åˆ°å‚·å®³æ™‚ï¼ŒæŒ‰ç…§æ¯”ä¾‹å°æ‰€æœ‰æ•µäººé€ æˆå‚·å®³
  if (isCompanion) {
    triggerVengeanceWillEffect(victim, damage);
  }
  
  const defenderEffects = getDefenderPassiveEffects(victim);
  
  // å®ˆè­·æ„å¿—ï¼šè¢«æ”»æ“Šæ™‚æœ‰æ©Ÿç‡å›å¾©æ‰€æœ‰äººHP
  if (defenderEffects.onHitHealChance > 0 && defenderEffects.onHitHealRatio > 0) {
    const triggerChance = Math.random();
    if (triggerChance < defenderEffects.onHitHealChance) {
      const totalAttrs = isHero 
        ? getHeroTotalAttributes(victim)
        : getCompanionTotalAttributes(victim);
      const vitality = totalAttrs.vitality || 0;
      const healAmount = Math.max(1, Math.floor(vitality * defenderEffects.onHitHealRatio));
      
      if (defenderEffects.onHitHealAoe) {
        // å…¨é«”å›å¾©
        const victimName = isHero ? 'å‹‡è€…' : victim.name;
        let totalHealed = 0;
        
        // å…ˆé¡¯ç¤ºè§¸ç™¼ä¿¡æ¯
        pushBattleLog(`${victimName}çš„å®ˆè­·æ„å¿—è§¸ç™¼ï¼`);
        
        // å›å¾©å‹‡è€…
        if (state.hero.stats.hp > 0 && state.hero.stats.hp < state.hero.stats.maxHp) {
          const oldHp = state.hero.stats.hp;
          state.hero.stats.hp = Math.min(state.hero.stats.maxHp, state.hero.stats.hp + healAmount);
          const actualHeal = state.hero.stats.hp - oldHp;
          if (actualHeal > 0) {
            totalHealed += actualHeal;
            pushBattleLog(`â†’ å‹‡è€…å›å¾©äº† ${actualHeal} HPï¼`);
          }
        }
        
        // å›å¾©æ‰€æœ‰æ´»è‘—çš„åŒä¼´
        const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
        activeCompanions.forEach(companion => {
          if (companion.stats.hp < companion.stats.maxHp) {
            const oldHp = companion.stats.hp;
            companion.stats.hp = Math.min(companion.stats.maxHp, companion.stats.hp + healAmount);
            const actualHeal = companion.stats.hp - oldHp;
            if (actualHeal > 0) {
              totalHealed += actualHeal;
              pushBattleLog(`â†’ ${companion.name}å›å¾©äº† ${actualHeal} HPï¼`);
            }
          }
        });
        
        // å¦‚æœæ²’æœ‰äººéœ€è¦å›å¾©ï¼Œé¡¯ç¤ºæç¤º
        if (totalHealed === 0) {
          pushBattleLog(`â†’ æ‰€æœ‰äººHPå·²æ»¿ï¼Œç„¡éœ€å›å¾©ã€‚`);
        }
      } else {
        // å–®é«”å›å¾©ï¼ˆåªå›å¾©è‡ªå·±ï¼‰
        const victimName = isHero ? 'å‹‡è€…' : victim.name;
        const oldHp = victim.stats.hp;
        victim.stats.hp = Math.min(victim.stats.maxHp, victim.stats.hp + healAmount);
        const actualHeal = victim.stats.hp - oldHp;
        if (actualHeal > 0) {
          pushBattleLog(`${victimName}çš„å®ˆè­·æ„å¿—è§¸ç™¼ï¼Œå›å¾©äº† ${actualHeal} HPï¼`);
        }
      }
      
      renderBattleDialog();
    }
  }
}

// æª¢æŸ¥ä¸¦æ‡‰ç”¨ç¥è–è­·ç›¾æ•ˆæœï¼ˆç•¶ä½¿ç”¨ç¥è–è­·ç›¾æŠ€èƒ½æ™‚è§¸ç™¼ï¼‰
// æ‡‰ç”¨é˜²æ­»è­·ç›¾æ•ˆæœ
function applyDeathWardEffect(skill, caster, target, silent = false) {
  if (!skill || !caster || !target) return;
  
  // åªå°é˜²æ­»è­·ç›¾æŠ€èƒ½æ‡‰ç”¨æ•ˆæœ
  if (skill.id !== 'sage_death_ward_1') return;
  
  const battle = state.ui.battle;
  if (!battle) return;
  
  const isHero = target === state.hero;
  const isCompanion = state.companions && state.companions.some(c => c === target);
  
  if (isHero) {
    battle.heroBuffs.deathWard = true;
    if (!silent) {
      pushBattleLog(`â†’ å‹‡è€…ç²å¾—é˜²æ­»è­·ç›¾æ•ˆæœï¼`);
    }
  } else if (isCompanion) {
    const companionIndex = state.companions.indexOf(target);
    if (companionIndex >= 0) {
      if (!battle.companionBuffs[companionIndex]) {
        battle.companionBuffs[companionIndex] = {};
      }
      battle.companionBuffs[companionIndex].deathWard = true;
      if (!silent) {
        pushBattleLog(`â†’ ${target.name}ç²å¾—é˜²æ­»è­·ç›¾æ•ˆæœï¼`);
      }
    }
  }
}

// æ‡‰ç”¨ç¥è–å›éŸ¿æ•ˆæœ
function applyHealingEchoEffect(skill, caster, target, healAmount) {
  if (!skill || !caster || !target || healAmount <= 0) return;
  
  const battle = state.ui.battle;
  const isInBattle = !!battle;
  
  // æˆ°é¬¥ç‹€æ…‹ä¸‹æª¢æŸ¥æ˜¯å¦å·²åœ¨æœ¬æ¬¡æˆ°é¬¥ä¸­ä½¿ç”¨é
  if (isInBattle && battle.healingEchoUsed) {
    return; // æœ¬æ¬¡æˆ°é¬¥å·²ç¶“ä½¿ç”¨éï¼Œä¸å†è§¸ç™¼
  }
  
  // æª¢æŸ¥æ–½æ³•è€…æ˜¯å¦æœ‰ç¥è–å›éŸ¿è¢«å‹•æŠ€èƒ½
  const isHeroCaster = caster === state.hero;
  const recoveryEffects = getRecoveryPassiveEffects(caster);
  
  if (recoveryEffects.healingEchoRatio <= 0) return;
  
  // è¨ˆç®—ç·©æ…¢æ¢å¾©å€¼ï¼šæ²»ç™‚å€¼ Ã— æ¯”ä¾‹
  const echoAmount = Math.floor(healAmount * recoveryEffects.healingEchoRatio);
  if (echoAmount <= 0) return;
  
  const isHero = target === state.hero;
  const isCompanion = state.companions && state.companions.some(c => c === target);
  
  if (isInBattle) {
    // æˆ°é¬¥ç‹€æ…‹ï¼šè¨˜éŒ„åˆ°æˆ°é¬¥æ—¥èªŒä¸¦å­˜å„²åœ¨æˆ°é¬¥buffä¸­
    battle.healingEchoUsed = true;
    
    if (isHero) {
      battle.heroBuffs.healingEcho = (battle.heroBuffs.healingEcho || 0) + echoAmount;
      pushBattleLog(`â†’ ç¥è–å›éŸ¿ï¼šå‹‡è€…ç²å¾— ${echoAmount} é»ç·©æ…¢æ¢å¾©ï¼ˆç´¯è¨ˆ ${battle.heroBuffs.healingEcho} é»ï¼‰ï¼`);
    } else if (isCompanion) {
      const companionIndex = state.companions.indexOf(target);
      if (companionIndex >= 0) {
        if (!battle.companionBuffs[companionIndex]) {
          battle.companionBuffs[companionIndex] = {};
        }
        battle.companionBuffs[companionIndex].healingEcho = (battle.companionBuffs[companionIndex].healingEcho || 0) + echoAmount;
        pushBattleLog(`â†’ ç¥è–å›éŸ¿ï¼š${target.name}ç²å¾— ${echoAmount} é»ç·©æ…¢æ¢å¾©ï¼ˆç´¯è¨ˆ ${battle.companionBuffs[companionIndex].healingEcho} é»ï¼‰ï¼`);
      }
    }
  } else {
    // éæˆ°é¬¥ç‹€æ…‹ï¼šç›´æ¥è¨˜éŒ„åˆ°æ—¥èªŒï¼ˆéæˆ°é¬¥ç‹€æ…‹ä¸‹ç·©æ…¢æ¢å¾©æœƒåœ¨ä¸‹ä¸€æ¬¡æˆ°é¬¥é–‹å§‹æ™‚ç”Ÿæ•ˆï¼‰
    const targetName = isHero ? 'ä½ ' : target.name;
    pushLog(`â†’ ç¥è–å›éŸ¿ï¼š${targetName}ç²å¾— ${echoAmount} é»ç·©æ…¢æ¢å¾©ï¼ˆå°‡åœ¨ä¸‹ä¸€æ¬¡æˆ°é¬¥é–‹å§‹æ™‚å›å¾©ï¼‰ï¼`);
  }
}

function applySacredShieldEffect(skill, caster, target) {
  if (!skill || !caster || !target) return;
  
  // åªå°ç¥è–è­·ç›¾æŠ€èƒ½æ‡‰ç”¨è­·ç›¾æ•ˆæœ
  if (skill.id !== 'paladin_sacred_shield_1') return;
  
  if (!skill.shieldRatio) return;
  
  // è¨ˆç®—è­·ç›¾å€¼ï¼šç›®æ¨™é«”åŠ› Ã— shieldRatio
  const isHero = target === state.hero;
  const totalAttrs = isHero 
    ? getHeroTotalAttributes(target)
    : getCompanionTotalAttributes(target);
  const vitality = totalAttrs.vitality;
  const shieldAmount = Math.floor(vitality * skill.shieldRatio);
  
  if (shieldAmount > 0) {
    target.stats.shield = (target.stats.shield || 0) + shieldAmount;
    const targetName = isHero ? 'å‹‡è€…' : target.name;
    const casterName = caster === state.hero ? 'ä½ ' : caster.name;
    
    // åˆ¤æ–·æ˜¯å¦åœ¨æˆ°é¬¥ä¸­
    const isInBattle = state.ui.battle && state.ui.battle.active;
    if (isInBattle) {
      pushBattleLog(`â†’ ${targetName}ç²å¾—äº† ${shieldAmount} è­·ç›¾ï¼`);
    } else {
      pushLog(`${targetName}ç²å¾—äº† ${shieldAmount} è­·ç›¾ï¼`);
    }
  }
}

// ç²å–æ¢å¾©å‹è¢«å‹•æŠ€èƒ½æ•ˆæœ
function getRecoveryPassiveEffects(hero) {
  const effects = {
    recoveryBoost: 0, // æ²»ç™‚æ•ˆæœæå‡ç™¾åˆ†æ¯”
    perTurnMpRegen: 0, // æ¯å›åˆå›å¾©çš„MPå€¼
    perTurnHpRegen: 0, // æ¯å›åˆå›å¾©çš„HPå€¼
    attackMpReturn: 0, // æ”»æ“Šæ•µäººæ™‚å›å¾©çš„MPå€¼
    healingEchoRatio: 0, // æ¢å¾©HPæ™‚è½‰ç‚ºç·©æ…¢æ¢å¾©çš„æ¯”ä¾‹
  };
  
  if (!hero || !hero.skills) return effects;
  
  // ç²å–æ‰€æœ‰æŠ€èƒ½ï¼ˆåŒ…æ‹¬åœ£ç‰©æä¾›çš„è¢«åŠ¨æŠ€èƒ½å’Œè£å‚™æŠ€èƒ½ï¼‰
  const allSkills = [...hero.skills];
  
  // å¦‚æœæ˜¯åŒä¼´ï¼Œæª¢æŸ¥åœ£ç‰©æä¾›çš„è¢«åŠ¨æŠ€èƒ½
  if (hero.equippedRelic) {
    const relic = state.relics.find(r => r.id === hero.equippedRelic);
    if (relic && relic.passiveSkill && relic.passiveSkill.id) {
      allSkills.push(relic.passiveSkill.id);
    }
  }
  
  // å¦‚æœæ˜¯è‹±é›„ï¼Œæª¢æŸ¥è£å‚™æä¾›çš„è¢«åŠ¨æŠ€èƒ½ï¼ˆç¾…å¾·è£å‚™ï¼‰
  if (hero === state.hero && hero.equipment) {
    ['weapon', 'shield', 'armor', 'accessory'].forEach(slot => {
      const equipmentId = hero.equipment[slot];
      if (equipmentId) {
        const passiveSkillId = getEquipmentPassiveSkillId(equipmentId);
        if (passiveSkillId && !allSkills.includes(passiveSkillId)) {
          allSkills.push(passiveSkillId);
        }
      }
    });
  }
  
  // æŸ¥æ‰¾æœ€é«˜éšçš„æ¢å¾©å‹è¢«å‹•æŠ€èƒ½ï¼ˆæ¯ç¨®æ•ˆæœå–æœ€é«˜éšï¼‰
  // æŒ‰æŠ€èƒ½é“¾åˆ†ç»„ï¼Œæ¯”è¾ƒtierï¼Œé€‰æ‹©æœ€é«˜çš„
  const skillChains = new Map(); // chainId -> { learnedTier, learnedSkill, relicTier, relicSkill }
  
  allSkills.forEach(skillId => {
    const skill = SKILL_LOOKUP.get(skillId);
    let actualSkill = skill;
    let isRelicSkill = false;
    
    // å¦‚æœæ˜¯åœ£ç‰©æŠ€èƒ½ï¼Œç›´æ¥ä½¿ç”¨åœ£ç‰©ä¸­çš„æŠ€èƒ½å¯¹è±¡
    if (!skill && hero.equippedRelic) {
      const relic = state.relics.find(r => r.id === hero.equippedRelic);
      if (relic && relic.passiveSkill && relic.passiveSkill.id === skillId) {
        actualSkill = relic.passiveSkill;
        isRelicSkill = true;
      }
    }
    
    // æ”¯æŒæ¢å¾©å‹è¢«åŠ¨æŠ€èƒ½å’Œè£…å¤‡æŠ€èƒ½ï¼ˆç½—å¾·çº¹ç« ï¼‰
    if (!actualSkill || actualSkill.kind !== 'passive') return;
    if (actualSkill.flow !== 'recovery' && !(actualSkill.isEquipmentSkill && (actualSkill.perTurnHpRegen !== undefined || actualSkill.perTurnMpRegen !== undefined))) return;
    
    // è£…å¤‡æŠ€èƒ½å¯èƒ½æ²¡æœ‰ chainIdï¼Œä½¿ç”¨æŠ€èƒ½IDä½œä¸º chainId
    const chainId = actualSkill.chainId || skill?.chainId || (actualSkill.isEquipmentSkill ? `equipment_${skillId}` : null);
    if (!chainId) return;
    
    const tier = actualSkill.tier || 0;
    
    if (!skillChains.has(chainId)) {
      skillChains.set(chainId, {
        learnedTier: 0,
        learnedSkill: null,
        relicTier: 0,
        relicSkill: null,
      });
    }
    
    const chainData = skillChains.get(chainId);
    if (isRelicSkill) {
      if (tier > chainData.relicTier) {
        chainData.relicTier = tier;
        chainData.relicSkill = actualSkill;
      }
    } else {
      if (tier > chainData.learnedTier) {
        chainData.learnedTier = tier;
        chainData.learnedSkill = actualSkill;
      }
    }
  });
  
  // å¯¹äºæ¯ä¸ªæŠ€èƒ½é“¾ï¼Œé€‰æ‹©tieræ›´é«˜çš„æŠ€èƒ½ï¼ˆåœ£ç‰©æˆ–å·²å­¦ä¹ ï¼‰
  skillChains.forEach((chainData, chainId) => {
    let finalSkill = null;
    
    // å¦‚æœåœ£ç‰©æŠ€èƒ½çš„tieræ›´é«˜ï¼Œä½¿ç”¨åœ£ç‰©æŠ€èƒ½ï¼›å¦åˆ™ä½¿ç”¨å·²å­¦ä¹ çš„æŠ€èƒ½
    if (chainData.relicTier > chainData.learnedTier) {
      finalSkill = chainData.relicSkill;
    } else if (chainData.learnedTier > 0) {
      finalSkill = chainData.learnedSkill;
    }
    
    if (finalSkill) {
      if (finalSkill.recoveryBoost !== undefined) {
        effects.recoveryBoost = Math.max(effects.recoveryBoost, finalSkill.recoveryBoost);
      }
      // æ¯å›åˆå›å¾©æ•ˆæœç´¯åŠ ï¼ˆè£å‚™æŠ€èƒ½å’ŒæŠ€èƒ½å¯ä»¥ç–ŠåŠ ï¼‰
      if (finalSkill.perTurnMpRegen !== undefined) {
        effects.perTurnMpRegen += finalSkill.perTurnMpRegen;
      }
      if (finalSkill.perTurnHpRegen !== undefined) {
        effects.perTurnHpRegen += finalSkill.perTurnHpRegen;
      }
      if (finalSkill.attackMpReturn !== undefined) {
        effects.attackMpReturn = Math.max(effects.attackMpReturn, finalSkill.attackMpReturn);
      }
      if (finalSkill.healingEchoRatio !== undefined) {
        effects.healingEchoRatio = Math.max(effects.healingEchoRatio, finalSkill.healingEchoRatio);
      }
    }
  });
  
  // å¤„ç†è£…å¤‡æŠ€èƒ½ï¼ˆå¦‚æœæ²¡æœ‰é€šè¿‡æŠ€èƒ½é“¾å¤„ç†ï¼Œç›´æ¥å¤„ç†ï¼‰
  allSkills.forEach(skillId => {
    const skill = SKILL_LOOKUP.get(skillId);
    if (skill && skill.isEquipmentSkill && skill.kind === 'passive') {
      // æ£€æŸ¥æ˜¯å¦å·²ç»åœ¨æŠ€èƒ½é“¾ä¸­å¤„ç†è¿‡
      const alreadyProcessed = Array.from(skillChains.values()).some(chainData => 
        (chainData.learnedSkill && chainData.learnedSkill.id === skillId) ||
        (chainData.relicSkill && chainData.relicSkill.id === skillId)
      );
      
      if (!alreadyProcessed) {
        // ç›´æ¥åº”ç”¨è£…å¤‡æŠ€èƒ½æ•ˆæœ
    if (skill.perTurnMpRegen !== undefined) {
          effects.perTurnMpRegen += skill.perTurnMpRegen;
    }
    if (skill.perTurnHpRegen !== undefined) {
          effects.perTurnHpRegen += skill.perTurnHpRegen;
    }
      }
    }
  });
  
  return effects;
}

// ç²å–é­”æ³•å‹è¢«å‹•æŠ€èƒ½æ•ˆæœ
function getMagicPassiveEffects(hero) {
  const effects = {
    magicDamageBoost: 0, // é­”æ³•å‚·å®³æå‡ç™¾åˆ†æ¯”
    spellMpReturn: 0, // æ³•è¡“æ”»æ“Šå›å¾©çš„MPå€¼
    postBattleMpRegen: 0, // æˆ°é¬¥å¾Œæ¢å¾©MPçš„æ¯”ç‡
    magicCritChance: 0, // é­”æ³•æš´æ“Šæ©Ÿç‡
    magicCritMultiplier: 1.5, // é­”æ³•æš´æ“Šå€ç‡ï¼ˆå›ºå®š1.5å€ï¼‰
    mpBonus: 0, // å›ºå®šMPåŠ æˆ
    freeSpellChance: 0, // ä½¿ç”¨é­”æ³•æˆ–æ¢å¾©æ™‚ä¸æ¶ˆè€—MPçš„æ©Ÿç‡
  };
  
  if (!hero || !hero.skills) return effects;
  
  // ç²å–æ‰€æœ‰æŠ€èƒ½ï¼ˆåŒ…æ‹¬åœ£ç‰©æä¾›çš„è¢«åŠ¨æŠ€èƒ½ï¼‰
  const allSkills = [...hero.skills];
  
  // å¦‚æœæ˜¯åŒä¼´ï¼Œæª¢æŸ¥åœ£ç‰©æä¾›çš„è¢«åŠ¨æŠ€èƒ½
  if (hero.equippedRelic) {
    const relic = state.relics.find(r => r.id === hero.equippedRelic);
    if (relic && relic.passiveSkill && relic.passiveSkill.id) {
      allSkills.push(relic.passiveSkill.id);
    }
  }
  
  // æŸ¥æ‰¾æœ€é«˜éšçš„é­”æ³•å‹è¢«å‹•æŠ€èƒ½ï¼ˆæ¯ç¨®æ•ˆæœå–æœ€é«˜éšï¼‰
  // æŒ‰æŠ€èƒ½é“¾åˆ†ç»„ï¼Œæ¯”è¾ƒtierï¼Œé€‰æ‹©æœ€é«˜çš„
  const skillChains = new Map(); // chainId -> { learnedTier, learnedSkill, relicTier, relicSkill }
  
  allSkills.forEach(skillId => {
    const skill = SKILL_LOOKUP.get(skillId);
    let actualSkill = skill;
    let isRelicSkill = false;
    
    // å¦‚æœæ˜¯åœ£ç‰©æŠ€èƒ½ï¼Œç›´æ¥ä½¿ç”¨åœ£ç‰©ä¸­çš„æŠ€èƒ½å¯¹è±¡
    if (!skill && hero.equippedRelic) {
      const relic = state.relics.find(r => r.id === hero.equippedRelic);
      if (relic && relic.passiveSkill && relic.passiveSkill.id === skillId) {
        actualSkill = relic.passiveSkill;
        isRelicSkill = true;
      }
    }
    
    if (!actualSkill || actualSkill.kind !== 'passive' || actualSkill.flow !== 'magic') return;
    
    const chainId = actualSkill.chainId || skill?.chainId;
    if (!chainId) return;
    
    const tier = actualSkill.tier || 0;
    
    if (!skillChains.has(chainId)) {
      skillChains.set(chainId, {
        learnedTier: 0,
        learnedSkill: null,
        relicTier: 0,
        relicSkill: null,
      });
    }
    
    const chainData = skillChains.get(chainId);
    if (isRelicSkill) {
      if (tier > chainData.relicTier) {
        chainData.relicTier = tier;
        chainData.relicSkill = actualSkill;
      }
    } else {
      if (tier > chainData.learnedTier) {
        chainData.learnedTier = tier;
        chainData.learnedSkill = actualSkill;
      }
    }
  });
  
  // å¯¹äºæ¯ä¸ªæŠ€èƒ½é“¾ï¼Œé€‰æ‹©tieræ›´é«˜çš„æŠ€èƒ½ï¼ˆåœ£ç‰©æˆ–å·²å­¦ä¹ ï¼‰
  skillChains.forEach((chainData, chainId) => {
    let finalSkill = null;
    
    // å¦‚æœåœ£ç‰©æŠ€èƒ½çš„tieræ›´é«˜ï¼Œä½¿ç”¨åœ£ç‰©æŠ€èƒ½ï¼›å¦åˆ™ä½¿ç”¨å·²å­¦ä¹ çš„æŠ€èƒ½
    if (chainData.relicTier > chainData.learnedTier) {
      finalSkill = chainData.relicSkill;
    } else if (chainData.learnedTier > 0) {
      finalSkill = chainData.learnedSkill;
    }
    
    if (finalSkill) {
      if (finalSkill.magicDamageBoost !== undefined) {
        effects.magicDamageBoost = Math.max(effects.magicDamageBoost, finalSkill.magicDamageBoost);
      }
      if (finalSkill.spellMpReturn !== undefined) {
        effects.spellMpReturn = Math.max(effects.spellMpReturn, finalSkill.spellMpReturn);
      }
      if (finalSkill.postBattleMpRegen !== undefined) {
        effects.postBattleMpRegen = Math.max(effects.postBattleMpRegen, finalSkill.postBattleMpRegen);
      }
      if (finalSkill.magicCritChance !== undefined) {
        effects.magicCritChance = Math.max(effects.magicCritChance, finalSkill.magicCritChance);
        if (finalSkill.magicCritMultiplier !== undefined) {
          effects.magicCritMultiplier = finalSkill.magicCritMultiplier;
        }
      }
      if (finalSkill.mpBonus !== undefined) {
        effects.mpBonus = Math.max(effects.mpBonus, finalSkill.mpBonus);
      }
      if (finalSkill.freeSpellChance !== undefined) {
        effects.freeSpellChance = Math.max(effects.freeSpellChance, finalSkill.freeSpellChance);
      }
    }
  });
  
  return effects;
}

// ç²å–å‹‡è€…ä¹‹è¡€è¢«å‹•æŠ€èƒ½æ•ˆæœ
function getHeroBloodPassiveEffects(hero) {
  const effects = {
    allAttributesBonus: 0, // å…¨èƒ½åŠ›+20
    recoveryBonus: 0, // å›å¾©åŠ›+60
    magicBonus: 0, // é­”åŠ›+60
    mpBonus: 0, // MP+50
  };
  
  if (!hero || !hero.skills) return effects;
  
  // æŸ¥æ‰¾å‹‡è€…ä¹‹è¡€è¢«å‹•æŠ€èƒ½
  hero.skills.forEach(skillId => {
    const skill = SKILL_LOOKUP.get(skillId);
    if (!skill || skill.kind !== 'passive' || skill.flow !== 'hero') return;
    
    if (skill.allAttributesBonus !== undefined) {
      effects.allAttributesBonus = Math.max(effects.allAttributesBonus, skill.allAttributesBonus);
    }
    if (skill.recoveryBonus !== undefined) {
      effects.recoveryBonus += skill.recoveryBonus; // ç´¯åŠ å›å¾©åŠ›åŠ æˆ
    }
    if (skill.magicBonus !== undefined) {
      effects.magicBonus += skill.magicBonus; // ç´¯åŠ é­”åŠ›åŠ æˆ
    }
    if (skill.mpBonus !== undefined) {
      effects.mpBonus += skill.mpBonus; // ç´¯åŠ MPåŠ æˆï¼ˆå›å¾©ä¹‹è¡€å’Œæ³•å¸«ä¹‹è¡€å¯ä»¥ç–ŠåŠ ï¼‰
    }
  });
  
  return effects;
}

// ç²å–æ­¦å™¨å¤§å¸«è¢«å‹•æŠ€èƒ½æ•ˆæœ
function getWeaponmasterPassiveEffects(hero) {
  const effects = {
    normalAttackAoe: false, // æ™®æ”»è®Šç‚ºå…¨é«”æ”»æ“Š
    normalAttackDamageRatio: 1.0, // æ™®æ”»å‚·å®³æ¯”ä¾‹
    ignoreDefense: false, // ç„¡è¦–é˜²ç¦¦
  };
  
  if (!hero || !hero.skills) return effects;
  
  // ç²å–æ‰€æœ‰æŠ€èƒ½ï¼ˆåŒ…æ‹¬åœ£ç‰©æä¾›çš„è¢«åŠ¨æŠ€èƒ½ï¼‰
  const allSkills = [...hero.skills];
  
  // å¦‚æœæ˜¯åŒä¼´ï¼Œæª¢æŸ¥åœ£ç‰©æä¾›çš„è¢«åŠ¨æŠ€èƒ½
  if (hero.equippedRelic) {
    const relic = state.relics.find(r => r.id === hero.equippedRelic);
    if (relic && relic.passiveSkill && relic.passiveSkill.id) {
      allSkills.push(relic.passiveSkill.id);
    }
  }
  
  // æŸ¥æ‰¾æ­¦å™¨å¤§å¸«è¢«å‹•æŠ€èƒ½
  allSkills.forEach(skillId => {
    const skill = SKILL_LOOKUP.get(skillId);
    let actualSkill = skill;
    
    // å¦‚æœæ˜¯åœ£ç‰©æŠ€èƒ½ï¼Œç›´æ¥ä½¿ç”¨åœ£ç‰©ä¸­çš„æŠ€èƒ½å¯¹è±¡
    if (!skill && hero.equippedRelic) {
      const relic = state.relics.find(r => r.id === hero.equippedRelic);
      if (relic && relic.passiveSkill && relic.passiveSkill.id === skillId) {
        actualSkill = relic.passiveSkill;
      }
    }
    
    if (!actualSkill || actualSkill.kind !== 'passive') return;
    if (!actualSkill.isAdvancedSkill || actualSkill.advancedClass !== 'weaponmaster') return;
    
    // åŠç¥ä¹‹è·¯ï¼šåŠæ°£ç¸±æ©«
    if (actualSkill.weaponmasterPath === 'sword_god') {
      if (actualSkill.normalAttackAoe !== undefined) {
        effects.normalAttackAoe = actualSkill.normalAttackAoe;
      }
      if (actualSkill.normalAttackDamageRatio !== undefined) {
        effects.normalAttackDamageRatio = actualSkill.normalAttackDamageRatio;
      }
    }
    
    // åˆºå®¢ä¹‹è·¯ï¼šç ´ç”²ä¹‹åˆƒ
    if (actualSkill.weaponmasterPath === 'assassin') {
      if (actualSkill.ignoreDefense !== undefined) {
        effects.ignoreDefense = actualSkill.ignoreDefense;
      }
    }
  });
  
  return effects;
}

// ç²å–æ•æ·å‹è¢«å‹•æŠ€èƒ½æ•ˆæœ
function getAgilityPassiveEffects(hero) {
  const effects = {
    hitRateBonus: 0, // å›ºå®šå‘½ä¸­ç‡åŠ æˆ
    critRateBonus: 0, // å›ºå®šæš´æ“Šç‡åŠ æˆ
    dodgeRateBonus: 0, // å›ºå®šé–ƒé¿ç‡åŠ æˆ
    goldBoost: 0, // é‡‘å¹£ç²å¾—æå‡ç™¾åˆ†æ¯”
    dropRateBoost: 0, // ç‰©å“æ‰è½ç‡æå‡ç™¾åˆ†æ¯”
  };
  
  if (!hero || !hero.skills) return effects;
  
  // ç²å–æ‰€æœ‰æŠ€èƒ½ï¼ˆåŒ…æ‹¬åœ£ç‰©æä¾›çš„è¢«åŠ¨æŠ€èƒ½å’Œè£å‚™æŠ€èƒ½ï¼‰
  const allSkills = [...hero.skills];
  
  // å¦‚æœæ˜¯åŒä¼´ï¼Œæª¢æŸ¥åœ£ç‰©æä¾›çš„è¢«åŠ¨æŠ€èƒ½
  if (hero.equippedRelic) {
    const relic = state.relics.find(r => r.id === hero.equippedRelic);
    if (relic && relic.passiveSkill && relic.passiveSkill.id) {
      allSkills.push(relic.passiveSkill.id);
    }
  }
  
  // å¦‚æœæ˜¯è‹±é›„ï¼Œæª¢æŸ¥è£å‚™æä¾›çš„è¢«åŠ¨æŠ€èƒ½ï¼ˆç¾…å¾·è£å‚™ï¼‰
  if (hero === state.hero && hero.equipment) {
    ['weapon', 'shield', 'armor', 'accessory'].forEach(slot => {
      const equipmentId = hero.equipment[slot];
      if (equipmentId) {
        const passiveSkillId = getEquipmentPassiveSkillId(equipmentId);
        if (passiveSkillId && !allSkills.includes(passiveSkillId)) {
          allSkills.push(passiveSkillId);
        }
      }
    });
  }
  
  // æŸ¥æ‰¾æœ€é«˜éšçš„æ•æ·å‹è¢«å‹•æŠ€èƒ½ï¼ˆæ¯ç¨®æ•ˆæœå–æœ€é«˜éšï¼‰
  // æŒ‰æŠ€èƒ½é“¾åˆ†ç»„ï¼Œæ¯”è¾ƒtierï¼Œé€‰æ‹©æœ€é«˜çš„
  const skillChains = new Map(); // chainId -> { learnedTier, learnedSkill, relicTier, relicSkill }
  
  allSkills.forEach(skillId => {
    const skill = SKILL_LOOKUP.get(skillId);
    let actualSkill = skill;
    let isRelicSkill = false;
    
    // å¦‚æœæ˜¯åœ£ç‰©æŠ€èƒ½ï¼Œç›´æ¥ä½¿ç”¨åœ£ç‰©ä¸­çš„æŠ€èƒ½å¯¹è±¡
    if (!skill && hero.equippedRelic) {
      const relic = state.relics.find(r => r.id === hero.equippedRelic);
      if (relic && relic.passiveSkill && relic.passiveSkill.id === skillId) {
        actualSkill = relic.passiveSkill;
        isRelicSkill = true;
      }
    }
    
    // æ”¯æŒæ•æ·å‹è¢«åŠ¨æŠ€èƒ½å’Œè£…å¤‡æŠ€èƒ½ï¼ˆç½—å¾·ä¹‹å‰‘ã€ç½—å¾·ä¹‹ç›¾ï¼‰
    if (!actualSkill || actualSkill.kind !== 'passive') return;
    if (actualSkill.flow !== 'agility' && !(actualSkill.isEquipmentSkill && (actualSkill.hitRateBonus !== undefined || actualSkill.critRateBonus !== undefined || actualSkill.dodgeRateBonus !== undefined))) return;
    
    // è£…å¤‡æŠ€èƒ½å¯èƒ½æ²¡æœ‰ chainIdï¼Œä½¿ç”¨æŠ€èƒ½IDä½œä¸º chainId
    const chainId = actualSkill.chainId || skill?.chainId || (actualSkill.isEquipmentSkill ? `equipment_${skillId}` : null);
    if (!chainId) return;
    
    const tier = actualSkill.tier || 0;
    
    if (!skillChains.has(chainId)) {
      skillChains.set(chainId, {
        learnedTier: 0,
        learnedSkill: null,
        relicTier: 0,
        relicSkill: null,
      });
    }
    
    const chainData = skillChains.get(chainId);
    if (isRelicSkill) {
      if (tier > chainData.relicTier) {
        chainData.relicTier = tier;
        chainData.relicSkill = actualSkill;
      }
    } else {
      if (tier > chainData.learnedTier) {
        chainData.learnedTier = tier;
        chainData.learnedSkill = actualSkill;
      }
    }
  });
  
  // å¯¹äºæ¯ä¸ªæŠ€èƒ½é“¾ï¼Œé€‰æ‹©tieræ›´é«˜çš„æŠ€èƒ½ï¼ˆåœ£ç‰©æˆ–å·²å­¦ä¹ ï¼‰
  skillChains.forEach((chainData, chainId) => {
    let finalSkill = null;
    
    // å¦‚æœåœ£ç‰©æŠ€èƒ½çš„tieræ›´é«˜ï¼Œä½¿ç”¨åœ£ç‰©æŠ€èƒ½ï¼›å¦åˆ™ä½¿ç”¨å·²å­¦ä¹ çš„æŠ€èƒ½
    if (chainData.relicTier > chainData.learnedTier) {
      finalSkill = chainData.relicSkill;
    } else if (chainData.learnedTier > 0) {
      finalSkill = chainData.learnedSkill;
    }
    
    if (finalSkill) {
      // å¯¹äºåŒä¸€æŠ€èƒ½é“¾çš„ä¸åŒtierï¼Œå·²ç»é€šè¿‡ä¸Šé¢çš„é€»è¾‘å–äº†æœ€é«˜tier
      // å¯¹äºä¸åŒæŠ€èƒ½é“¾ï¼Œåº”è¯¥ç´¯åŠ æ•ˆæœï¼ˆå‘½ä¸­ç‡å’Œæš´å‡»ç‡å¯ä»¥ç´¯åŠ ï¼‰
      if (finalSkill.hitRateBonus !== undefined) {
        // ç´¯åŠ ä¸åŒæŠ€èƒ½é“¾çš„å‘½ä¸­ç‡åŠ æˆ
        effects.hitRateBonus += finalSkill.hitRateBonus;
      }
      if (finalSkill.critRateBonus !== undefined) {
        // ç´¯åŠ ä¸åŒæŠ€èƒ½é“¾çš„æš´å‡»ç‡åŠ æˆ
        effects.critRateBonus += finalSkill.critRateBonus;
      }
      if (finalSkill.dodgeRateBonus !== undefined) {
        // ç´¯åŠ ä¸åŒæŠ€èƒ½é“¾çš„é—ªé¿ç‡åŠ æˆ
        effects.dodgeRateBonus = (effects.dodgeRateBonus || 0) + finalSkill.dodgeRateBonus;
      }
      if (finalSkill.goldBoost !== undefined) {
        // é‡‘å¸åŠ æˆå–æœ€å¤§å€¼ï¼ˆé€šå¸¸åªæœ‰ä¸€ä¸ªæŠ€èƒ½é“¾æœ‰é‡‘å¸åŠ æˆï¼‰
        effects.goldBoost = Math.max(effects.goldBoost, finalSkill.goldBoost);
      }
      if (finalSkill.dropRateBoost !== undefined) {
        // æ‰è½ç‡åŠ æˆå–æœ€å¤§å€¼ï¼ˆé€šå¸¸åªæœ‰ä¸€ä¸ªæŠ€èƒ½é“¾æœ‰æ‰è½ç‡åŠ æˆï¼‰
        effects.dropRateBoost = Math.max(effects.dropRateBoost, finalSkill.dropRateBoost);
      }
    }
  });
  
  // å¤„ç†è£…å¤‡æŠ€èƒ½ï¼ˆå¦‚æœæ²¡æœ‰é€šè¿‡æŠ€èƒ½é“¾å¤„ç†ï¼Œç›´æ¥å¤„ç†ï¼‰
  allSkills.forEach(skillId => {
    const skill = SKILL_LOOKUP.get(skillId);
    if (skill && skill.isEquipmentSkill && skill.kind === 'passive') {
      // æ£€æŸ¥æ˜¯å¦å·²ç»åœ¨æŠ€èƒ½é“¾ä¸­å¤„ç†è¿‡
      const alreadyProcessed = Array.from(skillChains.values()).some(chainData => 
        (chainData.learnedSkill && chainData.learnedSkill.id === skillId) ||
        (chainData.relicSkill && chainData.relicSkill.id === skillId)
      );
      
      if (!alreadyProcessed) {
        // ç›´æ¥åº”ç”¨è£…å¤‡æŠ€èƒ½æ•ˆæœ
    if (skill.hitRateBonus !== undefined) {
          effects.hitRateBonus += skill.hitRateBonus;
    }
    if (skill.critRateBonus !== undefined) {
          effects.critRateBonus += skill.critRateBonus;
    }
        if (skill.dodgeRateBonus !== undefined) {
          effects.dodgeRateBonus = (effects.dodgeRateBonus || 0) + skill.dodgeRateBonus;
    }
      }
    }
  });
  
  return effects;
}

// è¨ˆç®—é­”é˜²ï¼ˆé­”æ³•é˜²ç¦¦åŠ›ï¼‰
function calculateMagicDefense(character, characterType = 'hero') {
  let recovery = 0;
  let magic = 0;
  
  if (characterType === 'hero') {
    const totalAttrs = getHeroTotalAttributes(character);
    recovery = totalAttrs.recovery || 0;
    magic = totalAttrs.magic || 0;
  } else if (characterType === 'companion') {
    const totalAttrs = getCompanionTotalAttributes(character);
    recovery = totalAttrs.recovery || 0;
    magic = totalAttrs.magic || 0;
  } else {
    // æ•µäºº
    recovery = character.attributes ? (character.attributes.recovery || 0) : 0;
    magic = character.attributes ? (character.attributes.magic || 0) : 0;
  }
  
  // é­”é˜² = (å›å¾©åŠ› + é­”åŠ›) / 10ï¼ˆå‘ä¸‹å–æ•´ï¼‰
  return Math.floor((recovery + magic) / 10);
}

// è¨ˆç®—æœƒå¿ƒä¸€æ“Šæ©Ÿç‡
function calculateCritChance(attacker, skill = null) {
  // æœƒå¿ƒä¸€æ“Šç‡ = 5 + æ•æ· / 15ï¼ˆå°æ•¸ç„¡æ¢ä»¶é€²ä½ï¼‰
  let critChance = 0;
  
  // åˆ¤æ–·æ”»æ“Šè€…æ˜¯è‹±é›„ã€åŒä¼´é‚„æ˜¯æ•µäºº
  const isHero = attacker === state.hero;
  // æ£€æŸ¥æ˜¯å¦æ˜¯ä»»æ„ä¸€ä¸ªåŒä¼´ï¼ˆä¸ä»…ä»…æ˜¯ç¬¬ä¸€ä¸ªï¼‰
  const isCompanion = state.companions && state.companions.some(c => c === attacker);
  
  if (isHero) {
    const totalAttrs = getHeroTotalAttributes(attacker);
    const agility = totalAttrs.agility;
    
    // æœƒå¿ƒä¸€æ“Šç‡ = 5 + æ•æ· / 15ï¼ˆå°æ•¸ç„¡æ¢ä»¶é€²ä½ï¼‰
    critChance = 5 + Math.ceil(agility / 15);
    
    // åŠ ä¸ŠæŠ€èƒ½çš„æœƒå¿ƒä¸€æ“Šæ©Ÿç‡åŠ æˆ
    if (skill && skill.critChance !== undefined) {
      // å¦‚æœ critChance < 1.0ï¼Œè¡¨ç¤ºæ˜¯å°æ•¸æ ¼å¼ï¼ˆå¦‚ 0.5 = 50%ï¼‰ï¼Œéœ€è¦è½‰æ›ç‚ºç™¾åˆ†æ¯”
      // å¦‚æœ critChance >= 1.0ï¼Œè¡¨ç¤ºæ˜¯ç™¾åˆ†æ¯”æ ¼å¼ï¼ˆå¦‚ 20 = 20%ï¼‰
      if (skill.critChance < 1.0) {
        critChance += skill.critChance * 100;
      } else {
      critChance += skill.critChance;
      }
    }
    
    // æ‡‰ç”¨æ•æ·å‹è¢«å‹•æŠ€èƒ½ï¼šå›ºå®šæš´æ“Šç‡åŠ æˆï¼ˆåŒ…æ‹¬è£å‚™æŠ€èƒ½ï¼‰
    const agilityEffects = getAgilityPassiveEffects(attacker);
    if (agilityEffects.critRateBonus > 0) {
      critChance += agilityEffects.critRateBonus;
    }
    
    // æ‡‰ç”¨åŠæ„buffï¼šæå‡æš´æ“Šç‡
    const battle = state.ui.battle;
    if (battle && battle.heroBuffs && battle.heroBuffs.swordIntent) {
      critChance += battle.heroBuffs.swordIntent.critBoost;
    }
  } else if (isCompanion) {
    const totalAttrs = getCompanionTotalAttributes(attacker);
    const agility = totalAttrs.agility;
    
    // æœƒå¿ƒä¸€æ“Šç‡ = 5 + æ•æ· / 15ï¼ˆå°æ•¸ç„¡æ¢ä»¶é€²ä½ï¼‰
    critChance = 5 + Math.ceil(agility / 15);
    
    // åŠ ä¸ŠæŠ€èƒ½çš„æœƒå¿ƒä¸€æ“Šæ©Ÿç‡åŠ æˆ
    if (skill && skill.critChance !== undefined) {
      // å¦‚æœ critChance < 1.0ï¼Œè¡¨ç¤ºæ˜¯å°æ•¸æ ¼å¼ï¼ˆå¦‚ 0.5 = 50%ï¼‰ï¼Œéœ€è¦è½‰æ›ç‚ºç™¾åˆ†æ¯”
      // å¦‚æœ critChance >= 1.0ï¼Œè¡¨ç¤ºæ˜¯ç™¾åˆ†æ¯”æ ¼å¼ï¼ˆå¦‚ 20 = 20%ï¼‰
      if (skill.critChance < 1.0) {
        critChance += skill.critChance * 100;
      } else {
      critChance += skill.critChance;
      }
    }
    
    // æ‡‰ç”¨æ•æ·å‹è¢«å‹•æŠ€èƒ½ï¼šå›ºå®šæš´æ“Šç‡åŠ æˆï¼ˆåŒä¼´ä¹Ÿå¯ä»¥æœ‰ï¼‰
    const agilityEffects = getAgilityPassiveEffects(attacker);
    if (agilityEffects.critRateBonus > 0) {
      critChance += agilityEffects.critRateBonus;
    }
  } else {
    // æ•µäººï¼šæœƒå¿ƒä¸€æ“Šç‡ = 5 + æ•æ· / 15ï¼ˆå°æ•¸ç„¡æ¢ä»¶é€²ä½ï¼‰
    const agility = attacker.attributes.agility || 0;
    critChance = 5 + Math.ceil(agility / 15);
    
    // åŠ ä¸ŠæŠ€èƒ½çš„æœƒå¿ƒä¸€æ“Šæ©Ÿç‡åŠ æˆ
    if (skill && skill.critChance !== undefined) {
      // å¦‚æœ critChance < 1.0ï¼Œè¡¨ç¤ºæ˜¯å°æ•¸æ ¼å¼ï¼ˆå¦‚ 0.5 = 50%ï¼‰ï¼Œéœ€è¦è½‰æ›ç‚ºç™¾åˆ†æ¯”
      // å¦‚æœ critChance >= 1.0ï¼Œè¡¨ç¤ºæ˜¯ç™¾åˆ†æ¯”æ ¼å¼ï¼ˆå¦‚ 20 = 20%ï¼‰
      if (skill.critChance < 1.0) {
        critChance += skill.critChance * 100;
      } else {
      critChance += skill.critChance;
      }
    }
  }
  
  return critChance;
}

// æª¢æŸ¥æ˜¯å¦è§¸ç™¼æœƒå¿ƒä¸€æ“Š
function checkCrit(attacker, skill = null) {
  // å¦‚æœæŠ€èƒ½æœ‰ critChance ä¸” >= 100ï¼ˆ100%ï¼‰ï¼Œå¿…å®šæœƒå¿ƒä¸€æ“Š
  // æ³¨æ„ï¼šcritChance å¯èƒ½æ˜¯å°æ•¸æ ¼å¼ï¼ˆ0.5 = 50%ï¼‰æˆ–ç™¾åˆ†æ¯”æ ¼å¼ï¼ˆ100 = 100%ï¼‰
  if (skill && skill.critChance !== undefined) {
    const skillCritChance = skill.critChance < 1.0 ? skill.critChance * 100 : skill.critChance;
    if (skillCritChance >= 100) {
    return true;
    }
  }
  const critChance = calculateCritChance(attacker, skill);
  return Math.random() * 100 < critChance;
}

// è¨ˆç®—å‘½ä¸­ç‡
function calculateHitRate(attacker, skill = null, target = null) {
  // åŸºæœ¬å‘½ä¸­ç‡ï¼š90%
  let hitRate = 90;
  
  // åˆ¤æ–·æ”»æ“Šè€…æ˜¯è‹±é›„ã€åŒä¼´é‚„æ˜¯æ•µäºº
  const isHero = attacker === state.hero;
  // æ£€æŸ¥æ˜¯å¦æ˜¯ä»»æ„ä¸€ä¸ªåŒä¼´ï¼ˆä¸ä»…ä»…æ˜¯ç¬¬ä¸€ä¸ªï¼‰
  const isCompanion = state.companions && state.companions.some(c => c === attacker);
  
  let agility = 0;
  if (isHero) {
    const totalAttrs = getHeroTotalAttributes(attacker);
    agility = totalAttrs.agility;
  } else if (isCompanion) {
    const totalAttrs = getCompanionTotalAttributes(attacker);
    agility = totalAttrs.agility;
  } else {
    agility = attacker.attributes?.agility || 0;
  }
  
  // åŠ ä¸Šæ•æ·/15çš„åŠ æ¬Šï¼ˆå°æ•¸ç„¡æ¢ä»¶é€²ä½ï¼‰
  hitRate += Math.ceil(agility / 15);
  
  // åŠ ä¸ŠæŠ€èƒ½çš„å‘½ä¸­ç‡åŠ æ¬Šå€¼
  if (skill && skill.hitRate !== undefined) {
    hitRate += skill.hitRate;
  }
  
    // æ‡‰ç”¨æ•æ·å‹è¢«å‹•æŠ€èƒ½ï¼šå›ºå®šå‘½ä¸­ç‡åŠ æˆï¼ˆè‹±é›„å’ŒåŒä¼´éƒ½å¯ä»¥æœ‰ï¼ŒåŒ…æ‹¬è£å‚™æŠ€èƒ½ï¼‰
    if (isHero || isCompanion) {
    const agilityEffects = getAgilityPassiveEffects(attacker);
    if (agilityEffects.hitRateBonus > 0) {
      hitRate += agilityEffects.hitRateBonus;
    }
  }
  
  // å¦‚æœç›®æ¨™å­˜åœ¨ï¼Œæ¸›å»ç›®æ¨™çš„é–ƒé¿ç‡
  if (target) {
    const targetDodge = calculateDodgeRate(target);
    hitRate -= targetDodge;
  }
  
  // å‘½ä¸­ç‡ä¸‹é™é™åˆ¶åœ¨ 5%ï¼Œå…è¨±è¶…é100%
  hitRate = Math.max(5, hitRate);
  
  return hitRate;
}

// è¨ˆç®—é–ƒé¿ç‡
function calculateDodgeRate(character) {
  let agility = 0;
  
  // åˆ¤æ–·æ˜¯è‹±é›„ã€åŒä¼´é‚„æ˜¯æ•µäºº
  const isHero = character === state.hero;
  // æ£€æŸ¥æ˜¯å¦æ˜¯ä»»æ„ä¸€ä¸ªåŒä¼´ï¼ˆä¸ä»…ä»…æ˜¯ç¬¬ä¸€ä¸ªï¼‰
  const isCompanion = state.companions && state.companions.some(c => c === character);
  
  if (isHero) {
    const totalAttrs = getHeroTotalAttributes(character);
    agility = totalAttrs.agility;
  } else if (isCompanion) {
    const totalAttrs = getCompanionTotalAttributes(character);
    agility = totalAttrs.agility;
  } else {
    agility = character.attributes?.agility || 0;
  }
  
  // é–ƒé¿ç‡ = æ•æ·/15ï¼ˆå°æ•¸ç„¡æ¢ä»¶é€²ä½ï¼‰
  let dodgeRate = Math.ceil(agility / 15);
  
  // æ‡‰ç”¨æ•æ·å‹è¢«å‹•æŠ€èƒ½çš„é–ƒé¿ç‡åŠ æˆï¼ˆè‹±é›„å’ŒåŒä¼´éƒ½å¯ä»¥æœ‰ï¼‰
  if (isHero || isCompanion) {
    const agilityEffects = getAgilityPassiveEffects(character);
    if (agilityEffects.dodgeRateBonus > 0) {
      dodgeRate += agilityEffects.dodgeRateBonus;
    }
  }
  
  return dodgeRate;
}

function calculatePhysicalDamage(power = 0, target) {
  const hero = state.hero;
  // ç‰©ç†å‚·å®³ = (æ”»æ“ŠåŠ› + è£å‚™æ”»æ“ŠåŠ› + æŠ€èƒ½åŠ å€¼) - é˜²å®ˆåŠ›
  const totalAttrs = getHeroTotalAttributes(hero);
  let attack = totalAttrs.attack;
  const equipmentAttack = getEquipmentAttack(hero);
  const skillBonus = power; // æŠ€èƒ½åŠ å€¼
  
  // æ‡‰ç”¨åŠå£«å‹è¢«å‹•æŠ€èƒ½ï¼šé¡å¤–æå‡æ”»æ“ŠåŠ›
  const passiveEffects = getSwordPassiveEffects(hero);
  if (passiveEffects.attackBoost > 0) {
    attack = Math.round(attack * (1 + passiveEffects.attackBoost));
  }
  
  // æª¢æŸ¥æ˜¯å¦æœ‰ç ´ç”²ä¹‹åˆƒbuffï¼šç„¡è¦–é˜²ç¦¦
  const battle = state.ui.battle;
  let defense = target.attributes ? target.attributes.defense : (target.defense || 0);
  if (battle && battle.heroBuffs && battle.heroBuffs.ignoreDefense) {
    defense = 0; // ç„¡è¦–é˜²ç¦¦
  }
  
  let damage = (attack + equipmentAttack + skillBonus) - defense;
  damage = Math.max(1, Math.round(damage));
  
  // æª¢æŸ¥æœƒå¿ƒä¸€æ“Šï¼ˆæ™®é€šæ”»æ“Šæ²’æœ‰æŠ€èƒ½ï¼Œæ‰€ä»¥å‚³nullï¼‰
  const isCrit = checkCrit(hero, null);
  if (isCrit) {
    damage = Math.round(damage * 2); // æœƒå¿ƒä¸€æ“Šå‚·å®³ç¿»å€
  }
  
  // è¼¸å‡ºæ™®é€šæ”»æ“Šå‚·å®³è¨ˆç®—æ—¥èªŒ
  const totalAttack = attack + equipmentAttack + skillBonus;
  const targetName = target.name || 'ç›®æ¨™';
  console.log(`[å‚·å®³è¨ˆç®—] å‹‡è€… æ™®é€šæ”»æ“Š ${targetName}ï¼šæ”»æ“Šå€¼=${totalAttack}, é˜²ç¦¦å€¼=${defense}, æœ€çµ‚å‚·å®³=${damage}${isCrit ? ' (æœƒå¿ƒä¸€æ“Š)' : ''}`);
  
  return { damage, isCrit };
}

function calculateSkillDamage(skill, attacker, target) {
  const skillPower = skill.power || 0; // æŠ€èƒ½åŠ æ¬Šå€¼æˆ–å›ºå®šå€¼
  let baseDamage = 0;
  let defense = 0;
  
  // è–æ“Šï¼šåªä½¿ç”¨å›ºå®šå€¼ï¼Œä¸å—ä»»ä½•å› ç´ å½±éŸ¿
  const isEnhancedHeal = skill.id && skill.id.startsWith('enhanced_heal_');
  if (isEnhancedHeal) {
    // è–æ“Šåªä½¿ç”¨å›ºå®šå€¼ï¼ˆpowerï¼‰ï¼Œä¸å—æ”»æ“ŠåŠ›ã€å›å¾©åŠ›ç­‰å½±éŸ¿
    baseDamage = skillPower;
    defense = 0; // è–æ“Šä¸å—é˜²ç¦¦æ¸›å‚·
    let damage = baseDamage;
    damage = Math.max(1, Math.round(damage));
    
    // è–æ“Šä¸è§¸ç™¼æœƒå¿ƒä¸€æ“Š
    return { damage, isCrit: false };
  }
  
  // åˆ¤æ–·æ”»æ“Šè€…æ˜¯è‹±é›„ã€åŒä¼´é‚„æ˜¯æ•µäºº
  const isHero = attacker === state.hero;
  // æ£€æŸ¥æ˜¯å¦æ˜¯ä»»æ„ä¸€ä¸ªåŒä¼´ï¼ˆä¸ä»…ä»…æ˜¯ç¬¬ä¸€ä¸ªï¼‰
  const isCompanion = state.companions && state.companions.some(c => c === attacker);
  
  if (skill.flow === 'magic') {
    // é­”æ³•å‚·å®³ï¼šå›ºå®šå€¼ + é­”åŠ›/3ï¼ˆæˆ–ä½¿ç”¨magicRatioï¼‰
    const baseValue = skillPower; // powerä½œç‚ºå›ºå®šå€¼
    let magic = 0;
    if (isHero) {
      const totalAttrs = getHeroTotalAttributes(attacker);
      magic = totalAttrs.magic;
    } else if (isCompanion) {
      const totalAttrs = getCompanionTotalAttributes(attacker);
      magic = totalAttrs.magic;
    } else {
      magic = attacker.attributes.magic;
    }
    
    // å¦‚æœæŠ€èƒ½æœ‰magicRatioå±¬æ€§ï¼ˆå¦‚å…ƒç´ çˆ†ç™¼ï¼‰ï¼Œä½¿ç”¨è©²æ¯”ä¾‹
    if (skill.magicRatio && skill.magicRatio > 0) {
      const magicBonus = Math.floor(magic * skill.magicRatio);
      baseDamage = baseValue + magicBonus;
    } else {
      // å›ºå®šå€¼ + é­”åŠ›/3
      baseDamage = baseValue + Math.floor(magic / 3);
    }
    
    // æ‡‰ç”¨é­”æ³•å‹è¢«å‹•æŠ€èƒ½ï¼šå¢åŠ é­”æ³•å‚·å®³ï¼ˆè‹±é›„å’ŒåŒä¼´éƒ½å¯ä»¥æœ‰é­”æ³•å‹è¢«å‹•æŠ€èƒ½ï¼‰
      const magicEffects = getMagicPassiveEffects(attacker);
      if (magicEffects.magicDamageBoost > 0) {
        baseDamage = Math.ceil(baseDamage * (1 + magicEffects.magicDamageBoost));
    }
    
    // æ³•è¡“ä¸å—é˜²å®ˆæ¸›å‚·
    defense = 0;
  } else if (skill.flow === 'sword') {
    // åŠæŠ€å‚·å®³ï¼šæ”»æ“ŠåŠ› + åŠ æ¬Šå€¼ï¼ˆä¸æ˜¯ä¹˜ä»¥ï¼‰
    let attack = 0;
    let magic = 0;
    
    if (isHero) {
      const totalAttrs = getHeroTotalAttributes(attacker);
      attack = totalAttrs.attack;
      attack += getEquipmentAttack(attacker);
      magic = totalAttrs.magic;
      
      // æ‡‰ç”¨åŠå£«å‹è¢«å‹•æŠ€èƒ½ï¼šé¡å¤–æå‡æ”»æ“ŠåŠ›
      const passiveEffects = getSwordPassiveEffects(attacker);
      if (passiveEffects.attackBoost > 0) {
        attack = Math.round(attack * (1 + passiveEffects.attackBoost));
      }
      
      // æ‡‰ç”¨åŠæ„buffï¼šæå‡æ”»æ“ŠåŠ›
      const battle = state.ui.battle;
      if (battle && battle.heroBuffs && battle.heroBuffs.swordIntent) {
        attack = Math.round(attack * (1 + battle.heroBuffs.swordIntent.attackBoost));
      }
      
      // è™•ç†é˜²å®ˆè¡æ“ŠæŠ€èƒ½ï¼šæ”»æ“ŠåŠ› = æ”»æ“Šçš„30% + é˜²å®ˆåŠ›çš„ç™¾åˆ†æ¯”
      if (skill.defenseBoostPercent && skill.defenseBoostPercent > 0) {
        const defense = totalAttrs.defense;
        const attackPortion = Math.floor(attack * 0.3); // æ”»æ“Šçš„30%
        const defensePortion = Math.floor(defense * skill.defenseBoostPercent); // é˜²å®ˆåŠ›çš„ç™¾åˆ†æ¯”
        attack = attackPortion + defensePortion;
      }
      
      // è™•ç†åŠç¥ä¹‹è·¯ï¼šå‚·å®³ = (1 + 3x(æ¶ˆè€—MP/æœ€å¤§MPä¸€åŠ)) Ã— æ”»æ“ŠåŠ›ï¼ˆå„ªå…ˆç´šæœ€é«˜ï¼‰
      if (skill.dynamicMpCost && skill.dynamicMpCost === true && skill.weaponmasterPath === 'sword_god') {
        const consumedMp = battle && battle.tempMpCost ? battle.tempMpCost : 0;
        const maxMp = attacker.stats.maxMp;
        const mpCostMaxRatio = skill.mpCostMaxRatio || 0.5;
        const halfMaxMp = Math.floor(maxMp * mpCostMaxRatio);
        const damageMultiplierBase = skill.damageMultiplierBase || 1;
        const damageMultiplierPerMp = skill.damageMultiplierPerMp || 3;
        
        if (halfMaxMp > 0) {
          // å³ä½¿consumedMpä¸º0ï¼Œä¹Ÿåº”è¯¥æœ‰åŸºç¡€å€ç‡ï¼ˆ1å€ï¼‰
          const mpRatio = consumedMp / halfMaxMp; // æ¶ˆè€—MP / æœ€å¤§MPä¸€åŠ
          const multiplier = damageMultiplierBase + damageMultiplierPerMp * mpRatio;
          baseDamage = Math.round(attack * multiplier);
          // åŠç¥é™è‡¨ï¼šè¼¸å‡ºæ”»æ“Šæ•¸å€¼è¨ˆç®—æ—¥èªŒï¼ˆè©³ç´°ç‰ˆï¼‰
          console.log(`[åŠç¥é™è‡¨] è©³ç´°è¨ˆç®—ï¼š`);
          console.log(`  æœ€å¤§MP: ${maxMp}, ä¸€åŠMP: ${halfMaxMp}, å¯¦éš›æ¶ˆè€—MP: ${consumedMp}`);
          console.log(`  MPæ¯”ä¾‹: ${mpRatio.toFixed(4)} (${consumedMp}/${halfMaxMp})`);
          console.log(`  åŸºç¤å€ç‡: ${damageMultiplierBase}, MPå€ç‡åŠ æˆ: ${damageMultiplierPerMp} Ã— ${mpRatio.toFixed(4)} = ${(damageMultiplierPerMp * mpRatio).toFixed(4)}`);
          console.log(`  ç¸½å€ç‡: ${multiplier.toFixed(4)} (${damageMultiplierBase} + ${damageMultiplierPerMp} Ã— ${mpRatio.toFixed(4)})`);
          console.log(`  æ”»æ“ŠåŠ›: ${attack}`);
          console.log(`  åŸºç¤å‚·å®³è¨ˆç®—: ${attack} Ã— ${multiplier.toFixed(4)} = ${(attack * multiplier).toFixed(2)}`);
          console.log(`  æœ€çµ‚åŸºç¤å‚·å®³: ${baseDamage}`);
        } else {
          // å¦‚æœæœ€å¤§MPä¸º0ï¼Œä½¿ç”¨åŸºç¡€æ”»å‡»åŠ›
          baseDamage = attack + skillPower;
          console.log(`[åŠç¥é™è‡¨] æ”»æ“ŠåŠ›: ${attack}, æœ€å¤§MPç‚º0ï¼Œä½¿ç”¨åŸºç¤æ”»æ“ŠåŠ›: ${baseDamage}`);
        }
      }
      // è™•ç†å‹‡è€…æ–¬æŠ€èƒ½ï¼šæ”»æ“ŠåŠ› + é­”åŠ› Ã— æ¯”ä¾‹
      else if (skill.magicRatio && skill.magicRatio > 0) {
        const magicBonus = Math.floor(magic * skill.magicRatio);
        baseDamage = attack + magicBonus;
      }
      // è™•ç†æ¨èº«æ–¬æŠ€èƒ½ï¼šæœ€çµ‚å‚·å®³ = æ‰£æ‰çš„HP Ã— å€æ•°ï¼ˆä¸ä½¿ç”¨æ”»æ“ŠåŠ›ï¼‰
      else if (skill.attackBoostMultiplier && skill.attackBoostMultiplier > 0 && skill.hpCostPercent) {
        const battle = state.ui.battle;
        const hpCostAmount = battle && battle.tempHpCost ? battle.tempHpCost : 0;
        if (hpCostAmount > 0) {
          // æ¨èº«æ–¬ï¼šæ‰£æ‰çš„HP Ã— å€æ•°
          baseDamage = hpCostAmount * skill.attackBoostMultiplier;
        } else {
          baseDamage = attack + skillPower;
        }
      } else if (skill.attackMultiplier && skill.attackMultiplier > 0) {
        // è“„åŠ›æ–¬ï¼šæ”»æ“ŠåŠ› Ã— å€ç‡
        baseDamage = Math.round(attack * skill.attackMultiplier);
      } else {
        // æ™®é€šåŠæŠ€ï¼šæ”»æ“ŠåŠ› + åŠ æ¬Šå€¼ï¼ˆç›´æ¥ç›¸åŠ ï¼‰
        baseDamage = attack + skillPower;
      }
    } else if (isCompanion) {
      const totalAttrs = getCompanionTotalAttributes(attacker);
      attack = totalAttrs.attack;
      magic = totalAttrs.magic;
      
      // æ‡‰ç”¨åŠæ„buffï¼šæå‡æ”»æ“ŠåŠ›
      const battle = state.ui.battle;
      if (battle && battle.companionBuffs) {
        const companionIndex = state.companions.indexOf(attacker);
        if (companionIndex >= 0 && battle.companionBuffs[companionIndex] && battle.companionBuffs[companionIndex].swordIntent) {
          attack = Math.round(attack * (1 + battle.companionBuffs[companionIndex].swordIntent.attackBoost));
        }
      }
      // è™•ç†åŠç¥ä¹‹è·¯ï¼šå‚·å®³ = (1 + 3x(æ¶ˆè€—MP/æœ€å¤§MPä¸€åŠ)) Ã— æ”»æ“ŠåŠ›ï¼ˆå„ªå…ˆç´šæœ€é«˜ï¼‰
      if (skill.dynamicMpCost && skill.dynamicMpCost === true && skill.weaponmasterPath === 'sword_god') {
        const consumedMp = battle && battle.tempMpCost ? battle.tempMpCost : 0;
        const maxMp = attacker.stats.maxMp;
        const mpCostMaxRatio = skill.mpCostMaxRatio || 0.5;
        const halfMaxMp = Math.floor(maxMp * mpCostMaxRatio);
        const damageMultiplierBase = skill.damageMultiplierBase || 1;
        const damageMultiplierPerMp = skill.damageMultiplierPerMp || 3;
        
        if (halfMaxMp > 0) {
          // å³ä½¿consumedMpä¸º0ï¼Œä¹Ÿåº”è¯¥æœ‰åŸºç¡€å€ç‡ï¼ˆ1å€ï¼‰
          const mpRatio = consumedMp / halfMaxMp; // æ¶ˆè€—MP / æœ€å¤§MPä¸€åŠ
          const multiplier = damageMultiplierBase + damageMultiplierPerMp * mpRatio;
          baseDamage = Math.round(attack * multiplier);
          // åŠç¥é™è‡¨ï¼šè¼¸å‡ºæ”»æ“Šæ•¸å€¼è¨ˆç®—æ—¥èªŒï¼ˆè©³ç´°ç‰ˆï¼‰
          console.log(`[åŠç¥é™è‡¨-åŒä¼´] è©³ç´°è¨ˆç®—ï¼š`);
          console.log(`  æœ€å¤§MP: ${maxMp}, ä¸€åŠMP: ${halfMaxMp}, å¯¦éš›æ¶ˆè€—MP: ${consumedMp}`);
          console.log(`  MPæ¯”ä¾‹: ${mpRatio.toFixed(4)} (${consumedMp}/${halfMaxMp})`);
          console.log(`  åŸºç¤å€ç‡: ${damageMultiplierBase}, MPå€ç‡åŠ æˆ: ${damageMultiplierPerMp} Ã— ${mpRatio.toFixed(4)} = ${(damageMultiplierPerMp * mpRatio).toFixed(4)}`);
          console.log(`  ç¸½å€ç‡: ${multiplier.toFixed(4)} (${damageMultiplierBase} + ${damageMultiplierPerMp} Ã— ${mpRatio.toFixed(4)})`);
          console.log(`  æ”»æ“ŠåŠ›: ${attack}`);
          console.log(`  åŸºç¤å‚·å®³è¨ˆç®—: ${attack} Ã— ${multiplier.toFixed(4)} = ${(attack * multiplier).toFixed(2)}`);
          console.log(`  æœ€çµ‚åŸºç¤å‚·å®³: ${baseDamage}`);
        } else {
          // å¦‚æœæœ€å¤§MPä¸º0ï¼Œä½¿ç”¨åŸºç¡€æ”»å‡»åŠ›
          baseDamage = attack + skillPower;
          console.log(`[åŠç¥é™è‡¨-åŒä¼´] æ”»æ“ŠåŠ›: ${attack}, æœ€å¤§MPç‚º0ï¼Œä½¿ç”¨åŸºç¤æ”»æ“ŠåŠ›: ${baseDamage}`);
        }
      }
      // è™•ç†åˆºå®¢ä¹‹è·¯ï¼šæ”»æ“ŠåŠ›=æ•æ·Ã—100% + æ”»æ“ŠÃ—50%
      else if (skill.weaponmasterPath === 'assassin' && skill.agilityRatio && skill.attackRatio) {
        const agility = totalAttrs.agility || 0;
        const attack = totalAttrs.attack || 0;
        const agilityDamage = Math.floor(agility * skill.agilityRatio);
        const attackDamage = Math.floor(attack * skill.attackRatio);
        baseDamage = agilityDamage + attackDamage;
      }
      // è™•ç†è‡³è–æ–¬æŠ€èƒ½ï¼šé«”åŠ›Ã—80% + æ²»ç™‚èƒ½åŠ›Ã—80%
      else if (skill.id === 'paladin_divine_slash_1' && skill.vitalityRatio && skill.recoveryRatio) {
        const vitality = totalAttrs.vitality || 0;
        const recovery = totalAttrs.recovery || 0;
        const vitalityDamage = Math.floor(vitality * skill.vitalityRatio);
        const recoveryDamage = Math.floor(recovery * skill.recoveryRatio);
        console.log('vitalityDamage', vitalityDamage);
        console.log('recoveryDamage', recoveryDamage);  
        baseDamage = vitalityDamage + recoveryDamage;
      }
      // è™•ç†é˜²å®ˆè¡æ“ŠæŠ€èƒ½ï¼šå‚·å®³ = æ”»æ“ŠåŠ›Ã—50% + defenseBoostPercent Ã— é˜²ç¦¦åŠ›
      else if (skill.defenseBoostPercent && skill.defenseBoostPercent > 0) {
        const defense = totalAttrs.defense;
        const attackPortion = Math.round(attack * 0.5); // æ”»æ“Šçš„50%
        const defensePortion = Math.floor(defense * skill.defenseBoostPercent); // é˜²å®ˆåŠ›çš„ç™¾åˆ†æ¯”
        baseDamage = attackPortion + defensePortion;
      } 
      // è™•ç†å‹‡è€…æ–¬æŠ€èƒ½ï¼ˆåŒä¼´ä¹Ÿå¯ä»¥ä½¿ç”¨ï¼Œä½†é€šå¸¸æ˜¯å‹‡è€…å°ˆç”¨ï¼‰
      else if (skill.magicRatio && skill.magicRatio > 0) {
        const magicBonus = Math.floor(magic * skill.magicRatio);
        baseDamage = attack + magicBonus;
      } else if (skill.attackMultiplier && skill.attackMultiplier > 0) {
        // è“„åŠ›æ–¬ï¼šæ”»æ“ŠåŠ› Ã— å€ç‡
        baseDamage = Math.round(attack * skill.attackMultiplier);
      } else {
        // æ™®é€šåŠæŠ€ï¼šæ”»æ“ŠåŠ› + åŠ æ¬Šå€¼
        baseDamage = attack + skillPower;
      }
    } else {
      attack = attacker.attributes.attack;
      magic = attacker.attributes.magic || 0;
      
      // æª¢æŸ¥æ˜¯å¦æœ‰æ”»æ“ŠåŠ›æ¸›å°‘debuffï¼ˆè…æ“Šï¼‰
      const battle = state.ui.battle;
      if (battle && battle.enemyDebuffs) {
        const enemyIndex = battle.enemies.indexOf(attacker);
        if (enemyIndex >= 0 && battle.enemyDebuffs[enemyIndex] && battle.enemyDebuffs[enemyIndex].attackDown) {
          const attackDown = battle.enemyDebuffs[enemyIndex].attackDown;
          // æ‡‰ç”¨æ”»æ“ŠåŠ›æ¸›å°‘æ•ˆæœï¼šæ¸›å°‘1/3æ”»æ“ŠåŠ›
          attack = Math.max(0, Math.floor(attack * (1 - attackDown.ratio)));
        }
      }
      
      // è™•ç†å‹‡è€…æ–¬æŠ€èƒ½ï¼ˆæ•µäººä¹Ÿå¯ä»¥ä½¿ç”¨ï¼Œä½†é€šå¸¸æ˜¯å‹‡è€…å°ˆç”¨ï¼‰
      if (skill.magicRatio && skill.magicRatio > 0) {
        const magicBonus = Math.floor(magic * skill.magicRatio);
        baseDamage = attack + magicBonus;
      } else {
        // æ™®é€šåŠæŠ€ï¼šæ”»æ“ŠåŠ› + åŠ æ¬Šå€¼
        baseDamage = attack + skillPower;
      }
    }
    
    // è¨ˆç®—ç›®æ¨™çš„é˜²ç¦¦å€¼
    const isTargetHero = target === state.hero;
    const activeCompanion = getActiveCompanion();
    const isTargetCompanion = activeCompanion && target === activeCompanion;
    
    let initialDefense = 0; // è¨˜éŒ„åˆå§‹é˜²ç¦¦å€¼ï¼ˆç”¨æ–¼åŠç¥é™è‡¨æ—¥èªŒï¼‰
    if (isTargetHero) {
      const targetAttrs = getHeroTotalAttributes(target);
      initialDefense = targetAttrs.defense + getEquipmentDefense(target);
      defense = initialDefense;
    } else if (isTargetCompanion) {
      const targetAttrs = getCompanionTotalAttributes(target);
      initialDefense = targetAttrs.defense;
      defense = initialDefense;
    } else {
      // æ•µäººç›®æ¨™
      initialDefense = target.attributes ? target.attributes.defense : (target.defense || 0);
      defense = initialDefense;
    }
    
    // æª¢æŸ¥æ˜¯å¦æœ‰ç ´ç”²ä¹‹åˆƒbuffï¼šç„¡è¦–é˜²ç¦¦ï¼ˆåƒ…å°æ•µäººç›®æ¨™æœ‰æ•ˆï¼‰
    const battle = state.ui.battle;
    let hasIgnoreDefense = false;
    if (battle && !isTargetHero && !isTargetCompanion) {
      if (isHero && battle.heroBuffs && battle.heroBuffs.ignoreDefense) {
        defense = 0; // ç„¡è¦–é˜²ç¦¦
        hasIgnoreDefense = true;
      } else if (isCompanion) {
        const companionIndex = state.companions.indexOf(attacker);
        if (companionIndex >= 0 && battle.companionBuffs && battle.companionBuffs[companionIndex] && battle.companionBuffs[companionIndex].ignoreDefense) {
          defense = 0; // ç„¡è¦–é˜²ç¦¦
          hasIgnoreDefense = true;
        }
      }
    }
    
    // æª¢æŸ¥ç›®æ¨™æ˜¯å¦æœ‰é˜²å®ˆå€¼æ¸›å°‘debuffï¼ˆé…¸æ€§ç®­ï¼‰
    // å¦‚æœå·²ç¶“æœ‰ç ´ç”²ä¹‹åˆƒï¼Œè·³édefenseDownçš„è¨ˆç®—ï¼ˆå› ç‚ºé˜²ç¦¦å·²ç¶“æ˜¯0ï¼‰
    if (battle && !hasIgnoreDefense) {
      // æª¢æŸ¥æ•µäººdebuffï¼ˆå‹æ–¹å°æ•µäººæ–½åŠ çš„ï¼‰
      if (battle.enemyDebuffs) {
        const enemyIndex = battle.enemies.indexOf(target);
        if (enemyIndex >= 0 && battle.enemyDebuffs[enemyIndex] && battle.enemyDebuffs[enemyIndex].defenseDown) {
          const defenseDown = battle.enemyDebuffs[enemyIndex].defenseDown;
          // æ‡‰ç”¨é˜²å®ˆå€¼æ¸›å°‘æ•ˆæœï¼šæ¸›å°‘1/3é˜²å®ˆå€¼
          defense = Math.max(0, Math.floor(defense * (1 - defenseDown.ratio)));
        }
      }
      
      // æª¢æŸ¥å‹æ–¹debuffï¼ˆæ•µäººå°å‹æ–¹æ–½åŠ çš„ï¼‰
      if (battle.friendlyDebuffs) {
        if (isTargetHero && battle.friendlyDebuffs.hero && battle.friendlyDebuffs.hero.defenseDown) {
          const defenseDown = battle.friendlyDebuffs.hero.defenseDown;
          defense = Math.max(0, Math.floor(defense * (1 - defenseDown.ratio)));
        } else if (isTargetCompanion && battle.friendlyDebuffs.companions) {
          const companionIndex = state.companions.indexOf(target);
          if (companionIndex >= 0 && battle.friendlyDebuffs.companions[companionIndex] && battle.friendlyDebuffs.companions[companionIndex].defenseDown) {
            const defenseDown = battle.friendlyDebuffs.companions[companionIndex].defenseDown;
            defense = Math.max(0, Math.floor(defense * (1 - defenseDown.ratio)));
          }
        }
      }
    }
    
    // åŠç¥é™è‡¨ï¼šè¼¸å‡ºé˜²å®ˆå€¼æ—¥èªŒ
    if (skill.dynamicMpCost && skill.dynamicMpCost === true && skill.weaponmasterPath === 'sword_god') {
      console.log(`[åŠç¥é™è‡¨] åˆå§‹é˜²å®ˆå€¼: ${initialDefense}, æœ€çµ‚é˜²å®ˆå€¼: ${defense}${hasIgnoreDefense ? ' (ç ´ç”²ä¹‹åˆƒç„¡è¦–é˜²ç¦¦)' : ''}`);
    }
  } else if (skill.flow === 'agility') {
    // æ•æ·æŠ€å‚·å®³ï¼šæª¢æŸ¥æ˜¯å¦æœ‰agilityBonus
    // å¦‚æœæœ‰agilityBonusï¼Œä½¿ç”¨æ”»æ“ŠåŠ›Ã—50% + æ•æ·Ã—agilityBonus
    // å¦å‰‡ä½¿ç”¨æ”»æ“ŠåŠ› + åŠ æ¬Šå€¼ + æ•æ·ä¿®æ­£
    let attack = 0;
    let agility = 0;
    let baseAttack = 0; // åŸºç¤æ”»æ“ŠåŠ›ï¼ˆç”¨æ–¼æš—å½±çªè¥²ï¼‰
    if (isHero) {
      const totalAttrs = getHeroTotalAttributes(attacker);
      baseAttack = totalAttrs.attack; // åŸºç¤æ”»æ“ŠåŠ›ï¼ˆä¸åŒ…å«è£å‚™å’Œè¢«å‹•æŠ€èƒ½ï¼‰
      attack = totalAttrs.attack;
      attack += getEquipmentAttack(attacker);
      agility = totalAttrs.agility;
      
      // æ‡‰ç”¨åŠå£«å‹è¢«å‹•æŠ€èƒ½ï¼šé¡å¤–æå‡æ”»æ“ŠåŠ›
      const passiveEffects = getSwordPassiveEffects(attacker);
      if (passiveEffects.attackBoost > 0) {
        attack = Math.round(attack * (1 + passiveEffects.attackBoost));
      }
    } else if (isCompanion) {
      const totalAttrs = getCompanionTotalAttributes(attacker);
      baseAttack = totalAttrs.attack; // åŸºç¤æ”»æ“ŠåŠ›
      attack = totalAttrs.attack;
      agility = totalAttrs.agility;
    } else {
      baseAttack = attacker.attributes.attack || 0; // åŸºç¤æ”»æ“ŠåŠ›
      attack = attacker.attributes.attack;
      agility = attacker.attributes.agility || 0;
    }
    
    // è™•ç†åˆºå®¢ä¹‹è·¯ï¼šæš—å½±çªè¥² - æ”»æ“ŠåŠ›=æ•æ·Ã—100% + æ”»æ“ŠÃ—50%ï¼ˆä½¿ç”¨åŸºç¤æ”»æ“ŠåŠ›ï¼‰
    if (skill.weaponmasterPath === 'assassin' && skill.agilityRatio && skill.attackRatio) {
      const agilityDamage = Math.floor(agility * skill.agilityRatio);
      const attackDamage = Math.floor(baseAttack * skill.attackRatio);
      baseDamage = agilityDamage + attackDamage;
    }
    // å¦‚æœæœ‰agilityBonusï¼Œä½¿ç”¨æ”»æ“ŠåŠ›Ã—50% + æ•æ·Ã—agilityBonus
    else if (skill.agilityBonus !== undefined && skill.agilityBonus > 0) {
      const agilityBonus = skill.agilityBonus || 0;
      baseDamage = Math.round(attack * 0.5) + Math.round(agility * agilityBonus);
    } else {
    // æ”»æ“ŠåŠ› + åŠ æ¬Šå€¼
    baseDamage = attack + skillPower;
    
    // å¦‚æœæœ‰æ•æ·ä¿®æ­£ï¼ˆagilityBonusï¼‰ï¼ŒåŠ ä¸Šæ•æ·ä¿®æ­£å€¼
    // agilityBonus è¡¨ç¤ºæ•æ·çš„ç™¾åˆ†æ¯”åŠ æˆï¼ˆå¦‚ 0.2 è¡¨ç¤ºæ•æ·çš„20%ï¼‰
    if (skill.agilityBonus) {
      const agilityBonus = Math.floor(agility * skill.agilityBonus);
      baseDamage += agilityBonus;
      }
    }
    
    // è¨ˆç®—ç›®æ¨™çš„é˜²ç¦¦å€¼
    const isTargetHero = target === state.hero;
    const activeCompanion = getActiveCompanion();
    const isTargetCompanion = activeCompanion && target === activeCompanion;
    
    if (isTargetHero) {
      const targetAttrs = getHeroTotalAttributes(target);
      defense = targetAttrs.defense + getEquipmentDefense(target);
    } else if (isTargetCompanion) {
      const targetAttrs = getCompanionTotalAttributes(target);
      defense = targetAttrs.defense;
    } else {
      // æ•µäººç›®æ¨™
    defense = target.attributes ? target.attributes.defense : (target.defense || 0);
    }
    
    // æª¢æŸ¥æ˜¯å¦æœ‰ç ´ç”²ä¹‹åˆƒbuffï¼šç„¡è¦–é˜²ç¦¦ï¼ˆåƒ…å°æ•µäººç›®æ¨™æœ‰æ•ˆï¼‰
    const battle = state.ui.battle;
    let hasIgnoreDefense = false;
    if (battle && !isTargetHero && !isTargetCompanion) {
      if (isHero && battle.heroBuffs && battle.heroBuffs.ignoreDefense) {
        defense = 0; // ç„¡è¦–é˜²ç¦¦
        hasIgnoreDefense = true;
      } else if (isCompanion) {
        const companionIndex = state.companions.indexOf(attacker);
        if (companionIndex >= 0 && battle.companionBuffs && battle.companionBuffs[companionIndex] && battle.companionBuffs[companionIndex].ignoreDefense) {
          defense = 0; // ç„¡è¦–é˜²ç¦¦
          hasIgnoreDefense = true;
        }
      }
    }
    
    // æª¢æŸ¥ç›®æ¨™æ˜¯å¦æœ‰é˜²å®ˆå€¼æ¸›å°‘debuffï¼ˆé…¸æ€§ç®­ï¼‰
    // å¦‚æœå·²ç¶“æœ‰ç ´ç”²ä¹‹åˆƒï¼Œè·³édefenseDownçš„è¨ˆç®—ï¼ˆå› ç‚ºé˜²ç¦¦å·²ç¶“æ˜¯0ï¼‰
    if (battle && !hasIgnoreDefense) {
      // æª¢æŸ¥æ•µäººdebuffï¼ˆå‹æ–¹å°æ•µäººæ–½åŠ çš„ï¼‰
      if (battle.enemyDebuffs) {
        const enemyIndex = battle.enemies.indexOf(target);
        if (enemyIndex >= 0 && battle.enemyDebuffs[enemyIndex] && battle.enemyDebuffs[enemyIndex].defenseDown) {
          const defenseDown = battle.enemyDebuffs[enemyIndex].defenseDown;
          // æ‡‰ç”¨é˜²å®ˆå€¼æ¸›å°‘æ•ˆæœï¼šæ¸›å°‘1/3é˜²å®ˆå€¼
          defense = Math.max(0, Math.floor(defense * (1 - defenseDown.ratio)));
        }
      }
      
      // æª¢æŸ¥å‹æ–¹debuffï¼ˆæ•µäººå°å‹æ–¹æ–½åŠ çš„ï¼‰
      if (battle.friendlyDebuffs) {
        if (isTargetHero && battle.friendlyDebuffs.hero && battle.friendlyDebuffs.hero.defenseDown) {
          const defenseDown = battle.friendlyDebuffs.hero.defenseDown;
          defense = Math.max(0, Math.floor(defense * (1 - defenseDown.ratio)));
        } else if (isTargetCompanion && battle.friendlyDebuffs.companions) {
          const companionIndex = state.companions.indexOf(target);
          if (companionIndex >= 0 && battle.friendlyDebuffs.companions[companionIndex] && battle.friendlyDebuffs.companions[companionIndex].defenseDown) {
            const defenseDown = battle.friendlyDebuffs.companions[companionIndex].defenseDown;
            defense = Math.max(0, Math.floor(defense * (1 - defenseDown.ratio)));
          }
        }
      }
    }
  } else if (skill.flow === 'hero') {
    // é–ƒé›»æ–¬æŠ€èƒ½ï¼š(æ”»æ“Š+é­”åŠ›+é˜²å®ˆ+é«”åŠ›+æ¢å¾©+æ•æ·) Ã— æ¯”ä¾‹
    if (skill.allAttributesRatio && skill.allAttributesRatio > 0) {
      if (isHero) {
        const totalAttrs = getHeroTotalAttributes(attacker);
        const allAttributesSum = totalAttrs.attack + totalAttrs.magic + totalAttrs.defense + 
                                  totalAttrs.vitality + totalAttrs.recovery + totalAttrs.agility;
        // åŠ ä¸Šè£å‚™çš„æ”»æ“ŠåŠ›å’Œé˜²ç¦¦åŠ›
        const equipmentAttack = getEquipmentAttack(attacker);
        const equipmentDefense = getEquipmentDefense(attacker);
        const totalSum = allAttributesSum + equipmentAttack + equipmentDefense;
        baseDamage = Math.floor(totalSum * skill.allAttributesRatio);
      } else if (isCompanion) {
        const totalAttrs = getCompanionTotalAttributes(attacker);
        const allAttributesSum = totalAttrs.attack + totalAttrs.magic + totalAttrs.defense + 
                                  totalAttrs.vitality + totalAttrs.recovery + totalAttrs.agility;
        baseDamage = Math.floor(allAttributesSum * skill.allAttributesRatio);
      } else {
        // æ•µäººä½¿ç”¨ï¼ˆé€šå¸¸ä¸æœƒæœ‰ï¼‰
        const attrs = attacker.attributes || {};
        const allAttributesSum = (attrs.attack || 0) + (attrs.magic || 0) + (attrs.defense || 0) + 
                                  (attrs.vitality || 0) + (attrs.recovery || 0) + (attrs.agility || 0);
        baseDamage = Math.floor(allAttributesSum * skill.allAttributesRatio);
      }
    } else {
      // èˆŠç‰ˆå‹‡è€…æ–¬æŠ€èƒ½ï¼ˆå…¼å®¹æ€§ï¼‰ï¼šæ”»æ“ŠåŠ› + é­”åŠ› Ã— æ¯”ä¾‹
    let attack = 0;
    let magic = 0;
    
    if (isHero) {
      const totalAttrs = getHeroTotalAttributes(attacker);
      attack = totalAttrs.attack;
      attack += getEquipmentAttack(attacker);
      magic = totalAttrs.magic;
      
      // æ‡‰ç”¨åŠå£«å‹è¢«å‹•æŠ€èƒ½ï¼šé¡å¤–æå‡æ”»æ“ŠåŠ›
      const passiveEffects = getSwordPassiveEffects(attacker);
      if (passiveEffects.attackBoost > 0) {
        attack = Math.round(attack * (1 + passiveEffects.attackBoost));
      }
    } else if (isCompanion) {
      const totalAttrs = getCompanionTotalAttributes(attacker);
      attack = totalAttrs.attack;
      magic = totalAttrs.magic;
    } else {
      attack = attacker.attributes.attack;
      magic = attacker.attributes.magic || 0;
      
      // æª¢æŸ¥æ˜¯å¦æœ‰æ”»æ“ŠåŠ›æ¸›å°‘debuffï¼ˆè…æ“Šï¼‰
      const battle = state.ui.battle;
      if (battle && battle.enemyDebuffs) {
        const enemyIndex = battle.enemies.indexOf(attacker);
        if (enemyIndex >= 0 && battle.enemyDebuffs[enemyIndex] && battle.enemyDebuffs[enemyIndex].attackDown) {
          const attackDown = battle.enemyDebuffs[enemyIndex].attackDown;
          // æ‡‰ç”¨æ”»æ“ŠåŠ›æ¸›å°‘æ•ˆæœï¼šæ¸›å°‘1/3æ”»æ“ŠåŠ›
          attack = Math.max(0, Math.floor(attack * (1 - attackDown.ratio)));
        }
      }
    }
    
    // æ”»æ“ŠåŠ› + é­”åŠ› Ã— æ¯”ä¾‹
    if (skill.magicRatio && skill.magicRatio > 0) {
      const magicBonus = Math.floor(magic * skill.magicRatio);
      baseDamage = attack + magicBonus;
    } else {
      // å¦‚æœæ²’æœ‰ magicRatioï¼Œä½¿ç”¨æ”»æ“ŠåŠ› + åŠ æ¬Šå€¼
      baseDamage = attack + skillPower;
      }
    }
    
    // è¨ˆç®—ç›®æ¨™çš„é˜²ç¦¦å€¼
    const isTargetHero = target === state.hero;
    const activeCompanion = getActiveCompanion();
    const isTargetCompanion = activeCompanion && target === activeCompanion;
    
    if (isTargetHero) {
      const targetAttrs = getHeroTotalAttributes(target);
      defense = targetAttrs.defense + getEquipmentDefense(target);
    } else if (isTargetCompanion) {
      const targetAttrs = getCompanionTotalAttributes(target);
      defense = targetAttrs.defense;
    } else {
      // æ•µäººç›®æ¨™
    defense = target.attributes ? target.attributes.defense : (target.defense || 0);
    }
    
    // æª¢æŸ¥æ˜¯å¦æœ‰ç ´ç”²ä¹‹åˆƒbuffï¼šç„¡è¦–é˜²ç¦¦ï¼ˆåƒ…å°æ•µäººç›®æ¨™æœ‰æ•ˆï¼‰
    const battle = state.ui.battle;
    let hasIgnoreDefense = false;
    if (battle && !isTargetHero && !isTargetCompanion) {
      if (isHero && battle.heroBuffs && battle.heroBuffs.ignoreDefense) {
        defense = 0; // ç„¡è¦–é˜²ç¦¦
        hasIgnoreDefense = true;
      } else if (isCompanion) {
        const companionIndex = state.companions.indexOf(attacker);
        if (companionIndex >= 0 && battle.companionBuffs && battle.companionBuffs[companionIndex] && battle.companionBuffs[companionIndex].ignoreDefense) {
          defense = 0; // ç„¡è¦–é˜²ç¦¦
          hasIgnoreDefense = true;
        }
      }
    }
    
    // æª¢æŸ¥ç›®æ¨™æ˜¯å¦æœ‰é˜²å®ˆå€¼æ¸›å°‘debuffï¼ˆé…¸æ€§ç®­ï¼‰
    // å¦‚æœå·²ç¶“æœ‰ç ´ç”²ä¹‹åˆƒï¼Œè·³édefenseDownçš„è¨ˆç®—ï¼ˆå› ç‚ºé˜²ç¦¦å·²ç¶“æ˜¯0ï¼‰
    if (battle && !hasIgnoreDefense) {
      // æª¢æŸ¥æ•µäººdebuffï¼ˆå‹æ–¹å°æ•µäººæ–½åŠ çš„ï¼‰
      if (battle.enemyDebuffs) {
        const enemyIndex = battle.enemies.indexOf(target);
        if (enemyIndex >= 0 && battle.enemyDebuffs[enemyIndex] && battle.enemyDebuffs[enemyIndex].defenseDown) {
          const defenseDown = battle.enemyDebuffs[enemyIndex].defenseDown;
          // æ‡‰ç”¨é˜²å®ˆå€¼æ¸›å°‘æ•ˆæœï¼šæ¸›å°‘1/3é˜²å®ˆå€¼
          defense = Math.max(0, Math.floor(defense * (1 - defenseDown.ratio)));
        }
      }
      
      // æª¢æŸ¥å‹æ–¹debuffï¼ˆæ•µäººå°å‹æ–¹æ–½åŠ çš„ï¼‰
      if (battle.friendlyDebuffs) {
        if (isTargetHero && battle.friendlyDebuffs.hero && battle.friendlyDebuffs.hero.defenseDown) {
          const defenseDown = battle.friendlyDebuffs.hero.defenseDown;
          defense = Math.max(0, Math.floor(defense * (1 - defenseDown.ratio)));
        } else if (isTargetCompanion && battle.friendlyDebuffs.companions) {
          const companionIndex = state.companions.indexOf(target);
          if (companionIndex >= 0 && battle.friendlyDebuffs.companions[companionIndex] && battle.friendlyDebuffs.companions[companionIndex].defenseDown) {
            const defenseDown = battle.friendlyDebuffs.companions[companionIndex].defenseDown;
            defense = Math.max(0, Math.floor(defense * (1 - defenseDown.ratio)));
          }
        }
      }
    }
  } else {
    // å…¶ä»–é¡å‹ï¼ˆåŒ…æ‹¬defender flowï¼Œå¦‚æ¨èº«æ–¬ã€è‡³è–æ–¬ï¼‰
    if (isHero) {
      const totalAttrs = getHeroTotalAttributes(attacker);
      let attack = totalAttrs.attack || 0;
      attack += getEquipmentAttack(attacker);
      
      // æ‡‰ç”¨åŠå£«å‹è¢«å‹•æŠ€èƒ½ï¼šé¡å¤–æå‡æ”»æ“ŠåŠ›
      const passiveEffects = getSwordPassiveEffects(attacker);
      if (passiveEffects.attackBoost > 0) {
        attack = Math.round(attack * (1 + passiveEffects.attackBoost));
      }
      
      // è™•ç†è‡³è–æ–¬æŠ€èƒ½ï¼šé«”åŠ›Ã—80% + æ²»ç™‚èƒ½åŠ›Ã—80%
      if (skill.id === 'paladin_divine_slash_1' && skill.vitalityRatio && skill.recoveryRatio) {
        const vitality = totalAttrs.vitality || 0;
        const recovery = totalAttrs.recovery || 0;
        const vitalityDamage = Math.floor(vitality * skill.vitalityRatio);
        const recoveryDamage = Math.floor(recovery * skill.recoveryRatio);
        baseDamage = vitalityDamage + recoveryDamage;
      }
      // è™•ç†é˜²å®ˆè¡æ“ŠæŠ€èƒ½ï¼šå‚·å®³ = æ”»æ“ŠåŠ›Ã—50% + defenseBoostPercent Ã— é˜²ç¦¦åŠ›
      else if (skill.defenseBoostPercent && skill.defenseBoostPercent > 0) {
        const defense = totalAttrs.defense;
        const attackPortion = Math.round(attack * 0.5); // æ”»æ“Šçš„50%
        const defensePortion = Math.floor(defense * skill.defenseBoostPercent); // é˜²å®ˆåŠ›çš„ç™¾åˆ†æ¯”
        baseDamage = attackPortion + defensePortion;
      } else {
        // è™•ç†æ¨èº«æ–¬æŠ€èƒ½ï¼šå‚·å®³ = æ”»æ“ŠåŠ›Ã—50% + æ¶ˆè€—HP Ã— å€æ•°
      // æ³¨æ„ï¼šæ¨èº«æ–¬çš„è¨ˆç®—è¦åœ¨é˜²å®ˆè¡æ“Šä¹‹å¾Œï¼Œç¢ºä¿æ˜¯æœ€çµ‚çš„æ”»æ“ŠåŠ›
      if (skill.attackBoostMultiplier && skill.attackBoostMultiplier > 0 && skill.hpCostPercent) {
        const battle = state.ui.battle;
        const hpCostAmount = battle && battle.tempHpCost ? battle.tempHpCost : 0;
        if (hpCostAmount > 0) {
            // æ¨èº«æ–¬ï¼šæ”»æ“ŠåŠ›Ã—50% + æ¶ˆè€—HP Ã— å€æ•°
            const attackPortion = Math.round(attack * 0.5);
            baseDamage = attackPortion + (hpCostAmount * skill.attackBoostMultiplier);
        } else {
      baseDamage = attack + skillPower;
        }
      } else {
      baseDamage = attack + skillPower;
        }
      }
    } else if (isCompanion) {
      const totalAttrs = getCompanionTotalAttributes(attacker);
      let attack = totalAttrs.attack || 0;
      
      // æ‡‰ç”¨åŠå£«å‹è¢«å‹•æŠ€èƒ½ï¼šé¡å¤–æå‡æ”»æ“ŠåŠ›ï¼ˆåŒä¼´ä¹Ÿå¯ä»¥æœ‰åŠå£«å‹è¢«å‹•æŠ€èƒ½ï¼‰
      const passiveEffects = getSwordPassiveEffects(attacker);
      if (passiveEffects.attackBoost > 0) {
        attack = Math.round(attack * (1 + passiveEffects.attackBoost));
      }
      
      // è™•ç†é˜²å®ˆè¡æ“ŠæŠ€èƒ½ï¼šå‚·å®³ = æ”»æ“ŠåŠ›Ã—50% + defenseBoostPercent Ã— é˜²ç¦¦åŠ›
      if (skill.defenseBoostPercent && skill.defenseBoostPercent > 0) {
        const defense = totalAttrs.defense;
        const attackPortion = Math.round(attack * 0.5); // æ”»æ“Šçš„50%
        const defensePortion = Math.floor(defense * skill.defenseBoostPercent); // é˜²å®ˆåŠ›çš„ç™¾åˆ†æ¯”
        baseDamage = attackPortion + defensePortion;
      } else {
        // è™•ç†æ¨èº«æ–¬æŠ€èƒ½ï¼šå‚·å®³ = æ”»æ“ŠåŠ›Ã—50% + æ¶ˆè€—HP Ã— å€æ•°
      if (skill.attackBoostMultiplier && skill.attackBoostMultiplier > 0 && skill.hpCostPercent) {
        const battle = state.ui.battle;
        const hpCostAmount = battle && battle.tempHpCost ? battle.tempHpCost : 0;
        if (hpCostAmount > 0) {
            // æ¨èº«æ–¬ï¼šæ”»æ“ŠåŠ›Ã—50% + æ¶ˆè€—HP Ã— å€æ•°
            const attackPortion = Math.round(attack * 0.5);
            baseDamage = attackPortion + (hpCostAmount * skill.attackBoostMultiplier);
        } else {
      baseDamage = attack + skillPower;
        }
      } else {
        baseDamage = attack + skillPower;
        }
      }
    } else {
      // æ•µäºº
      let attack = attacker.attributes.attack || 0;
      
      // æª¢æŸ¥æ˜¯å¦æœ‰æ”»æ“ŠåŠ›æ¸›å°‘debuffï¼ˆè…æ“Šï¼‰
      const battle = state.ui.battle;
      if (battle && battle.enemyDebuffs) {
        const enemyIndex = battle.enemies.indexOf(attacker);
        if (enemyIndex >= 0 && battle.enemyDebuffs[enemyIndex] && battle.enemyDebuffs[enemyIndex].attackDown) {
          const attackDown = battle.enemyDebuffs[enemyIndex].attackDown;
          // æ‡‰ç”¨æ”»æ“ŠåŠ›æ¸›å°‘æ•ˆæœï¼šæ¸›å°‘1/3æ”»æ“ŠåŠ›
          attack = Math.max(0, Math.floor(attack * (1 - attackDown.ratio)));
        }
      }
      
      baseDamage = attack + skillPower;
    }
    // è¨ˆç®—ç›®æ¨™çš„é˜²ç¦¦å€¼
    const isTargetHero = target === state.hero;
    const activeCompanion = getActiveCompanion();
    const isTargetCompanion = activeCompanion && target === activeCompanion;
    
    if (isTargetHero) {
      const targetAttrs = getHeroTotalAttributes(target);
      defense = targetAttrs.defense + getEquipmentDefense(target);
    } else if (isTargetCompanion) {
      const targetAttrs = getCompanionTotalAttributes(target);
      defense = targetAttrs.defense;
    } else {
      // æ•µäººç›®æ¨™
    defense = target.attributes ? target.attributes.defense : (target.defense || 0);
    }
    
    // æª¢æŸ¥ç›®æ¨™æ˜¯å¦æœ‰é˜²å®ˆå€¼æ¸›å°‘debuffï¼ˆé…¸æ€§ç®­ï¼‰
    const battle = state.ui.battle;
    if (battle) {
      // æª¢æŸ¥æ•µäººdebuffï¼ˆå‹æ–¹å°æ•µäººæ–½åŠ çš„ï¼‰
      if (battle.enemyDebuffs) {
        const enemyIndex = battle.enemies.indexOf(target);
        if (enemyIndex >= 0 && battle.enemyDebuffs[enemyIndex] && battle.enemyDebuffs[enemyIndex].defenseDown) {
          const defenseDown = battle.enemyDebuffs[enemyIndex].defenseDown;
          // æ‡‰ç”¨é˜²å®ˆå€¼æ¸›å°‘æ•ˆæœï¼šæ¸›å°‘1/3é˜²å®ˆå€¼
          defense = Math.max(0, Math.floor(defense * (1 - defenseDown.ratio)));
        }
      }
      
      // æª¢æŸ¥å‹æ–¹debuffï¼ˆæ•µäººå°å‹æ–¹æ–½åŠ çš„ï¼‰
      if (battle.friendlyDebuffs) {
        if (isTargetHero && battle.friendlyDebuffs.hero && battle.friendlyDebuffs.hero.defenseDown) {
          const defenseDown = battle.friendlyDebuffs.hero.defenseDown;
          defense = Math.max(0, Math.floor(defense * (1 - defenseDown.ratio)));
        } else if (isTargetCompanion && battle.friendlyDebuffs.companions) {
          const companionIndex = state.companions.indexOf(target);
          if (companionIndex >= 0 && battle.friendlyDebuffs.companions[companionIndex] && battle.friendlyDebuffs.companions[companionIndex].defenseDown) {
            const defenseDown = battle.friendlyDebuffs.companions[companionIndex].defenseDown;
            defense = Math.max(0, Math.floor(defense * (1 - defenseDown.ratio)));
          }
        }
      }
    }
  }
  
  // å°æ–¼é­”æ³•æŠ€èƒ½ï¼Œä½¿ç”¨å›å¾©åŠ›å’Œé­”åŠ›çš„æ¸›å‚·
  let damage;
  if (skill.flow === 'magic') {
    // é­”æ³•å‚·å®³æœƒè¢«æ¸›å‚·ï¼š(å›å¾©åŠ›+é­”åŠ›) / 10
    // åˆ¤æ–·ç›®æ¨™æ˜¯è‹±é›„ã€åŒä¼´é‚„æ˜¯æ•µäºº
    const isTargetHero = target === state.hero;
    const activeCompanion = getActiveCompanion();
    const isTargetCompanion = activeCompanion && target === activeCompanion;
    
    let targetRecovery = 0;
    let targetMagic = 0;
    
    if (isTargetHero) {
      const targetAttrs = getHeroTotalAttributes(target);
      targetRecovery = targetAttrs.recovery || 0;
      targetMagic = targetAttrs.magic || 0;
    } else if (isTargetCompanion) {
      const targetAttrs = getCompanionTotalAttributes(target);
      targetRecovery = targetAttrs.recovery || 0;
      targetMagic = targetAttrs.magic || 0;
    } else {
      // æ•µäºº
      targetRecovery = target.attributes ? (target.attributes.recovery || 0) : 0;
      targetMagic = target.attributes ? (target.attributes.magic || 0) : 0;
    }
    
    // è¨ˆç®—æ¸›å‚·å€¼ï¼š(å›å¾©åŠ›+é­”åŠ›) / 10
    const magicReduction = Math.floor((targetRecovery + targetMagic) / 10);
    damage = baseDamage - magicReduction;
  } else {
    // å…¶ä»–æŠ€èƒ½é¡å‹éœ€è¦æ¸›å»é˜²ç¦¦
    damage = baseDamage - defense;
  }
  damage = Math.max(1, Math.round(damage));
  
  // åŠç¥é™è‡¨ï¼šè¼¸å‡ºæœ€çµ‚å‚·å®³æ—¥èªŒ
  if (skill.dynamicMpCost && skill.dynamicMpCost === true && skill.weaponmasterPath === 'sword_god') {
    console.log(`[åŠç¥é™è‡¨] åŸºç¤å‚·å®³: ${baseDamage}, é˜²å®ˆå€¼: ${defense}, æœ€çµ‚å‚·å®³: ${damage}`);
  }
  
  // é€£æ“ŠæŠ€èƒ½ç‰¹æ®Šè™•ç†ï¼šæ”»æ“ŠåŠ›Ã—50% + æ•æ·Ã—agilityBonusï¼ˆæ¯ä¸€ä¸‹éƒ½è¦æ¸›å»é˜²å®ˆåŠ›ï¼Œæ¯ä¸€ä¸‹éƒ½ç¨ç«‹åˆ¤æ–·æœƒå¿ƒä¸€æ“Šï¼‰
  const isMultiHit = skill.hitCount && skill.hitCount > 1;
  const hasAgilityBonus = skill.agilityBonus !== undefined && skill.agilityBonus > 0;
  let isCrit = false;
  let critMultiplier = 2; // æ™®é€šæš´æ“Šå€ç‡
  
  if (isMultiHit && hasAgilityBonus) {
    // é€£æ“ŠæŠ€èƒ½ï¼šä½¿ç”¨æ”»æ“ŠåŠ›Ã—50% + æ•æ·Ã—agilityBonus
    // ç²å–æ”»æ“ŠåŠ›å’Œæ•æ·å€¼
    let attack = 0;
    let agility = 0;
    
    if (isHero) {
      const totalAttrs = getHeroTotalAttributes(attacker);
      attack = totalAttrs.attack;
      attack += getEquipmentAttack(attacker); // åŠ ä¸Šè£å‚™æ”»æ“ŠåŠ›
      agility = totalAttrs.agility;
      
      // æ‡‰ç”¨åŠå£«å‹è¢«å‹•æŠ€èƒ½ï¼šé¡å¤–æå‡æ”»æ“ŠåŠ›
      const passiveEffects = getSwordPassiveEffects(attacker);
      if (passiveEffects.attackBoost > 0) {
        attack = Math.round(attack * (1 + passiveEffects.attackBoost));
      }
    } else if (isCompanion) {
      const totalAttrs = getCompanionTotalAttributes(attacker);
      attack = totalAttrs.attack;
      agility = totalAttrs.agility;
    } else {
      // æ•µäºº
      attack = attacker.attributes ? (attacker.attributes.attack || 0) : 0;
      agility = attacker.attributes ? (attacker.attributes.agility || 0) : 0;
    }
    
    // é€£æ“ŠåŸºç¤å‚·å®³ = æ”»æ“ŠåŠ›Ã—50% + æ•æ·Ã—agilityBonus
    const agilityBonus = skill.agilityBonus || 0;
    baseDamage = Math.round(attack * 0.5) + Math.round(agility * agilityBonus);
    
    // æ¯ä¸€ä¸‹éƒ½è¦æ¸›å»é˜²å®ˆåŠ›
  if (skill.flow === 'magic') {
      // é­”æ³•å‚·å®³æœƒè¢«æ¸›å‚·ï¼š(å›å¾©åŠ›+é­”åŠ›) / 10
      // åˆ¤æ–·ç›®æ¨™æ˜¯è‹±é›„ã€åŒä¼´é‚„æ˜¯æ•µäºº
      const isTargetHero = target === state.hero;
      const activeCompanion = getActiveCompanion();
      const isTargetCompanion = activeCompanion && target === activeCompanion;
      
      let targetRecovery = 0;
      let targetMagic = 0;
      
      if (isTargetHero) {
        const targetAttrs = getHeroTotalAttributes(target);
        targetRecovery = targetAttrs.recovery || 0;
        targetMagic = targetAttrs.magic || 0;
      } else if (isTargetCompanion) {
        const targetAttrs = getCompanionTotalAttributes(target);
        targetRecovery = targetAttrs.recovery || 0;
        targetMagic = targetAttrs.magic || 0;
      } else {
        // æ•µäºº
        targetRecovery = target.attributes ? (target.attributes.recovery || 0) : 0;
        targetMagic = target.attributes ? (target.attributes.magic || 0) : 0;
      }
      
      // è¨ˆç®—æ¸›å‚·å€¼ï¼š(å›å¾©åŠ›+é­”åŠ›) / 10
      const magicReduction = Math.floor((targetRecovery + targetMagic) / 10);
      damage = baseDamage - magicReduction;
    } else {
      // å…¶ä»–æŠ€èƒ½é¡å‹éœ€è¦æ¸›å»é˜²ç¦¦ï¼ˆæ¯ä¸€ä¸‹éƒ½è¦æ¸›å»é˜²å®ˆåŠ›ï¼‰
      damage = baseDamage - defense;
    }
    damage = Math.max(1, Math.round(damage));
    
    // æ¯ä¸€ä¸‹éƒ½ç¨ç«‹åˆ¤æ–·æœƒå¿ƒä¸€æ“Š
    if (skill.flow === 'magic') {
      // é­”æ³•æŠ€èƒ½ï¼šå…ˆæª¢æŸ¥æŠ€èƒ½æœ¬èº«çš„ critChanceï¼Œç„¶å¾ŒåŠ ä¸Šè¢«å‹•æŠ€èƒ½çš„é­”æ³•æš´æ“Šç‡
      let magicCritChance = 0;
      
      // å¦‚æœæŠ€èƒ½æœ‰ critChance å±¬æ€§ï¼Œä½¿ç”¨å®ƒ
      if (skill.critChance !== undefined) {
        // å¦‚æœ critChance < 1.0ï¼Œè¡¨ç¤ºæ˜¯å°æ•¸æ ¼å¼ï¼ˆå¦‚ 0.5 = 50%ï¼‰ï¼Œéœ€è¦è½‰æ›ç‚ºç™¾åˆ†æ¯”
        // å¦‚æœ critChance >= 1.0ï¼Œè¡¨ç¤ºæ˜¯ç™¾åˆ†æ¯”æ ¼å¼ï¼ˆå¦‚ 20 = 20%ï¼‰
        if (skill.critChance < 1.0) {
          magicCritChance = skill.critChance * 100;
        } else {
          magicCritChance = skill.critChance;
        }
      }
      
      // åŠ ä¸Šè¢«å‹•æŠ€èƒ½çš„é­”æ³•æš´æ“Šç‡
      const magicEffects = getMagicPassiveEffects(attacker);
      if (magicEffects.magicCritChance > 0) {
        magicCritChance += magicEffects.magicCritChance;
      }
      
      // åˆ¤æ–·æ˜¯å¦è§¸ç™¼é­”æ³•æš´æ“Š
      if (magicCritChance > 0) {
        const magicCritRoll = Math.random() * 100;
        if (magicCritRoll < magicCritChance) {
          isCrit = true;
          critMultiplier = magicEffects.magicCritMultiplier || 1.5; // é­”æ³•æš´æ“Šä½¿ç”¨1.5å€
        }
      }
    } else {
      // éé­”æ³•æŠ€èƒ½ï¼šæ¯ä¸€ä¸‹éƒ½ç¨ç«‹åˆ¤æ–·æœƒå¿ƒä¸€æ“Š
      isCrit = checkCrit(attacker, skill);
    }
  } else {
    // éé€£æ“ŠæŠ€èƒ½æˆ–æ²’æœ‰agilityBonusçš„å¤šæ®µæ”»æ“Šï¼šä½¿ç”¨åŸä¾†çš„é‚è¼¯
    // æª¢æŸ¥æœƒå¿ƒä¸€æ“Š
    if (skill.flow === 'magic') {
      // é­”æ³•æŠ€èƒ½ï¼šå…ˆæª¢æŸ¥æŠ€èƒ½æœ¬èº«çš„ critChanceï¼Œç„¶å¾ŒåŠ ä¸Šè¢«å‹•æŠ€èƒ½çš„é­”æ³•æš´æ“Šç‡
      let magicCritChance = 0;
      
      // å¦‚æœæŠ€èƒ½æœ‰ critChance å±¬æ€§ï¼Œä½¿ç”¨å®ƒ
      if (skill.critChance !== undefined) {
        // å¦‚æœ critChance < 1.0ï¼Œè¡¨ç¤ºæ˜¯å°æ•¸æ ¼å¼ï¼ˆå¦‚ 0.5 = 50%ï¼‰ï¼Œéœ€è¦è½‰æ›ç‚ºç™¾åˆ†æ¯”
        // å¦‚æœ critChance >= 1.0ï¼Œè¡¨ç¤ºæ˜¯ç™¾åˆ†æ¯”æ ¼å¼ï¼ˆå¦‚ 20 = 20%ï¼‰
        if (skill.critChance < 1.0) {
          magicCritChance = skill.critChance * 100;
        } else {
          magicCritChance = skill.critChance;
        }
      }
      
      // åŠ ä¸Šè¢«å‹•æŠ€èƒ½çš„é­”æ³•æš´æ“Šç‡
      const magicEffects = getMagicPassiveEffects(attacker);
      if (magicEffects.magicCritChance > 0) {
        magicCritChance += magicEffects.magicCritChance;
      }
      
      // åˆ¤æ–·æ˜¯å¦è§¸ç™¼é­”æ³•æš´æ“Š
      if (magicCritChance > 0) {
        const magicCritRoll = Math.random() * 100;
        if (magicCritRoll < magicCritChance) {
          isCrit = true;
          critMultiplier = magicEffects.magicCritMultiplier || 1.5; // é­”æ³•æš´æ“Šä½¿ç”¨1.5å€
        }
      }
  } else {
    // éé­”æ³•æŠ€èƒ½ä½¿ç”¨æ™®é€šæœƒå¿ƒä¸€æ“Šè¨ˆç®—
    isCrit = checkCrit(attacker, skill);
    }
  }
  
  if (isCrit) {
    damage = Math.round(damage * critMultiplier); // ä½¿ç”¨ç›¸æ‡‰çš„æš´æ“Šå€ç‡
  }
  
  // è¼¸å‡ºæ”»æ“Šå‚·å®³è¨ˆç®—æ—¥èªŒï¼ˆåƒ…æ”»æ“Šé¡å‹æŠ€èƒ½ï¼Œæ’é™¤æ²»ç™‚å’Œè–æ“Šï¼‰
  if (skill.kind === 'attack' && !isEnhancedHeal) {
    const attackerName = isHero ? 'å‹‡è€…' : (isCompanion ? attacker.name : 'æ•µäºº');
    const targetName = target === state.hero ? 'å‹‡è€…' : (target.name || 'ç›®æ¨™');
    console.log(`[å‚·å®³è¨ˆç®—] ${attackerName} ä½¿ç”¨ã€Œ${skill.name}ã€æ”»æ“Š ${targetName}ï¼šåŸºç¤å‚·å®³=${baseDamage}, é˜²ç¦¦å€¼=${defense}, æœ€çµ‚å‚·å®³=${damage}${isCrit ? ' (æœƒå¿ƒä¸€æ“Š)' : ''}`);
  }
  
  return { damage, isCrit };
}

// é€šç”¨æ²»ç™‚è¨ˆç®—å‡½æ•¸ï¼ˆæ”¯æŒè‹±é›„å’ŒåŒä¼´ï¼‰
function calculateHealingFor(skill, healer) {
  const isHero = healer === state.hero;
  const totalAttrs = isHero 
    ? getHeroTotalAttributes(healer)
    : getCompanionTotalAttributes(healer);
  const recovery = totalAttrs.recovery;
  const baseValue = skill.power || 0; // powerä½œç‚ºå›ºå®šå€¼
  
  // å¦‚æœæŠ€èƒ½æœ‰recoveryRatioå±¬æ€§ï¼Œä½¿ç”¨è©²æ¯”ä¾‹ï¼ˆå¦‚å‹‡è€…ä¹‹è¡€ã€ç¥è–è­·ç›¾ï¼‰
  if (skill.recoveryRatio !== undefined) {
    const base = baseValue + Math.floor(recovery * skill.recoveryRatio);
    let finalBase = Math.ceil(base);
    
    // æ‡‰ç”¨æ¢å¾©å‹è¢«å‹•æŠ€èƒ½ï¼šå¢åŠ æ²»ç™‚æ•ˆæœ
    const recoveryEffects = getRecoveryPassiveEffects(healer);
    if (recoveryEffects.recoveryBoost > 0) {
      finalBase = Math.ceil(finalBase * (1 + recoveryEffects.recoveryBoost));
    }
    
    return finalBase;
  }
  
  // è–æ“Šä½¿ç”¨å›å¾©åŠ›/2ï¼Œå…¶ä»–æ²»ç™‚æŠ€èƒ½ä½¿ç”¨å›å¾©åŠ›/3
  const isEnhancedHeal = skill.id && skill.id.startsWith('enhanced_heal_');
  const recoveryDivisor = isEnhancedHeal ? 2 : 3;
  
  // æ²»ç™‚æ•ˆæœï¼šå›ºå®šå€¼ + å›å¾©åŠ›/divisor
  let base = baseValue + Math.floor(recovery / recoveryDivisor);
  
  // æ‡‰ç”¨æ¢å¾©å‹è¢«å‹•æŠ€èƒ½ï¼šå¢åŠ æ²»ç™‚æ•ˆæœï¼ˆè‹±é›„å’ŒåŒä¼´éƒ½å¯ä»¥æœ‰æ¢å¾©å‹è¢«å‹•æŠ€èƒ½ï¼‰
    const recoveryEffects = getRecoveryPassiveEffects(healer);
    if (recoveryEffects.recoveryBoost > 0) {
      base = Math.ceil(base * (1 + recoveryEffects.recoveryBoost));
  }
  
  return Math.ceil(base);
}

function healHero(amount) {
  state.hero.stats.hp = Math.ceil(Math.min(state.hero.stats.maxHp, state.hero.stats.hp + amount));
}

function applyDamageToEnemy(enemyIndex, damage, template, isBasicAttack = false, skill = null, isCrit = false, attacker = null) {
  const battle = state.ui.battle;
  if (!battle || enemyIndex < 0 || enemyIndex >= battle.enemies.length) return;
  
  const enemy = battle.enemies[enemyIndex];
  const actualAttacker = attacker || state.hero;
  const isHero = actualAttacker === state.hero;
  
  // çµ±ä¸€æ‡‰ç”¨å‚·å®³ï¼ˆåŒ…å«å¾©ä»‡æ„å¿—æ•ˆæœï¼‰
  damage = applyDamageToEnemyUnified(enemy, damage, actualAttacker);
  
  consumeBreakingArmor(actualAttacker, damage, isBasicAttack, skill);

  // Bug fix: åŒä¼´ä¹Ÿå¯ä»¥æœ‰è¢«å‹•æŠ€èƒ½ï¼ˆå¦‚å¸è¡€ã€é€£æ“Šï¼‰
  const passiveEffects = getSwordPassiveEffects(actualAttacker);
  const critMsg = isCrit ? 'ï¼ˆæœƒå¿ƒä¸€æ“Šï¼ï¼‰' : '';
  pushLog(template.replace('%d', damage) + critMsg);
  
  applyLifesteal(actualAttacker, damage, passiveEffects);

  renderBattleDialog();
  
  if (enemy.stats.hp <= 0) {
    pushLog(`${enemy.name} è¢«æ“Šå€’ï¼`);
    // æª¢æŸ¥æ˜¯å¦æ‰€æœ‰æ•µäººéƒ½è¢«æ“Šå€’
    const allDefeated = battle.enemies.every(e => e.stats.hp <= 0);
    if (allDefeated) {
      setTimeout(() => {
        concludeBattle(true);
      }, 800);
      return;
    }
  }
  
  // æ‡‰ç”¨é€£æ“Šè¢«å‹•ï¼šæœ‰æ©Ÿç‡å¤šæ”»æ“Š1æ¬¡ï¼ˆåƒ…åœ¨æ”»æ“Šæˆ–åŠæŠ€å¾Œï¼‰
  if (passiveEffects.doubleAttackChance > 0 && Math.random() < passiveEffects.doubleAttackChance) {
    // æª¢æŸ¥ç›®æ¨™æ˜¯å¦é‚„æ´»è‘—
    if (enemy.stats.hp > 0) {
      // åˆ¤æ–·æ˜¯æ™®é€šæ”»æ“Šé‚„æ˜¯åŠæŠ€
      let doubleDamage = 0;
      let isCrit = false;
      if (isBasicAttack) {
        const result = calculatePhysicalDamage(1, enemy);
        doubleDamage = result.damage;
        isCrit = result.isCrit;
      } else if (skill && skill.flow === 'sword') {
        const result = calculateSkillDamage(skill, actualAttacker, enemy);
        doubleDamage = result.damage;
        isCrit = result.isCrit;
      } else {
        // éåŠæŠ€ä¸è§¸ç™¼é€£æ“Šï¼Œç›´æ¥è¿”å›ï¼ˆå›åˆç”±è¡Œå‹•éšŠåˆ—ç³»çµ±ç®¡ç†ï¼‰
        return;
      }
      
      // çµ±ä¸€æ‡‰ç”¨å‚·å®³ï¼ˆåŒ…å«å¾©ä»‡æ„å¿—æ•ˆæœï¼‰
      doubleDamage = applyDamageToEnemyUnified(enemy, doubleDamage, actualAttacker);
      const critMsg = isCrit ? 'ï¼ˆæœƒå¿ƒä¸€æ“Šï¼ï¼‰' : '';
      pushBattleLog(`å‹‡è€…é€£æ“ŠæŠ€å·§è§¸ç™¼ï¼é¡å¤–é€ æˆ ${doubleDamage} å‚·å®³ï¼${critMsg}`);
      
      applyLifesteal(actualAttacker, doubleDamage, passiveEffects);

      renderBattleDialog();
      
      if (enemy.stats.hp <= 0) {
        pushLog(`${enemy.name} è¢«æ“Šå€’ï¼`);
        const allDefeated = battle.enemies.every(e => e.stats.hp <= 0);
        if (allDefeated) {
          setTimeout(() => {
            concludeBattle(true);
          }, 800);
          return;
        }
      }
    }
  }
  
  // ä¸å†åœ¨é€™è£¡çµæŸå›åˆï¼Œå›åˆç”±è¡Œå‹•éšŠåˆ—ç³»çµ±çµ±ä¸€ç®¡ç†
}

// æ§‹å»ºè¡Œå‹•éšŠåˆ—ï¼ˆæŒ‰æ•æ·æ’åºï¼‰
function buildActionQueue() {
  const battle = state.ui.battle;
  if (!battle) return null;
  
  const hero = state.hero;
  const companion = getActiveCompanion();
  const enemies = battle.enemies.filter(e => e.stats.hp > 0);
  
  const actions = [];
  
  // 1. æ·»åŠ å‹‡è€…è¡Œå‹•ï¼ˆåªæœ‰ç•¶å‹‡è€…æ´»è‘—ä¸”æœ‰è¡Œå‹•æ™‚æ‰æ·»åŠ ï¼‰
  if (hero && hero.stats.hp > 0 && battle.heroAction) {
    actions.push({
      type: 'hero',
      character: hero,
      action: battle.heroAction,
      agility: getCharacterAgility(hero, 'hero'),
    });
  }
  // å¦‚æœå‹‡è€…æ­»äº¡ä½†æ²’æœ‰è¡Œå‹•ï¼ˆéˆé­‚è§€æˆ°ï¼‰ï¼Œä¸æ·»åŠ å‹‡è€…è¡Œå‹•ï¼Œä½†ç¹¼çºŒæ§‹å»ºå…¶ä»–è§’è‰²çš„è¡Œå‹•éšŠåˆ—
  
  // 2. æ·»åŠ æ‰€æœ‰åŒä¼´çš„è¡Œå‹•ï¼ˆAIè‡ªå‹•æ±ºå®šï¼‰
  const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
  activeCompanions.forEach(companion => {
    const companionAction = determineCompanionAction(companion);
    if (companionAction) {
      // ç¢ºä¿æ”»æ“Šé¡å‹çš„è¡Œå‹•æœ‰æœ‰æ•ˆçš„ç›®æ¨™ç´¢å¼•
      if (companionAction.type === 'attack') {
        const targetIndex = companionAction.targetEnemyIndex;
        if (targetIndex === undefined || targetIndex === null || 
            targetIndex < 0 || !battle.enemies[targetIndex] || 
            battle.enemies[targetIndex].stats.hp <= 0) {
          // ç›®æ¨™ç„¡æ•ˆï¼Œé‡æ–°é¸æ“‡
          const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
          if (aliveEnemies.length > 0) {
            companionAction.targetEnemyIndex = battle.enemies.indexOf(aliveEnemies[0]);
          } else {
            // æ²’æœ‰æ´»è‘—çš„æ•µäººï¼Œè·³éé€™æ¬¡è¡Œå‹•
            pushBattleLog(`${companion.name}æº–å‚™æ”»æ“Šï¼Œä½†æ²’æœ‰å¯æ”»æ“Šçš„ç›®æ¨™ã€‚`);
            return; // è·³éé€™å€‹åŒä¼´
          }
        }
      }
      // å¦‚æœæ˜¯å–®é«”æ”»æ“ŠæŠ€èƒ½ï¼Œç¢ºä¿æœ‰æœ‰æ•ˆçš„ç›®æ¨™ç´¢å¼•
      if (companionAction.type === 'skill' && companionAction.targetEnemyIndex !== undefined) {
        const targetIndex = companionAction.targetEnemyIndex;
        if (targetIndex === undefined || targetIndex === null || 
            targetIndex < 0 || !battle.enemies[targetIndex] || 
            battle.enemies[targetIndex].stats.hp <= 0) {
          // ç›®æ¨™ç„¡æ•ˆï¼Œé‡æ–°é¸æ“‡
          const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
          if (aliveEnemies.length > 0) {
            companionAction.targetEnemyIndex = battle.enemies.indexOf(aliveEnemies[0]);
          }
        }
      }
      
      actions.push({
        type: 'companion',
        character: companion,
        action: companionAction,
        agility: getCharacterAgility(companion, 'companion'),
      });
    } else {
      // å¦‚æœæ²’æœ‰æ±ºå®šè¡Œå‹•ï¼ˆç†è«–ä¸Šä¸æ‡‰è©²ç™¼ç”Ÿï¼‰ï¼Œä½¿ç”¨æ™®é€šæ”»æ“Šä½œç‚ºå¾Œå‚™
      const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
      if (aliveEnemies.length > 0) {
        const targetEnemy = aliveEnemies[Math.floor(Math.random() * aliveEnemies.length)];
        actions.push({
          type: 'companion',
          character: companion,
          action: {
            type: 'attack',
            targetEnemyIndex: battle.enemies.indexOf(targetEnemy),
          },
          agility: getCharacterAgility(companion, 'companion'),
        });
      } else {
        // æ²’æœ‰æ´»è‘—çš„æ•µäººï¼Œè¨˜éŒ„ä½†é‚„æ˜¯æ·»åŠ è¡Œå‹•ï¼ˆæˆ°é¬¥æ‡‰è©²å·²ç¶“çµæŸï¼‰
        pushBattleLog(`${companion.name}æº–å‚™è¡Œå‹•ï¼Œä½†æ²’æœ‰å¯æ”»æ“Šçš„ç›®æ¨™ã€‚`);
      }
    }
  });
  
  // 3. æ·»åŠ æ•µäººè¡Œå‹•ï¼ˆAIè‡ªå‹•æ±ºå®šï¼‰
  enemies.forEach((enemy, index) => {
    if (enemy && enemy.stats.hp > 0) {
      // æª¢æŸ¥æ•µäººæ˜¯å¦æœ‰å¤šæ¬¡è¡Œå‹•å±¬æ€§ï¼ˆBosså°ˆç”¨ï¼‰
      const actionsPerTurn = enemy.actionsPerTurn || 1;
      
      // èª¿è©¦ï¼šæª¢æŸ¥Bossçš„actionsPerTurn
      if (enemy.monsterType === 'boss') {
      }
      
      // ç‚ºæ¯å€‹è¡Œå‹•æ¬¡æ•¸æ·»åŠ ä¸€å€‹è¡Œå‹•
      for (let actionCount = 0; actionCount < actionsPerTurn; actionCount++) {
      const enemyAction = determineEnemyAction(enemy, battle);
      if (enemyAction) {
        actions.push({
          type: 'enemy',
          character: enemy,
          enemyIndex: battle.enemies.indexOf(enemy),
          action: enemyAction,
          agility: getCharacterAgility(enemy, 'enemy'),
            // ç‚ºå¤šæ¬¡è¡Œå‹•æ·»åŠ ä¸€å€‹å°çš„éš¨æ©Ÿåç§»ï¼Œç¢ºä¿è¡Œå‹•é †åºç•¥æœ‰ä¸åŒ
            actionNumber: actionCount,
          });
          
          // èª¿è©¦ï¼šè¨˜éŒ„æ·»åŠ çš„è¡Œå‹•
          if (enemy.monsterType === 'boss' && actionsPerTurn > 1) {
          }
        }
      }
    }
  });
  
  // 4. æŒ‰æ•æ·å¾é«˜åˆ°ä½æ’åºï¼ˆç›¸åŒæ•æ·æ™‚ä½¿ç”¨å›ºå®šçš„éšæœºç§å­ä¿è¯ç¨³å®šï¼‰
  // å…ˆä¸ºæ¯ä¸ªè¡ŒåŠ¨æ·»åŠ éšæœºå€¼ç”¨äºç›¸åŒæ•æ·æ—¶çš„æ’åº
  actions.forEach((action, index) => {
    action._sortRandom = Math.random();
  });
  
  actions.sort((a, b) => {
    // é¦–å…ˆæŒ‰æ•æ·æ’åºï¼ˆé«˜åˆ°ä½ï¼‰
    if (b.agility !== a.agility) {
      return b.agility - a.agility;
    }
    // ç›¸åŒæ•æ·æ™‚ï¼Œå¦‚æœæ˜¯åŒä¸€å€‹æ•µäººçš„å¤šæ¬¡è¡Œå‹•ï¼ŒæŒ‰è¡Œå‹•ç·¨è™Ÿæ’åºï¼ˆå…ˆåŸ·è¡Œç¬¬ä¸€æ¬¡è¡Œå‹•ï¼‰
    if (a.type === 'enemy' && b.type === 'enemy' && 
        a.enemyIndex === b.enemyIndex && 
        a.actionNumber !== undefined && b.actionNumber !== undefined) {
      return a.actionNumber - b.actionNumber;
    }
    // ç›¸åŒæ•æ·æ™‚ä½¿ç”¨é å…ˆç”Ÿæˆçš„éš¨æ©Ÿå€¼æ’åº
    return b._sortRandom - a._sortRandom;
  });
  
  // æ¸…ç†è‡¨æ™‚æ’åºå€¼
  actions.forEach(action => {
    delete action._sortRandom;
  });
  
  return actions;
}

// æª¢æŸ¥æ˜¯å¦æ‰€æœ‰è§’è‰²ï¼ˆå‹‡è€…+åŒä¼´ï¼‰éƒ½æ­»äº¡
function areAllCharactersDead() {
  const hero = state.hero;
  const companions = state.companions || [];
  
  // æª¢æŸ¥å‹‡è€…æ˜¯å¦æ­»äº¡
  if (hero && hero.stats && hero.stats.hp > 0) {
    return false; // å‹‡è€…é‚„æ´»è‘—
  }
  
  // æª¢æŸ¥æ˜¯å¦æœ‰ä»»ä½•åŒä¼´é‚„æ´»è‘—
  const aliveCompanions = companions.filter(c => c && c.stats && c.stats.hp > 0);
  if (aliveCompanions.length > 0) {
    return false; // æœ‰åŒä¼´é‚„æ´»è‘—
  }
  
  // æ‰€æœ‰è§’è‰²éƒ½æ­»äº¡
  return true;
}

// åŸ·è¡Œè¡Œå‹•éšŠåˆ—
function executeActionQueue() {
  const battle = state.ui.battle;
  if (!battle) return;
  
  // å¦‚æœæ­£åœ¨åŸ·è¡Œï¼Œç›´æ¥è¿”å›
  if (battle.isExecutingActions) {
    return;
  }
  
  // æª¢æŸ¥æ˜¯å¦æœ‰ä¸»è§’è¡Œå‹•ï¼Œå¦‚æœæ²’æœ‰å‰‡ä¸åŸ·è¡Œï¼ˆé™¤éå‹‡è€…æ­»äº¡ï¼Œæ­¤æ™‚å…è¨±åŸ·è¡Œè¡Œå‹•éšŠåˆ—è®“åŒä¼´å’Œæ•µäººç¹¼çºŒè¡Œå‹•ï¼‰
  if (!battle.heroAction && (!state.hero || state.hero.stats.hp > 0)) {
    return;
  }
  
  // æ¨™è¨˜ç‚ºæ­£åœ¨åŸ·è¡Œ
  battle.isExecutingActions = true;
  
  // å›åˆé–‹å§‹æ™‚ï¼Œé‡æ–°è¨ˆç®—åŠ æ¬Šï¼ˆæ¸…ç©ºé˜²å®ˆè¡æ“Šä½¿ç”¨è€…åˆ—è¡¨ï¼‰
  battle.defenseWaveUsers = [];
  
  // å¢åŠ å›åˆæ•¸
  battle.turnCount = (battle.turnCount || 0) + 1;
  
  // è§¸ç™¼ç¥è–å›éŸ¿çš„ç·©æ…¢æ¢å¾©æ•ˆæœï¼ˆæ¯å›åˆé–‹å§‹æ™‚ï¼‰
  triggerHealingEchoEffects();
  
  // è™•ç†å…‰ç’°æ•ˆæœï¼ˆæ¯å›åˆé–‹å§‹æ™‚æ‡‰ç”¨ï¼Œç„¶å¾Œæ¸›å°‘æŒçºŒæ™‚é–“ï¼‰
  if (battle.aura && battle.aura.duration > 0) {
    applyAuraEffects();
    battle.aura.duration -= 1;
    if (battle.aura.duration <= 0) {
      const auraName = getAuraName(battle.aura.type);
      pushBattleLog(`ã€Œ${auraName}ã€æ•ˆæœçµæŸã€‚`);
      battle.aura = null;
    }
  }
  
  // 1. æ§‹å»ºè¡Œå‹•éšŠåˆ—ï¼ˆåŒ…æ‹¬æ‰€æœ‰è§’è‰²ï¼šä¸»è§’ã€åŒä¼´ã€æ•µäººï¼‰
  const actionQueue = buildActionQueue();
  
  if (!actionQueue || actionQueue.length === 0) {
    battle.isExecutingActions = false;
    battle.heroAction = null;
    // å¦‚æœå‹‡è€…æ­»äº¡ä¸”æ²’æœ‰è¡Œå‹•éšŠåˆ—ï¼Œæª¢æŸ¥æ˜¯å¦æ‰€æœ‰è§’è‰²éƒ½æ­»äº¡
    if (state.hero && state.hero.stats.hp <= 0) {
      if (areAllCharactersDead()) {
        if (!state.ui.deathInfo && battle && battle.enemies && battle.enemies.length > 0) {
          const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
          const lastEnemy = aliveEnemies.length > 0 ? aliveEnemies[0] : battle.enemies[0];
          state.ui.deathInfo = {
            cause: 'unknown',
            attacker: lastEnemy ? lastEnemy.name : 'æœªçŸ¥',
            damage: 0,
            skill: null,
            isCrit: false,
          };
        }
        concludeBattle(false);
        return;
      }
      // å¦‚æœé‚„æœ‰æ´»è‘—çš„åŒä¼´ï¼Œç¹¼çºŒæˆ°é¬¥ï¼ˆå›åˆ°å‹‡è€…å›åˆï¼Œä½†å‹‡è€…å·²æ­»ï¼Œæœƒå†æ¬¡é¡¯ç¤ºéˆé­‚è§€æˆ°ï¼‰
    }
    battle.turn = 'hero';
    renderBattleDialog();
    return;
  }
  
  // 2. è™•ç†debuffç‹€æ…‹ï¼ˆæ¯å›åˆé–‹å§‹æ™‚ï¼Œåœ¨æ‰€æœ‰è¡Œå‹•åŸ·è¡Œå‰ï¼‰
  if (battle.enemyDebuffs) {
    // ä½¿ç”¨ Object.keys çš„å‰¯æœ¬ï¼Œé¿å…åœ¨è¿­ä»£æ™‚ä¿®æ”¹å°è±¡
    const enemyIndices = Object.keys(battle.enemyDebuffs).map(s => parseInt(s));
    
    enemyIndices.forEach(enemyIndex => {
      if (enemyIndex >= 0 && enemyIndex < battle.enemies.length) {
        const enemy = battle.enemies[enemyIndex];
        
        // å¦‚æœæ•µäººä¸å­˜åœ¨æˆ–å·²æ­»äº¡ï¼Œæ¸…ç†å…¶ debuff ç‹€æ…‹
        if (!enemy || enemy.stats.hp <= 0) {
          if (battle.enemyDebuffs[enemyIndex]) {
            delete battle.enemyDebuffs[enemyIndex];
          }
          return;
        }
        
        // è™•ç†ä¸­æ¯’ç‹€æ…‹ï¼ˆå›åˆçµæŸæ™‚çµç®—ï¼Œä¸åœ¨å›åˆé–‹å§‹æ™‚è™•ç†ï¼‰
        // ä¸­æ¯’å‚·å®³å°‡åœ¨å›åˆçµæŸæ™‚çµ±ä¸€çµç®—
        
        // è™•ç†æ¸›é€Ÿç‹€æ…‹ï¼ˆæ¸›å°‘æŒçºŒæ™‚é–“ï¼Œä½†ä¸é€ æˆå‚·å®³ï¼‰
        if (battle.enemyDebuffs[enemyIndex] && battle.enemyDebuffs[enemyIndex].slow) {
          const slow = battle.enemyDebuffs[enemyIndex].slow;
          
          // æ¸›å°‘æŒçºŒæ™‚é–“
          slow.duration -= 1;
          
          // å¦‚æœæŒçºŒæ™‚é–“ç‚º0ï¼Œç§»é™¤æ¸›é€Ÿç‹€æ…‹
          if (slow.duration <= 0) {
            delete battle.enemyDebuffs[enemyIndex].slow;
            if (Object.keys(battle.enemyDebuffs[enemyIndex]).length === 0) {
              delete battle.enemyDebuffs[enemyIndex];
            }
            pushBattleLog(`â†’ ${enemy.name}çš„æ¸›é€Ÿæ•ˆæœå·²è§£é™¤ã€‚`);
          }
        }
        
        // è™•ç†é˜²å®ˆå€¼æ¸›å°‘ç‹€æ…‹ï¼ˆæ¸›å°‘æŒçºŒæ™‚é–“ï¼Œä½†ä¸é€ æˆå‚·å®³ï¼‰
        if (battle.enemyDebuffs[enemyIndex] && battle.enemyDebuffs[enemyIndex].defenseDown) {
          const defenseDown = battle.enemyDebuffs[enemyIndex].defenseDown;
          
          // æ¸›å°‘æŒçºŒæ™‚é–“
          defenseDown.duration -= 1;
          
          // å¦‚æœæŒçºŒæ™‚é–“ç‚º0ï¼Œç§»é™¤é˜²å®ˆå€¼æ¸›å°‘ç‹€æ…‹
          if (defenseDown.duration <= 0) {
            delete battle.enemyDebuffs[enemyIndex].defenseDown;
            if (Object.keys(battle.enemyDebuffs[enemyIndex]).length === 0) {
              delete battle.enemyDebuffs[enemyIndex];
            }
            pushBattleLog(`â†’ ${enemy.name}çš„é˜²å®ˆå€¼æ¸›å°‘æ•ˆæœå·²è§£é™¤ã€‚`);
          }
        }
        
        // è™•ç†æ”»æ“ŠåŠ›æ¸›å°‘ç‹€æ…‹ï¼ˆæ¸›å°‘æŒçºŒæ™‚é–“ï¼Œä½†ä¸é€ æˆå‚·å®³ï¼‰
        if (battle.enemyDebuffs[enemyIndex] && battle.enemyDebuffs[enemyIndex].attackDown) {
          const attackDown = battle.enemyDebuffs[enemyIndex].attackDown;
          
          // æ¸›å°‘æŒçºŒæ™‚é–“
          attackDown.duration -= 1;
          
          // å¦‚æœæŒçºŒæ™‚é–“ç‚º0ï¼Œç§»é™¤æ”»æ“ŠåŠ›æ¸›å°‘ç‹€æ…‹
          if (attackDown.duration <= 0) {
            delete battle.enemyDebuffs[enemyIndex].attackDown;
            if (Object.keys(battle.enemyDebuffs[enemyIndex]).length === 0) {
              delete battle.enemyDebuffs[enemyIndex];
            }
            pushBattleLog(`â†’ ${enemy.name}çš„æ”»æ“ŠåŠ›æ¸›å°‘æ•ˆæœå·²è§£é™¤ã€‚`);
          }
        }
      } else {
        // ç´¢å¼•ç„¡æ•ˆï¼Œæ¸…ç†è©² debuff ç‹€æ…‹
        if (battle.enemyDebuffs[enemyIndex]) {
          delete battle.enemyDebuffs[enemyIndex];
        }
      }
    });
  }
  
  // 2.5. è™•ç†å‹æ–¹debuffç‹€æ…‹ï¼ˆæ¯å›åˆé–‹å§‹æ™‚ï¼Œåœ¨æ‰€æœ‰è¡Œå‹•åŸ·è¡Œå‰ï¼‰
  if (battle.friendlyDebuffs) {
    // è™•ç†å‹‡è€…çš„debuff
    if (battle.friendlyDebuffs.hero && state.hero && state.hero.stats.hp > 0) {
      const heroDebuffs = battle.friendlyDebuffs.hero;
      
      // è™•ç†ä¸­æ¯’ç‹€æ…‹ï¼ˆå›åˆçµæŸæ™‚çµç®—ï¼Œä¸åœ¨å›åˆé–‹å§‹æ™‚è™•ç†ï¼‰
      // ä¸­æ¯’å‚·å®³å°‡åœ¨å›åˆçµæŸæ™‚çµ±ä¸€çµç®—
      
      // è™•ç†æ¸›é€Ÿç‹€æ…‹
      if (heroDebuffs.slow) {
        heroDebuffs.slow.duration -= 1;
        if (heroDebuffs.slow.duration <= 0) {
          delete heroDebuffs.slow;
        }
      }
      
      // è™•ç†é˜²å®ˆå€¼æ¸›å°‘ç‹€æ…‹
      if (heroDebuffs.defenseDown) {
        heroDebuffs.defenseDown.duration -= 1;
        if (heroDebuffs.defenseDown.duration <= 0) {
          delete heroDebuffs.defenseDown;
        }
      }
      
      // å¦‚æœæ‰€æœ‰debufféƒ½æ¸…é™¤äº†ï¼Œæ¸…ç†ç©ºå°è±¡
      if (Object.keys(heroDebuffs).length === 0) {
        delete battle.friendlyDebuffs.hero;
      }
    }
    
    // è™•ç†åŒä¼´çš„debuff
    if (battle.friendlyDebuffs.companions) {
      const companionIndices = Object.keys(battle.friendlyDebuffs.companions).map(s => parseInt(s));
      companionIndices.forEach(companionIndex => {
        if (companionIndex >= 0 && companionIndex < state.companions.length) {
          const companion = state.companions[companionIndex];
          if (!companion || companion.stats.hp <= 0) {
            // å¦‚æœåŒä¼´ä¸å­˜åœ¨æˆ–å·²æ­»äº¡ï¼Œæ¸…ç†å…¶ debuff ç‹€æ…‹
            delete battle.friendlyDebuffs.companions[companionIndex];
            return;
          }
          
          const companionDebuffs = battle.friendlyDebuffs.companions[companionIndex];
          
          // è™•ç†ä¸­æ¯’ç‹€æ…‹ï¼ˆå›åˆçµæŸæ™‚çµç®—ï¼Œä¸åœ¨å›åˆé–‹å§‹æ™‚è™•ç†ï¼‰
          // ä¸­æ¯’å‚·å®³å°‡åœ¨å›åˆçµæŸæ™‚çµ±ä¸€çµç®—
          
          // è™•ç†æ¸›é€Ÿç‹€æ…‹
          if (companionDebuffs.slow) {
            companionDebuffs.slow.duration -= 1;
            if (companionDebuffs.slow.duration <= 0) {
              delete companionDebuffs.slow;
            }
          }
          
          // è™•ç†é˜²å®ˆå€¼æ¸›å°‘ç‹€æ…‹
          if (companionDebuffs.defenseDown) {
            companionDebuffs.defenseDown.duration -= 1;
            if (companionDebuffs.defenseDown.duration <= 0) {
              delete companionDebuffs.defenseDown;
            }
          }
          
          // å¦‚æœæ‰€æœ‰debufféƒ½æ¸…é™¤äº†ï¼Œæ¸…ç†ç©ºå°è±¡
          if (Object.keys(companionDebuffs).length === 0) {
            delete battle.friendlyDebuffs.companions[companionIndex];
          }
        }
      });
    }
  }
  
  // 2. é¡¯ç¤ºè¡Œå‹•é †åºï¼ˆèª¿è©¦ç”¨ï¼Œå¯ä»¥åœ¨æ§åˆ¶å°çœ‹åˆ°ï¼‰
  const actionOrder = actionQueue.map((item, idx) => {
    const charName = item.type === 'hero' ? 'å‹‡è€…' 
                   : item.type === 'companion' ? item.character.name 
                   : item.character.name;
    const actionInfo = item.type === 'enemy' && item.actionNumber !== undefined 
      ? ` (è¡Œå‹•${item.actionNumber + 1})` 
      : '';
    return `${idx + 1}. ${charName}${actionInfo} (æ•æ·: ${item.agility})`;
  });
  
  // èª¿è©¦ï¼šçµ±è¨ˆæ¯å€‹æ•µäººçš„è¡Œå‹•æ¬¡æ•¸
  const enemyActionCounts = {};
  actionQueue.forEach(item => {
    if (item.type === 'enemy') {
      const enemyName = item.character.name;
      enemyActionCounts[enemyName] = (enemyActionCounts[enemyName] || 0) + 1;
    }
  });
  Object.keys(enemyActionCounts).forEach(enemyName => {
    if (enemyActionCounts[enemyName] > 1) {
    }
  });
  
  // 3. ä¾æ¬¡åŸ·è¡Œè¡Œå‹•ï¼ˆæŒ‰ç…§æ•æ·æ’åºå¾Œçš„é †åºï¼‰
  let currentIndex = 0;
  
  function executeNextAction() {
    // å…ˆæª¢æŸ¥æˆ°é¬¥æ˜¯å¦å·²ç¶“çµæŸï¼ˆåœ¨æ‰€æœ‰è¡Œå‹•åŸ·è¡Œå‰æª¢æŸ¥ï¼‰
    const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
    if (aliveEnemies.length === 0) {
      battle.isExecutingActions = false;
      battle.heroAction = null;
      concludeBattle(true);
      return;
    }
    
    // æª¢æŸ¥æ˜¯å¦æ‰€æœ‰è¡Œå‹•éƒ½å·²åŸ·è¡Œ
    if (currentIndex >= actionQueue.length) {
      // æ‰€æœ‰è¡Œå‹•åŸ·è¡Œå®Œç•¢
      battle.isExecutingActions = false;
      battle.heroAction = null;
      
      // å†æ¬¡æª¢æŸ¥æˆ°é¬¥æ˜¯å¦çµæŸï¼ˆé˜²æ­¢åœ¨åŸ·è¡Œéç¨‹ä¸­æ•µäººå…¨éƒ¨æ­»äº¡ï¼‰
      const finalAliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
      if (finalAliveEnemies.length === 0) {
        concludeBattle(true);
        return;
      }
      
      // æª¢æŸ¥æ˜¯å¦æ‰€æœ‰è§’è‰²éƒ½æ­»äº¡ï¼Œåªæœ‰å…¨éƒ¨æ­»äº¡æ‰çµæŸéŠæˆ²
      if (areAllCharactersDead()) {
        // ç¢ºä¿æœ‰æ­»äº¡ä¿¡æ¯ï¼ˆå¦‚æœæ²’æœ‰ï¼Œå‰µå»ºé»˜èªçš„ï¼‰
        if (!state.ui.deathInfo && battle && battle.enemies && battle.enemies.length > 0) {
          const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
          const lastEnemy = aliveEnemies.length > 0 ? aliveEnemies[0] : battle.enemies[0];
          state.ui.deathInfo = {
            cause: 'unknown',
            attacker: lastEnemy ? lastEnemy.name : 'æœªçŸ¥',
            damage: 0,
            skill: null,
            isCrit: false,
          };
        }
        concludeBattle(false);
        return;
      }
      
      // å›åˆçµæŸæ™‚è™•ç†buff/debuffæŒçºŒæ™‚é–“
      // 1. è™•ç†åŠæ„buffæŒçºŒæ™‚é–“
      if (battle.heroBuffs && battle.heroBuffs.swordIntent) {
        battle.heroBuffs.swordIntent.duration -= 1;
        if (battle.heroBuffs.swordIntent.duration <= 0) {
          pushBattleLog(`â†’ å‹‡è€…çš„åŠæ„æ•ˆæœçµæŸäº†ã€‚`);
          battle.heroBuffs.swordIntent = null;
        }
      }
      
      // è™•ç†åŒä¼´çš„åŠæ„buff
      if (battle.companionBuffs) {
        Object.keys(battle.companionBuffs).forEach(key => {
          const companionIndex = parseInt(key);
          if (!isNaN(companionIndex) && battle.companionBuffs[companionIndex] && battle.companionBuffs[companionIndex].swordIntent) {
            battle.companionBuffs[companionIndex].swordIntent.duration -= 1;
            if (battle.companionBuffs[companionIndex].swordIntent.duration <= 0) {
              const companion = state.companions[companionIndex];
              if (companion) {
                pushBattleLog(`â†’ ${companion.name}çš„åŠæ„æ•ˆæœçµæŸäº†ã€‚`);
              }
              battle.companionBuffs[companionIndex].swordIntent = null;
            }
          }
        });
      }
      
      // å›åˆçµæŸæ™‚çµç®—ä¸­æ¯’å‚·å®³
      // 1. è™•ç†æ•µäººçš„ä¸­æ¯’
      if (battle.enemyDebuffs) {
        const enemyIndices = Object.keys(battle.enemyDebuffs).map(s => parseInt(s));
        enemyIndices.forEach(enemyIndex => {
          if (enemyIndex >= 0 && enemyIndex < battle.enemies.length) {
            const enemy = battle.enemies[enemyIndex];
            if (enemy && enemy.stats.hp > 0 && battle.enemyDebuffs[enemyIndex] && battle.enemyDebuffs[enemyIndex].poison) {
              const poison = battle.enemyDebuffs[enemyIndex].poison;
              
              // æ‡‰ç”¨ä¸­æ¯’å‚·å®³ï¼ˆä¸å—é˜²å®ˆå½±éŸ¿ï¼‰
              const oldHp = enemy.stats.hp;
              enemy.stats.hp = Math.max(0, enemy.stats.hp - poison.damage);
              const actualDamage = oldHp - enemy.stats.hp;
              if (actualDamage > 0) {
                pushBattleLog(`â†’ ${enemy.name}å—åˆ°ä¸­æ¯’å‚·å®³ ${actualDamage} é»ï¼`);
              }
              
              poison.duration -= 1;
              if (poison.duration <= 0) {
                delete battle.enemyDebuffs[enemyIndex].poison;
                pushBattleLog(`â†’ ${enemy.name}çš„ä¸­æ¯’ç‹€æ…‹è§£é™¤äº†ã€‚`);
              }
            }
          }
        });
      }
      
      // 2. è™•ç†å‹‡è€…çš„ä¸­æ¯’
      if (battle.friendlyDebuffs && battle.friendlyDebuffs.hero && state.hero && state.hero.stats.hp > 0) {
        const heroDebuffs = battle.friendlyDebuffs.hero;
        if (heroDebuffs.poison) {
          const poison = heroDebuffs.poison;
          
          // æ‡‰ç”¨ä¸­æ¯’å‚·å®³ï¼ˆä¸å—é˜²å®ˆå½±éŸ¿ï¼Œä½†å…ˆæ‰£é™¤è­·ç›¾ï¼‰
          let remainingDamage = poison.damage;
          
          ({ finalDamage: remainingDamage } = absorbShield(state.hero, remainingDamage, 'å‹‡è€…'));

          // å‰©é¤˜å‚·å®³æ‰£é™¤HP
          if (remainingDamage > 0) {
            const oldHp = state.hero.stats.hp;
            state.hero.stats.hp = Math.max(0, state.hero.stats.hp - remainingDamage);
            const actualDamage = oldHp - state.hero.stats.hp;
            if (actualDamage > 0) {
              pushBattleLog(`å‹‡è€…å—åˆ°ä¸­æ¯’å‚·å®³ ${actualDamage}ï¼`);
            }
          }
          
          poison.duration -= 1;
          if (poison.duration <= 0) {
            delete heroDebuffs.poison;
            pushBattleLog(`å‹‡è€…çš„ä¸­æ¯’ç‹€æ…‹è§£é™¤äº†ã€‚`);
          }
        }
      }
      
      // 3. è™•ç†åŒä¼´çš„ä¸­æ¯’
      if (battle.friendlyDebuffs && battle.friendlyDebuffs.companions) {
        const companionIndices = Object.keys(battle.friendlyDebuffs.companions).map(s => parseInt(s));
        companionIndices.forEach(companionIndex => {
          if (companionIndex >= 0 && companionIndex < state.companions.length) {
            const companion = state.companions[companionIndex];
            if (companion && companion.stats.hp > 0 && battle.friendlyDebuffs.companions[companionIndex]) {
              const companionDebuffs = battle.friendlyDebuffs.companions[companionIndex];
              if (companionDebuffs.poison) {
                const poison = companionDebuffs.poison;
                
                // æ‡‰ç”¨ä¸­æ¯’å‚·å®³ï¼ˆä¸å—é˜²å®ˆå½±éŸ¿ï¼Œä½†å…ˆæ‰£é™¤è­·ç›¾ï¼‰
                let remainingDamage = poison.damage;
                
                ({ finalDamage: remainingDamage } = absorbShield(companion, remainingDamage, companion.name));

                // å‰©é¤˜å‚·å®³æ‰£é™¤HP
                if (remainingDamage > 0) {
                  const oldHp = companion.stats.hp;
                  companion.stats.hp = Math.max(0, companion.stats.hp - remainingDamage);
                  const actualDamage = oldHp - companion.stats.hp;
                  if (actualDamage > 0) {
                    pushBattleLog(`${companion.name}å—åˆ°ä¸­æ¯’å‚·å®³ ${actualDamage}ï¼`);
                    // è§¸ç™¼è¢«æ”»æ“Šæ™‚çš„è¢«å‹•æŠ€èƒ½ï¼ˆå¾©ä»‡æ„å¿—ç­‰ï¼‰
                    triggerOnHitPassiveEffects(companion, actualDamage);
                  }
                }
                
                poison.duration -= 1;
                if (poison.duration <= 0) {
                  delete companionDebuffs.poison;
                  pushBattleLog(`${companion.name}çš„ä¸­æ¯’ç‹€æ…‹è§£é™¤äº†ã€‚`);
                }
              }
            }
          }
        });
      }
      
      // æ‡‰ç”¨æ¢å¾©å‹è¢«å‹•æŠ€èƒ½ï¼šæ¯å›åˆå›å¾©HP/MPï¼ˆå›åˆçµæŸæ™‚ï¼‰
      // åªæœ‰åœ¨æˆ°é¬¥æœªçµæŸæ™‚æ‰åŸ·è¡Œå›å¾©
      const hero = state.hero;
      if (hero && hero.stats.hp > 0) {
        const recoveryEffects = getRecoveryPassiveEffects(hero);
        
        // æ¯å›åˆå›å¾©HP
        if (recoveryEffects.perTurnHpRegen > 0) {
          const oldHp = hero.stats.hp;
          hero.stats.hp = Math.min(hero.stats.maxHp, hero.stats.hp + recoveryEffects.perTurnHpRegen);
          const actualRegen = hero.stats.hp - oldHp;
          if (actualRegen > 0) {
            pushBattleLog(`æ¢å¾©å‹è¢«å‹•æŠ€èƒ½ï¼šæ¯å›åˆå›å¾© ${actualRegen} HPã€‚`);
          }
        }
        
        // æ¯å›åˆå›å¾©MP
        if (recoveryEffects.perTurnMpRegen > 0) {
          const oldMp = hero.stats.mp;
          hero.stats.mp = Math.min(hero.stats.maxMp, hero.stats.mp + recoveryEffects.perTurnMpRegen);
          const actualRegen = hero.stats.mp - oldMp;
          if (actualRegen > 0) {
            pushBattleLog(`æ¢å¾©å‹è¢«å‹•æŠ€èƒ½ï¼šæ¯å›åˆå›å¾© ${actualRegen} MPã€‚`);
          }
        }
      }
      
      // æ‡‰ç”¨åŒä¼´çš„æ¢å¾©å‹è¢«å‹•æŠ€èƒ½ï¼šæ¯å›åˆå›å¾©HP/MP
      const companions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
      companions.forEach(companion => {
        const recoveryEffects = getRecoveryPassiveEffects(companion);
        
        // æ¯å›åˆå›å¾©HP
        if (recoveryEffects.perTurnHpRegen > 0) {
          const oldHp = companion.stats.hp;
          companion.stats.hp = Math.min(companion.stats.maxHp, companion.stats.hp + recoveryEffects.perTurnHpRegen);
          const actualRegen = companion.stats.hp - oldHp;
          if (actualRegen > 0) {
            pushBattleLog(`æ¢å¾©å‹è¢«å‹•æŠ€èƒ½ï¼š${companion.name}æ¯å›åˆå›å¾© ${actualRegen} HPã€‚`);
          }
        }
        
        // æ¯å›åˆå›å¾©MP
        if (recoveryEffects.perTurnMpRegen > 0) {
          const oldMp = companion.stats.mp;
          companion.stats.mp = Math.min(companion.stats.maxMp, companion.stats.mp + recoveryEffects.perTurnMpRegen);
          const actualRegen = companion.stats.mp - oldMp;
          if (actualRegen > 0) {
            pushBattleLog(`æ¢å¾©å‹è¢«å‹•æŠ€èƒ½ï¼š${companion.name}æ¯å›åˆå›å¾© ${actualRegen} MPã€‚`);
          }
        }
      });
      
      // é–‹å§‹æ–°çš„å›åˆ
      battle.turn = 'hero';
      battle.selectedEnemyIndex = null; // é‡ç½®é¸æ“‡ç‹€æ…‹
      battle.pendingSkill = null; // é‡ç½®å¾…ä½¿ç”¨æŠ€èƒ½
      battle.pendingItem = null; // é‡ç½®å¾…ä½¿ç”¨é“å…·
      renderBattleDialog();
      return;
    }
    
    // ç²å–ç•¶å‰è¦åŸ·è¡Œçš„è¡Œå‹•
    const actionItem = actionQueue[currentIndex];
    currentIndex++;
    
    // æª¢æŸ¥è§’è‰²æ˜¯å¦é‚„æ´»è‘—
    if (actionItem.character.stats.hp <= 0) {
      // è·³éå·²æ­»çš„è§’è‰²ï¼Œç¹¼çºŒä¸‹ä¸€å€‹
      if (actionItem.type === 'companion') {
        pushBattleLog(`${actionItem.character.name}å·²æ­»äº¡ï¼Œç„¡æ³•è¡Œå‹•ã€‚`);
      } else if (actionItem.type === 'hero') {
        pushBattleLog('å‹‡è€…å·²æ­»äº¡ï¼Œç„¡æ³•è¡Œå‹•ã€‚');
      }
      setTimeout(executeNextAction, 100);
      return;
    }
    
    // åŸ·è¡Œè¡Œå‹•
    executeAction(actionItem).then(() => {
      // åŸ·è¡Œå®Œç•¢å¾Œï¼Œæª¢æŸ¥æˆ°é¬¥æ˜¯å¦æ‡‰è©²æå‰çµæŸ
      const aliveEnemiesAfterAction = battle.enemies.filter(e => e.stats.hp > 0);
      
      // å¦‚æœæ‰€æœ‰æ•µäººéƒ½è¢«æ“Šå€’ï¼Œç«‹å³çµæŸæˆ°é¬¥ï¼ˆå‹åˆ©ï¼‰
      if (aliveEnemiesAfterAction.length === 0) {
        battle.isExecutingActions = false;
        battle.heroAction = null;
        concludeBattle(true);
        return;
      }
      
      // æª¢æŸ¥æ˜¯å¦æ‰€æœ‰è§’è‰²éƒ½æ­»äº¡ï¼Œåªæœ‰å…¨éƒ¨æ­»äº¡æ‰çµæŸæˆ°é¬¥ï¼ˆå¤±æ•—ï¼‰
      if (areAllCharactersDead()) {
        // ç¢ºä¿æœ‰æ­»äº¡ä¿¡æ¯ï¼ˆå¦‚æœæ²’æœ‰ï¼Œå‰µå»ºé»˜èªçš„ï¼‰
        if (!state.ui.deathInfo && battle && battle.enemies && battle.enemies.length > 0) {
          const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
          const lastEnemy = aliveEnemies.length > 0 ? aliveEnemies[0] : battle.enemies[0];
          state.ui.deathInfo = {
            cause: 'unknown',
            attacker: lastEnemy ? lastEnemy.name : 'æœªçŸ¥',
            damage: 0,
            skill: null,
            isCrit: false,
          };
        }
        battle.isExecutingActions = false;
        battle.heroAction = null;
        concludeBattle(false);
        return;
      }
      
      // ç­‰å¾…ä¸€å°æ®µæ™‚é–“å†åŸ·è¡Œä¸‹ä¸€å€‹è¡Œå‹•
      setTimeout(executeNextAction, 400);
    }).catch((error) => {
      // å³ä½¿å‡ºéŒ¯ä¹Ÿç¹¼çºŒä¸‹ä¸€å€‹è¡Œå‹•
      setTimeout(executeNextAction, 400);
    });
  }
  
  // é–‹å§‹åŸ·è¡Œç¬¬ä¸€å€‹è¡Œå‹•
  executeNextAction();
}

// æ±ºå®šåŒä¼´çš„è¡Œå‹•ï¼ˆè¿”å›è¡Œå‹•å°è±¡ï¼Œä¸åŸ·è¡Œï¼‰
// æ ¹æ“šè·æ¥­èˆ‡å€‹æ€§è¨ˆç®—åŒä¼´çš„ã€Œå›å¾©è¡Œå‹•ã€æ©Ÿç‡
function getCompanionHealChance(companion, aiBehavior = {}) {
  const heroTypeId = companion.heroType;
  
  // åŸºç¤è·æ¥­å›å¾©æ©Ÿç‡
  // ç‰§å¸«(healer)ï¼š90%ï¼Œè–é¨å£«(paladin)ï¼š70%ï¼Œè³¢è€…(sage)ï¼š70%ï¼Œå…¶ä»–ï¼š20%
  let baseChance = 0.2;
  if (heroTypeId === 'healer') {
    baseChance = 0.9;
  } else if (heroTypeId === 'paladin' || heroTypeId === 'sage') {
    baseChance = 0.7;
  }
  
  // å€‹æ€§è£œæ­£ï¼šä½¿ç”¨ healPriority ä½œç‚ºå€ç‡ï¼ˆ1.2 = +20%ï¼Œ0.8 = -20%ï¼‰
  const priority = (typeof aiBehavior.healPriority === 'number') ? aiBehavior.healPriority : 1;
  let finalChance = baseChance * priority;
  
  // å¤¾åœ¨ [0, 0.99] ç¯„åœå…§ï¼Œé¿å…100%é–æ­»
  finalChance = Math.max(0, Math.min(0.99, finalChance));
  return finalChance;
}

// è¨ˆç®—åŒä¼´çš„æ²»ç™‚å‚¾å‘ï¼ˆ100åˆ†ç‚ºæ»¿åˆ†ï¼‰
// åŸºæº–å€¼æ ¹æ“šè·æ¥­ï¼Œå€‹æ€§ä¿®æ­£ç¯„åœ -0.2 åˆ° +0.2
function getCompanionHealTendency(companion) {
  if (!companion) return 0;
  
  const heroTypeId = companion.heroType;
  // åŸºç¤è·æ¥­å›å¾©æ©Ÿç‡
  let baseChance = 0.2;
  if (heroTypeId === 'healer') {
    baseChance = 0.9;
  } else if (heroTypeId === 'paladin' || heroTypeId === 'sage') {
    baseChance = 0.7;
  }
  
  // å€‹æ€§ä¿®æ­£ï¼ˆ-0.2 åˆ° +0.2ï¼‰
  let personalityModifier = 0;
  if (companion.personalityId) {
    const personality = COMPANION_PERSONALITIES[companion.personalityId] || COMPANION_PERSONALITIES.balanced;
    const tendencyModifiers = personality.tendencyModifiers || {};
    personalityModifier = tendencyModifiers.heal || 0;
  }
  
  // æ‡‰ç”¨å€‹æ€§ä¿®æ­£ï¼ˆä½œç‚ºç™¾åˆ†æ¯”å¢æ¸›ï¼‰
  let finalChance = baseChance * (1 + personalityModifier);
  finalChance = Math.max(0, Math.min(0.99, finalChance));
  
  return Math.floor(finalChance * 100);
}

// è¨ˆç®—åŒä¼´çš„é˜²å®ˆå‚¾å‘ï¼ˆ100åˆ†ç‚ºæ»¿åˆ†ï¼‰
// åŸºæº–å€¼æ ¹æ“šè·æ¥­ï¼Œå€‹æ€§ä¿®æ­£ç¯„åœ -0.2 åˆ° +0.2
function getCompanionDefenseTendency(companion) {
  if (!companion) return 0;
  
  // åŸºç¤é˜²å®ˆæ©Ÿç‡
  let baseChance = 0;
  if (companion.companionTypeId === 'knight') {
    baseChance = 0.3; // é¨å£«30%
  } else if (companion.companionTypeId === 'paladin') {
    baseChance = 0.2; // è–é¨å£«20%
  } else if (companion.personalityId) {
    // å…¶ä»–è·æ¥­æ ¹æ“šå€‹æ€§çš„ guardChance
    const personality = COMPANION_PERSONALITIES[companion.personalityId] || COMPANION_PERSONALITIES.balanced;
    const aiBehavior = personality.aiBehavior || {};
    baseChance = aiBehavior.guardChance || 0;
  }
  
  // å€‹æ€§ä¿®æ­£ï¼ˆ-0.2 åˆ° +0.2ï¼‰
  let personalityModifier = 0;
  if (companion.personalityId) {
    const personality = COMPANION_PERSONALITIES[companion.personalityId] || COMPANION_PERSONALITIES.balanced;
    const tendencyModifiers = personality.tendencyModifiers || {};
    personalityModifier = tendencyModifiers.defense || 0;
  }
  
  // æ‡‰ç”¨å€‹æ€§ä¿®æ­£ï¼ˆä½œç‚ºç™¾åˆ†æ¯”å¢æ¸›ï¼‰
  let finalChance = baseChance * (1 + personalityModifier);
  finalChance = Math.max(0, Math.min(0.99, finalChance));
  
  return Math.floor(finalChance * 100);
}

// è¨ˆç®—åŒä¼´ä½¿ç”¨é˜²å®ˆæŠ€èƒ½çš„æ©Ÿç‡ï¼ˆåŒ…å«å€‹æ€§è£œæ­£ï¼‰
function getCompanionDefenseSkillChance(companion) {
  if (!companion) return 0;
  
  let baseChance = 0;
  
  // é¨å£«çš„é˜²å®ˆç‡æ˜¯30%
  if (companion.companionTypeId === 'knight') {
    baseChance = 0.3;
  }
  // è–é¨å£«çš„é˜²å®ˆç‡æ˜¯20%
  else if (companion.companionTypeId === 'paladin') {
    baseChance = 0.2;
  }
  // å…¶ä»–è·æ¥­æ ¹æ“šå€‹æ€§çš„ guardChance è¨ˆç®—
  else if (companion.personalityId) {
    const personalityId = companion.personalityId;
    const personality = COMPANION_PERSONALITIES[personalityId] || COMPANION_PERSONALITIES.balanced;
    const aiBehavior = personality.aiBehavior || {};
    baseChance = aiBehavior.guardChance || 0;
  }
  
  // æ‡‰ç”¨å€‹æ€§è£œæ­£ï¼ˆå¦‚æœæœ‰ guardPriority æˆ–å…¶ä»–è£œæ­£ï¼‰
  // ç›®å‰ç›´æ¥ä½¿ç”¨ baseChanceï¼Œæœªä¾†å¯ä»¥æ·»åŠ è£œæ­£
  
  return Math.max(0, Math.min(0.99, baseChance));
}

// è¨ˆç®—åŒä¼´çš„è¼”åŠ©å‚¾å‘ï¼ˆ100åˆ†ç‚ºæ»¿åˆ†ï¼‰
// åŸºæº–å€¼50%ï¼Œå€‹æ€§ä¿®æ­£ç¯„åœ -0.2 åˆ° +0.2
function getCompanionSupportTendency(companion) {
  if (!companion) return 50;
  
  const baseChance = 0.5; // åŸºæº–å€¼50%
  
  // å€‹æ€§ä¿®æ­£ï¼ˆ-0.2 åˆ° +0.2ï¼‰
  let personalityModifier = 0;
  if (companion.personalityId) {
    const personality = COMPANION_PERSONALITIES[companion.personalityId] || COMPANION_PERSONALITIES.balanced;
    const tendencyModifiers = personality.tendencyModifiers || {};
    personalityModifier = tendencyModifiers.support || 0;
  }
  
  // æ‡‰ç”¨å€‹æ€§ä¿®æ­£ï¼ˆä½œç‚ºç™¾åˆ†æ¯”å¢æ¸›ï¼‰
  let finalChance = baseChance * (1 + personalityModifier);
  finalChance = Math.max(0, Math.min(0.99, finalChance));
  
  return Math.floor(finalChance * 100);
}

// è¨ˆç®—åŒä¼´çš„æ”»æ“Šå‚¾å‘ï¼ˆ100åˆ†ç‚ºæ»¿åˆ†ï¼‰
// åŸºæº–å€¼80%ï¼Œå€‹æ€§ä¿®æ­£ç¯„åœ -0.2 åˆ° +0.2
function getCompanionAttackTendency(companion) {
  if (!companion) return 80;
  
  const baseChance = 0.8; // åŸºæº–å€¼80%
  
  // å€‹æ€§ä¿®æ­£ï¼ˆ-0.2 åˆ° +0.2ï¼‰
  let personalityModifier = 0;
  if (companion.personalityId) {
    const personality = COMPANION_PERSONALITIES[companion.personalityId] || COMPANION_PERSONALITIES.balanced;
    const tendencyModifiers = personality.tendencyModifiers || {};
    personalityModifier = tendencyModifiers.attack || 0;
  }
  
  // æ‡‰ç”¨å€‹æ€§ä¿®æ­£ï¼ˆä½œç‚ºç™¾åˆ†æ¯”å¢æ¸›ï¼‰
  let finalChance = baseChance * (1 + personalityModifier);
  finalChance = Math.max(0, Math.min(0.99, finalChance));
  
  return Math.floor(finalChance * 100);
}

// è¨ˆç®—åŒä¼´çš„å…¨é«”æ”»æ“Šå‚¾å‘ï¼ˆ100åˆ†ç‚ºæ»¿åˆ†ï¼‰
// åŸºæº–å€¼30%ï¼Œå€‹æ€§ä¿®æ­£ç¯„åœ -0.2 åˆ° +0.2
function getCompanionAoeTendency(companion) {
  if (!companion) return 30;
  
  const baseChance = 0.3; // åŸºæº–å€¼30%
  
  // å€‹æ€§ä¿®æ­£ï¼ˆ-0.2 åˆ° +0.2ï¼‰
  let personalityModifier = 0;
  if (companion.personalityId) {
    const personality = COMPANION_PERSONALITIES[companion.personalityId] || COMPANION_PERSONALITIES.balanced;
    const tendencyModifiers = personality.tendencyModifiers || {};
    personalityModifier = tendencyModifiers.aoe || 0;
  }
  
  // æ‡‰ç”¨å€‹æ€§ä¿®æ­£ï¼ˆä½œç‚ºç™¾åˆ†æ¯”å¢æ¸›ï¼‰
  let finalChance = baseChance * (1 + personalityModifier);
  finalChance = Math.max(0, Math.min(0.99, finalChance));
  
  return Math.floor(finalChance * 100);
}

function determineCompanionAction(companion) {
  // å¦‚æœæ²’æœ‰å‚³å…¥åŒä¼´ï¼Œä½¿ç”¨ç¬¬ä¸€å€‹æ´»è‘—çš„åŒä¼´ï¼ˆå‘å¾Œå…¼å®¹ï¼‰
  if (!companion) {
    companion = getActiveCompanion();
  }
  if (!companion || companion.stats.hp <= 0) return null;
  
  const battle = state.ui.battle;
  const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
  if (aliveEnemies.length === 0) return null;
  
  const hero = state.hero;
  
  // ç²å–å€‹æ€§é…ç½®
  const personalityId = companion.personalityId || 'balanced';
  const personality = COMPANION_PERSONALITIES[personalityId] || COMPANION_PERSONALITIES.balanced;
  const aiBehavior = personality.aiBehavior || {};
  const healChance = getCompanionHealChance(companion, aiBehavior);
  
  // ç²å–æ‰€æœ‰å¯ç”¨æŠ€èƒ½
  const availableSkills = companion.skills
    .map(id => SKILL_LOOKUP.get(id))
    .filter(skill => skill && skill.kind !== 'passive' && (skill.mpCost || 0) <= companion.stats.mp && isSkillEnabled(skill.id, companion));
  
  // æª¢æŸ¥æ˜¯å¦éœ€è¦ä½¿ç”¨é˜²å®ˆï¼ˆæ ¹æ“šå€‹æ€§ï¼‰
  if (aiBehavior.guardChance && aiBehavior.guardChance > 0) {
    const guardRoll = Math.random();
    if (guardRoll < aiBehavior.guardChance) {
    return {
        type: 'guard',
    };
    }
  }
  
  // 0.5. ç¬¬ä¸€å›åˆæª¢æŸ¥enhanceé¡æŠ€èƒ½ï¼ˆé˜²æ­»è­·ç›¾ç­‰ï¼‰ï¼š50%åŸºç¤æ©Ÿç‡ï¼Œå—å€‹æ€§å½±éŸ¿
  // æ³¨æ„ï¼šturnCountåœ¨executeActionQueueä¸­æœƒå…ˆå¢åŠ ï¼Œæ‰€ä»¥ç¬¬ä¸€å›åˆæ™‚turnCountæ˜¯1
  const isFirstTurn = battle.turnCount === 1;
  if (isFirstTurn) {
    const enhanceSkills = availableSkills.filter(skill => skill.kind === 'enhance');
    if (enhanceSkills.length > 0) {
      // åŸºç¤50%æ©Ÿç‡
      let enhanceUseChance = 0.5;
      
      // å—å€‹æ€§å½±éŸ¿ï¼šæ ¹æ“šskillUseChanceèª¿æ•´ï¼ˆ0.5ç‚ºä¸­æ€§é»ï¼‰
      if (typeof aiBehavior.skillUseChance === 'number') {
        const delta = aiBehavior.skillUseChance - 0.5; // 0.5è¦–ç‚ºä¸­ç«‹
        enhanceUseChance = 0.5 + delta; // å€‹æ€§å‚¾å‘ä½¿ç”¨æŠ€èƒ½æ™‚ï¼ŒenhanceæŠ€èƒ½ä½¿ç”¨ç‡ä¹Ÿæé«˜
      }
      enhanceUseChance = Math.max(0, Math.min(0.99, enhanceUseChance));
      
      const enhanceRoll = Math.random();
      if (enhanceRoll < enhanceUseChance) {
        // éš¨æ©Ÿé¸æ“‡ä¸€å€‹enhanceæŠ€èƒ½ä½¿ç”¨
        const selectedEnhanceSkill = enhanceSkills[Math.floor(Math.random() * enhanceSkills.length)];
        return {
          type: 'skill',
          skillId: selectedEnhanceSkill.id,
          target: null, // enhanceé¡æŠ€èƒ½é€šå¸¸ä¸éœ€è¦ç›®æ¨™
        };
      }
    }
  }
  
  // 0. æª¢æŸ¥å¾©æ´»éœ€æ±‚ï¼ˆæœ€é«˜å„ªå…ˆç´šï¼‰ï¼šåªæœ‰æœ‰äººæ­»äº¡æ™‚æ‰æœƒä½¿ç”¨å¾©æ´»è¡“
  const reviveSkills = availableSkills.filter(skill => skill.id === 'revive_companion');
  if (reviveSkills.length > 0) {
    // æª¢æŸ¥æ˜¯å¦æœ‰æ­»äº¡çš„åŒä¼´æˆ–å‹‡è€…
    const allCompanions = (state.companions || []).filter(c => c && c.stats);
    const deadCompanions = allCompanions.filter(c => c.stats.hp <= 0);
    const isHeroDead = hero && hero.stats.hp <= 0;
    
    // å¦‚æœæœ‰æ­»äº¡çš„åŒä¼´ï¼Œå„ªå…ˆå¾©æ´»åŒä¼´
    if (deadCompanions.length > 0) {
      // éš¨æ©Ÿé¸æ“‡ä¸€å€‹æ­»äº¡çš„åŒä¼´å¾©æ´»
      const targetCompanion = deadCompanions[Math.floor(Math.random() * deadCompanions.length)];
      const companionIndex = allCompanions.indexOf(targetCompanion);
      if (companionIndex >= 0) {
        const roll = Math.random();
        // å¾©æ´»è¡“ä½¿ç”¨æ©Ÿç‡è¼ƒé«˜ï¼ˆ80%ï¼‰ï¼Œå› ç‚ºå¾©æ´»å¾ˆé‡è¦
        if (roll < 0.8) {
          return {
            type: 'skill',
            skillId: reviveSkills[0].id,
            target: 'companion',
            companionIndex: companionIndex,
          };
        }
      }
    }
    // å¦‚æœæ²’æœ‰æ­»äº¡çš„åŒä¼´ï¼Œä½†å‹‡è€…æ­»äº¡ï¼Œä¹Ÿå¯ä»¥å¾©æ´»å‹‡è€…ï¼ˆä½†å¾©æ´»è¡“ä¸»è¦æ˜¯å¾©æ´»åŒä¼´ï¼‰
    // æ³¨æ„ï¼šå¾©æ´»è¡“é€šå¸¸åªèƒ½å¾©æ´»åŒä¼´ï¼Œä¸èƒ½å¾©æ´»å‹‡è€…ï¼Œæ‰€ä»¥é€™è£¡ä¸è™•ç†å‹‡è€…æ­»äº¡çš„æƒ…æ³
  }
  
  // 1. æª¢æŸ¥æ²»ç™‚éœ€æ±‚ï¼ˆå„ªå…ˆç´šæ¬¡é«˜ï¼‰
  const companionHpPercent = companion.stats.hp / companion.stats.maxHp;
  const heroHpPercent = hero.stats.hp / hero.stats.maxHp;
  
  // æª¢æŸ¥æ‰€æœ‰åŒä¼´çš„HPç™¾åˆ†æ¯”
  const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
  const allCharacters = [
    { type: 'hero', hpPercent: heroHpPercent, character: hero },
    { type: 'companion', hpPercent: companionHpPercent, character: companion },
  ];
  
  activeCompanions.forEach(comp => {
    if (comp !== companion) {
    const compHpPercent = comp.stats.hp / comp.stats.maxHp;
      allCharacters.push({ type: 'companion', hpPercent: compHpPercent, character: comp });
    }
  });
  
  // ç¾¤é«”æ²»ç™‚é–¾å€¼ï¼šæ”¹ç‚º50%ï¼Œåªæœ‰è¡€é‡å°‘æ–¼50%æ™‚æ‰æœƒä½¿ç”¨æ²»ç™‚
  const lowHpThreshold = 0.5; // å›ºå®š50%
  
  // æ‰¾å‡ºæ‰€æœ‰HP < 50%çš„è§’è‰²ï¼ˆç”¨æ–¼ç¾¤é«”æ²»ç™‚åˆ¤æ–·ï¼‰
  const lowHpCharacters = allCharacters.filter(c => c.hpPercent < lowHpThreshold);
  const lowHpCount = lowHpCharacters.length;
  
  // å¦‚æœæœ‰2å€‹æˆ–ä»¥ä¸Šçš„äººHP < 50%ï¼Œä¸”é€šéå›å¾©æ©Ÿç‡åˆ¤å®šï¼Œæ‰æœƒä½¿ç”¨ç¯„åœè£œè¡€æŠ€èƒ½
  if (lowHpCount >= 2) {
    const aoeHealSkills = availableSkills.filter(skill => 
      skill.kind === 'heal' && skill.aoe
    );
    if (aoeHealSkills.length > 0) {
      const roll = Math.random();
      if (roll < healChance) {
      return {
        type: 'skill',
          skillId: aoeHealSkills[0].id,
        target: null,
      };
    }
  }
  
    // åŒä¼´ä¸æœƒä½¿ç”¨é“å…·ï¼ˆå·²ç§»é™¤é“å…·ä½¿ç”¨é‚è¼¯ï¼‰
  }
  
  // å–®é«”æ²»ç™‚ï¼šåªæœ‰è¡€é‡å°‘æ–¼50%æ™‚æ‰æœƒä½¿ç”¨æ²»ç™‚
  // åŒæ™‚æœ‰å…©å€‹äººå°‘æ–¼50%æ™‚ï¼Œæ²»ç™‚æ¯”ä¾‹è¼ƒä½çš„äºº
  // åªè€ƒæ…®é‚„æ´»è‘—çš„è§’è‰²ï¼ˆæ™®é€šå›å¾©é­”æ³•ç„¡æ³•å¾©æ´»å·²æ­»äº¡çš„è§’è‰²ï¼‰
  const aliveCharacters = allCharacters.filter(c => c.character.stats.hp > 0);
  if (aliveCharacters.length > 0) {
    // å„ªå…ˆæª¢æŸ¥æ˜¯å¦æœ‰å›å¾©æŠ€èƒ½ä¸”MPè¶³å¤ 
    const healSkills = availableSkills.filter(skill => skill.kind === 'heal' && !skill.aoe);
    if (healSkills.length > 0) {
      // åªè€ƒæ…®HP < 50%çš„è§’è‰²
      const lowHpAliveCharacters = aliveCharacters.filter(c => c.hpPercent < 0.5);
      
      if (lowHpAliveCharacters.length > 0) {
        // é¸æ“‡HPç™¾åˆ†æ¯”æœ€ä½çš„ç›®æ¨™ï¼ˆå„ªå…ˆæ²»ç™‚æœ€å±éšªçš„è§’è‰²ï¼‰
        const lowestTarget = lowHpAliveCharacters.reduce((min, c) => 
          c.hpPercent < min.hpPercent ? c : min
        );
        
        // åªæœ‰æœ€ä½HPç™¾åˆ†æ¯”ä½æ–¼50%æ™‚ï¼Œæ‰æœƒä½¿ç”¨å›å¾©æŠ€èƒ½
        const roll = Math.random();
        if (roll < healChance) {
        const target = lowestTarget.type === 'hero' ? 'hero' : 'companion';
        return {
          type: 'skill',
        skillId: healSkills[0].id,
        target: target,
      };
        }
      }
    }
    
    // åŒä¼´ä¸æœƒä½¿ç”¨é“å…·ï¼ˆå·²ç§»é™¤é“å…·ä½¿ç”¨é‚è¼¯ï¼‰
  }
  
  // 1.5. æª¢æŸ¥è¼”åŠ©æŠ€èƒ½ï¼ˆsupporté¡å‹ï¼Œå¦‚è­·ç›¾ç­‰ï¼‰
  const supportSkills = availableSkills.filter(skill => 
    skill.kind === 'support' && skill.damageReduction === undefined
  );
  if (supportSkills.length > 0) {
    // è¼”åŠ©æŠ€èƒ½ä½¿ç”¨æ©Ÿç‡åŸºæ–¼ skillUseChance
    const baseSkillUseChance = 0.8;
    let skillUseChance = baseSkillUseChance;
    if (typeof aiBehavior.skillUseChance === 'number') {
      const delta = aiBehavior.skillUseChance - 0.5; // 0.5è¦–ç‚ºä¸­ç«‹
      skillUseChance = baseSkillUseChance + delta;
    }
    skillUseChance = Math.max(0, Math.min(0.99, skillUseChance));
    
    const supportRoll = Math.random();
    if (supportRoll < skillUseChance) {
      // éš¨æ©Ÿé¸æ“‡ä¸€å€‹è¼”åŠ©æŠ€èƒ½ä½¿ç”¨
      const selectedSupportSkill = supportSkills[Math.floor(Math.random() * supportSkills.length)];
      // è¼”åŠ©æŠ€èƒ½é€šå¸¸å°è‡ªå·±æˆ–éšŠå‹ä½¿ç”¨ï¼Œé€™è£¡ç°¡åŒ–ç‚ºå°è‡ªå·±ä½¿ç”¨
      return {
        type: 'skill',
        skillId: selectedSupportSkill.id,
        target: 'companion',
        companionIndex: state.companions.indexOf(companion),
      };
    }
  }
  
  // 1.6. æª¢æŸ¥æ˜¯å¦æœ‰å‚·å®³æ¸›å…æŠ€èƒ½ï¼Œæ ¹æ“šé˜²å®ˆæ©Ÿç‡ï¼ˆåŠ ä¸Šå€‹æ€§è£œæ­£ï¼‰æ±ºå®šæ˜¯å¦ä½¿ç”¨
  const damageReductionSkills = availableSkills.filter(skill => 
    skill.damageReduction !== undefined
  );
  if (damageReductionSkills.length > 0) {
    const defenseChance = getCompanionDefenseSkillChance(companion);
    const defenseRoll = Math.random();
    if (defenseRoll < defenseChance) {
      // éš¨æ©Ÿé¸æ“‡ä¸€å€‹å‚·å®³æ¸›å…æŠ€èƒ½ä½¿ç”¨ï¼ˆå°è‡ªå·±ä½¿ç”¨ï¼‰
      const selectedDefenseSkill = damageReductionSkills[Math.floor(Math.random() * damageReductionSkills.length)];
      return {
        type: 'skill',
        skillId: selectedDefenseSkill.id,
        target: 'companion', // å°è‡ªå·±ä½¿ç”¨
        companionIndex: state.companions.indexOf(companion),
      };
    }
  }
  
  // 2. åˆ¤æ–·æ˜¯å¦ä½¿ç”¨æ”»æ“ŠæŠ€èƒ½ï¼ˆç‰©ç†/é­”æ³•ç­‰ï¼‰
  // åŸºç¤80%æ©Ÿç‡ï¼Œå€‹æ€§åšåŠ æ¸›ï¼ˆä»¥0.5ç‚ºä¸­æ€§é»ï¼‰
  const baseSkillUseChance = 0.8;
  let skillUseChance = baseSkillUseChance;
  if (typeof aiBehavior.skillUseChance === 'number') {
    const delta = aiBehavior.skillUseChance - 0.5; // 0.5è¦–ç‚ºä¸­ç«‹
    skillUseChance = baseSkillUseChance + delta;
  }
  skillUseChance = Math.max(0, Math.min(0.99, skillUseChance));
  
  const useSkillRoll = Math.random();
  const willUseSkill = useSkillRoll < skillUseChance;
  
  if (willUseSkill && availableSkills.length > 0) {
    // æ ¹æ“šè·æ¥­æ±ºå®šä¸»è¦æµæ´¾ï¼ˆé€²éšè·æ¥­æœ‰å…©å€‹æµæ´¾ï¼‰
    const flowMap = {
      attacker: 'sword',
      defender: 'defender',
      mage: 'magic',
      healer: 'recovery',
      agile: 'agility',
      sage: ['magic', 'recovery'],
      paladin: ['defender', 'recovery'],
      weaponmaster: ['sword', 'agility'],
    };
    const heroTypeId = companion.heroType;
    const primaryFlowOrFlows = flowMap[heroTypeId] || 'sword';
    const primaryFlows = Array.isArray(primaryFlowOrFlows) ? primaryFlowOrFlows : [primaryFlowOrFlows];
    
    // 80% æ©Ÿç‡å„ªå…ˆä½¿ç”¨æœ¬è·æ¥­ï¼ˆå°æ–¼é€²éšè·æ¥­æ˜¯å…©å€‹æµæ´¾éƒ½ç®—æœ¬è·ï¼‰
    const ownFlowPoolChance = 0.8;
    const ownFlowRoll = Math.random();
    
    const ownFlowSkills = availableSkills.filter(skill => 
      skill.flow && primaryFlows.includes(skill.flow)
    );
    const otherFlowSkills = availableSkills.filter(skill => 
      !skill.flow || !primaryFlows.includes(skill.flow)
    );
    
    let candidateSkills = [];
    if (ownFlowRoll < ownFlowPoolChance && ownFlowSkills.length > 0) {
      candidateSkills = ownFlowSkills;
    } else if (otherFlowSkills.length > 0) {
      candidateSkills = otherFlowSkills;
    } else {
      candidateSkills = availableSkills;
    }
    
    // 3. åœ¨é¸å‡ºçš„æŠ€èƒ½æ± ä¸­ï¼Œå„ªå…ˆè€ƒæ…®å…¨é«”æ”»æ“Š
    const aoeThreshold = aiBehavior.aoeThreshold !== undefined ? aiBehavior.aoeThreshold : 3; // é è¨­3éš»æ€ªï¼Œå€‹æ€§å¯æ”¹æˆ2
    const aoeAttackSkills = candidateSkills.filter(skill => 
      skill.kind === 'attack' && skill.aoe
    );
    
    if (aliveEnemies.length >= aoeThreshold && aoeAttackSkills.length > 0) {
      const selectedAoeSkill = aoeAttackSkills[Math.floor(Math.random() * aoeAttackSkills.length)];
        return {
          type: 'skill',
        skillId: selectedAoeSkill.id,
        target: null,
      };
    }
    
    // å¦å‰‡ä½¿ç”¨å–®é«”æ”»æ“ŠæŠ€èƒ½
    const singleAttackSkills = candidateSkills.filter(skill => 
      skill.kind === 'attack' && !skill.aoe
    );
    
    if (singleAttackSkills.length > 0) {
      const selectedSkill = singleAttackSkills[Math.floor(Math.random() * singleAttackSkills.length)];
    const targetEnemy = aliveEnemies[Math.floor(Math.random() * aliveEnemies.length)];
    return {
      type: 'skill',
        skillId: selectedSkill.id,
      targetEnemyIndex: battle.enemies.indexOf(targetEnemy),
    };
    }
  }
  
  // 4. æ²’æœ‰ä½¿ç”¨æŠ€èƒ½ï¼Œä½¿ç”¨æ™®é€šæ”»æ“Š
  const targetEnemy = aliveEnemies[Math.floor(Math.random() * aliveEnemies.length)];
  return {
    type: 'attack',
    targetEnemyIndex: battle.enemies.indexOf(targetEnemy),
  };
}

// æ±ºå®šæ•µäººçš„è¡Œå‹•ï¼ˆè¿”å›è¡Œå‹•å°è±¡ï¼Œä¸åŸ·è¡Œï¼‰
function determineEnemyAction(enemy, battle) {
  if (!enemy || enemy.stats.hp <= 0) return null;
  
  const hero = state.hero;
  const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
  
  // æª¢æŸ¥æ˜¯å¦æœ‰å˜²è«·ç›®æ¨™ï¼ˆä½¿ç”¨å‚·å®³æ¸›å…çš„è§’è‰²ï¼‰
  // å¦‚æœæœ‰å˜²è«·ç›®æ¨™ä¸”é‚„æ´»è‘—ï¼Œå–®é«”æ”»æ“Šå¿…é ˆæ”»æ“Šè©²ç›®æ¨™
  let target = null;
  if (battle.tauntTarget && battle.tauntTarget.character && battle.tauntTarget.character.stats.hp > 0) {
    // æœ‰å˜²è«·ç›®æ¨™ï¼Œç›´æ¥ä½¿ç”¨è©²ç›®æ¨™ï¼ˆ100%å¸å¼•å–®é«”æ”»æ“Šï¼‰
    target = battle.tauntTarget;
  } else {
    // æ²’æœ‰å˜²è«·ç›®æ¨™æˆ–å˜²è«·ç›®æ¨™å·²æ­»äº¡ï¼Œä½¿ç”¨æ­£å¸¸çš„ç›®æ¨™é¸æ“‡é‚è¼¯
    // æ¸…é™¤å·²æ­»äº¡çš„å˜²è«·ç›®æ¨™
    if (battle.tauntTarget) {
      battle.tauntTarget = null;
    }
  
  // è¨ˆç®—ç›®æ¨™çš„æ”»æ“Šæ©Ÿç‡åŠ æ¬Šå€¼ï¼ˆæ¯å›åˆé–‹å§‹æ™‚é‡æ–°è¨ˆç®—ï¼‰
  // å…¬å¼ï¼š(æ”»æ“Š/2 + é˜²ç¦¦ + é«”åŠ›Ã—2) Ã— (1 + æŠ€èƒ½åŠ æ¬Š)
  // å¦‚æœä½¿ç”¨äº†å‚·å®³æ¸›å…æŠ€èƒ½ï¼Œå† Ã— 10å€
  function calculateTargetWeight(character, characterType) {
    let attrs;
    if (characterType === 'hero') {
      attrs = getHeroTotalAttributes(character);
    } else {
      attrs = getCompanionTotalAttributes(character);
    }
    
    // åŸºç¤åŠ æ¬Š = æ”»æ“Š/2 + é˜²ç¦¦ + é«”åŠ›Ã—2
    const baseWeight = Math.floor(attrs.attack / 2) + attrs.defense + attrs.vitality * 2;
    
    // æ‡‰ç”¨é˜²å®ˆå‹è¢«å‹•æŠ€èƒ½ï¼šå¢åŠ è¢«æ”»æ“Šæ©Ÿç‡ï¼ˆæŠ€èƒ½åŠ æ¬Šï¼‰
    const defenderEffects = characterType === 'hero' 
      ? getDefenderPassiveEffects(character)
      : getDefenderPassiveEffects(character);
    let skillMultiplier = 1.0;
    if (defenderEffects.aggroBoost > 0) {
      skillMultiplier = 1 + defenderEffects.aggroBoost;
    }
    
    // è¨ˆç®—åŠ æ¬Š = åŸºç¤åŠ æ¬Š Ã— (1 + æŠ€èƒ½åŠ æ¬Š + è£å‚™åŠ æ¬Š)
    // è£å‚™çš„è¢«æ”»æ“Šç‡åŠ æˆå·²é€šé getDefenderPassiveEffects è¨ˆç®—
    let weight = baseWeight * skillMultiplier;
    
    // æª¢æŸ¥æ˜¯å¦ä½¿ç”¨äº†å‚·å®³æ¸›å…æŠ€èƒ½ï¼ˆæœ¬å›åˆï¼‰
    // å¦‚æœä½¿ç”¨äº†å‚·å®³æ¸›å…ï¼ŒåŠ æ¬Š Ã— 10å€
    if (characterType === 'hero') {
      if (battle.heroBuffs && battle.heroBuffs.guard > 0) {
        // ä½¿ç”¨äº†å‚·å®³æ¸›å…ï¼ŒåŠ æ¬Š Ã— 10å€
        weight = weight * 10;
      }
    } else {
      // åŒä¼´
      if (battle.companionBuffs && battle.companionBuffs.guard > 0) {
        // ä½¿ç”¨äº†å‚·å®³æ¸›å…ï¼ŒåŠ æ¬Š Ã— 10å€
        weight = weight * 10;
      }
    }
    
    return Math.round(weight);
  }
  }
  
  // é¸æ“‡ç›®æ¨™ï¼ˆæ ¹æ“šæ–°çš„åŠ æ¬Šè¨ˆç®—å…¬å¼ï¼‰
  const targets = [];
  if (hero.stats.hp > 0) {
    const heroWeight = calculateTargetWeight(hero, 'hero');
    targets.push({ type: 'hero', character: hero, weight: heroWeight });
  }
  // æ·»åŠ æ‰€æœ‰æ´»ç€çš„åŒä¼´ä½œä¸ºç›®æ ‡
  const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
  activeCompanions.forEach(companion => {
    const companionWeight = calculateTargetWeight(companion, 'companion');
    targets.push({ type: 'companion', character: companion, weight: companionWeight });
  });
  
  if (targets.length === 0) return null;
  
  // ä½¿ç”¨åŠ æ¬Šéš¨æ©Ÿé¸æ“‡ç›®æ¨™
  const totalWeight = targets.reduce((sum, t) => sum + t.weight, 0);
  let random = Math.random() * totalWeight;
  for (const t of targets) {
    random -= t.weight;
    if (random <= 0) {
      target = t;
      break;
    }
  }
  // å¦‚æœå› ç‚ºæµ®é»æ•¸ç²¾åº¦å•é¡Œæ²’æœ‰é¸ä¸­ï¼Œé¸æ“‡æœ€å¾Œä¸€å€‹
  if (!target) {
    target = targets[targets.length - 1];
  }
  
  // æª¢æŸ¥æ˜¯å¦æœ‰å¯ç”¨æŠ€èƒ½ï¼ˆæ ¹æ“šæ¯å€‹æŠ€èƒ½çš„æ¦‚ç‡ï¼‰
  // skills æ ¼å¼ï¼š[{id: 'skill_id', probability: 0.2}, ...]
  // æ¯å€‹æŠ€èƒ½æœ‰ç¨ç«‹çš„æ¦‚ç‡ï¼Œä¾‹å¦‚ 0.3 å°±æ˜¯ 30% ä½¿ç”¨é€™å€‹æŠ€èƒ½
  const availableSkills = (enemy.skills || [])
    .map(skillEntry => {
      const skill = SKILL_LOOKUP.get(skillEntry.id || skillEntry);
      if (!skill || skill.kind === 'passive' || (skill.mpCost || 0) > enemy.stats.mp) {
        return null;
      }
      // å¦‚æœæ˜¯æ–°æ ¼å¼ï¼ˆå°è±¡ï¼‰ï¼Œä½¿ç”¨ probabilityï¼›å¦‚æœæ˜¯èˆŠæ ¼å¼ï¼ˆå­—ç¬¦ä¸²ï¼‰ï¼Œä½¿ç”¨é»˜èªæ¦‚ç‡ 0.2
      const probability = typeof skillEntry === 'object' ? (skillEntry.probability || 0.2) : 0.2;
      return { skill, probability };
    })
    .filter(entry => entry !== null);
  
  // æ ¹æ“šæ¯å€‹æŠ€èƒ½çš„ç¨ç«‹æ¦‚ç‡é¸æ“‡æŠ€èƒ½
  // probability å€¼ç›´æ¥è¡¨ç¤ºç™¾åˆ†æ¯”ï¼š0.5 = 50%æ©Ÿç‡ä½¿ç”¨è©²æŠ€èƒ½
  if (enemy.stats.mp > 0 && availableSkills.length > 0) {
    // å°æ¯å€‹æŠ€èƒ½ç¨ç«‹åˆ¤æ–·æ˜¯å¦ä½¿ç”¨ï¼ˆæ ¹æ“šå…¶æ¦‚ç‡ï¼‰
    // ä½¿ç”¨ <= ç¢ºä¿æ¦‚ç‡å€¼ 0.5 å°æ‡‰ 50% æ©Ÿç‡ï¼ˆroll åœ¨ [0, 1) å€é–“ï¼Œroll <= 0.5 çš„æ¦‚ç‡æ˜¯ 50%ï¼‰
    for (const entry of availableSkills) {
      const roll = Math.random(); // 0 åˆ° 1 ä¹‹é–“çš„éš¨æ©Ÿæ•¸ï¼ˆä¸åŒ…æ‹¬1ï¼‰
      if (roll <= entry.probability) {
        // é€™å€‹æŠ€èƒ½è¢«é¸ä¸­ï¼Œä½¿ç”¨å®ƒ
        // probability = 0.5 æ™‚ï¼Œroll <= 0.5 çš„æ¦‚ç‡æ˜¯ 50%
        // AOEæŠ€èƒ½ä¸å—å˜²è«·å½±éŸ¿ï¼Œå–®é«”æŠ€èƒ½æ‰å—å˜²è«·å½±éŸ¿
        if (entry.skill.aoe) {
          // AOEæŠ€èƒ½ï¼šä¸éœ€è¦ç‰¹å®šç›®æ¨™
          return {
            type: 'skill',
            skillId: entry.skill.id,
            targetType: null,
            targetCharacter: null,
          };
        } else {
          // å–®é«”æŠ€èƒ½ï¼šå—å˜²è«·å½±éŸ¿ï¼Œå¿…é ˆæ”»æ“Šå˜²è«·ç›®æ¨™
    return {
      type: 'skill',
          skillId: entry.skill.id,
      targetType: target.type,
      targetCharacter: target.character,
    };
        }
      }
    }
    // å¦‚æœæ‰€æœ‰æŠ€èƒ½éƒ½æ²’æœ‰è¢«é¸ä¸­ï¼Œä½¿ç”¨æ™®é€šæ”»æ“Š
  }
  
  return {
    type: 'attack',
    targetType: target.type,
    targetCharacter: target.character,
  };
}

// åŸ·è¡Œè‹±é›„è¡Œå‹•
function executeHeroAction(action, resolve) {
  const battle = state.ui.battle;
  if (!action) {
    resolve();
    return;
  }
  
  if (action.type === 'attack') {
    // åŸ·è¡Œæ”»æ“Š
    let targetIndex = action.targetEnemyIndex;
    
    // å¦‚æœç›®æ ‡å·²æ­»äº¡ï¼Œè‡ªåŠ¨é€‰æ‹©ç¬¬ä¸€ä¸ªæ´»ç€çš„æ•Œäºº
    if (targetIndex < 0 || !battle.enemies[targetIndex] || battle.enemies[targetIndex].stats.hp <= 0) {
      const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
      if (aliveEnemies.length === 0) {
        // æ²¡æœ‰æ´»ç€çš„æ•Œäººï¼Œæˆ˜æ–—åº”è¯¥å·²ç»ç»“æŸ
        resolve();
        return;
      }
      targetIndex = battle.enemies.indexOf(aliveEnemies[0]);
    }
    
    battle.selectedEnemyIndex = targetIndex;
    performBasicAttackDirectly();
  } else if (action.type === 'skill') {
    // åŸ·è¡ŒæŠ€èƒ½
    const skill = SKILL_LOOKUP.get(action.skillId);
    if (skill && skill.aoe) {
      // å…¨ä½“æŠ€èƒ½ï¼šä¸éœ€è¦è®¾ç½®selectedEnemyIndexï¼Œç›´æ¥æ‰§è¡Œ
      battle.selectedEnemyIndex = null;
    } else if (action.targetEnemyIndex !== undefined && action.targetEnemyIndex !== null) {
      // å–®é«”æ”»æ“ŠæŠ€èƒ½ï¼šè¨­ç½®æ•µäººç›®æ¨™
      battle.selectedEnemyIndex = action.targetEnemyIndex;
    } else if (action.target === 'hero') {
      // å–®é«”å›å¾©æŠ€èƒ½ï¼šç›®æ¨™æ˜¯è‡ªå·±
      battle.selectedEnemyIndex = -1;
    } else if (action.target === 'companion') {
      // å–®é«”å›å¾©æŠ€èƒ½ï¼šç›®æ¨™æ˜¯åŒä¼´ï¼ˆä½¿ç”¨ç¬¬ä¸€å€‹æ´»è‘—çš„åŒä¼´ï¼‰
      // æ³¨æ„ï¼šé€™è£¡ä½¿ç”¨ -2 è¡¨ç¤ºç¬¬ä¸€å€‹åŒä¼´ï¼Œå¦‚æœéœ€è¦æ”¯æŒå¤šå€‹åŒä¼´ï¼Œéœ€è¦å‚³å…¥ companionIndex
      battle.selectedEnemyIndex = -2;
    } else if (action.companionIndex !== undefined && action.companionIndex !== null) {
      // å–®é«”å›å¾©æŠ€èƒ½ï¼šç›®æ¨™æ˜¯æŒ‡å®šçš„åŒä¼´ï¼ˆä½¿ç”¨ companionIndexï¼‰
      // companionIndex æ˜¯æ‰€æœ‰åŒä¼´çš„ç´¢å¼•ï¼ˆåŒ…æ‹¬å·²æ­»äº¡çš„ï¼‰ï¼Œè½‰æ›ç‚º selectedEnemyIndexï¼ˆ-2 - indexï¼‰
      battle.selectedEnemyIndex = -2 - action.companionIndex;
    } else {
      // å¦‚æœæ²’æœ‰æŒ‡å®šç›®æ¨™ï¼Œå°æ–¼æ”»æ“ŠæŠ€èƒ½ï¼Œè®“ performSkillDirectly è‡ªå‹•é¸æ“‡ç›®æ¨™
      battle.selectedEnemyIndex = null;
    }
    performSkillDirectly(action.skillId);
  } else if (action.type === 'guard') {
    // åŸ·è¡Œé˜²å®ˆ
    performGuardDirectly();
  } else if (action.type === 'item') {
    // ä½¿ç”¨é“å…·
    useBattleItemDirectly(action.itemId, action.target);
  }
  
  setTimeout(() => {
    // åŸ·è¡Œå®Œç•¢å¾Œé‡ç½®é¸æ“‡ç‹€æ…‹ï¼Œç¢ºä¿ä¸‹æ¬¡å¯ä»¥é‡æ–°é¸æ“‡ç›®æ¨™
    battle.selectedEnemyIndex = null;
    renderBattleDialog();
    resolve();
  }, 400);
}

// åŸ·è¡ŒåŒä¼´è¡Œå‹•
function executeCompanionAction(companion, action, resolve) {
  const battle = state.ui.battle;
  if (!action || !companion) {
    if (companion && !action) {
      pushBattleLog(`${companion.name}æ²’æœ‰è¡Œå‹•ã€‚`);
    }
    resolve();
    return;
  }
  
  // æª¢æŸ¥åŒä¼´æ˜¯å¦é‚„æ´»è‘—
  if (companion.stats.hp <= 0) {
    pushBattleLog(`${companion.name}å·²æ­»äº¡ï¼Œç„¡æ³•è¡Œå‹•ã€‚`);
    resolve();
    return;
  }
  
  if (action.type === 'attack') {
    // åŸ·è¡Œæ”»æ“Š
    let targetIndex = action.targetEnemyIndex;
    
    // å¦‚æœç›®æ ‡æ— æ•ˆæˆ–å·²æ­»äº¡ï¼Œè‡ªåŠ¨é€‰æ‹©ç¬¬ä¸€ä¸ªæ´»ç€çš„æ•Œäºº
    if (targetIndex === undefined || targetIndex === null ||
        targetIndex < 0 || !battle.enemies[targetIndex] || 
        battle.enemies[targetIndex].stats.hp <= 0) {
      const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
      if (aliveEnemies.length === 0) {
        // æ²¡æœ‰æ´»ç€çš„æ•Œäºº
        pushBattleLog(`${companion.name}è©¦åœ–æ”»æ“Šï¼Œä½†æ²’æœ‰å¯æ”»æ“Šçš„ç›®æ¨™ã€‚`);
        setTimeout(() => {
          renderBattleDialog();
          resolve();
        }, 400);
        return;
      }
      targetIndex = battle.enemies.indexOf(aliveEnemies[0]);
    }
    
    const targetEnemy = battle.enemies[targetIndex];
    if (targetEnemy && targetEnemy.stats.hp > 0) {
      performCompanionBasicAttackDirectly(companion, targetIndex);
    } else {
      // å¦‚æœè¿˜æ˜¯æ— æ•ˆï¼Œå†æ¬¡å°è¯•é€‰æ‹©ç¬¬ä¸€ä¸ªæ´»ç€çš„æ•Œäºº
      const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
      if (aliveEnemies.length > 0) {
        targetIndex = battle.enemies.indexOf(aliveEnemies[0]);
        performCompanionBasicAttackDirectly(companion, targetIndex);
      } else {
        pushBattleLog(`${companion.name}è©¦åœ–æ”»æ“Šï¼Œä½†æ²’æœ‰å¯æ”»æ“Šçš„ç›®æ¨™ã€‚`);
      }
    }
  } else if (action.type === 'skill') {
    // åŸ·è¡ŒæŠ€èƒ½
    const skill = SKILL_LOOKUP.get(action.skillId);
    if (skill) {
      // æª¢æŸ¥MPæ˜¯å¦è¶³å¤ 
      const mpCost = skill.mpCost || 0;
      if (companion.stats.mp < mpCost) {
        pushBattleLog(`${companion.name}MPä¸è¶³ï¼Œç„¡æ³•æ–½æ”¾ã€Œ${skill.name}ã€ã€‚`);
        // MPä¸è¶³æ™‚ä¹Ÿè¦resolve
        setTimeout(() => {
          renderBattleDialog();
          resolve();
        }, 400);
      } else {
        // å¢å¼·æŠ€èƒ½ï¼ˆå…‰ç’°ã€è‡ªèº«buffæˆ–é˜²æ­»è­·ç›¾ï¼‰è™•ç†
        if (skill.kind === 'enhance') {
          // æª¢æŸ¥æ˜¯å¦ç‚ºé˜²æ­»è­·ç›¾æŠ€èƒ½ï¼ˆé€šédeathWardå±¬æ€§æˆ–æŠ€èƒ½IDï¼‰
          const isDeathWardSkill = skill.deathWard || skill.id === 'sage_death_ward_1';
          if (isDeathWardSkill) {
            applyDeathWardToAllAllies(skill, companion, companion.name);
            setTimeout(() => {
              resolve();
            }, 400);
            return;
          }
          
          // æª¢æŸ¥æ˜¯å¦ç‚ºè‡ªèº«buffï¼ˆåŠæ„ï¼‰é‚„æ˜¯å…‰ç’°
          if (skill.selfBuff) {
            // åŠæ„æŠ€èƒ½ï¼šå°è‡ªå·±ä½¿ç”¨
            const mpCost = skill.mpCost || 0;
            if (companion.stats.mp < mpCost) {
              pushBattleLog(`${companion.name} MPä¸è¶³ï¼Œç„¡æ³•ä½¿ç”¨ã€Œ${skill.name}ã€ã€‚`);
              setTimeout(() => {
                renderBattleDialog();
                resolve();
              }, 400);
              return;
            }
            
            // æ¶ˆè€—MPï¼ˆæª¢æŸ¥å…ƒç´ å…±é³´æ•ˆæœï¼‰
            let actualMpCost = mpCost;
            if (mpCost > 0 && (skill.flow === 'magic' || skill.kind === 'heal')) {
              const magicEffects = getMagicPassiveEffects(companion);
              if (magicEffects.freeSpellChance > 0) {
                const triggerChance = Math.random();
                if (triggerChance < magicEffects.freeSpellChance) {
                  actualMpCost = 0;
                  pushBattleLog(`å…ƒç´ å…±é³´ï¼š${companion.name}ä½¿ç”¨ã€Œ${skill.name}ã€æ™‚ä¸æ¶ˆè€—MPï¼`);
                }
              }
            }
            companion.stats.mp -= actualMpCost;
            
            // æ‡‰ç”¨åŠæ„buff
            const attackBoost = skill.attackBoost || 0;
            const critBoost = skill.critBoost || 0;
            const duration = skill.duration || 3;
            
            const companionIndex = state.companions.indexOf(companion);
            if (companionIndex >= 0) {
              if (!battle.companionBuffs[companionIndex]) {
                battle.companionBuffs[companionIndex] = {};
              }
              battle.companionBuffs[companionIndex].swordIntent = {
                attackBoost: attackBoost,
                critBoost: critBoost,
                duration: duration,
              };
              pushBattleLog(`${companion.name}æ–½æ”¾ã€Œ${skill.name}ã€ï¼`);
              pushBattleLog(`â†’ æ”»æ“ŠåŠ›æå‡ ${Math.round(attackBoost * 100)}%ï¼Œæš´æ“Šç‡æå‡ ${critBoost}%ï¼ŒæŒçºŒ ${duration} å›åˆã€‚`);
            }
          } else {
            // å…‰ç’°æŠ€èƒ½ï¼šå…¨é«”æŠ€èƒ½ï¼Œä¸è€—MP
            useAuraSkill(companion, skill, companion.name, false);
          }
          setTimeout(() => {
            renderBattleDialog();
            resolve();
          }, 400);
          return;
        }
        
        // å¦‚æœæ˜¯æ”»æ“ŠæŠ€èƒ½ï¼Œéœ€è¦è¨­ç½®ç›®æ¨™æ•µäºº
        if (skill.kind === 'attack' && !skill.aoe) {
          // å–®é«”æ”»æ“ŠæŠ€èƒ½éœ€è¦ç›®æ¨™
          let targetIndex = action.targetEnemyIndex;
          
          // å¦‚æœç›®æ ‡æ— æ•ˆæˆ–å·²æ­»äº¡ï¼Œè‡ªåŠ¨é€‰æ‹©ç¬¬ä¸€ä¸ªæ´»ç€çš„æ•Œäºº
          if (targetIndex === undefined || targetIndex === null || 
              targetIndex < 0 || !battle.enemies[targetIndex] || 
              battle.enemies[targetIndex].stats.hp <= 0) {
            const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
            if (aliveEnemies.length === 0) {
              pushBattleLog(`${companion.name}è©¦åœ–æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œä½†æ²’æœ‰å¯æ”»æ“Šçš„ç›®æ¨™ã€‚`);
              setTimeout(() => {
                renderBattleDialog();
                resolve();
              }, 400);
              return;
            }
            targetIndex = battle.enemies.indexOf(aliveEnemies[0]);
          }
          
          battle.selectedEnemyIndex = targetIndex;
          performCompanionSkillDirectly(companion, skill, null);
        } else if (action.target === 'hero') {
          battle.selectedEnemyIndex = -1;
          performCompanionSkillDirectly(companion, skill, action.target);
        } else if (action.target === 'companion') {
          // å¦‚æœæ˜¯å¾©æ´»è¡“ï¼Œéœ€è¦è¨­ç½®æ­£ç¢ºçš„åŒä¼´ç´¢å¼•
          const isReviveSkill = skill.id === 'revive_companion';
          if (isReviveSkill && action.companionIndex !== undefined) {
            // å¾©æ´»è¡“ï¼šè¨­ç½®ç›®æ¨™åŒä¼´ç´¢å¼•ï¼ˆ-2è¡¨ç¤ºç¬¬ä¸€å€‹åŒä¼´ï¼Œ-3è¡¨ç¤ºç¬¬äºŒå€‹ï¼Œä»¥æ­¤é¡æ¨ï¼‰
            battle.selectedEnemyIndex = -(action.companionIndex + 2);
            battle.companionAction = { companionIndex: action.companionIndex };
          } else {
          battle.selectedEnemyIndex = -2;
          }
          performCompanionSkillDirectly(companion, skill, action.target);
        } else {
          // å…¨é«”æ”»æ“Šæˆ–å…¶ä»–æƒ…æ³
          performCompanionSkillDirectly(companion, skill, action.target);
        }
        
        // åŸ·è¡Œå®ŒæŠ€èƒ½å¾Œæ›´æ–°UIä¸¦resolve
        setTimeout(() => {
          renderBattleDialog();
          resolve();
        }, 400);
      }
    } else {
      pushBattleLog(`${companion.name}è©¦åœ–ä½¿ç”¨æŠ€èƒ½ï¼Œä½†æŠ€èƒ½ä¸å­˜åœ¨ã€‚`);
      setTimeout(() => {
        renderBattleDialog();
        resolve();
      }, 400);
    }
  } else if (action.type === 'item') {
    // ä½¿ç”¨é“å…·
    const hero = state.hero;
    if (!hero || !hero.items) {
      pushBattleLog(`${companion.name}è©¦åœ–ä½¿ç”¨é“å…·ï¼Œä½†æ²’æœ‰å¯ç”¨é“å…·ã€‚`);
      setTimeout(() => {
        renderBattleDialog();
        resolve();
      }, 400);
      return;
    }
    
    const itemEntry = hero.items.find(entry => entry.id === action.itemId);
    if (!itemEntry || itemEntry.qty <= 0) {
      pushBattleLog(`${companion.name}è©¦åœ–ä½¿ç”¨é“å…·ï¼Œä½†é“å…·å·²ç”¨å®Œã€‚`);
      setTimeout(() => {
        renderBattleDialog();
        resolve();
      }, 400);
      return;
    }
    
    const item = ITEM_LOOKUP.get(action.itemId);
    if (!item) {
      pushBattleLog(`${companion.name}è©¦åœ–ä½¿ç”¨é“å…·ï¼Œä½†é“å…·ä¸å­˜åœ¨ã€‚`);
      setTimeout(() => {
        renderBattleDialog();
        resolve();
      }, 400);
      return;
    }
    
    // ç¢ºå®šç›®æ¨™
    let targetCharacter = hero;
    let targetName = 'å‹‡è€…';
    if (action.target === 'companion') {
      // é¸æ“‡HPæœ€ä½çš„åŒä¼´ä½œç‚ºç›®æ¨™
      const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
      if (activeCompanions.length > 0) {
        const lowestCompanion = activeCompanions.reduce((min, c) => {
          const minHpPercent = min.stats.hp / min.stats.maxHp;
          const cHpPercent = c.stats.hp / c.stats.maxHp;
          return cHpPercent < minHpPercent ? c : min;
        });
        targetCharacter = lowestCompanion;
        targetName = lowestCompanion.name;
      }
    }
    
    // æ‡‰ç”¨é“å…·æ•ˆæœä¸¦è¨˜éŒ„æ¢å¾©å€¼
    let healAmount = 0;
    let mpAmount = 0;
    const oldHp = targetCharacter.stats.hp;
    const oldMp = targetCharacter.stats.mp;
    
    if (item.type === 'heal') {
      const newHp = Math.min(targetCharacter.stats.maxHp, targetCharacter.stats.hp + item.value);
      healAmount = Math.ceil(newHp - oldHp);
      targetCharacter.stats.hp = Math.ceil(newHp);
    } else if (item.type === 'mp') {
      const newMp = Math.min(targetCharacter.stats.maxMp, targetCharacter.stats.mp + item.value);
      mpAmount = Math.ceil(newMp - oldMp);
      targetCharacter.stats.mp = Math.ceil(newMp);
    } else if (item.type === 'full') {
      healAmount = Math.ceil(targetCharacter.stats.maxHp - oldHp);
      mpAmount = Math.ceil(targetCharacter.stats.maxMp - oldMp);
      targetCharacter.stats.hp = Math.ceil(targetCharacter.stats.maxHp);
      targetCharacter.stats.mp = Math.ceil(targetCharacter.stats.maxMp);
    }
    
    // æ¶ˆè€—é“å…·
    itemEntry.qty -= 1;
    if (itemEntry.qty <= 0) {
      hero.items = hero.items.filter(entry => entry.qty > 0);
    }
    
    // é¡¯ç¤ºè¨Šæ¯
    let logMsg = `${companion.name}å°${targetName}ä½¿ç”¨ ${item.name}ã€‚`;
    if (healAmount > 0 || mpAmount > 0) {
      const effects = [];
      if (healAmount > 0) effects.push(`å›å¾© ${healAmount} HP`);
      if (mpAmount > 0) effects.push(`å›å¾© ${mpAmount} MP`);
      logMsg += ` ${effects.join('ã€')}ï¼`;
    }
    
    pushBattleLog(logMsg);
  }
  
  setTimeout(() => {
    renderBattleDialog();
    resolve();
  }, 400);
}

// åŸ·è¡Œæ•µäººè¡Œå‹•
function executeEnemyAction(actionItem, resolve) {
  const battle = state.ui.battle;
  const { character: enemy, action, enemyIndex } = actionItem;
  
  if (!action || !enemy) {
    resolve();
    return;
  }
  
  if (action.type === 'attack') {
    // æ•µäººæ”»æ“Š
    const target = action.targetCharacter;
    if (target && target.stats.hp > 0) {
      performEnemyBasicAttackDirectly(enemy, target, enemyIndex);
    }
  } else if (action.type === 'skill') {
    // æ•µäººä½¿ç”¨æŠ€èƒ½
    const skill = SKILL_LOOKUP.get(action.skillId);
    if (skill) {
      const target = action.targetCharacter;
      if (target) {
        performEnemySkillDirectly(enemy, skill, target, enemyIndex);
      }
    }
  }
  
  setTimeout(() => {
    renderBattleDialog();
    resolve();
  }, 400);
}

// åŸ·è¡Œå–®å€‹è¡Œå‹•
function executeAction(actionItem) {
  return new Promise((resolve) => {
    const { type, character, action } = actionItem;
    
    if (type === 'hero') {
      executeHeroAction(action, resolve);
    } else if (type === 'companion') {
      executeCompanionAction(character, action, resolve);
    } else if (type === 'enemy') {
      executeEnemyAction(actionItem, resolve);
    } else {
      resolve();
    }
  });
}

// ========== ç›´æ¥åŸ·è¡Œå‡½æ•¸ï¼ˆä¸æª¢æŸ¥å›åˆï¼Œä¸åˆ‡æ›å›åˆï¼‰==========

// å‹‡è€…ç›´æ¥åŸ·è¡Œæ™®é€šæ”»æ“Š
function performBasicAttackDirectly() {
  const battle = state.ui.battle;
  if (!battle) return;
  
  let targetIndex = battle.selectedEnemyIndex;
  
  // å¦‚æœç›®æ ‡æ— æ•ˆæˆ–å·²æ­»äº¡ï¼Œè‡ªåŠ¨é€‰æ‹©ç¬¬ä¸€ä¸ªæ´»ç€çš„æ•Œäºº
  if (targetIndex < 0 || !battle.enemies[targetIndex] || battle.enemies[targetIndex].stats.hp <= 0) {
    const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
    if (aliveEnemies.length === 0) {
      // æ²¡æœ‰æ´»ç€çš„æ•Œäººï¼Œæˆ˜æ–—åº”è¯¥å·²ç»ç»“æŸ
      pushBattleLog('å‹‡è€…æ”»æ“Šï¼Œä½†æ²’æœ‰å¯æ”»æ“Šçš„ç›®æ¨™ã€‚');
      return;
    }
    targetIndex = battle.enemies.indexOf(aliveEnemies[0]);
    battle.selectedEnemyIndex = targetIndex;
  }
  
  const targetEnemy = battle.enemies[targetIndex];
  if (!targetEnemy || targetEnemy.stats.hp <= 0) {
    pushBattleLog('å‹‡è€…æ”»æ“Šï¼Œä½†ç›®æ¨™å·²æ­»äº¡ã€‚');
    return;
  }
  
  const hero = state.hero;
  
  // è¨ˆç®—å‘½ä¸­ç‡å’Œæœƒå¿ƒä¸€æ“Šç‡
  const hitRate = calculateHitRate(hero, null, targetEnemy);
  const critChance = calculateCritChance(hero, null);
  
  // æª¢æŸ¥æ˜¯å¦å‘½ä¸­
  const hitRoll = Math.random() * 100;
  if (hitRoll >= hitRate) {
    pushBattleLog(`å‹‡è€…æ”»æ“Šæœªå‘½ä¸­ï¼ (å‘½ä¸­ç‡: ${hitRate}%)`);
    return;
  }
  
  // æª¢æŸ¥æ˜¯å¦æœ‰åŠç¥ä¹‹è·¯è¢«å‹•æŠ€ï¼šæ™®æ”»è®Šç‚ºå…¨é«”æ”»æ“Š
  const weaponmasterEffects = getWeaponmasterPassiveEffects(hero);
  if (weaponmasterEffects.normalAttackAoe) {
    // å…¨é«”æ”»æ“Šï¼Œå‚·å®³8æˆ
    const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
    let totalDamage = 0;
    let hasCrit = false;
    
    aliveEnemies.forEach((enemy, index) => {
      const { damage, isCrit } = calculatePhysicalDamage(1, enemy);
      // æ‡‰ç”¨å‚·å®³æ¯”ä¾‹ï¼ˆ8æˆï¼‰
      const adjustedDamage = Math.max(1, Math.round(damage * weaponmasterEffects.normalAttackDamageRatio));
      const enemyIndex = battle.enemies.indexOf(enemy);
      applyDamageToEnemyDirectly(enemyIndex, adjustedDamage, '', true, null, isCrit);
      totalDamage += adjustedDamage;
      if (isCrit) hasCrit = true;
    });
    
    const critMsg = hasCrit ? 'ï¼ˆæœƒå¿ƒä¸€æ“Šï¼ï¼‰' : '';
    pushBattleLog(`å‹‡è€…åŠæ°£ç¸±æ©«ï¼å°æ‰€æœ‰æ•µäººé€ æˆ ${totalDamage} ç¸½å‚·å®³ï¼${critMsg}`);
  } else {
    const { damage, isCrit } = calculatePhysicalDamage(1, targetEnemy);
    const critMsg = isCrit ? 'ï¼ˆæœƒå¿ƒä¸€æ“Šï¼ï¼‰' : '';
    pushBattleLog(`å‹‡è€…æ®åŠæ”»æ“Š (å‘½ä¸­ç‡: ${hitRate}%, æœƒå¿ƒ: ${critChance}%)ï¼Œé€ æˆ ${damage} å‚·å®³ï¼${critMsg}`);
    applyDamageToEnemyDirectly(targetIndex, damage, '', true, null, isCrit);
  }
  
  // æ‡‰ç”¨æ¢å¾©å‹è¢«å‹•æŠ€èƒ½ï¼šæ”»æ“Šæ•µäººå›å¾©MP
  const recoveryEffects = getRecoveryPassiveEffects(hero);
  if (recoveryEffects.attackMpReturn > 0 && damage > 0) {
    const oldMp = hero.stats.mp;
    hero.stats.mp = Math.min(hero.stats.maxMp, hero.stats.mp + recoveryEffects.attackMpReturn);
    const actualReturn = hero.stats.mp - oldMp;
    if (actualReturn > 0) {
      pushBattleLog(`æ¢å¾©å‹è¢«å‹•æŠ€èƒ½ï¼šæ”»æ“Šå›å¾© ${actualReturn} MPã€‚`);
    }
  }
}

// å‹‡è€…ç›´æ¥åŸ·è¡Œé˜²å®ˆ
function performGuardDirectly() {
  const battle = state.ui.battle;
  if (!battle) return;
  
  battle.heroBuffs.guard = Math.max(battle.heroBuffs.guard, 0.45);
  pushBattleLog('å‹‡è€…æ“ºå‡ºé˜²å®ˆå§¿æ…‹ï¼Œä¸‹ä¸€æ¬¡å—åˆ°çš„å‚·å®³å¤§å¹…é™ä½ã€‚');
}

// å‹‡è€…ç›´æ¥åŸ·è¡ŒæŠ€èƒ½
function performSkillDirectly(skillId) {
  const battle = state.ui.battle;
  if (!battle) {
    return;
  }
  
  const skill = SKILL_LOOKUP.get(skillId);
  if (!skill || skill.kind === 'passive') {
    pushBattleLog(`ç„¡æ³•ä½¿ç”¨æŠ€èƒ½ï¼šæŠ€èƒ½ä¸å­˜åœ¨æˆ–ç‚ºè¢«å‹•æŠ€èƒ½ã€‚`);
    return;
  }
  
  const hero = state.hero;
  if (!hero) {
    pushBattleLog(`ç„¡æ³•ä½¿ç”¨æŠ€èƒ½ï¼šå‹‡è€…ä¸å­˜åœ¨ã€‚`);
    return;
  }
  
  // æª¢æŸ¥ MP æ¶ˆè€—ï¼ˆå…‰ç’°æŠ€èƒ½ä¸è€—MPï¼‰
  const mpCost = skill.mpCost || 0;
  if (skill.kind !== 'enhance' && hero.stats.mp < mpCost) {
    pushBattleLog(`å‹‡è€… MP ä¸è¶³ï¼Œç„¡æ³•ä½¿ç”¨ã€Œ${skill.name}ã€ï¼`);
    return;
  }
  
  // å¢å¼·æŠ€èƒ½ï¼ˆå…‰ç’°ã€è‡ªèº«buffæˆ–é˜²æ­»è­·ç›¾ï¼‰è™•ç†
  if (skill.kind === 'enhance') {
    // æª¢æŸ¥æ˜¯å¦ç‚ºé˜²æ­»è­·ç›¾æŠ€èƒ½ï¼ˆé€šédeathWardå±¬æ€§æˆ–æŠ€èƒ½IDï¼‰
    const isDeathWardSkill = skill.deathWard || skill.id === 'sage_death_ward_1';
    if (isDeathWardSkill) {
      applyDeathWardToAllAllies(skill, hero, 'å‹‡è€…');
      return;
    }
    
    // æª¢æŸ¥æ˜¯å¦ç‚ºè‡ªèº«buffï¼ˆåŠæ„ï¼‰é‚„æ˜¯å…‰ç’°
    if (skill.selfBuff) {
      // è‡ªèº«buffæŠ€èƒ½ï¼ˆåŠæ„ï¼‰ï¼šæ¶ˆè€—MPï¼Œæå‡è‡ªèº«èƒ½åŠ›
      if (hero.stats.mp < mpCost) {
        pushBattleLog(`å‹‡è€… MP ä¸è¶³ï¼Œç„¡æ³•ä½¿ç”¨æ­¤æŠ€èƒ½ï¼`);
        renderBattleDialog();
        return;
      }
      
      hero.stats.mp -= mpCost;
      
      // æ‡‰ç”¨åŠæ„buff
      const attackBoost = skill.attackBoost || 0;
      const critBoost = skill.critBoost || 0;
      const duration = skill.duration || 3;
      
      battle.heroBuffs.swordIntent = {
        attackBoost: attackBoost,
        critBoost: critBoost,
        duration: duration,
      };
      pushBattleLog(`å‹‡è€…æ–½æ”¾ã€Œ${skill.name}ã€ï¼`);
      pushBattleLog(`â†’ æ”»æ“ŠåŠ›æå‡ ${Math.round(attackBoost * 100)}%ï¼Œæš´æ“Šç‡æå‡ ${critBoost}%ï¼ŒæŒçºŒ ${duration} å›åˆã€‚`);
      
      renderBattleDialog();
      return;
    }
    
    // å…¶ä»–enhanceæŠ€èƒ½ï¼ˆå…‰ç’°ï¼‰é€šéuseAuraSkillè™•ç†
    useAuraSkill(hero, skill, 'å‹‡è€…', true);
    renderBattleDialog();
    return;
  }
  
  // æ¶ˆè€—MPï¼ˆæª¢æŸ¥å…ƒç´ å…±é³´æ•ˆæœï¼‰
  const dynamicMp = calculateDynamicMpCost(skill, hero);
  let actualMpCost = dynamicMp.mpCost;
  battle.tempMpCost = dynamicMp.tempMpCost;
  if (!dynamicMp.tempMpCost) {
    // éå‹•æ…‹MPï¼šæª¢æŸ¥å…ƒç´ å…±é³´å…è²»æ–½æ³•
    if (mpCost > 0 && (skill.flow === 'magic' || skill.kind === 'heal')) {
      const magicEffects = getMagicPassiveEffects(hero);
      if (magicEffects.freeSpellChance > 0) {
        const triggerChance = Math.random();
        if (triggerChance < magicEffects.freeSpellChance) {
          actualMpCost = 0;
          pushBattleLog(`å…ƒç´ å…±é³´ï¼šä½ ä½¿ç”¨ã€Œ${skill.name}ã€æ™‚ä¸æ¶ˆè€—MPï¼`);
        }
      }
    }
  }
  hero.stats.mp -= actualMpCost;
  
  // è™•ç†æ¨èº«æ–¬æŠ€èƒ½ï¼šæ‰£HPä¸¦è¨˜éŒ„æ‰£æ‰çš„HPå€¼
  const hpCostAmount = calculateAndApplyHpCost(skill, hero, '');
  
  // æ‡‰ç”¨åŠå£«å‹è¢«å‹•æŠ€èƒ½ï¼šä½¿ç”¨åŠæŠ€å¾Œè¿”å›MP
  const passiveEffects = getSwordPassiveEffects(hero);
  if (skill.flow === 'sword' && passiveEffects.mpReturnRate > 0 && skill.kind !== 'enhance') {
    const mpReturn = Math.round(mpCost * passiveEffects.mpReturnRate);
    if (mpReturn > 0) {
      hero.stats.mp = Math.min(hero.stats.maxMp, hero.stats.mp + mpReturn);
      pushBattleLog(`å‹‡è€…åŠæ°£å›æ¹§å›å¾©äº† ${mpReturn} MPï¼`);
    }
  }
  
  
  if (skill.kind === 'attack') {
    const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
    const isMultiHit = skill.hitCount && skill.hitCount > 1;
    
    // å…¨é«”æ”»æ“Š
    if (skill.aoe) {
      pushBattleLog(`å‹‡è€…æ–½æ”¾ã€Œ${skill.name}ã€ï¼`);
      
      // æª¢æŸ¥æ˜¯å¦ä½¿ç”¨äº†é˜²å®ˆè¡æ“ŠæŠ€èƒ½ï¼ˆdefense_wave_*ï¼‰
      if (skill.id && skill.id.startsWith('defense_wave_')) {
        if (!battle.defenseWaveUsers) {
          battle.defenseWaveUsers = [];
        }
        battle.defenseWaveUsers.push({ type: 'hero', character: hero });
      }
      
      let totalDamage = 0;
      battle.enemies.forEach((enemy, index) => {
        if (enemy.stats.hp > 0) {
          const enemyIndex = battle.enemies.indexOf(enemy);
          let { damage, isCrit } = calculateSkillDamage(skill, hero, enemy);
          // çµ±ä¸€æ‡‰ç”¨å‚·å®³ï¼ˆåŒ…å«å¾©ä»‡æ„å¿—æ•ˆæœï¼‰
          damage = applyDamageToEnemyUnified(enemy, damage, hero);
          totalDamage += damage;
          const critMsg = isCrit ? 'ï¼ˆæœƒå¿ƒä¸€æ“Šï¼ï¼‰' : '';
          // è§¸ç™¼å…ƒç´ å‹•ç•«
          triggerAttackAnimation(enemyIndex, isCrit, skill);
          // å¦‚æœæ˜¯æ¨èº«æ–¬ï¼Œé¡¯ç¤ºè©³ç´°ä¿¡æ¯
          if (skill.hpCostPercent && skill.attackBoostMultiplier && battle.tempHpCost > 0) {
            const hpCost = battle.tempHpCost;
            const multiplier = skill.attackBoostMultiplier;
            pushBattleLog(`â†’ å°${enemy.name}é€ æˆ ${damage} å‚·å®³ï¼ˆæ¶ˆè€— ${hpCost} HP Ã— ${multiplier}å€ï¼‰${critMsg}`);
          } else {
          pushBattleLog(`â†’ å°${enemy.name}é€ æˆ ${damage} å‚·å®³${critMsg}`);
          }
          
          if (enemy.stats.hp <= 0) {
            pushBattleLog(`â†’ ${enemy.name} è¢«æ“Šå€’ï¼`);
          }
          
          // æ‡‰ç”¨å¸è¡€è¢«å‹•
          if (skill.flow === 'sword') {
            const passiveEffects = getSwordPassiveEffects(hero);
            if (passiveEffects.lifestealRate > 0 && damage > 0) {
              const lifestealAmount = Math.max(1, Math.round(damage * passiveEffects.lifestealRate));
              hero.stats.hp = Math.min(hero.stats.maxHp, hero.stats.hp + lifestealAmount);
            }
          }
        }
      });
      
      // æ›´æ–°UIé¡¯ç¤º
      renderBattleDialog();
      
      // æ‡‰ç”¨æ¢å¾©å‹è¢«å‹•æŠ€èƒ½ï¼šæ”»æ“Šæ•µäººå›å¾©MPï¼ˆå…¨é«”æ”»æ“Šåªå›å¾©ä¸€æ¬¡ï¼‰
      if (totalDamage > 0) {
        const recoveryEffects = getRecoveryPassiveEffects(hero);
        if (recoveryEffects.attackMpReturn > 0) {
          const oldMp = hero.stats.mp;
          hero.stats.mp = Math.min(hero.stats.maxMp, hero.stats.mp + recoveryEffects.attackMpReturn);
          const actualReturn = hero.stats.mp - oldMp;
          if (actualReturn > 0) {
            pushBattleLog(`æ¢å¾©å‹è¢«å‹•æŠ€èƒ½ï¼šæ”»æ“Šå›å¾© ${actualReturn} MPã€‚`);
          }
        }
      }
      
      // æ‡‰ç”¨é­”æ³•å‹è¢«å‹•æŠ€èƒ½ï¼šæ³•è¡“æ”»æ“Šå›å¾©MPï¼ˆå…¨é«”æ³•è¡“æ”»æ“Šåªå›å¾©ä¸€æ¬¡ï¼‰
      if (skill.flow === 'magic' && totalDamage > 0) {
        const magicEffects = getMagicPassiveEffects(hero);
        if (magicEffects.spellMpReturn > 0) {
          const oldMp = hero.stats.mp;
          hero.stats.mp = Math.min(hero.stats.maxMp, hero.stats.mp + magicEffects.spellMpReturn);
          const actualReturn = hero.stats.mp - oldMp;
          if (actualReturn > 0) {
            pushBattleLog(`é­”æ³•å‹è¢«å‹•æŠ€èƒ½ï¼šæ³•è¡“æ”»æ“Šå›å¾© ${actualReturn} MPã€‚`);
          }
        }
      }
      
      // æª¢æŸ¥æ˜¯å¦æ‰€æœ‰æ•µäººéƒ½è¢«æ“Šå€’
      const allDefeated = battle.enemies.every(e => e.stats.hp <= 0);
      if (allDefeated) {
        setTimeout(() => {
          concludeBattle(true);
        }, 800);
        return;
      }
    } 
    // å¤šæ®µæ”»æ“Šï¼ˆé€£æ“Šæˆ–éš¨æ©Ÿï¼‰
    else if (isMultiHit) {
      const hitCount = skill.hitCount || 2;
      let totalDamage = 0;
      const hitDetails = []; // è¨˜éŒ„æ¯ä¸€ä¸‹æ”»æ“Šçš„è©³ç´°ä¿¡æ¯
      // é€£æ“ŠæŠ€èƒ½ï¼ˆagility_comboï¼‰éœ€è¦é¸æ“‡ç›®æ¨™ï¼Œå°åŒä¸€å€‹ç›®æ¨™é€²è¡Œå¤šæ¬¡æ”»æ“Š
      const isComboSkill = skill.id && (skill.id.startsWith('combo_strike_') || skill.id === 'agility_combo');
      
      pushBattleLog(`å‹‡è€…æ–½æ”¾ã€Œ${skill.name}ã€ï¼`);
      
      // å¦‚æœæ˜¯é€£æ“ŠæŠ€èƒ½ï¼Œå…ˆé¸æ“‡ç›®æ¨™
      let fixedTarget = null;
      if (isComboSkill) {
        // é€£æ“ŠæŠ€èƒ½ï¼šå°åŒä¸€å€‹ç›®æ¨™é€²è¡Œå¤šæ¬¡æ”»æ“Š
        if (battle.selectedEnemyIndex !== null && battle.selectedEnemyIndex >= 0) {
          fixedTarget = battle.enemies[battle.selectedEnemyIndex];
        } else {
          // å¦‚æœæ²’æœ‰é¸æ“‡ç›®æ¨™ï¼Œè‡ªå‹•é¸æ“‡ç¬¬ä¸€å€‹æ´»è‘—çš„æ•µäºº
          const aliveEnemiesList = battle.enemies.filter(e => e.stats.hp > 0);
          if (aliveEnemiesList.length > 0) {
            fixedTarget = aliveEnemiesList[0];
            battle.selectedEnemyIndex = battle.enemies.indexOf(fixedTarget);
          }
        }
      }
      
      for (let i = 0; i < hitCount; i++) {
        const aliveEnemiesList = battle.enemies.filter(e => e.stats.hp > 0);
        if (aliveEnemiesList.length === 0) break;
        
        // é€£æ“ŠæŠ€èƒ½ï¼šå°åŒä¸€å€‹ç›®æ¨™æ”»æ“Šï¼›éš¨æ©Ÿå¤šæ®µï¼šéš¨æ©Ÿé¸æ“‡ç›®æ¨™
        const target = isComboSkill && fixedTarget && fixedTarget.stats.hp > 0 
          ? fixedTarget 
          : aliveEnemiesList[Math.floor(Math.random() * aliveEnemiesList.length)];
        const targetIndex = battle.enemies.indexOf(target);
        let { damage, isCrit } = calculateSkillDamage(skill, hero, target);
        // çµ±ä¸€æ‡‰ç”¨å‚·å®³ï¼ˆåŒ…å«å¾©ä»‡æ„å¿—æ•ˆæœï¼‰
        damage = applyDamageToEnemyUnified(target, damage, hero);
        totalDamage += damage;
        const critMsg = isCrit ? 'ï¼ˆæœƒå¿ƒä¸€æ“Šï¼ï¼‰' : '';
        
        // è¨˜éŒ„æ¯ä¸€ä¸‹æ”»æ“Šçš„è©³ç´°ä¿¡æ¯
        hitDetails.push({
          target: target.name,
          damage: damage,
          isCrit: isCrit,
          hitNumber: i + 1
        });
        
        // é¡¯ç¤ºæ¯ä¸€ä¸‹æ”»æ“Š
        pushBattleLog(`â†’ ç¬¬${i + 1}æ“Šï¼šå°${target.name}é€ æˆ ${damage} å‚·å®³${critMsg}`);
        
        if (target.stats.hp <= 0) {
          pushBattleLog(`â†’ ${target.name} è¢«æ“Šå€’ï¼`);
          const allDefeated = battle.enemies.every(e => e.stats.hp <= 0);
          if (allDefeated) {
            setTimeout(() => {
              concludeBattle(true);
            }, 800);
            return;
          }
        }
        
        // æ‡‰ç”¨å¸è¡€è¢«å‹•
        if (skill.flow === 'sword') {
          const passiveEffects = getSwordPassiveEffects(hero);
          if (passiveEffects.lifestealRate > 0 && damage > 0) {
            const lifestealAmount = Math.max(1, Math.round(damage * passiveEffects.lifestealRate));
            hero.stats.hp = Math.min(hero.stats.maxHp, hero.stats.hp + lifestealAmount);
          }
        }
      }
      
      // é¡¯ç¤ºç¸½å‚·å®³
      pushBattleLog(`ç¸½å…±é€ æˆ ${totalDamage} å‚·å®³ï¼`);
      
      // æ›´æ–°UIé¡¯ç¤º
      renderBattleDialog();
      
      // æ‡‰ç”¨æ¢å¾©å‹è¢«å‹•æŠ€èƒ½ï¼šæ”»æ“Šæ•µäººå›å¾©MPï¼ˆå¤šæ®µæ”»æ“Šåªå›å¾©ä¸€æ¬¡ï¼‰
      if (totalDamage > 0) {
        const recoveryEffects = getRecoveryPassiveEffects(hero);
        if (recoveryEffects.attackMpReturn > 0) {
          const oldMp = hero.stats.mp;
          hero.stats.mp = Math.min(hero.stats.maxMp, hero.stats.mp + recoveryEffects.attackMpReturn);
          const actualReturn = hero.stats.mp - oldMp;
          if (actualReturn > 0) {
            pushBattleLog(`æ¢å¾©å‹è¢«å‹•æŠ€èƒ½ï¼šæ”»æ“Šå›å¾© ${actualReturn} MPã€‚`);
          }
        }
      }
      
      // æ‡‰ç”¨é­”æ³•å‹è¢«å‹•æŠ€èƒ½ï¼šæ³•è¡“æ”»æ“Šå›å¾©MPï¼ˆå¤šæ®µæ³•è¡“æ”»æ“Šåªå›å¾©ä¸€æ¬¡ï¼‰
      if (skill.flow === 'magic' && totalDamage > 0) {
        const magicEffects = getMagicPassiveEffects(hero);
        if (magicEffects.spellMpReturn > 0) {
          const oldMp = hero.stats.mp;
          hero.stats.mp = Math.min(hero.stats.maxMp, hero.stats.mp + magicEffects.spellMpReturn);
          const actualReturn = hero.stats.mp - oldMp;
          if (actualReturn > 0) {
            pushBattleLog(`é­”æ³•å‹è¢«å‹•æŠ€èƒ½ï¼šæ³•è¡“æ”»æ“Šå›å¾© ${actualReturn} MPã€‚`);
          }
        }
      }
      
      // æª¢æŸ¥æ˜¯å¦æ‰€æœ‰æ•µäººéƒ½è¢«æ“Šå€’
      const allDefeated = battle.enemies.every(e => e.stats.hp <= 0);
      if (allDefeated) {
        setTimeout(() => {
          concludeBattle(true);
        }, 800);
        return;
      }
    }
    // å–®é«”æ”»æ“Š
    else {
      let targetIndex = battle.selectedEnemyIndex;
      // å¦‚æœç›®æ¨™ç„¡æ•ˆï¼Œè‡ªå‹•é¸æ“‡ç¬¬ä¸€å€‹æ´»è‘—çš„æ•µäºº
      if (targetIndex === null || targetIndex === undefined || targetIndex < 0 || 
          !battle.enemies[targetIndex] || battle.enemies[targetIndex].stats.hp <= 0) {
        const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
        if (aliveEnemies.length > 0) {
          targetIndex = battle.enemies.indexOf(aliveEnemies[0]);
        } else {
          pushBattleLog(`å‹‡è€…æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œä½†æ²’æœ‰å¯æ”»æ“Šçš„ç›®æ¨™ã€‚`);
          return;
        }
      }
      
      const targetEnemy = battle.enemies[targetIndex];
      if (targetEnemy && targetEnemy.stats.hp > 0) {
        // è¨ˆç®—å‘½ä¸­ç‡å’Œæœƒå¿ƒä¸€æ“Šç‡
        const hitRate = calculateHitRate(hero, skill, targetEnemy);
        let critChance = 0;
        let critLabel = 'æœƒå¿ƒ';
        
        // é­”æ³•æŠ€èƒ½é¡¯ç¤ºé­”æ³•æš´æ“Šç‡ï¼Œå…¶ä»–æŠ€èƒ½é¡¯ç¤ºæ™®é€šæœƒå¿ƒä¸€æ“Šç‡
        if (skill.flow === 'magic') {
          const magicEffects = getMagicPassiveEffects(hero);
          critChance = magicEffects.magicCritChance || 0;
          critLabel = 'é­”æ³•æš´æ“Š';
        } else {
          critChance = calculateCritChance(hero, skill);
        }
        
        // æª¢æŸ¥æ˜¯å¦å‘½ä¸­
        const hitRoll = Math.random() * 100;
        if (hitRoll >= hitRate) {
          pushBattleLog(`å‹‡è€…æ–½æ”¾ã€Œ${skill.name}ã€æœªå‘½ä¸­ï¼ (å‘½ä¸­ç‡: ${hitRate}%)`);
          return;
        }
        
        let { damage, isCrit } = calculateSkillDamage(skill, hero, targetEnemy);
        // çµ±ä¸€æ‡‰ç”¨å‚·å®³ï¼ˆåŒ…å«å¾©ä»‡æ„å¿—æ•ˆæœï¼‰
        damage = applyDamageToEnemyUnified(targetEnemy, damage, hero);
        const critMsg = isCrit ? 'ï¼ˆæœƒå¿ƒä¸€æ“Šï¼ï¼‰' : '';
        const critDisplay = critChance > 0 ? `${critLabel}: ${critChance}%` : '';
        
        // è§¸ç™¼å…ƒç´ å‹•ç•«
        triggerAttackAnimation(targetIndex, isCrit, skill);
        
        // å¦‚æœæ˜¯æ¨èº«æ–¬ï¼Œé¡¯ç¤ºè©³ç´°ä¿¡æ¯
        if (skill.hpCostPercent && skill.attackBoostMultiplier && battle.tempHpCost > 0) {
          const hpCost = battle.tempHpCost;
          const multiplier = skill.attackBoostMultiplier;
          pushBattleLog(`å‹‡è€…æ–½æ”¾ã€Œ${skill.name}ã€ (å‘½ä¸­ç‡: ${hitRate}%${critDisplay ? `, ${critDisplay}` : ''})ï¼ˆæ¶ˆè€— ${hpCost} HP Ã— ${multiplier}å€ï¼‰ï¼Œå°${targetEnemy.name}é€ æˆ ${damage} å‚·å®³ï¼${critMsg}`);
        } else {
        pushBattleLog(`å‹‡è€…æ–½æ”¾ã€Œ${skill.name}ã€ (å‘½ä¸­ç‡: ${hitRate}%${critDisplay ? `, ${critDisplay}` : ''})ï¼Œå°${targetEnemy.name}é€ æˆ ${damage} å‚·å®³ï¼${critMsg}`);
        }
        
        // æ›´æ–°UIé¡¯ç¤º
        renderBattleDialog();
        
        // æ‡‰ç”¨å¸è¡€è¢«å‹•
        if (skill.flow === 'sword') {
          const passiveEffects = getSwordPassiveEffects(hero);
          if (passiveEffects.lifestealRate > 0 && damage > 0) {
            const lifestealAmount = Math.max(1, Math.round(damage * passiveEffects.lifestealRate));
            hero.stats.hp = Math.min(hero.stats.maxHp, hero.stats.hp + lifestealAmount);
            if (lifestealAmount > 0) {
              pushBattleLog(`å‹‡è€…å—œè¡€åŠè¡“å›å¾©äº† ${lifestealAmount} HPï¼`);
            }
          }
        }
        
        // æ‡‰ç”¨æ¢å¾©å‹è¢«å‹•æŠ€èƒ½ï¼šæ”»æ“Šæ•µäººå›å¾©MP
        const recoveryEffects = getRecoveryPassiveEffects(hero);
        if (recoveryEffects.attackMpReturn > 0 && damage > 0) {
          const oldMp = hero.stats.mp;
          hero.stats.mp = Math.min(hero.stats.maxMp, hero.stats.mp + recoveryEffects.attackMpReturn);
          const actualReturn = hero.stats.mp - oldMp;
          if (actualReturn > 0) {
            pushBattleLog(`æ¢å¾©å‹è¢«å‹•æŠ€èƒ½ï¼šæ”»æ“Šå›å¾© ${actualReturn} MPã€‚`);
          }
        }
        
        // æ‡‰ç”¨é­”æ³•å‹è¢«å‹•æŠ€èƒ½ï¼šæ³•è¡“æ”»æ“Šå›å¾©MP
        if (skill.flow === 'magic' && damage > 0) {
          const magicEffects = getMagicPassiveEffects(hero);
          if (magicEffects.spellMpReturn > 0) {
            const oldMp = hero.stats.mp;
            hero.stats.mp = Math.min(hero.stats.maxMp, hero.stats.mp + magicEffects.spellMpReturn);
            const actualReturn = hero.stats.mp - oldMp;
            if (actualReturn > 0) {
              pushBattleLog(`é­”æ³•å‹è¢«å‹•æŠ€èƒ½ï¼šæ³•è¡“æ”»æ“Šå›å¾© ${actualReturn} MPã€‚`);
            }
          }
        }
        
        // è–æ“Šï¼šå°æ•µäººé€ æˆå‚·å®³å¾Œï¼Œå›å¾©è‡ªå·±1/2æ²»ç™‚èƒ½åŠ›çš„HP
        const isEnhancedHeal = skill.id && skill.id.startsWith('enhanced_heal_');
        if (isEnhancedHeal && damage > 0) {
          const totalAttrs = getHeroTotalAttributes(hero);
          const recovery = totalAttrs.recovery;
          const healAmount = Math.floor(recovery / 2);
          const oldHeroHp = hero.stats.hp;
          hero.stats.hp = Math.min(hero.stats.maxHp, hero.stats.hp + healAmount);
          const actualHealed = hero.stats.hp - oldHeroHp;
          if (actualHealed > 0) {
            pushBattleLog(`â†’ å‹‡è€…å›å¾©äº† ${actualHealed} HPï¼ˆ${oldHeroHp} â†’ ${hero.stats.hp}ï¼‰`);
          }
        }
        
        // é–ƒé›»éˆï¼šå°ç¬¬ä¸€å€‹ç›®æ¨™é€ æˆå‚·å®³å¾Œï¼Œå½ˆè·³åˆ°å¦ä¸€å€‹éš¨æ©Ÿæ•µäºº
        if (skill.chainDamage && skill.chainRatio) {
          const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0 && e !== targetEnemy);
          if (aliveEnemies.length > 0) {
            // éš¨æ©Ÿé¸æ“‡å¦ä¸€å€‹æ•µäºº
            const chainTarget = aliveEnemies[Math.floor(Math.random() * aliveEnemies.length)];
            const chainTargetIndex = battle.enemies.indexOf(chainTarget);
            
            // è¨ˆç®—é€£é–å‚·å®³ï¼ˆåŸæœ¬å‚·å®³çš„80%ï¼‰
            const chainDamage = Math.max(1, Math.floor(damage * skill.chainRatio));
            const oldChainHp = chainTarget.stats.hp;
            chainTarget.stats.hp = Math.max(0, chainTarget.stats.hp - chainDamage);
            
            // è§¸ç™¼å…ƒç´ å‹•ç•«
            triggerAttackAnimation(chainTargetIndex, false, skill);
            
            pushBattleLog(`â†’ é–ƒé›»éˆå½ˆè·³åˆ°${chainTarget.name}ï¼Œé€ æˆ ${chainDamage} å‚·å®³ï¼`);
            
            // æª¢æŸ¥é€£é–ç›®æ¨™æ˜¯å¦è¢«æ“Šå€’
            if (chainTarget.stats.hp <= 0) {
              pushBattleLog(`â†’ ${chainTarget.name} è¢«æ“Šå€’ï¼`);
              const allDefeated = battle.enemies.every(e => e.stats.hp <= 0);
              if (allDefeated) {
                setTimeout(() => {
                  concludeBattle(true);
                }, 800);
                return;
              }
            }
            
            renderBattleDialog();
          }
        }
        
        // é…¸æ€§ç®­ï¼šé€ æˆé˜²å®ˆå€¼æ¸›å°‘æ•ˆæœï¼ˆå…©å›åˆï¼Œæ¸›å°‘1/3é˜²å®ˆå€¼ï¼‰
        if (skill.id && skill.id.startsWith('acid_arrow_') && skill.defenseDownDuration && skill.defenseDownRatio) {
          // åˆå§‹åŒ– enemyDebuffs
          if (!battle.enemyDebuffs) {
            battle.enemyDebuffs = {};
          }
          
          // è¨­ç½®é˜²å®ˆå€¼æ¸›å°‘ç‹€æ…‹ï¼ˆå¦‚æœå·²ç¶“æœ‰é˜²å®ˆå€¼æ¸›å°‘ç‹€æ…‹ï¼Œé‡ç½®æŒçºŒæ™‚é–“ï¼‰
          if (!battle.enemyDebuffs[targetIndex]) {
            battle.enemyDebuffs[targetIndex] = {};
          }
          
          const hadDefenseDown = battle.enemyDebuffs[targetIndex].defenseDown ? true : false;
          battle.enemyDebuffs[targetIndex].defenseDown = {
            duration: skill.defenseDownDuration, // æŒçºŒ2å›åˆ
            ratio: skill.defenseDownRatio // æ¸›å°‘1/3é˜²å®ˆå€¼
          };
          
          if (hadDefenseDown) {
            pushBattleLog(`â†’ ${targetEnemy.name}çš„é˜²å®ˆå€¼æ¸›å°‘æ•ˆæœè¢«åˆ·æ–°ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.defenseDownDuration}å›åˆä¸­ï¼Œé˜²å®ˆå€¼æ¸›å°‘ ${Math.round(skill.defenseDownRatio * 100)}%ã€‚`);
          } else {
            pushBattleLog(`â†’ ${targetEnemy.name}çš„é˜²å®ˆå€¼è¢«è…è•æ¸›å°‘ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.defenseDownDuration}å›åˆä¸­ï¼Œé˜²å®ˆå€¼æ¸›å°‘ ${Math.round(skill.defenseDownRatio * 100)}%ã€‚`);
          }
        }
        
        // å†°å‡é­”æ³•ï¼šé€ æˆæ¸›é€Ÿæ•ˆæœï¼ˆå…©å›åˆï¼Œæ¸›å°‘1/3é€Ÿåº¦ï¼‰
        if (skill.id && skill.id.startsWith('iceball_') && skill.slowDuration && skill.slowRatio) {
          // åˆå§‹åŒ– enemyDebuffs
          if (!battle.enemyDebuffs) {
            battle.enemyDebuffs = {};
          }
          
          // è¨­ç½®æ¸›é€Ÿç‹€æ…‹ï¼ˆå¦‚æœå·²ç¶“æœ‰æ¸›é€Ÿç‹€æ…‹ï¼Œé‡ç½®æŒçºŒæ™‚é–“ï¼‰
          if (!battle.enemyDebuffs[targetIndex]) {
            battle.enemyDebuffs[targetIndex] = {};
          }
          
          const hadSlow = battle.enemyDebuffs[targetIndex].slow ? true : false;
          battle.enemyDebuffs[targetIndex].slow = {
            duration: skill.slowDuration, // æŒçºŒ2å›åˆ
            ratio: skill.slowRatio // æ¸›å°‘1/3é€Ÿåº¦
          };
          
          if (hadSlow) {
            pushBattleLog(`â†’ ${targetEnemy.name}çš„æ¸›é€Ÿæ•ˆæœè¢«åˆ·æ–°ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.slowDuration}å›åˆä¸­ï¼Œé€Ÿåº¦æ¸›å°‘ ${Math.round(skill.slowRatio * 100)}%ã€‚`);
          } else {
            pushBattleLog(`â†’ ${targetEnemy.name}è¢«å†°å‡æ¸›é€Ÿï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.slowDuration}å›åˆä¸­ï¼Œé€Ÿåº¦æ¸›å°‘ ${Math.round(skill.slowRatio * 100)}%ã€‚`);
          }
        }
        
        // åˆºå®¢ä¹‹è·¯ï¼šä¸­æ¯’+é™ä½æ”»æ“ŠåŠ›
        if (skill.weaponmasterPath === 'assassin' && skill.poisonRatio && skill.attackDownRatio && skill.debuffDuration) {
          // åˆå§‹åŒ– enemyDebuffs
          if (!battle.enemyDebuffs) {
            battle.enemyDebuffs = {};
          }
          
          if (!battle.enemyDebuffs[targetIndex]) {
            battle.enemyDebuffs[targetIndex] = {};
          }
          
          // è¨ˆç®—ä¸­æ¯’å‚·å®³ï¼š20%æ•æ·
          const totalAttrs = getHeroTotalAttributes(hero);
          const agility = totalAttrs.agility || 0;
          const poisonDamage = Math.max(1, Math.floor(agility * skill.poisonRatio));
          const poisonDuration = skill.debuffDuration;
          
          // è¨­ç½®ä¸­æ¯’ç‹€æ…‹
          const hadPoison = battle.enemyDebuffs[targetIndex].poison ? true : false;
          battle.enemyDebuffs[targetIndex].poison = {
            duration: poisonDuration,
            damage: poisonDamage,
            casterAgility: agility
          };
          
          // è¨­ç½®æ”»æ“ŠåŠ›æ¸›å°‘ç‹€æ…‹
          const hadAttackDown = battle.enemyDebuffs[targetIndex].attackDown ? true : false;
          battle.enemyDebuffs[targetIndex].attackDown = {
            duration: skill.debuffDuration,
            ratio: skill.attackDownRatio
          };
          
          // ç«‹å³æ‡‰ç”¨ä¸€æ¬¡ä¸­æ¯’å‚·å®³
          const oldHp = targetEnemy.stats.hp;
          targetEnemy.stats.hp = Math.max(0, targetEnemy.stats.hp - poisonDamage);
          const immediateDamage = oldHp - targetEnemy.stats.hp;
          if (immediateDamage > 0) {
            pushBattleLog(`â†’ ${targetEnemy.name}ç«‹å³å—åˆ°ä¸­æ¯’å‚·å®³ ${immediateDamage} é»ï¼`);
          }
          
          if (hadPoison) {
            pushBattleLog(`â†’ ${targetEnemy.name}çš„æ¯’è¢«åˆ·æ–°ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${poisonDuration}å›åˆä¸­ï¼Œæ¯å›åˆçµæŸæ™‚å—åˆ° ${poisonDamage} å‚·å®³ã€‚`);
          } else {
            pushBattleLog(`â†’ ${targetEnemy.name}ä¸­æ¯’äº†ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${poisonDuration}å›åˆä¸­ï¼Œæ¯å›åˆçµæŸæ™‚å—åˆ° ${poisonDamage} å‚·å®³ã€‚`);
          }
          
          if (hadAttackDown) {
            pushBattleLog(`â†’ ${targetEnemy.name}çš„æ”»æ“ŠåŠ›æ¸›å°‘æ•ˆæœè¢«åˆ·æ–°ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.debuffDuration}å›åˆä¸­ï¼Œæ”»æ“ŠåŠ›æ¸›å°‘ ${Math.round(skill.attackDownRatio * 100)}%ã€‚`);
          } else {
            pushBattleLog(`â†’ ${targetEnemy.name}çš„æ”»æ“ŠåŠ›è¢«å‰Šå¼±ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.debuffDuration}å›åˆä¸­ï¼Œæ”»æ“ŠåŠ›æ¸›å°‘ ${Math.round(skill.attackDownRatio * 100)}%ã€‚`);
          }
          
          // æš—å½±çªè¥²ä½¿ç”¨å¾Œæ¶ˆè€—ç ´ç”²ä¹‹åˆƒbuffï¼ˆå‹‡è€…ï¼‰
          if (battle.heroBuffs && battle.heroBuffs.ignoreDefense) {
            battle.heroBuffs.ignoreDefense = false;
            pushBattleLog(`â†’ å‹‡è€…çš„ç ´ç”²ä¹‹åˆƒæ•ˆæœå·²æ¶ˆè€—ï¼`);
          }
        }
        // è…æ“Šï¼šé™ä½æ•µäººæ”»æ“ŠåŠ›1/3ï¼ˆæŒçºŒ2å›åˆï¼‰
        else if (skill.id && skill.id.startsWith('kidney_strike_') && skill.attackDownDuration && skill.attackDownRatio) {
          // åˆå§‹åŒ– enemyDebuffs
          if (!battle.enemyDebuffs) {
            battle.enemyDebuffs = {};
          }
          
          // è¨­ç½®æ”»æ“ŠåŠ›æ¸›å°‘ç‹€æ…‹ï¼ˆå¦‚æœå·²ç¶“æœ‰æ”»æ“ŠåŠ›æ¸›å°‘ç‹€æ…‹ï¼Œé‡ç½®æŒçºŒæ™‚é–“ï¼‰
          if (!battle.enemyDebuffs[targetIndex]) {
            battle.enemyDebuffs[targetIndex] = {};
          }
          
          const hadAttackDown = battle.enemyDebuffs[targetIndex].attackDown ? true : false;
          battle.enemyDebuffs[targetIndex].attackDown = {
            duration: skill.attackDownDuration, // æŒçºŒ2å›åˆ
            ratio: skill.attackDownRatio // æ¸›å°‘1/3æ”»æ“ŠåŠ›
          };
          
          if (hadAttackDown) {
            pushBattleLog(`â†’ ${targetEnemy.name}çš„æ”»æ“ŠåŠ›æ¸›å°‘æ•ˆæœè¢«åˆ·æ–°ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.attackDownDuration}å›åˆä¸­ï¼Œæ”»æ“ŠåŠ›æ¸›å°‘ ${Math.round(skill.attackDownRatio * 100)}%ã€‚`);
          } else {
            pushBattleLog(`â†’ ${targetEnemy.name}çš„æ”»æ“ŠåŠ›è¢«å‰Šå¼±ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.attackDownDuration}å›åˆä¸­ï¼Œæ”»æ“ŠåŠ›æ¸›å°‘ ${Math.round(skill.attackDownRatio * 100)}%ã€‚`);
          }
        }
        
        // æª¢æŸ¥æ˜¯å¦å·å–ï¼ˆå·è¥²æŠ€èƒ½ï¼‰- 50%æ©Ÿç‡å·å–è£å‚™ï¼Œ50%æ©Ÿç‡å·å–é‡‘å¹£
        if (skill.stealGold && skill.stealGoldChance && skill.stealGoldPercent && targetEnemy.goldDrop) {
          // æª¢æŸ¥è©²æ€ªç‰©æ˜¯å¦å·²è¢«å·é
          if (battle.stolenEnemies && battle.stolenEnemies.has(targetIndex)) {
            pushBattleLog(`${targetEnemy.name} å·²ç¶“æ²’æœ‰æ±è¥¿äº†ã€‚`);
          } else if (Math.random() < skill.stealGoldChance) {
            // æ¨™è¨˜è©²æ€ªç‰©å·²è¢«å·é
            if (!battle.stolenEnemies) {
              battle.stolenEnemies = new Set();
            }
            battle.stolenEnemies.add(targetIndex);
            
            // 50%æ©Ÿç‡å·å–è£å‚™ï¼Œ50%æ©Ÿç‡å·å–é‡‘å¹£
            const stealEquipment = Math.random() < 0.5;
            
            if (stealEquipment) {
              // å·å–è£å‚™ï¼šæ ¹æ“šç•¶å‰éšæ®µéš¨æ©Ÿç”Ÿæˆä¸€å€‹è£å‚™
              const currentTier = state.world.stage;
              const tierEquipment = EQUIPMENT.filter(eq => eq.tier === currentTier);
              if (tierEquipment.length > 0) {
                const equipment = tierEquipment[Math.floor(Math.random() * tierEquipment.length)];
                const itemId = `equipment_${equipment.id}`;
                const hasInBag = hero.items.some(entry => entry.id === itemId && entry.qty > 0);
                const isOwned = hero.equipmentInventory && hero.equipmentInventory.includes(equipment.id) || hasInBag;
                
                if (!isOwned) {
                  // æª¢æŸ¥é“å…·æ¬„æ˜¯å¦å·²æ»¿
                  limitInventorySize();
                  const currentItemCount = hero.items.filter(item => item.qty > 0).length;
                  
                  if (currentItemCount >= 8) {
                    // é“å…·æ¬„å·²æ»¿ï¼Œç›´æ¥æ·»åŠ åˆ°è£å‚™åº«å­˜
                    if (!hero.equipmentInventory) {
                      hero.equipmentInventory = [];
                    }
                    if (!hero.equipmentInventory.includes(equipment.id)) {
                      hero.equipmentInventory.push(equipment.id);
                      pushBattleLog(`å·è¥²æˆåŠŸï¼å·å–äº† ${equipment.name}ï¼ˆé“å…·æ¬„å·²æ»¿ï¼Œå·²æ”¾å…¥è£å‚™åº«å­˜ï¼‰ï¼`);
                    } else {
                      pushBattleLog(`å·è¥²æˆåŠŸï¼ä½†å·²æ“æœ‰ ${equipment.name}ã€‚`);
                    }
                  } else {
                    // å°‡è£å‚™æ”¾å…¥é“å…·è¢‹
                    let itemEntry = hero.items.find(entry => entry.id === itemId);
                    if (itemEntry) {
                      itemEntry.qty += 1;
                    } else {
                      hero.items.push({ id: itemId, qty: 1 });
                    }
                    pushBattleLog(`å·è¥²æˆåŠŸï¼å·å–äº† ${equipment.name}ï¼ˆå·²æ”¾å…¥é“å…·è¢‹ï¼‰ï¼`);
                  }
                } else {
                  pushBattleLog(`å·è¥²æˆåŠŸï¼ä½†å·²æ“æœ‰ ${equipment.name}ã€‚`);
                }
              } else {
                // å¦‚æœæ²’æœ‰è©²éšæ®µçš„è£å‚™ï¼Œæ”¹ç‚ºå·å–é‡‘å¹£
                const stolenGold = Math.max(1, Math.floor(targetEnemy.goldDrop * skill.stealGoldPercent));
                const currentGoldDrop = targetEnemy.goldDrop - (targetEnemy.stolenGold || 0);
                const actualStolen = Math.min(stolenGold, currentGoldDrop);
                if (actualStolen > 0) {
                  if (!targetEnemy.stolenGold) {
                    targetEnemy.stolenGold = 0;
                  }
                  targetEnemy.stolenGold += actualStolen;
                  hero.stats.gold += actualStolen;
                  pushBattleLog(`å·è¥²æˆåŠŸï¼å·å–äº† ${actualStolen} é‡‘å¹£ï¼`);
                }
              }
            } else {
              // å·å–é‡‘å¹£
              const stolenGold = Math.max(1, Math.floor(targetEnemy.goldDrop * skill.stealGoldPercent));
              // å¾æ•µäººçš„ goldDrop ä¸­æ‰£é™¤ï¼ˆå¦‚æœå·²ç¶“è¢«å·å–éï¼Œå¾å‰©é¤˜çš„æ‰£é™¤ï¼‰
              const currentGoldDrop = targetEnemy.goldDrop - (targetEnemy.stolenGold || 0);
              const actualStolen = Math.min(stolenGold, currentGoldDrop);
              if (actualStolen > 0) {
                if (!targetEnemy.stolenGold) {
                  targetEnemy.stolenGold = 0;
                }
                targetEnemy.stolenGold += actualStolen;
                hero.stats.gold += actualStolen;
                pushBattleLog(`å·è¥²æˆåŠŸï¼å·å–äº† ${actualStolen} é‡‘å¹£ï¼`);
              }
            }
          }
        }
        
        if (targetEnemy.stats.hp <= 0) {
          pushBattleLog(`${targetEnemy.name} è¢«æ“Šå€’ï¼`);
          const allDefeated = battle.enemies.every(e => e.stats.hp <= 0);
          if (allDefeated) {
            setTimeout(() => {
              concludeBattle(true);
            }, 800);
            return;
          }
        }
        
        // æ‡‰ç”¨é€£æ“Šè¢«å‹•ï¼šæœ‰æ©Ÿç‡å¤šæ”»æ“Š1æ¬¡ï¼ˆåƒ…åœ¨åŠæŠ€å¾Œï¼‰
        if (skill.flow === 'sword') {
          const passiveEffects = getSwordPassiveEffects(hero);
          if (passiveEffects.doubleAttackChance > 0 && Math.random() < passiveEffects.doubleAttackChance) {
            // æª¢æŸ¥ç›®æ¨™æ˜¯å¦é‚„æ´»è‘—
            if (targetEnemy.stats.hp > 0) {
              const result = calculateSkillDamage(skill, hero, targetEnemy);
              let doubleDamage = result.damage;
              const doubleIsCrit = result.isCrit;
              
              // çµ±ä¸€æ‡‰ç”¨å‚·å®³ï¼ˆåŒ…å«å¾©ä»‡æ„å¿—æ•ˆæœï¼‰
              doubleDamage = applyDamageToEnemyUnified(targetEnemy, doubleDamage, hero);
              
              // è§¸ç™¼é€£æ“Šå‹•ç•«
              triggerAttackAnimation(targetIndex, doubleIsCrit, skill);
              const doubleCritMsg = doubleIsCrit ? 'ï¼ˆæœƒå¿ƒä¸€æ“Šï¼ï¼‰' : '';
              pushBattleLog(`å‹‡è€…é€£æ“ŠæŠ€å·§è§¸ç™¼ï¼é¡å¤–é€ æˆ ${doubleDamage} å‚·å®³ï¼${doubleCritMsg}`);
              
              // é€£æ“Šä¹Ÿè§¸ç™¼å¸è¡€
              if (passiveEffects.lifestealRate > 0 && doubleDamage > 0) {
                const doubleLifesteal = Math.max(1, Math.round(doubleDamage * passiveEffects.lifestealRate));
                hero.stats.hp = Math.min(hero.stats.maxHp, hero.stats.hp + doubleLifesteal);
                pushBattleLog(`å‹‡è€…å—œè¡€åŠè¡“å›å¾©äº† ${doubleLifesteal} HPï¼`);
              }
              
              // é€£æ“Šä¹Ÿå¯èƒ½è§¸ç™¼å·å–ï¼ˆä½†æ©Ÿç‡è¼ƒä½ï¼Œåªåœ¨ç¬¬ä¸€æ¬¡æ”»æ“Šæœªè§¸ç™¼æ™‚ï¼‰- 50%æ©Ÿç‡å·å–è£å‚™ï¼Œ50%æ©Ÿç‡å·å–é‡‘å¹£
              if (skill.stealGold && skill.stealGoldChance && skill.stealGoldPercent && targetEnemy.goldDrop) {
                // æª¢æŸ¥è©²æ€ªç‰©æ˜¯å¦å·²è¢«å·é
                if (battle.stolenEnemies && battle.stolenEnemies.has(targetIndex)) {
                  // å·²è¢«å·éï¼Œä¸è§¸ç™¼é€£æ“Šå·å–
                } else {
                const currentGoldDrop = targetEnemy.goldDrop - (targetEnemy.stolenGold || 0);
                if (currentGoldDrop > 0 && Math.random() < (skill.stealGoldChance * 0.5)) {
                    // æ¨™è¨˜è©²æ€ªç‰©å·²è¢«å·é
                    if (!battle.stolenEnemies) {
                      battle.stolenEnemies = new Set();
                    }
                    battle.stolenEnemies.add(targetIndex);
                    
                  // 50%æ©Ÿç‡å·å–è£å‚™ï¼Œ50%æ©Ÿç‡å·å–é‡‘å¹£
                  const stealEquipment = Math.random() < 0.5;
                  
                  if (stealEquipment) {
                    // å·å–è£å‚™ï¼šæ ¹æ“šç•¶å‰éšæ®µéš¨æ©Ÿç”Ÿæˆä¸€å€‹è£å‚™
                    const currentTier = state.world.stage;
                    const tierEquipment = EQUIPMENT.filter(eq => eq.tier === currentTier);
                    if (tierEquipment.length > 0) {
                      const equipment = tierEquipment[Math.floor(Math.random() * tierEquipment.length)];
                      const itemId = `equipment_${equipment.id}`;
                      const hasInBag = hero.items.some(entry => entry.id === itemId && entry.qty > 0);
                      const isOwned = hero.equipmentInventory && hero.equipmentInventory.includes(equipment.id) || hasInBag;
                      
                      if (!isOwned) {
                        limitInventorySize();
                        const currentItemCount = hero.items.filter(item => item.qty > 0).length;
                        
                        if (currentItemCount >= 8) {
                          if (!hero.equipmentInventory) {
                            hero.equipmentInventory = [];
                          }
                          if (!hero.equipmentInventory.includes(equipment.id)) {
                            hero.equipmentInventory.push(equipment.id);
                            pushBattleLog(`é€£æ“Šå·è¥²ï¼é¡å¤–å·å–äº† ${equipment.name}ï¼ˆé“å…·æ¬„å·²æ»¿ï¼Œå·²æ”¾å…¥è£å‚™åº«å­˜ï¼‰ï¼`);
                          } else {
                            pushBattleLog(`é€£æ“Šå·è¥²ï¼ä½†å·²æ“æœ‰ ${equipment.name}ã€‚`);
                          }
                        } else {
                          let itemEntry = hero.items.find(entry => entry.id === itemId);
                          if (itemEntry) {
                            itemEntry.qty += 1;
                          } else {
                            hero.items.push({ id: itemId, qty: 1 });
                          }
                          pushBattleLog(`é€£æ“Šå·è¥²ï¼é¡å¤–å·å–äº† ${equipment.name}ï¼ˆå·²æ”¾å…¥é“å…·è¢‹ï¼‰ï¼`);
                        }
                      } else {
                        pushBattleLog(`é€£æ“Šå·è¥²ï¼ä½†å·²æ“æœ‰ ${equipment.name}ã€‚`);
                      }
                    } else {
                      // å¦‚æœæ²’æœ‰è©²éšæ®µçš„è£å‚™ï¼Œæ”¹ç‚ºå·å–é‡‘å¹£
                      const stolenGold = Math.max(1, Math.floor(targetEnemy.goldDrop * skill.stealGoldPercent * 0.5));
                      const actualStolen = Math.min(stolenGold, currentGoldDrop);
                      if (actualStolen > 0) {
                        if (!targetEnemy.stolenGold) {
                          targetEnemy.stolenGold = 0;
                        }
                        targetEnemy.stolenGold += actualStolen;
                        hero.stats.gold += actualStolen;
                        pushBattleLog(`é€£æ“Šå·è¥²ï¼é¡å¤–å·å–äº† ${actualStolen} é‡‘å¹£ï¼`);
                      }
                    }
                  } else {
                    // å·å–é‡‘å¹£
                    const stolenGold = Math.max(1, Math.floor(targetEnemy.goldDrop * skill.stealGoldPercent * 0.5));
                    const actualStolen = Math.min(stolenGold, currentGoldDrop);
                    if (actualStolen > 0) {
                      if (!targetEnemy.stolenGold) {
                        targetEnemy.stolenGold = 0;
                      }
                      targetEnemy.stolenGold += actualStolen;
                      hero.stats.gold += actualStolen;
                      pushBattleLog(`é€£æ“Šå·è¥²ï¼é¡å¤–å·å–äº† ${actualStolen} é‡‘å¹£ï¼`);
                      }
                    }
                  }
                }
              }
              
              renderBattleDialog();
              
              if (targetEnemy.stats.hp <= 0) {
                pushBattleLog(`${targetEnemy.name} è¢«æ“Šå€’ï¼`);
                const allDefeated = battle.enemies.every(e => e.stats.hp <= 0);
                if (allDefeated) {
                  setTimeout(() => {
                    concludeBattle(true);
                  }, 800);
                  return;
                }
              }
            }
          }
        }
      } else {
        pushBattleLog(`å‹‡è€…æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œä½†ç›®æ¨™å·²æ­»äº¡ã€‚`);
      }
    }
    battle.tempHpCost = 0;
  } else if (skill.kind === 'debuff') {
    // DebuffæŠ€èƒ½ï¼ˆä¸‹æ¯’ç­‰ï¼‰
    if (skill.id && skill.id.startsWith('poison_attack')) {
      // ä¸‹æ¯’æŠ€èƒ½
      const targetIndex = battle.selectedEnemyIndex;
      if (targetIndex === null || targetIndex < 0 || targetIndex >= battle.enemies.length) {
        pushBattleLog(`ç„¡æ³•ä½¿ç”¨ã€Œ${skill.name}ã€ï¼šéœ€è¦é¸æ“‡ç›®æ¨™ã€‚`);
        hero.stats.mp += mpCost; // é€€å›MP
        return;
      }
      
      const targetEnemy = battle.enemies[targetIndex];
      if (!targetEnemy || targetEnemy.stats.hp <= 0) {
        pushBattleLog(`ç„¡æ³•ä½¿ç”¨ã€Œ${skill.name}ã€ï¼šç›®æ¨™å·²æ­»äº¡ã€‚`);
        hero.stats.mp += mpCost; // é€€å›MP
        return;
      }
      
      // è¨ˆç®—æ–½æ³•è€…çš„æ•æ·å€¼
      const totalAttrs = getHeroTotalAttributes(hero);
      const casterAgility = totalAttrs.agility;
      
      // è¨ˆç®—ä¸­æ¯’å‚·å®³ï¼ˆæ ¹æ“šæŠ€èƒ½ç­‰ç´šçš„æ¯”ç‡ï¼‰
      const poisonDamage = Math.max(1, Math.floor(casterAgility * (skill.poisonRatio || 0.3)));
      const poisonDuration = skill.poisonDuration || 3;
      
      // åˆå§‹åŒ– enemyDebuffs
      if (!battle.enemyDebuffs) {
        battle.enemyDebuffs = {};
      }
      
      // è¨­ç½®ä¸­æ¯’ç‹€æ…‹ï¼ˆå¦‚æœå·²ç¶“æœ‰ä¸­æ¯’ç‹€æ…‹ï¼Œé‡ç½®æŒçºŒæ™‚é–“å’Œå‚·å®³ï¼Œè€Œä¸æ˜¯ç´¯åŠ ï¼‰
      if (!battle.enemyDebuffs[targetIndex]) {
        battle.enemyDebuffs[targetIndex] = {};
      }
      
      const hadPoison = battle.enemyDebuffs[targetIndex].poison ? true : false;
      battle.enemyDebuffs[targetIndex].poison = {
        duration: poisonDuration, // é‡ç½®æŒçºŒæ™‚é–“
        damage: poisonDamage, // ä½¿ç”¨æ–°çš„å‚·å®³å€¼
        casterAgility: casterAgility
      };
      
      pushBattleLog(`å‹‡è€…å°${targetEnemy.name}æ–½æ”¾ã€Œ${skill.name}ã€ï¼`);
      
      // ç«‹å³æ‡‰ç”¨ä¸€æ¬¡ä¸­æ¯’å‚·å®³ï¼ˆæ–½åŠ çš„é‚£ä¸€å›åˆå°±ç”Ÿæ•ˆï¼‰
      const oldHp = targetEnemy.stats.hp;
      targetEnemy.stats.hp = Math.max(0, targetEnemy.stats.hp - poisonDamage);
      const immediateDamage = oldHp - targetEnemy.stats.hp;
      if (immediateDamage > 0) {
        pushBattleLog(`â†’ ${targetEnemy.name}ç«‹å³å—åˆ°ä¸­æ¯’å‚·å®³ ${immediateDamage} é»ï¼`);
      }
      
      if (hadPoison) {
        pushBattleLog(`â†’ ${targetEnemy.name}çš„æ¯’è¢«åˆ·æ–°ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${poisonDuration}å›åˆä¸­ï¼Œæ¯å›åˆçµæŸæ™‚å—åˆ° ${poisonDamage} å‚·å®³ï¼ˆä¸å—é˜²å®ˆå½±éŸ¿ï¼‰ã€‚`);
      } else {
        pushBattleLog(`â†’ ${targetEnemy.name}ä¸­æ¯’äº†ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${poisonDuration}å›åˆä¸­ï¼Œæ¯å›åˆçµæŸæ™‚å—åˆ° ${poisonDamage} å‚·å®³ï¼ˆä¸å—é˜²å®ˆå½±éŸ¿ï¼‰ã€‚`);
      }
      
      battle.menu = 'root';
      endHeroTurn();
    } else {
      pushBattleLog(`æœªçŸ¥çš„debuffæŠ€èƒ½ï¼š${skill.name}ã€‚`);
    }
  } else if (skill.kind === 'support') {
    // è¼”åŠ©æŠ€èƒ½ï¼ˆè­·ç›¾ã€æ·¨åŒ–ç­‰ï¼‰
    
    // æª¢æŸ¥æ˜¯å¦ç‚ºæ·¨åŒ–æŠ€èƒ½
    const isPurifySkill = skill.id && (skill.id === 'purify_1' || skill.id === 'mass_purify_1');
    
    if (isPurifySkill) {
      // æ·¨åŒ–æŠ€èƒ½ï¼šè§£é™¤å‹æ–¹debuff
      hero.stats.mp -= mpCost;
      
      if (skill.aoe) {
        // å…¨é«”æ·¨åŒ–ï¼šè§£é™¤æ‰€æœ‰å‹æ–¹çš„æ‰€æœ‰debuff
        pushBattleLog(`å‹‡è€…æ–½æ”¾ã€Œ${skill.name}ã€ï¼`);
        let purifiedCount = 0;
        
        if (!battle.friendlyDebuffs) {
          battle.friendlyDebuffs = { hero: {}, companions: {} };
        }
        
        // è§£é™¤å‹‡è€…çš„debuff
        if (battle.friendlyDebuffs.hero && state.hero && state.hero.stats.hp > 0) {
          const heroDebuffCount = Object.keys(battle.friendlyDebuffs.hero).length;
          if (heroDebuffCount > 0) {
            battle.friendlyDebuffs.hero = {};
            purifiedCount++;
            pushBattleLog(`â†’ å‹‡è€…çš„æ‰€æœ‰debuffè¢«è§£é™¤ï¼`);
          }
        }
        
        // è§£é™¤æ‰€æœ‰åŒä¼´çš„debuff
        if (battle.friendlyDebuffs.companions) {
          const companionIndices = Object.keys(battle.friendlyDebuffs.companions).map(s => parseInt(s));
          companionIndices.forEach(companionIndex => {
            if (companionIndex >= 0 && companionIndex < state.companions.length) {
              const companion = state.companions[companionIndex];
              if (companion && companion.stats.hp > 0 && battle.friendlyDebuffs.companions[companionIndex]) {
                const debuffCount = Object.keys(battle.friendlyDebuffs.companions[companionIndex]).length;
                if (debuffCount > 0) {
                  delete battle.friendlyDebuffs.companions[companionIndex];
                  purifiedCount++;
                  pushBattleLog(`â†’ ${companion.name}çš„æ‰€æœ‰debuffè¢«è§£é™¤ï¼`);
                }
              }
            }
          });
        }
        
        if (purifiedCount === 0) {
          pushBattleLog(`â†’ æ²’æœ‰å‹æ–¹å—åˆ°debuffå½±éŸ¿ã€‚`);
        }
      } else {
        // å–®é«”æ·¨åŒ–ï¼šè§£é™¤ä¸€å€‹å‹æ–¹çš„æ‰€æœ‰debuff
        let targetCharacter = null;
        let targetName = '';
        
        if (battle.selectedEnemyIndex === -1) {
          // ç›®æ¨™æ˜¯è‡ªå·±
          targetCharacter = hero;
          targetName = 'è‡ªå·±';
        } else if (battle.selectedEnemyIndex !== null && battle.selectedEnemyIndex <= -2) {
          // ç›®æ¨™æ˜¯åŒä¼´
          const companionIndex = Math.abs(battle.selectedEnemyIndex) - 2;
          const allCompanions = (state.companions || []).filter(c => c && c.stats);
          if (companionIndex >= 0 && companionIndex < allCompanions.length) {
            targetCharacter = allCompanions[companionIndex];
            targetName = targetCharacter.name;
          }
        }
        
        if (!targetCharacter || targetCharacter.stats.hp <= 0) {
          pushBattleLog(`ç„¡æ³•ä½¿ç”¨ã€Œ${skill.name}ã€ï¼šç›®æ¨™ç„¡æ•ˆã€‚`);
          hero.stats.mp += mpCost; // é€€å›MP
          return;
        }
        
        pushBattleLog(`å‹‡è€…å°${targetName}æ–½æ”¾ã€Œ${skill.name}ã€ï¼`);
        
        if (!battle.friendlyDebuffs) {
          battle.friendlyDebuffs = { hero: {}, companions: {} };
        }
        
        const isTargetHero = targetCharacter === state.hero;
        if (isTargetHero) {
          if (battle.friendlyDebuffs.hero) {
            const debuffCount = Object.keys(battle.friendlyDebuffs.hero).length;
            if (debuffCount > 0) {
              battle.friendlyDebuffs.hero = {};
              pushBattleLog(`â†’ ${targetName}çš„æ‰€æœ‰debuffè¢«è§£é™¤ï¼`);
            } else {
              pushBattleLog(`â†’ ${targetName}æ²’æœ‰debuffç‹€æ…‹ã€‚`);
            }
          } else {
            pushBattleLog(`â†’ ${targetName}æ²’æœ‰debuffç‹€æ…‹ã€‚`);
          }
        } else {
          const companionIndex = state.companions.indexOf(targetCharacter);
          if (companionIndex >= 0) {
            if (!battle.friendlyDebuffs.companions[companionIndex]) {
              pushBattleLog(`â†’ ${targetName}æ²’æœ‰debuffç‹€æ…‹ã€‚`);
            } else {
              const debuffCount = Object.keys(battle.friendlyDebuffs.companions[companionIndex]).length;
              if (debuffCount > 0) {
                delete battle.friendlyDebuffs.companions[companionIndex];
                pushBattleLog(`â†’ ${targetName}çš„æ‰€æœ‰debuffè¢«è§£é™¤ï¼`);
              } else {
                pushBattleLog(`â†’ ${targetName}æ²’æœ‰debuffç‹€æ…‹ã€‚`);
              }
            }
          }
        }
      }
      
      battle.menu = 'root';
      endHeroTurn();
      return;
    }
    
    // å¦‚æœæ˜¯å…¨é«”è¼”åŠ©æŠ€èƒ½ï¼ˆè­·ç›¾ç­‰ï¼‰
    if (skill.aoe) {
      hero.stats.mp -= mpCost;
      pushBattleLog(`å‹‡è€…æ–½æ”¾ã€Œ${skill.name}ã€ï¼`);
      
      // è¨ˆç®—è­·ç›¾å€¼
      const totalAttrs = getHeroTotalAttributes(hero);
      const recovery = totalAttrs.recovery;
      const shieldAmount = skill.power + Math.floor(recovery / 2);
      
      // çµ¦è‡ªå·±æ·»åŠ è­·ç›¾
      if (hero.stats.hp > 0) {
        hero.stats.shield = (hero.stats.shield || 0) + shieldAmount;
        pushBattleLog(`â†’ å°è‡ªå·±æ–½åŠ  ${shieldAmount} è­·ç›¾ï¼`);
      }
      
      // çµ¦æ‰€æœ‰åŒä¼´æ·»åŠ è­·ç›¾
      const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
      activeCompanions.forEach(companion => {
        companion.stats.shield = (companion.stats.shield || 0) + shieldAmount;
        pushBattleLog(`â†’ å°${companion.name}æ–½åŠ  ${shieldAmount} è­·ç›¾ï¼`);
      });
    } else {
      // å–®é«”è¼”åŠ©æŠ€èƒ½
      let targetCharacter = null;
      let targetName = '';
      
      if (battle.selectedEnemyIndex === -1) {
        // ç›®æ¨™æ˜¯è‡ªå·±
        targetCharacter = hero;
        targetName = 'è‡ªå·±';
      } else if (battle.selectedEnemyIndex !== null && battle.selectedEnemyIndex <= -2) {
        // ç›®æ¨™æ˜¯åŒä¼´
        const companionIndex = Math.abs(battle.selectedEnemyIndex) - 2;
        const allCompanions = (state.companions || []).filter(c => c && c.stats);
        if (companionIndex >= 0 && companionIndex < allCompanions.length) {
          targetCharacter = allCompanions[companionIndex];
          targetName = targetCharacter.name;
        }
      }
      
      if (!targetCharacter || targetCharacter.stats.hp <= 0) {
        pushBattleLog(`å‹‡è€…è©¦åœ–æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œä½†ç›®æ¨™ç„¡æ•ˆã€‚`);
        return;
      }
      
      hero.stats.mp -= mpCost;
      
      // è¨ˆç®—è­·ç›¾å€¼
      const totalAttrs = getHeroTotalAttributes(hero);
      const recovery = totalAttrs.recovery;
      const shieldAmount = skill.power + Math.floor(recovery / 2);
      
      // çµ¦ç›®æ¨™æ·»åŠ è­·ç›¾
      targetCharacter.stats.shield = (targetCharacter.stats.shield || 0) + shieldAmount;
      pushBattleLog(`å‹‡è€…æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œå°${targetName}æ–½åŠ  ${shieldAmount} è­·ç›¾ï¼`);
    }
    
    renderBattleDialog();
    return;
  } else if (skill.kind === 'heal') {
    // å¦‚æœæ˜¯å…¨ä½“å›å¤æŠ€èƒ½ï¼Œç›´æ¥å¯¹æ‰€æœ‰å‹æ–¹ç”Ÿæ•ˆ
    if (skill.aoe) {
      let totalHeal = 0;
      pushBattleLog(`å‹‡è€…æ–½æ”¾ã€Œ${skill.name}ã€ï¼`);
      
      // æ²»ç–—è‡ªå·±ï¼ˆå‹‡è€…ï¼‰
      const selfAmount = calculateHealingFor(skill, hero);
      const oldHeroHp = hero.stats.hp;
      hero.stats.hp = Math.min(hero.stats.maxHp, hero.stats.hp + selfAmount);
      pushBattleLog(`â†’ å°è‡ªå·±å›å¾© ${selfAmount} HPï¼ˆ${oldHeroHp} â†’ ${hero.stats.hp}ï¼‰`);
      totalHeal += selfAmount;
      // è§¸ç™¼ç¥è–è­·ç›¾æ•ˆæœï¼ˆå¦‚æœæ˜¯ç¥è–è­·ç›¾æŠ€èƒ½ï¼‰
      applySacredShieldEffect(skill, hero, hero);
      
      // æ²»ç–—æ‰€æœ‰åŒä¼´ï¼ˆåŒ…æ‹¬å·²æ­»äº¡çš„ï¼Œä½†é€šå¸¸åªæ²»ç–—æ´»ç€çš„ï¼‰
      const activeCompanions = (state.companions || []).filter(c => c && c.stats);
      activeCompanions.forEach(companion => {
        // åªæ²»ç–—æ´»ç€çš„åŒä¼´ï¼Œå·²æ­»äº¡çš„åŒä¼´ä¸æ²»ç–—
        if (companion.stats.hp > 0) {
          const companionAmount = calculateHealingFor(skill, hero);
          const oldCompanionHp = companion.stats.hp;
          companion.stats.hp = Math.min(companion.stats.maxHp, companion.stats.hp + companionAmount);
          pushBattleLog(`â†’ å°${companion.name}å›å¾© ${companionAmount} HPï¼ˆ${oldCompanionHp} â†’ ${companion.stats.hp}ï¼‰`);
          totalHeal += companionAmount;
          // è§¸ç™¼ç¥è–è­·ç›¾æ•ˆæœï¼ˆå¦‚æœæ˜¯ç¥è–è­·ç›¾æŠ€èƒ½ï¼‰
          applySacredShieldEffect(skill, hero, companion);
        }
      });
      
      pushBattleLog(`ç¸½å…±å›å¾© ${totalHeal} HPï¼`);
    } else {
      // å–®é«”å›å¾©æŠ€èƒ½
      const isReviveSkill = skill.id === 'revive_companion';
    let target = null;
    if (battle.selectedEnemyIndex === -1) {
        // æ²»ç™‚è‡ªå·±ï¼ˆå¾©æ´»æŠ€èƒ½ä¸èƒ½å°è‡ªå·±ä½¿ç”¨ï¼‰
        if (!isReviveSkill) {
      target = hero;
        }
      } else if (battle.selectedEnemyIndex <= -2) {
        // æ²»ç™‚åŒä¼´ï¼š-2 è¡¨ç¤ºç¬¬ä¸€å€‹åŒä¼´ï¼Œ-3 è¡¨ç¤ºç¬¬äºŒå€‹ï¼Œä»¥æ­¤é¡æ¨
        const companionIndex = Math.abs(battle.selectedEnemyIndex) - 2;
        const allCompanions = (state.companions || []).filter(c => c && c.stats);
        if (isReviveSkill) {
          // å¾©æ´»æŠ€èƒ½ï¼šå¯ä»¥é¸æ“‡å·²æ­»äº¡çš„åŒä¼´
          target = allCompanions[companionIndex] || null;
        } else {
          // æ™®é€šæ²»ç™‚ï¼šåªèƒ½é¸æ“‡æ´»è‘—çš„åŒä¼´
          const activeCompanions = allCompanions.filter(c => c.stats.hp > 0);
        target = activeCompanions[companionIndex] || null;
        }
    } else if (battle.selectedEnemyIndex >= 0) {
      // æ²»ç™‚æ•µäºº
      target = battle.enemies[battle.selectedEnemyIndex];
    }
    
    if (target) {
        if (isReviveSkill && target.stats.hp <= 0) {
          // å¾©æ´»æŠ€èƒ½ï¼šå¾©æ´»å·²æ­»äº¡çš„åŒä¼´ï¼Œå›å¾©30%æœ€å¤§HP
          const revivePercent = skill.revivePercent || 0.3;
          const reviveHp = Math.max(1, Math.floor(target.stats.maxHp * revivePercent));
          target.stats.hp = reviveHp;
          pushBattleLog(`å‹‡è€…æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œå¾©æ´»äº†${target.name}ï¼Œå›å¾© ${reviveHp} HPï¼ˆ${target.stats.maxHp}çš„${Math.round(revivePercent * 100)}%ï¼‰ï¼`);
        } else if (!isReviveSkill && target.stats.hp > 0) {
          // æ™®é€šæ²»ç™‚ï¼šåªèƒ½æ²»ç™‚æ´»è‘—çš„è§’è‰²ï¼Œç„¡æ³•å¾©æ´»å·²æ­»äº¡çš„è§’è‰²
      const amount = calculateHealingFor(skill, hero);
      target.stats.hp = Math.ceil(Math.min(target.stats.maxHp, target.stats.hp + amount));
        const targetName = target === hero ? 'è‡ªå·±' : target.name;
      pushBattleLog(`å‹‡è€…æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œå°${targetName}å›å¾© ${amount} HPã€‚`);
        // è§¸ç™¼ç¥è–è­·ç›¾æ•ˆæœï¼ˆå¦‚æœæ˜¯ç¥è–è­·ç›¾æŠ€èƒ½ï¼‰
        applySacredShieldEffect(skill, hero, target);
        // è§¸ç™¼é˜²æ­»è­·ç›¾æ•ˆæœï¼ˆå¦‚æœæ˜¯é˜²æ­»è­·ç›¾æŠ€èƒ½ï¼‰
        applyDeathWardEffect(skill, hero, target);
        // è§¸ç™¼ç¥è–å›éŸ¿æ•ˆæœ
        applyHealingEchoEffect(skill, hero, target, amount);
        } else if (!isReviveSkill && target.stats.hp <= 0) {
          // æ™®é€šæ²»ç™‚æŠ€èƒ½ç„¡æ³•å¾©æ´»å·²æ­»äº¡çš„è§’è‰²
          pushBattleLog(`å‹‡è€…æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œä½†${target.name}å·²æ­»äº¡ï¼Œç„¡æ³•å›å¾©ã€‚`);
        }
      } else if (isReviveSkill) {
        pushBattleLog(`å‹‡è€…æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œä½†ç›®æ¨™ç„¡æ•ˆã€‚`);
      }
    }
  } else if (skill.kind === 'buff') {
    // è™•ç†å‚·å®³æ¸›å…æŠ€èƒ½
    if (skill.damageReduction !== undefined) {
      const damageReduction = skill.damageReduction;
      battle.heroBuffs.guard = Math.max(battle.heroBuffs.guard, damageReduction);
      pushBattleLog(`å‹‡è€…æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œé€™å›åˆå—åˆ°å‚·å®³æ¸›å°‘ ${Math.round(damageReduction * 100)}%ï¼`);
    } else {
      // åŸæœ‰çš„buffæŠ€èƒ½è™•ç†
    const guardBoost = Math.min(0.8, 0.3 + (skill.power || 0.3));
    battle.heroBuffs.guard = Math.max(battle.heroBuffs.guard, guardBoost);
    pushBattleLog(`å‹‡è€…æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œé˜²ç¦¦å¤§å¹…æå‡ã€‚`);
    }
  }
  
  battle.selectedEnemyIndex = null;
}

// ç›´æ¥æ‡‰ç”¨å‚·å®³åˆ°æ•µäººï¼ˆä¸æª¢æŸ¥å›åˆï¼‰
// è§¸ç™¼æ”»æ“Šå‹•ç•«
function triggerAttackAnimation(enemyIndex, isCrit = false, skill = null) {
  if (!dom.battleEnemySprites) return;
  
  // ä½¿ç”¨ data-enemy-sprite-index å±¬æ€§ä¾†æ‰¾åˆ°æ­£ç¢ºçš„æ•µäººç²¾éˆ
  const targetSprite = dom.battleEnemySprites.querySelector(`[data-enemy-sprite-index="${enemyIndex}"]`);
  if (!targetSprite) return;
  
  // ç§»é™¤ä¹‹å‰çš„å‹•ç•«é¡
  targetSprite.classList.remove('attacked', 'critical-hit', 'fire-hit', 'ice-hit', 'lightning-hit', 'explosion-hit');
  
  // å¼·åˆ¶é‡æ’ä»¥è§¸ç™¼å‹•ç•«
  void targetSprite.offsetWidth;
  
  // æ ¹æ“šæŠ€èƒ½é¡å‹é¸æ“‡å‹•ç•«
  let animationClass = 'attacked';
  let animationDuration = 400;
  
  if (skill) {
    const skillId = skill.id || '';
    // ç«é­”æ³•å‹•ç•«
    if (skillId.startsWith('fireball_')) {
      animationClass = 'fire-hit';
      animationDuration = 600;
    }
    // å†°é­”æ³•å‹•ç•«
    else if (skillId.startsWith('iceball_')) {
      animationClass = 'ice-hit';
      animationDuration = 600;
    }
    // é–ƒé›»é­”æ³•å‹•ç•«ï¼ˆå…¨é«”é–ƒé›»æ–¬ï¼‰
    else if (skillId === 'hero_blood_warrior_1' || skill.name && skill.name.includes('é–ƒé›»')) {
      animationClass = 'lightning-hit';
      animationDuration = 500;
    }
    // çˆ†ç‚¸é­”æ³•å‹•ç•«
    else if (skillId.startsWith('explosion_')) {
      animationClass = 'explosion-hit';
      animationDuration = 700;
    }
  }
  
  // å¦‚æœæ˜¯æœƒå¿ƒä¸€æ“Šï¼Œå„ªå…ˆä½¿ç”¨æœƒå¿ƒä¸€æ“Šå‹•ç•«
  if (isCrit && !skill) {
    animationClass = 'critical-hit';
    animationDuration = 600;
  }
  
  // æ·»åŠ å‹•ç•«é¡
  targetSprite.classList.add(animationClass);
  
  // å‹•ç•«çµæŸå¾Œç§»é™¤é¡
  setTimeout(() => {
    targetSprite.classList.remove(animationClass);
  }, animationDuration);
}

function applyDamageToEnemyDirectly(enemyIndex, damage, template, isBasicAttack = false, skill = null, isCrit = false, attacker = null) {
  const battle = state.ui.battle;
  if (!battle || enemyIndex < 0 || enemyIndex >= battle.enemies.length) return;
  
  const enemy = battle.enemies[enemyIndex];
  if (!enemy || enemy.stats.hp <= 0) return;
  
  // è§¸ç™¼æ”»æ“Šå‹•ç•«
  triggerAttackAnimation(enemyIndex, isCrit, skill);
  
  // ç¢ºå®šæ”»æ“Šè€…ï¼ˆå¦‚æœæ²’æœ‰å‚³å…¥ï¼Œä½¿ç”¨è‹±é›„ï¼‰
  const actualAttacker = attacker || state.hero;
  const isHero = actualAttacker === state.hero;
  
  // çµ±ä¸€æ‡‰ç”¨å‚·å®³ï¼ˆåŒ…å«å¾©ä»‡æ„å¿—æ•ˆæœï¼‰
  damage = applyDamageToEnemyUnified(enemy, damage, actualAttacker);
  
  // å¦‚æœæœ‰æ¨¡æ¿ï¼Œæ˜¾ç¤ºæ¶ˆæ¯ï¼ˆå¦åˆ™æ¶ˆæ¯å·²åœ¨è°ƒç”¨å¤„æ˜¾ç¤ºï¼‰
  if (template) {
    const message = template.replace('%d', damage.toString());
    pushBattleLog(message);
  }
  
  consumeBreakingArmor(actualAttacker, damage, isBasicAttack, skill);

  if (enemy.stats.hp <= 0) {
    pushBattleLog(`${enemy.name} è¢«æ“Šå€’ï¼`);
    const allDefeated = battle.enemies.every(e => e.stats.hp <= 0);
    if (allDefeated) {
      setTimeout(() => {
        concludeBattle(true);
      }, 800);
      return;
    }
  }
  
  // æ‡‰ç”¨é€£æ“Šè¢«å‹•ï¼šæœ‰æ©Ÿç‡å¤šæ”»æ“Š1æ¬¡ï¼ˆåƒ…åœ¨æ”»æ“Šæˆ–åŠæŠ€å¾Œï¼Œè‹±é›„å’ŒåŒä¼´éƒ½å¯ä»¥æœ‰é€£æ“Šè¢«å‹•ï¼‰
  const passiveEffects = getSwordPassiveEffects(actualAttacker);
  if (passiveEffects.doubleAttackChance > 0 && Math.random() < passiveEffects.doubleAttackChance) {
    // æª¢æŸ¥ç›®æ¨™æ˜¯å¦é‚„æ´»è‘—
    if (enemy.stats.hp > 0) {
      // åˆ¤æ–·æ˜¯æ™®é€šæ”»æ“Šé‚„æ˜¯åŠæŠ€
      let doubleDamage = 0;
      let doubleIsCrit = false;
      if (isBasicAttack) {
        if (isHero) {
          // è‹±é›„ä½¿ç”¨ calculatePhysicalDamage
          const result = calculatePhysicalDamage(1, enemy);
          doubleDamage = result.damage;
          doubleIsCrit = result.isCrit;
        } else {
          // åŒä¼´ä½¿ç”¨èˆ‡æ™®é€šæ”»æ“Šç›¸åŒçš„è¨ˆç®—é‚è¼¯
          const companionAttrs = getCompanionTotalAttributes(actualAttacker);
          const companionAttack = companionAttrs.attack;
          let companionDefense = enemy.attributes ? enemy.attributes.defense : (enemy.defense || 0);
          
          // æª¢æŸ¥æ˜¯å¦æœ‰ç ´ç”²ä¹‹åˆƒbuffï¼šç„¡è¦–é˜²ç¦¦
          const companionIndex = state.companions.indexOf(actualAttacker);
          if (companionIndex >= 0 && battle.companionBuffs && battle.companionBuffs[companionIndex] && battle.companionBuffs[companionIndex].ignoreDefense) {
            companionDefense = 0; // ç„¡è¦–é˜²ç¦¦
          }
          
          doubleDamage = Math.max(1, Math.round(companionAttack - companionDefense));
          doubleIsCrit = checkCrit(actualAttacker);
          if (doubleIsCrit) {
            doubleDamage = Math.round(doubleDamage * 2);
          }
        }
      } else if (skill && skill.flow === 'sword') {
        const result = calculateSkillDamage(skill, actualAttacker, enemy);
        doubleDamage = result.damage;
        doubleIsCrit = result.isCrit;
      } else {
        // éåŠæŠ€ä¸è§¸ç™¼é€£æ“Š
        return;
      }
      
      // çµ±ä¸€æ‡‰ç”¨å‚·å®³ï¼ˆåŒ…å«å¾©ä»‡æ„å¿—æ•ˆæœï¼‰
      doubleDamage = applyDamageToEnemyUnified(enemy, doubleDamage, actualAttacker);
      
      // è§¸ç™¼é€£æ“Šå‹•ç•«
      triggerAttackAnimation(enemyIndex, doubleIsCrit, skill);
      const critMsg = doubleIsCrit ? 'ï¼ˆæœƒå¿ƒä¸€æ“Šï¼ï¼‰' : '';
      const attackerName = isHero ? 'å‹‡è€…' : actualAttacker.name;
      pushBattleLog(`${attackerName}é€£æ“ŠæŠ€å·§è§¸ç™¼ï¼é¡å¤–é€ æˆ ${doubleDamage} å‚·å®³ï¼${critMsg}`);
      
      consumeBreakingArmor(actualAttacker, doubleDamage, isBasicAttack, skill);

      applyLifesteal(actualAttacker, doubleDamage, passiveEffects);

      renderBattleDialog();
      
      if (enemy.stats.hp <= 0) {
        pushBattleLog(`${enemy.name} è¢«æ“Šå€’ï¼`);
        const allDefeated = battle.enemies.every(e => e.stats.hp <= 0);
        if (allDefeated) {
          setTimeout(() => {
            concludeBattle(true);
          }, 800);
          return;
        }
      }
    }
  }
}

// åŒä¼´ç›´æ¥åŸ·è¡Œæ™®é€šæ”»æ“Š
function performCompanionBasicAttackDirectly(companion, targetIndex) {
  const battle = state.ui.battle;
  if (!battle || !companion) {
    if (companion) {
      pushBattleLog(`${companion.name}ç„¡æ³•æ”»æ“Šï¼ˆæˆ°é¬¥ç‹€æ…‹ç•°å¸¸ï¼‰ã€‚`);
    }
    return;
  }
  
  if (targetIndex < 0 || targetIndex >= battle.enemies.length) {
    pushBattleLog(`${companion.name}ç„¡æ³•æ”»æ“Šï¼ˆç›®æ¨™ç´¢å¼•ç„¡æ•ˆï¼‰ã€‚`);
    return;
  }
  
  let targetEnemy = battle.enemies[targetIndex];
  if (!targetEnemy) {
    pushBattleLog(`${companion.name}ç„¡æ³•æ”»æ“Šï¼ˆç›®æ¨™ä¸å­˜åœ¨ï¼‰ã€‚`);
    return;
  }
  
  // å¦‚æœç›®æ¨™å·²æ­»äº¡ï¼Œè‡ªå‹•é¸æ“‡ç¬¬ä¸€å€‹æ´»è‘—çš„æ•µäºº
  if (targetEnemy.stats.hp <= 0) {
    const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
    if (aliveEnemies.length === 0) {
      pushBattleLog(`${companion.name}æ”»æ“Šï¼Œä½†æ²’æœ‰å¯æ”»æ“Šçš„ç›®æ¨™ã€‚`);
      return;
    }
    // ä½¿ç”¨ç¬¬ä¸€å€‹æ´»è‘—çš„æ•µäºº
    targetIndex = battle.enemies.indexOf(aliveEnemies[0]);
    targetEnemy = battle.enemies[targetIndex];
    if (!targetEnemy || targetEnemy.stats.hp <= 0) {
      pushBattleLog(`${companion.name}æ”»æ“Šï¼Œä½†æ²’æœ‰å¯æ”»æ“Šçš„ç›®æ¨™ã€‚`);
      return;
    }
  }
  
  // æª¢æŸ¥åŒä¼´æ˜¯å¦é‚„æ´»è‘—
  if (companion.stats.hp <= 0) {
    pushBattleLog(`${companion.name}å·²æ­»äº¡ï¼Œç„¡æ³•æ”»æ“Šã€‚`);
    return;
  }
  
  const totalAttrs = getCompanionTotalAttributes(companion);
  const attack = totalAttrs.attack;
  let defense = targetEnemy.attributes ? targetEnemy.attributes.defense : (targetEnemy.defense || 0);
  
  // æª¢æŸ¥æ˜¯å¦æœ‰ç ´ç”²ä¹‹åˆƒbuffï¼šç„¡è¦–é˜²ç¦¦
  const companionIndex = state.companions.indexOf(companion);
  if (companionIndex >= 0 && battle.companionBuffs && battle.companionBuffs[companionIndex] && battle.companionBuffs[companionIndex].ignoreDefense) {
    defense = 0; // ç„¡è¦–é˜²ç¦¦
  }
  
  let damage = Math.max(1, Math.round(attack - defense));
  
  // æª¢æŸ¥æœƒå¿ƒä¸€æ“Šï¼ˆä½¿ç”¨èˆ‡å‹‡è€…ç›¸åŒçš„è¨ˆç®—æ–¹å¼ï¼‰
  const critChance = calculateCritChance(companion);
  const hitRate = calculateHitRate(companion, null, targetEnemy);
  
  // æª¢æŸ¥æ˜¯å¦å‘½ä¸­
  const hitRoll = Math.random() * 100;
  if (hitRoll >= hitRate) {
    pushBattleLog(`${companion.name}æ”»æ“Š${targetEnemy.name}æœªå‘½ä¸­ï¼ (å‘½ä¸­ç‡: ${hitRate}%)`);
    return;
  }
  
  // æª¢æŸ¥æ˜¯å¦æœ‰åŠç¥ä¹‹è·¯è¢«å‹•æŠ€ï¼šæ™®æ”»è®Šç‚ºå…¨é«”æ”»æ“Š
  const weaponmasterEffects = getWeaponmasterPassiveEffects(companion);
  if (weaponmasterEffects.normalAttackAoe) {
    // å…¨é«”æ”»æ“Šï¼Œå‚·å®³8æˆ
    const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
    let totalDamage = 0;
    let hasCrit = false;
    let buffRemoved = false; // æ¨™è¨˜æ˜¯å¦å·²ç§»é™¤ç ´ç”²ä¹‹åˆƒbuff
    
    aliveEnemies.forEach((enemy) => {
      const enemyAttrs = getCompanionTotalAttributes(companion);
      const enemyAttack = enemyAttrs.attack;
      let enemyDefense = enemy.attributes ? enemy.attributes.defense : (enemy.defense || 0);
      
      // æª¢æŸ¥æ˜¯å¦æœ‰ç ´ç”²ä¹‹åˆƒbuffï¼šç„¡è¦–é˜²ç¦¦ï¼ˆåƒ…åœ¨ç¬¬ä¸€æ¬¡æ”»æ“Šæ™‚æª¢æŸ¥ï¼‰
      if (!buffRemoved) {
        const companionIndex = state.companions.indexOf(companion);
        if (companionIndex >= 0 && battle.companionBuffs && battle.companionBuffs[companionIndex] && battle.companionBuffs[companionIndex].ignoreDefense) {
          enemyDefense = 0; // ç„¡è¦–é˜²ç¦¦
        }
      }
      
      let enemyDamage = Math.max(1, Math.round(enemyAttack - enemyDefense));
      
      // æ‡‰ç”¨å‚·å®³æ¯”ä¾‹ï¼ˆ8æˆï¼‰
      enemyDamage = Math.max(1, Math.round(enemyDamage * weaponmasterEffects.normalAttackDamageRatio));
      
      // æª¢æŸ¥æœƒå¿ƒä¸€æ“Š
      const enemyIsCrit = checkCrit(companion);
      if (enemyIsCrit) {
        enemyDamage = Math.round(enemyDamage * 2);
      }
      
      // è¼¸å‡ºåŒä¼´å…¨é«”æ”»æ“Šå‚·å®³è¨ˆç®—æ—¥èªŒ
      console.log(`[å‚·å®³è¨ˆç®—] ${companion.name} å…¨é«”æ”»æ“Š ${enemy.name}ï¼šæ”»æ“Šå€¼=${enemyAttack}, é˜²ç¦¦å€¼=${enemyDefense}, åŸºç¤å‚·å®³=${Math.max(1, Math.round((enemyAttack - enemyDefense) * weaponmasterEffects.normalAttackDamageRatio))}, æœ€çµ‚å‚·å®³=${enemyDamage}${enemyIsCrit ? ' (æœƒå¿ƒä¸€æ“Š)' : ''}`);
      
      const enemyIndex = battle.enemies.indexOf(enemy);
      triggerAttackAnimation(enemyIndex, enemyIsCrit, null);
      enemyDamage = applyDamageToEnemyUnified(enemy, enemyDamage, companion);
      totalDamage += enemyDamage;
      if (enemyIsCrit) hasCrit = true;
      
      // ç ´ç”²ä¹‹åˆƒï¼šç¬¬ä¸€æ¬¡æ”»æ“ŠæˆåŠŸå¾Œç§»é™¤buffï¼ˆconsumeBreakingArmor å…§éƒ¨å†ªç­‰ï¼‰
      if (!buffRemoved && enemyDamage > 0) {
        consumeBreakingArmor(companion, enemyDamage, true, null);
        buffRemoved = true;
      }
      
      if (enemy.stats.hp <= 0) {
        pushBattleLog(`${enemy.name} è¢«æ“Šå€’ï¼`);
      }
    });
    
    const critMsg = hasCrit ? 'ï¼ˆæœƒå¿ƒä¸€æ“Šï¼ï¼‰' : '';
    pushBattleLog(`${companion.name}åŠæ°£ç¸±æ©«ï¼å°æ‰€æœ‰æ•µäººé€ æˆ ${totalDamage} ç¸½å‚·å®³ï¼${critMsg}`);
    
    const allDefeated = battle.enemies.every(e => e.stats.hp <= 0);
    if (allDefeated) {
      setTimeout(() => {
        concludeBattle(true);
      }, 800);
      return;
    }
  } else {
    const isCrit = checkCrit(companion);
    if (isCrit) {
      damage = Math.round(damage * 2);
    }
    
    // è§¸ç™¼æ”»æ“Šå‹•ç•«ï¼ˆæ™®é€šæ”»æ“Šæ²’æœ‰æŠ€èƒ½ï¼‰
    triggerAttackAnimation(targetIndex, isCrit, null);
    
    // è¼¸å‡ºåŒä¼´æ™®é€šæ”»æ“Šå‚·å®³è¨ˆç®—æ—¥èªŒ
    console.log(`[å‚·å®³è¨ˆç®—] ${companion.name} æ™®é€šæ”»æ“Š ${targetEnemy.name}ï¼šæ”»æ“Šå€¼=${attack}, é˜²ç¦¦å€¼=${defense}, æœ€çµ‚å‚·å®³=${damage}${isCrit ? ' (æœƒå¿ƒä¸€æ“Š)' : ''}`);
    
    // Bug fix: ä½¿ç”¨çµ±ä¸€å‚·å®³å‡½å¼ï¼Œç¢ºä¿å¤šå½¢æ…‹ Boss è®Šèº«èƒ½æ­£ç¢ºè§¸ç™¼
    damage = applyDamageToEnemyUnified(targetEnemy, damage, companion);
    const critMsg = isCrit ? 'ï¼ˆæœƒå¿ƒä¸€æ“Šï¼ï¼‰' : '';
    pushBattleLog(`${companion.name}æ”»æ“Š${targetEnemy.name}ï¼Œé€ æˆ ${damage} å‚·å®³ï¼${critMsg}`);

    consumeBreakingArmor(companion, damage, true, null);
  }
  
  if (targetEnemy.stats.hp <= 0) {
    pushBattleLog(`${targetEnemy.name} è¢«æ“Šå€’ï¼`);
    const allDefeated = battle.enemies.every(e => e.stats.hp <= 0);
    if (allDefeated) {
      setTimeout(() => {
        concludeBattle(true);
      }, 800);
      return;
    }
  }
  
  // æ‡‰ç”¨é€£æ“Šè¢«å‹•ï¼šæœ‰æ©Ÿç‡å¤šæ”»æ“Š1æ¬¡ï¼ˆåƒ…åœ¨æ™®é€šæ”»æ“Šå¾Œï¼‰
  const passiveEffects = getSwordPassiveEffects(companion);
  if (passiveEffects.doubleAttackChance > 0 && Math.random() < passiveEffects.doubleAttackChance) {
    // æª¢æŸ¥ç›®æ¨™æ˜¯å¦é‚„æ´»è‘—
    if (targetEnemy.stats.hp > 0) {
      // è¨ˆç®—é€£æ“Šå‚·å®³ï¼ˆä½¿ç”¨èˆ‡åŒä¼´æ™®é€šæ”»æ“Šç›¸åŒçš„é‚è¼¯ï¼‰
      const doubleAttack = totalAttrs.attack;
      let doubleDefense = targetEnemy.attributes ? targetEnemy.attributes.defense : (targetEnemy.defense || 0);
      
      // æª¢æŸ¥æ˜¯å¦æœ‰ç ´ç”²ä¹‹åˆƒbuffï¼šç„¡è¦–é˜²ç¦¦
      const companionIndexForDouble = state.companions.indexOf(companion);
      if (companionIndexForDouble >= 0 && battle.companionBuffs && battle.companionBuffs[companionIndexForDouble] && battle.companionBuffs[companionIndexForDouble].ignoreDefense) {
        doubleDefense = 0; // ç„¡è¦–é˜²ç¦¦
      }
      
      let doubleDamage = Math.max(1, Math.round(doubleAttack - doubleDefense));
      
      // æª¢æŸ¥æœƒå¿ƒä¸€æ“Š
      const doubleIsCrit = checkCrit(companion);
      if (doubleIsCrit) {
        doubleDamage = Math.round(doubleDamage * 2);
      }
      
      // è§¸ç™¼é€£æ“Šå‹•ç•«
      triggerAttackAnimation(targetIndex, doubleIsCrit);
      
      doubleDamage = applyDamageToEnemyUnified(targetEnemy, doubleDamage, companion);
      const doubleCritMsg = doubleIsCrit ? 'ï¼ˆæœƒå¿ƒä¸€æ“Šï¼ï¼‰' : '';
      pushBattleLog(`${companion.name}é€£æ“ŠæŠ€å·§è§¸ç™¼ï¼é¡å¤–é€ æˆ ${doubleDamage} å‚·å®³ï¼${doubleCritMsg}`);
      
      consumeBreakingArmor(companion, doubleDamage, true, null);

      applyLifesteal(companion, doubleDamage, passiveEffects);

      renderBattleDialog();

      if (targetEnemy.stats.hp <= 0) {
        pushBattleLog(`${targetEnemy.name} è¢«æ“Šå€’ï¼`);
        const allDefeated = battle.enemies.every(e => e.stats.hp <= 0);
        if (allDefeated) {
          setTimeout(() => {
            concludeBattle(true);
          }, 800);
          return;
        }
      }
    }
  }
}

// åŒä¼´ç›´æ¥åŸ·è¡ŒæŠ€èƒ½
function performCompanionSkillDirectly(companion, skill, target) {
  const battle = state.ui.battle;
  if (!battle || !companion || !skill) {
    if (companion && !skill) {
      pushBattleLog(`${companion.name}è©¦åœ–ä½¿ç”¨æŠ€èƒ½ï¼Œä½†æŠ€èƒ½ä¸å­˜åœ¨ã€‚`);
    } else if (!companion) {
      pushBattleLog('åŒä¼´ä¸å­˜åœ¨ï¼Œç„¡æ³•ä½¿ç”¨æŠ€èƒ½ã€‚');
    }
    return;
  }
  
  // æª¢æŸ¥åŒä¼´æ˜¯å¦é‚„æ´»è‘—
  if (companion.stats.hp <= 0) {
    pushBattleLog(`${companion.name}å·²æ­»äº¡ï¼Œç„¡æ³•ä½¿ç”¨æŠ€èƒ½ã€‚`);
    return;
  }
  
  // å¢å¼·æŠ€èƒ½ï¼ˆå…‰ç’°ã€è‡ªèº«buffæˆ–é˜²æ­»è­·ç›¾ï¼‰è™•ç†
  if (skill.kind === 'enhance') {
    // æª¢æŸ¥æ˜¯å¦ç‚ºé˜²æ­»è­·ç›¾æŠ€èƒ½ï¼ˆé€šédeathWardå±¬æ€§æˆ–æŠ€èƒ½IDï¼‰
    const isDeathWardSkill = skill.deathWard || skill.id === 'sage_death_ward_1';
    if (isDeathWardSkill) {
      applyDeathWardToAllAllies(skill, companion, companion.name);
      return;
    } else {
      // å…¶ä»–enhanceæŠ€èƒ½ï¼ˆå…‰ç’°æˆ–è‡ªèº«buffï¼‰é€šéuseAuraSkillè™•ç†
      useAuraSkill(companion, skill, companion.name, false);
      renderBattleDialog();
      return;
    }
  }
  
  // æª¢æŸ¥MPæ˜¯å¦è¶³å¤ 
  const companionDynamicMp = calculateDynamicMpCost(skill, companion);
  let mpCost = companionDynamicMp.mpCost;
  battle.tempMpCost = companionDynamicMp.tempMpCost;
  
  if (companion.stats.mp < mpCost) {
    pushBattleLog(`${companion.name}MPä¸è¶³ï¼ˆéœ€è¦ ${mpCost}ï¼Œç•¶å‰ ${companion.stats.mp}ï¼‰ï¼Œç„¡æ³•æ–½æ”¾ã€Œ${skill.name}ã€ã€‚`);
    return;
  }
  
  companion.stats.mp = Math.max(0, companion.stats.mp - mpCost);
  
  // è™•ç†æ¨èº«æ–¬æŠ€èƒ½ï¼šæ‰£HPä¸¦è¨˜éŒ„æ‰£æ‰çš„HPå€¼ï¼ˆåŒä¼´ä¹Ÿèƒ½ä½¿ç”¨æ¨èº«æ–¬ï¼‰
  const hpCostAmount = calculateAndApplyHpCost(skill, companion, companion.name);
  
  const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
  
  if (skill.kind === 'attack') {
    const isMultiHit = skill.hitCount && skill.hitCount > 1;
    
    if (skill.aoe) {
      // å…¨é«”æ”»æ“Š
      pushBattleLog(`${companion.name}æ–½æ”¾ã€Œ${skill.name}ã€ï¼`);
      aliveEnemies.forEach((enemy) => {
        const enemyIndex = battle.enemies.indexOf(enemy);
        let { damage, isCrit } = calculateSkillDamage(skill, companion, enemy);
        // çµ±ä¸€æ‡‰ç”¨å‚·å®³ï¼ˆåŒ…å«å¾©ä»‡æ„å¿—æ•ˆæœï¼‰
        damage = applyDamageToEnemyUnified(enemy, damage, companion);
        const critMsg = isCrit ? 'ï¼ˆæœƒå¿ƒä¸€æ“Šï¼ï¼‰' : '';
        // è§¸ç™¼å…ƒç´ å‹•ç•«
        triggerAttackAnimation(enemyIndex, isCrit, skill);
        // å¦‚æœæ˜¯æ¨èº«æ–¬ï¼Œé¡¯ç¤ºè©³ç´°ä¿¡æ¯
        if (skill.hpCostPercent && skill.attackBoostMultiplier && battle.tempHpCost > 0) {
          const hpCost = battle.tempHpCost;
          const multiplier = skill.attackBoostMultiplier;
          pushBattleLog(`â†’ å°${enemy.name}é€ æˆ ${damage} å‚·å®³ï¼ˆæ¶ˆè€— ${hpCost} HP Ã— ${multiplier}å€ï¼‰${critMsg}`);
        } else {
        pushBattleLog(`â†’ å°${enemy.name}é€ æˆ ${damage} å‚·å®³${critMsg}`);
        }
        
        if (enemy.stats.hp <= 0) {
          pushBattleLog(`â†’ ${enemy.name} è¢«æ“Šå€’ï¼`);
        }
      });
    } else if (isMultiHit) {
      // å¤šæ®µæ”»æ“Šï¼ˆé€£æ“Šæˆ–éš¨æ©Ÿï¼‰
      const hitCount = skill.hitCount || 2;
      let totalDamage = 0;
      // é€£æ“ŠæŠ€èƒ½ï¼ˆagility_comboï¼‰éœ€è¦é¸æ“‡ç›®æ¨™ï¼Œå°åŒä¸€å€‹ç›®æ¨™é€²è¡Œå¤šæ¬¡æ”»æ“Š
      const isComboSkill = skill.id && (skill.id.startsWith('combo_strike_') || skill.id === 'agility_combo');
      
      pushBattleLog(`${companion.name}æ–½æ”¾ã€Œ${skill.name}ã€ï¼`);
      
      // å¦‚æœæ˜¯é€£æ“ŠæŠ€èƒ½ï¼Œå…ˆé¸æ“‡ç›®æ¨™
      let fixedTarget = null;
      if (isComboSkill) {
        // é€£æ“ŠæŠ€èƒ½ï¼šå°åŒä¸€å€‹ç›®æ¨™é€²è¡Œå¤šæ¬¡æ”»æ“Š
        if (battle.selectedEnemyIndex !== null && battle.selectedEnemyIndex >= 0) {
          fixedTarget = battle.enemies[battle.selectedEnemyIndex];
        } else {
          // å¦‚æœæ²’æœ‰é¸æ“‡ç›®æ¨™ï¼Œè‡ªå‹•é¸æ“‡ç¬¬ä¸€å€‹æ´»è‘—çš„æ•µäºº
          const aliveEnemiesList = battle.enemies.filter(e => e.stats.hp > 0);
          if (aliveEnemiesList.length > 0) {
            fixedTarget = aliveEnemiesList[0];
            battle.selectedEnemyIndex = battle.enemies.indexOf(fixedTarget);
          }
        }
      }
      
      for (let i = 0; i < hitCount; i++) {
        const aliveEnemiesList = battle.enemies.filter(e => e.stats.hp > 0);
        if (aliveEnemiesList.length === 0) break;
        
        // é€£æ“ŠæŠ€èƒ½ï¼šå°åŒä¸€å€‹ç›®æ¨™æ”»æ“Šï¼›éš¨æ©Ÿå¤šæ®µï¼šéš¨æ©Ÿé¸æ“‡ç›®æ¨™
        const target = isComboSkill && fixedTarget && fixedTarget.stats.hp > 0 
          ? fixedTarget 
          : aliveEnemiesList[Math.floor(Math.random() * aliveEnemiesList.length)];
        const targetIndex = battle.enemies.indexOf(target);
        let { damage, isCrit } = calculateSkillDamage(skill, companion, target);
        // çµ±ä¸€æ‡‰ç”¨å‚·å®³ï¼ˆåŒ…å«å¾©ä»‡æ„å¿—æ•ˆæœï¼‰
        damage = applyDamageToEnemyUnified(target, damage, companion);
        totalDamage += damage;
        const critMsg = isCrit ? 'ï¼ˆæœƒå¿ƒä¸€æ“Šï¼ï¼‰' : '';
        
        // è§¸ç™¼å…ƒç´ å‹•ç•«
        triggerAttackAnimation(targetIndex, isCrit, skill);
        
        // é¡¯ç¤ºæ¯ä¸€ä¸‹æ”»æ“Š
        // å¦‚æœæ˜¯æ¨èº«æ–¬ï¼Œé¡¯ç¤ºè©³ç´°ä¿¡æ¯
        if (skill.hpCostPercent && skill.attackBoostMultiplier && battle.tempHpCost > 0) {
          const hpCost = battle.tempHpCost;
          const multiplier = skill.attackBoostMultiplier;
          pushBattleLog(`â†’ ç¬¬${i + 1}æ“Šï¼šå°${target.name}é€ æˆ ${damage} å‚·å®³ï¼ˆæ¶ˆè€— ${hpCost} HP Ã— ${multiplier}å€ï¼‰${critMsg}`);
        } else {
          pushBattleLog(`â†’ ç¬¬${i + 1}æ“Šï¼šå°${target.name}é€ æˆ ${damage} å‚·å®³${critMsg}`);
        }
        
        if (target.stats.hp <= 0) {
          pushBattleLog(`â†’ ${target.name} è¢«æ“Šå€’ï¼`);
          const allDefeated = battle.enemies.every(e => e.stats.hp <= 0);
          if (allDefeated) {
            setTimeout(() => {
              concludeBattle(true);
            }, 800);
            return;
          }
        }
        
        // æ‡‰ç”¨å¸è¡€è¢«å‹•
        if (skill.flow === 'sword') {
          const passiveEffects = getSwordPassiveEffects(companion);
          if (passiveEffects.lifestealRate > 0 && damage > 0) {
            const lifestealAmount = Math.max(1, Math.round(damage * passiveEffects.lifestealRate));
            companion.stats.hp = Math.min(companion.stats.maxHp, companion.stats.hp + lifestealAmount);
          }
        }
      }
      
      // é¡¯ç¤ºç¸½å‚·å®³
      pushBattleLog(`ç¸½å…±é€ æˆ ${totalDamage} å‚·å®³ï¼`);
      
      // æ‡‰ç”¨æ¢å¾©å‹è¢«å‹•æŠ€èƒ½ï¼šæ”»æ“Šæ•µäººå›å¾©MPï¼ˆå¤šæ®µæ”»æ“Šåªå›å¾©ä¸€æ¬¡ï¼‰
      if (totalDamage > 0) {
        const recoveryEffects = getRecoveryPassiveEffects(companion);
        if (recoveryEffects.attackMpReturn > 0) {
          const oldMp = companion.stats.mp;
          companion.stats.mp = Math.min(companion.stats.maxMp, companion.stats.mp + recoveryEffects.attackMpReturn);
          const actualReturn = companion.stats.mp - oldMp;
          if (actualReturn > 0) {
            pushBattleLog(`æ¢å¾©å‹è¢«å‹•æŠ€èƒ½ï¼šæ”»æ“Šå›å¾© ${actualReturn} MPã€‚`);
          }
        }
      }
      
      // æ‡‰ç”¨é­”æ³•å‹è¢«å‹•æŠ€èƒ½ï¼šæ³•è¡“æ”»æ“Šå›å¾©MPï¼ˆå¤šæ®µæ³•è¡“æ”»æ“Šåªå›å¾©ä¸€æ¬¡ï¼‰
      if (skill.flow === 'magic' && totalDamage > 0) {
        const magicEffects = getMagicPassiveEffects(companion);
        if (magicEffects.spellMpReturn > 0) {
          const oldMp = companion.stats.mp;
          companion.stats.mp = Math.min(companion.stats.maxMp, companion.stats.mp + magicEffects.spellMpReturn);
          const actualReturn = companion.stats.mp - oldMp;
          if (actualReturn > 0) {
            pushBattleLog(`é­”æ³•å‹è¢«å‹•æŠ€èƒ½ï¼šæ³•è¡“æ”»æ“Šå›å¾© ${actualReturn} MPã€‚`);
          }
        }
      }
    } else {
      // å–®é«”æ”»æ“Š
      let targetIndex = battle.selectedEnemyIndex;
      
      // å¦‚æœç›®æ ‡æ— æ•ˆæˆ–å·²æ­»äº¡ï¼Œè‡ªåŠ¨é€‰æ‹©ç¬¬ä¸€ä¸ªæ´»ç€çš„æ•Œäºº
      if (targetIndex === undefined || targetIndex === null ||
          targetIndex < 0 || !battle.enemies[targetIndex] || 
          battle.enemies[targetIndex].stats.hp <= 0) {
        const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
        if (aliveEnemies.length === 0) {
          pushBattleLog(`${companion.name}è©¦åœ–æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œä½†æ²’æœ‰å¯æ”»æ“Šçš„ç›®æ¨™ã€‚`);
          battle.selectedEnemyIndex = null;
          return;
        }
        targetIndex = battle.enemies.indexOf(aliveEnemies[0]);
        battle.selectedEnemyIndex = targetIndex;
      }
      
      const targetEnemy = battle.enemies[targetIndex];
      if (targetEnemy && targetEnemy.stats.hp > 0) {
        let { damage, isCrit } = calculateSkillDamage(skill, companion, targetEnemy);
        // çµ±ä¸€æ‡‰ç”¨å‚·å®³ï¼ˆåŒ…å«å¾©ä»‡æ„å¿—æ•ˆæœï¼‰
        damage = applyDamageToEnemyUnified(targetEnemy, damage, companion);
        const critMsg = isCrit ? 'ï¼ˆæœƒå¿ƒä¸€æ“Šï¼ï¼‰' : '';
        
        // è§¸ç™¼å…ƒç´ å‹•ç•«
        triggerAttackAnimation(targetIndex, isCrit, skill);
        
        // å¦‚æœæ˜¯æ¨èº«æ–¬ï¼Œé¡¯ç¤ºè©³ç´°ä¿¡æ¯
        if (skill.hpCostPercent && skill.attackBoostMultiplier && battle.tempHpCost > 0) {
          const hpCost = battle.tempHpCost;
          const multiplier = skill.attackBoostMultiplier;
          pushBattleLog(`${companion.name}æ–½æ”¾ã€Œ${skill.name}ã€ï¼ˆæ¶ˆè€— ${hpCost} HP Ã— ${multiplier}å€ï¼‰ï¼Œå°${targetEnemy.name}é€ æˆ ${damage} å‚·å®³ï¼${critMsg}`);
        } else {
        pushBattleLog(`${companion.name}æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œå°${targetEnemy.name}é€ æˆ ${damage} å‚·å®³ï¼${critMsg}`);
        }
        
        // æ‡‰ç”¨å¸è¡€è¢«å‹•
        if (skill.flow === 'sword') {
          const passiveEffects = getSwordPassiveEffects(companion);
          if (passiveEffects.lifestealRate > 0 && damage > 0) {
            const lifestealAmount = Math.max(1, Math.round(damage * passiveEffects.lifestealRate));
            companion.stats.hp = Math.min(companion.stats.maxHp, companion.stats.hp + lifestealAmount);
          }
        }
        
        // å†°å‡é­”æ³•ï¼šé€ æˆæ¸›é€Ÿæ•ˆæœï¼ˆå…©å›åˆï¼Œæ¸›å°‘1/3é€Ÿåº¦ï¼‰
        if (skill.id && skill.id.startsWith('iceball_') && skill.slowDuration && skill.slowRatio) {
          // åˆå§‹åŒ– enemyDebuffs
          if (!battle.enemyDebuffs) {
            battle.enemyDebuffs = {};
          }
          
          // è¨­ç½®æ¸›é€Ÿç‹€æ…‹ï¼ˆå¦‚æœå·²ç¶“æœ‰æ¸›é€Ÿç‹€æ…‹ï¼Œé‡ç½®æŒçºŒæ™‚é–“ï¼‰
          if (!battle.enemyDebuffs[targetIndex]) {
            battle.enemyDebuffs[targetIndex] = {};
          }
          
          const hadSlow = battle.enemyDebuffs[targetIndex].slow ? true : false;
          battle.enemyDebuffs[targetIndex].slow = {
            duration: skill.slowDuration, // æŒçºŒ2å›åˆ
            ratio: skill.slowRatio // æ¸›å°‘1/3é€Ÿåº¦
          };
          
          if (hadSlow) {
            pushBattleLog(`â†’ ${targetEnemy.name}çš„æ¸›é€Ÿæ•ˆæœè¢«åˆ·æ–°ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.slowDuration}å›åˆä¸­ï¼Œé€Ÿåº¦æ¸›å°‘ ${Math.round(skill.slowRatio * 100)}%ã€‚`);
          } else {
            pushBattleLog(`â†’ ${targetEnemy.name}è¢«å†°å‡æ¸›é€Ÿï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.slowDuration}å›åˆä¸­ï¼Œé€Ÿåº¦æ¸›å°‘ ${Math.round(skill.slowRatio * 100)}%ã€‚`);
          }
        }
        
        // é…¸æ€§ç®­ï¼šé€ æˆé˜²å®ˆå€¼æ¸›å°‘æ•ˆæœï¼ˆå…©å›åˆï¼Œæ¸›å°‘1/3é˜²å®ˆå€¼ï¼‰
        if (skill.id && skill.id.startsWith('acid_arrow_') && skill.defenseDownDuration && skill.defenseDownRatio) {
          // åˆå§‹åŒ– enemyDebuffs
          if (!battle.enemyDebuffs) {
            battle.enemyDebuffs = {};
          }
          
          // è¨­ç½®é˜²å®ˆå€¼æ¸›å°‘ç‹€æ…‹ï¼ˆå¦‚æœå·²ç¶“æœ‰é˜²å®ˆå€¼æ¸›å°‘ç‹€æ…‹ï¼Œé‡ç½®æŒçºŒæ™‚é–“ï¼‰
          if (!battle.enemyDebuffs[targetIndex]) {
            battle.enemyDebuffs[targetIndex] = {};
          }
          
          const hadDefenseDown = battle.enemyDebuffs[targetIndex].defenseDown ? true : false;
          battle.enemyDebuffs[targetIndex].defenseDown = {
            duration: skill.defenseDownDuration, // æŒçºŒ2å›åˆ
            ratio: skill.defenseDownRatio // æ¸›å°‘1/3é˜²å®ˆå€¼
          };
          
          if (hadDefenseDown) {
            pushBattleLog(`â†’ ${targetEnemy.name}çš„é˜²å®ˆå€¼æ¸›å°‘æ•ˆæœè¢«åˆ·æ–°ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.defenseDownDuration}å›åˆä¸­ï¼Œé˜²å®ˆå€¼æ¸›å°‘ ${Math.round(skill.defenseDownRatio * 100)}%ã€‚`);
          } else {
            pushBattleLog(`â†’ ${targetEnemy.name}çš„é˜²å®ˆå€¼è¢«è…è•æ¸›å°‘ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.defenseDownDuration}å›åˆä¸­ï¼Œé˜²å®ˆå€¼æ¸›å°‘ ${Math.round(skill.defenseDownRatio * 100)}%ã€‚`);
          }
        }
        
        // æª¢æŸ¥æ˜¯å¦å·å–ï¼ˆå·è¥²æŠ€èƒ½ï¼‰- åŒä¼´ä¹Ÿå¯ä»¥ä½¿ç”¨ï¼Œ50%æ©Ÿç‡å·å–è£å‚™ï¼Œ50%æ©Ÿç‡å·å–é‡‘å¹£
        if (skill.stealGold && skill.stealGoldChance && skill.stealGoldPercent && targetEnemy.goldDrop) {
          // æª¢æŸ¥è©²æ€ªç‰©æ˜¯å¦å·²è¢«å·é
          if (battle.stolenEnemies && battle.stolenEnemies.has(targetIndex)) {
            pushBattleLog(`${targetEnemy.name} å·²ç¶“æ²’æœ‰æ±è¥¿äº†ã€‚`);
          } else if (Math.random() < skill.stealGoldChance) {
            // æ¨™è¨˜è©²æ€ªç‰©å·²è¢«å·é
            if (!battle.stolenEnemies) {
              battle.stolenEnemies = new Set();
            }
            battle.stolenEnemies.add(targetIndex);
            
            // 50%æ©Ÿç‡å·å–è£å‚™ï¼Œ50%æ©Ÿç‡å·å–é‡‘å¹£
            const stealEquipment = Math.random() < 0.5;
            
            if (stealEquipment) {
              // å·å–è£å‚™ï¼šæ ¹æ“šç•¶å‰éšæ®µéš¨æ©Ÿç”Ÿæˆä¸€å€‹è£å‚™
              const currentTier = state.world.stage;
              const tierEquipment = EQUIPMENT.filter(eq => eq.tier === currentTier);
              if (tierEquipment.length > 0) {
                const equipment = tierEquipment[Math.floor(Math.random() * tierEquipment.length)];
                const itemId = `equipment_${equipment.id}`;
                const hasInBag = hero.items.some(entry => entry.id === itemId && entry.qty > 0);
                const isOwned = hero.equipmentInventory && hero.equipmentInventory.includes(equipment.id) || hasInBag;
                
                if (!isOwned) {
                  // æª¢æŸ¥é“å…·æ¬„æ˜¯å¦å·²æ»¿
                  limitInventorySize();
                  const currentItemCount = hero.items.filter(item => item.qty > 0).length;
                  
                  if (currentItemCount >= 8) {
                    // é“å…·æ¬„å·²æ»¿ï¼Œç›´æ¥æ·»åŠ åˆ°è£å‚™åº«å­˜
                    if (!hero.equipmentInventory) {
                      hero.equipmentInventory = [];
                    }
                    if (!hero.equipmentInventory.includes(equipment.id)) {
                      hero.equipmentInventory.push(equipment.id);
                      pushBattleLog(`${companion.name}å·è¥²æˆåŠŸï¼å·å–äº† ${equipment.name}ï¼ˆé“å…·æ¬„å·²æ»¿ï¼Œå·²æ”¾å…¥è£å‚™åº«å­˜ï¼‰ï¼`);
                    } else {
                      pushBattleLog(`${companion.name}å·è¥²æˆåŠŸï¼ä½†å·²æ“æœ‰ ${equipment.name}ã€‚`);
                    }
                  } else {
                    // å°‡è£å‚™æ”¾å…¥é“å…·è¢‹
                    let itemEntry = hero.items.find(entry => entry.id === itemId);
                    if (itemEntry) {
                      itemEntry.qty += 1;
                    } else {
                      hero.items.push({ id: itemId, qty: 1 });
                    }
                    pushBattleLog(`${companion.name}å·è¥²æˆåŠŸï¼å·å–äº† ${equipment.name}ï¼ˆå·²æ”¾å…¥é“å…·è¢‹ï¼‰ï¼`);
                  }
                } else {
                  pushBattleLog(`${companion.name}å·è¥²æˆåŠŸï¼ä½†å·²æ“æœ‰ ${equipment.name}ã€‚`);
                }
              } else {
                // å¦‚æœæ²’æœ‰è©²éšæ®µçš„è£å‚™ï¼Œæ”¹ç‚ºå·å–é‡‘å¹£
                const stolenGold = Math.max(1, Math.floor(targetEnemy.goldDrop * skill.stealGoldPercent));
                const currentGoldDrop = targetEnemy.goldDrop - (targetEnemy.stolenGold || 0);
                const actualStolen = Math.min(stolenGold, currentGoldDrop);
                if (actualStolen > 0) {
                  if (!targetEnemy.stolenGold) {
                    targetEnemy.stolenGold = 0;
                  }
                  targetEnemy.stolenGold += actualStolen;
                  hero.stats.gold += actualStolen;
                  pushBattleLog(`${companion.name}å·è¥²æˆåŠŸï¼å·å–äº† ${actualStolen} é‡‘å¹£ï¼`);
                }
              }
            } else {
              // å·å–é‡‘å¹£
              const stolenGold = Math.max(1, Math.floor(targetEnemy.goldDrop * skill.stealGoldPercent));
              // å¾æ•µäººçš„ goldDrop ä¸­æ‰£é™¤ï¼ˆå¦‚æœå·²ç¶“è¢«å·å–éï¼Œå¾å‰©é¤˜çš„æ‰£é™¤ï¼‰
              const currentGoldDrop = targetEnemy.goldDrop - (targetEnemy.stolenGold || 0);
              const actualStolen = Math.min(stolenGold, currentGoldDrop);
              if (actualStolen > 0) {
                if (!targetEnemy.stolenGold) {
                  targetEnemy.stolenGold = 0;
                }
                targetEnemy.stolenGold += actualStolen;
                hero.stats.gold += actualStolen;
                pushBattleLog(`${companion.name}å·è¥²æˆåŠŸï¼å·å–äº† ${actualStolen} é‡‘å¹£ï¼`);
              }
            }
          }
        }
        
        if (targetEnemy.stats.hp <= 0) {
          pushBattleLog(`${targetEnemy.name} è¢«æ“Šå€’ï¼`);
          const allDefeated = battle.enemies.every(e => e.stats.hp <= 0);
          if (allDefeated) {
            setTimeout(() => {
              concludeBattle(true);
            }, 800);
            return;
          }
        }
        
        // æ‡‰ç”¨é€£æ“Šè¢«å‹•ï¼šæœ‰æ©Ÿç‡å¤šæ”»æ“Š1æ¬¡ï¼ˆåƒ…åœ¨åŠæŠ€å¾Œï¼‰
        if (skill.flow === 'sword') {
          const passiveEffects = getSwordPassiveEffects(companion);
          if (passiveEffects.doubleAttackChance > 0 && Math.random() < passiveEffects.doubleAttackChance) {
            // æª¢æŸ¥ç›®æ¨™æ˜¯å¦é‚„æ´»è‘—
            if (targetEnemy.stats.hp > 0) {
              const result = calculateSkillDamage(skill, companion, targetEnemy);
              let doubleDamage = result.damage;
              const doubleIsCrit = result.isCrit;
              
              // çµ±ä¸€æ‡‰ç”¨å‚·å®³ï¼ˆåŒ…å«å¾©ä»‡æ„å¿—æ•ˆæœï¼‰
              doubleDamage = applyDamageToEnemyUnified(targetEnemy, doubleDamage, companion);
              
              // è§¸ç™¼é€£æ“Šå‹•ç•«
              triggerAttackAnimation(targetIndex, doubleIsCrit, skill);
              const doubleCritMsg = doubleIsCrit ? 'ï¼ˆæœƒå¿ƒä¸€æ“Šï¼ï¼‰' : '';
              pushBattleLog(`${companion.name}é€£æ“ŠæŠ€å·§è§¸ç™¼ï¼é¡å¤–é€ æˆ ${doubleDamage} å‚·å®³ï¼${doubleCritMsg}`);
              
              // é€£æ“Šä¹Ÿè§¸ç™¼å¸è¡€
              if (passiveEffects.lifestealRate > 0 && doubleDamage > 0) {
                const doubleLifesteal = Math.max(1, Math.round(doubleDamage * passiveEffects.lifestealRate));
                companion.stats.hp = Math.min(companion.stats.maxHp, companion.stats.hp + doubleLifesteal);
                pushBattleLog(`${companion.name}å—œè¡€åŠè¡“å›å¾©äº† ${doubleLifesteal} HPï¼`);
              }
              
              renderBattleDialog();
              
              if (targetEnemy.stats.hp <= 0) {
                pushBattleLog(`${targetEnemy.name} è¢«æ“Šå€’ï¼`);
                const allDefeated = battle.enemies.every(e => e.stats.hp <= 0);
                if (allDefeated) {
                  setTimeout(() => {
                    concludeBattle(true);
                  }, 800);
                  return;
                }
              }
            }
          }
        }
        
        // è–æ“Šï¼šå°æ•µäººé€ æˆå‚·å®³å¾Œï¼Œå›å¾©è‡ªå·±1/2æ²»ç™‚èƒ½åŠ›çš„HP
        const isEnhancedHeal = skill.id && skill.id.startsWith('enhanced_heal_');
        if (isEnhancedHeal && damage > 0) {
          const totalAttrs = getCompanionTotalAttributes(companion);
          const recovery = totalAttrs.recovery;
          const healAmount = Math.floor(recovery / 2);
          const oldHp = companion.stats.hp;
          companion.stats.hp = Math.min(companion.stats.maxHp, companion.stats.hp + healAmount);
          const actualHealed = companion.stats.hp - oldHp;
          if (actualHealed > 0) {
            pushBattleLog(`â†’ ${companion.name}å›å¾©äº† ${actualHealed} HPï¼ˆ${oldHp} â†’ ${companion.stats.hp}ï¼‰`);
          }
        }
        
        // é–ƒé›»éˆï¼šå°ç¬¬ä¸€å€‹ç›®æ¨™é€ æˆå‚·å®³å¾Œï¼Œå½ˆè·³åˆ°å¦ä¸€å€‹éš¨æ©Ÿæ•µäºº
        if (skill.chainDamage && skill.chainRatio) {
          const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0 && e !== targetEnemy);
          if (aliveEnemies.length > 0) {
            // éš¨æ©Ÿé¸æ“‡å¦ä¸€å€‹æ•µäºº
            const chainTarget = aliveEnemies[Math.floor(Math.random() * aliveEnemies.length)];
            const chainTargetIndex = battle.enemies.indexOf(chainTarget);
            
            // è¨ˆç®—é€£é–å‚·å®³ï¼ˆåŸæœ¬å‚·å®³çš„80%ï¼‰
            const chainDamage = Math.max(1, Math.floor(damage * skill.chainRatio));
            const oldChainHp = chainTarget.stats.hp;
            chainTarget.stats.hp = Math.max(0, chainTarget.stats.hp - chainDamage);
            
            // è§¸ç™¼å…ƒç´ å‹•ç•«
            triggerAttackAnimation(chainTargetIndex, false, skill);
            
            pushBattleLog(`â†’ é–ƒé›»éˆå½ˆè·³åˆ°${chainTarget.name}ï¼Œé€ æˆ ${chainDamage} å‚·å®³ï¼`);
            
            // æª¢æŸ¥é€£é–ç›®æ¨™æ˜¯å¦è¢«æ“Šå€’
            if (chainTarget.stats.hp <= 0) {
              pushBattleLog(`â†’ ${chainTarget.name} è¢«æ“Šå€’ï¼`);
              const allDefeated = battle.enemies.every(e => e.stats.hp <= 0);
              if (allDefeated) {
                setTimeout(() => {
                  concludeBattle(true);
                }, 800);
                return;
              }
            }
            
            renderBattleDialog();
          }
        }
        
        // å†°å‡é­”æ³•ï¼šé€ æˆæ¸›é€Ÿæ•ˆæœï¼ˆå…©å›åˆï¼Œæ¸›å°‘1/3é€Ÿåº¦ï¼‰
        if (skill.id && skill.id.startsWith('iceball_') && skill.slowDuration && skill.slowRatio) {
          // åˆå§‹åŒ– enemyDebuffs
          if (!battle.enemyDebuffs) {
            battle.enemyDebuffs = {};
          }
          
          // è¨­ç½®æ¸›é€Ÿç‹€æ…‹ï¼ˆå¦‚æœå·²ç¶“æœ‰æ¸›é€Ÿç‹€æ…‹ï¼Œé‡ç½®æŒçºŒæ™‚é–“ï¼‰
          if (!battle.enemyDebuffs[targetIndex]) {
            battle.enemyDebuffs[targetIndex] = {};
          }
          
          const hadSlow = battle.enemyDebuffs[targetIndex].slow ? true : false;
          battle.enemyDebuffs[targetIndex].slow = {
            duration: skill.slowDuration, // æŒçºŒ2å›åˆ
            ratio: skill.slowRatio // æ¸›å°‘1/3é€Ÿåº¦
          };
          
          if (hadSlow) {
            pushBattleLog(`â†’ ${targetEnemy.name}çš„æ¸›é€Ÿæ•ˆæœè¢«åˆ·æ–°ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.slowDuration}å›åˆä¸­ï¼Œé€Ÿåº¦æ¸›å°‘ ${Math.round(skill.slowRatio * 100)}%ã€‚`);
          } else {
            pushBattleLog(`â†’ ${targetEnemy.name}è¢«å†°å‡æ¸›é€Ÿï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.slowDuration}å›åˆä¸­ï¼Œé€Ÿåº¦æ¸›å°‘ ${Math.round(skill.slowRatio * 100)}%ã€‚`);
          }
        }
        
        // é…¸æ€§ç®­ï¼šé€ æˆé˜²å®ˆå€¼æ¸›å°‘æ•ˆæœï¼ˆå…©å›åˆï¼Œæ¸›å°‘1/3é˜²å®ˆå€¼ï¼‰
        if (skill.id && skill.id.startsWith('acid_arrow_') && skill.defenseDownDuration && skill.defenseDownRatio) {
          // åˆå§‹åŒ– enemyDebuffs
          if (!battle.enemyDebuffs) {
            battle.enemyDebuffs = {};
          }
          
          // è¨­ç½®é˜²å®ˆå€¼æ¸›å°‘ç‹€æ…‹ï¼ˆå¦‚æœå·²ç¶“æœ‰é˜²å®ˆå€¼æ¸›å°‘ç‹€æ…‹ï¼Œé‡ç½®æŒçºŒæ™‚é–“ï¼‰
          if (!battle.enemyDebuffs[targetIndex]) {
            battle.enemyDebuffs[targetIndex] = {};
          }
          
          const hadDefenseDown = battle.enemyDebuffs[targetIndex].defenseDown ? true : false;
          battle.enemyDebuffs[targetIndex].defenseDown = {
            duration: skill.defenseDownDuration, // æŒçºŒ2å›åˆ
            ratio: skill.defenseDownRatio // æ¸›å°‘1/3é˜²å®ˆå€¼
          };
          
          if (hadDefenseDown) {
            pushBattleLog(`â†’ ${targetEnemy.name}çš„é˜²å®ˆå€¼æ¸›å°‘æ•ˆæœè¢«åˆ·æ–°ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.defenseDownDuration}å›åˆä¸­ï¼Œé˜²å®ˆå€¼æ¸›å°‘ ${Math.round(skill.defenseDownRatio * 100)}%ã€‚`);
          } else {
            pushBattleLog(`â†’ ${targetEnemy.name}çš„é˜²å®ˆå€¼è¢«è…è•æ¸›å°‘ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.defenseDownDuration}å›åˆä¸­ï¼Œé˜²å®ˆå€¼æ¸›å°‘ ${Math.round(skill.defenseDownRatio * 100)}%ã€‚`);
          }
        }
        
        // åˆºå®¢ä¹‹è·¯ï¼šä¸­æ¯’+é™ä½æ”»æ“ŠåŠ›
        if (skill.weaponmasterPath === 'assassin' && skill.poisonRatio && skill.attackDownRatio && skill.debuffDuration) {
          // åˆå§‹åŒ– enemyDebuffs
          if (!battle.enemyDebuffs) {
            battle.enemyDebuffs = {};
          }
          
          if (!battle.enemyDebuffs[targetIndex]) {
            battle.enemyDebuffs[targetIndex] = {};
          }
          
          // è¨ˆç®—ä¸­æ¯’å‚·å®³ï¼š20%æ•æ·
          const totalAttrs = getCompanionTotalAttributes(companion);
          const agility = totalAttrs.agility || 0;
          const poisonDamage = Math.max(1, Math.floor(agility * skill.poisonRatio));
          const poisonDuration = skill.debuffDuration;
          
          // è¨­ç½®ä¸­æ¯’ç‹€æ…‹
          const hadPoison = battle.enemyDebuffs[targetIndex].poison ? true : false;
          battle.enemyDebuffs[targetIndex].poison = {
            duration: poisonDuration,
            damage: poisonDamage,
            casterAgility: agility
          };
          
          // è¨­ç½®æ”»æ“ŠåŠ›æ¸›å°‘ç‹€æ…‹
          const hadAttackDown = battle.enemyDebuffs[targetIndex].attackDown ? true : false;
          battle.enemyDebuffs[targetIndex].attackDown = {
            duration: skill.debuffDuration,
            ratio: skill.attackDownRatio
          };
          
          // ç«‹å³æ‡‰ç”¨ä¸€æ¬¡ä¸­æ¯’å‚·å®³
          const oldHp = targetEnemy.stats.hp;
          targetEnemy.stats.hp = Math.max(0, targetEnemy.stats.hp - poisonDamage);
          const immediateDamage = oldHp - targetEnemy.stats.hp;
          if (immediateDamage > 0) {
            pushBattleLog(`â†’ ${targetEnemy.name}ç«‹å³å—åˆ°ä¸­æ¯’å‚·å®³ ${immediateDamage} é»ï¼`);
          }
          
          if (hadPoison) {
            pushBattleLog(`â†’ ${targetEnemy.name}çš„æ¯’è¢«åˆ·æ–°ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${poisonDuration}å›åˆä¸­ï¼Œæ¯å›åˆçµæŸæ™‚å—åˆ° ${poisonDamage} å‚·å®³ã€‚`);
          } else {
            pushBattleLog(`â†’ ${targetEnemy.name}ä¸­æ¯’äº†ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${poisonDuration}å›åˆä¸­ï¼Œæ¯å›åˆçµæŸæ™‚å—åˆ° ${poisonDamage} å‚·å®³ã€‚`);
          }
          
          if (hadAttackDown) {
            pushBattleLog(`â†’ ${targetEnemy.name}çš„æ”»æ“ŠåŠ›æ¸›å°‘æ•ˆæœè¢«åˆ·æ–°ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.debuffDuration}å›åˆä¸­ï¼Œæ”»æ“ŠåŠ›æ¸›å°‘ ${Math.round(skill.attackDownRatio * 100)}%ã€‚`);
          } else {
            pushBattleLog(`â†’ ${targetEnemy.name}çš„æ”»æ“ŠåŠ›è¢«å‰Šå¼±ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.debuffDuration}å›åˆä¸­ï¼Œæ”»æ“ŠåŠ›æ¸›å°‘ ${Math.round(skill.attackDownRatio * 100)}%ã€‚`);
          }
          
          // æš—å½±çªè¥²ä½¿ç”¨å¾Œæ¶ˆè€—ç ´ç”²ä¹‹åˆƒbuffï¼ˆåŒä¼´ï¼‰
          const companionIndex = state.companions.indexOf(companion);
          if (companionIndex >= 0 && battle.companionBuffs && battle.companionBuffs[companionIndex] && battle.companionBuffs[companionIndex].ignoreDefense) {
            battle.companionBuffs[companionIndex].ignoreDefense = false;
            pushBattleLog(`â†’ ${companion.name}çš„ç ´ç”²ä¹‹åˆƒæ•ˆæœå·²æ¶ˆè€—ï¼`);
          }
        }
        // è…æ“Šï¼šé™ä½æ•µäººæ”»æ“ŠåŠ›1/3ï¼ˆæŒçºŒ2å›åˆï¼‰
        else if (skill.id && skill.id.startsWith('kidney_strike_') && skill.attackDownDuration && skill.attackDownRatio) {
          // åˆå§‹åŒ– enemyDebuffs
          if (!battle.enemyDebuffs) {
            battle.enemyDebuffs = {};
          }
          
          // è¨­ç½®æ”»æ“ŠåŠ›æ¸›å°‘ç‹€æ…‹ï¼ˆå¦‚æœå·²ç¶“æœ‰æ”»æ“ŠåŠ›æ¸›å°‘ç‹€æ…‹ï¼Œé‡ç½®æŒçºŒæ™‚é–“ï¼‰
          if (!battle.enemyDebuffs[targetIndex]) {
            battle.enemyDebuffs[targetIndex] = {};
          }
          
          const hadAttackDown = battle.enemyDebuffs[targetIndex].attackDown ? true : false;
          battle.enemyDebuffs[targetIndex].attackDown = {
            duration: skill.attackDownDuration, // æŒçºŒ2å›åˆ
            ratio: skill.attackDownRatio // æ¸›å°‘1/3æ”»æ“ŠåŠ›
          };
          
          if (hadAttackDown) {
            pushBattleLog(`â†’ ${targetEnemy.name}çš„æ”»æ“ŠåŠ›æ¸›å°‘æ•ˆæœè¢«åˆ·æ–°ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.attackDownDuration}å›åˆä¸­ï¼Œæ”»æ“ŠåŠ›æ¸›å°‘ ${Math.round(skill.attackDownRatio * 100)}%ã€‚`);
          } else {
            pushBattleLog(`â†’ ${targetEnemy.name}çš„æ”»æ“ŠåŠ›è¢«å‰Šå¼±ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.attackDownDuration}å›åˆä¸­ï¼Œæ”»æ“ŠåŠ›æ¸›å°‘ ${Math.round(skill.attackDownRatio * 100)}%ã€‚`);
          }
        }
        
        // æ›´æ–°UIé¡¯ç¤º
        renderBattleDialog();
      } else {
        // å¦‚æœè¿˜æ˜¯æ— æ•ˆï¼Œå†æ¬¡å°è¯•é€‰æ‹©ç¬¬ä¸€ä¸ªæ´»ç€çš„æ•Œäºº
        const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
        if (aliveEnemies.length > 0) {
          targetIndex = battle.enemies.indexOf(aliveEnemies[0]);
          battle.selectedEnemyIndex = targetIndex;
          const newTargetEnemy = battle.enemies[targetIndex];
          if (newTargetEnemy && newTargetEnemy.stats.hp > 0) {
            let { damage, isCrit } = calculateSkillDamage(skill, companion, newTargetEnemy);
            // çµ±ä¸€æ‡‰ç”¨å‚·å®³ï¼ˆåŒ…å«å¾©ä»‡æ„å¿—æ•ˆæœï¼‰
            damage = applyDamageToEnemyUnified(newTargetEnemy, damage, companion);
            const critMsg = isCrit ? 'ï¼ˆæœƒå¿ƒä¸€æ“Šï¼ï¼‰' : '';
            pushBattleLog(`${companion.name}æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œå°${newTargetEnemy.name}é€ æˆ ${damage} å‚·å®³ï¼${critMsg}`);
            
            // æ‡‰ç”¨å¸è¡€è¢«å‹•
            if (skill.flow === 'sword') {
              const passiveEffects = getSwordPassiveEffects(companion);
              if (passiveEffects.lifestealRate > 0 && damage > 0) {
                const lifestealAmount = Math.max(1, Math.round(damage * passiveEffects.lifestealRate));
                companion.stats.hp = Math.min(companion.stats.maxHp, companion.stats.hp + lifestealAmount);
              }
            }
            
            if (newTargetEnemy.stats.hp <= 0) {
              pushBattleLog(`${newTargetEnemy.name} è¢«æ“Šå€’ï¼`);
              const allDefeated = battle.enemies.every(e => e.stats.hp <= 0);
              if (allDefeated) {
                setTimeout(() => {
                  concludeBattle(true);
                }, 800);
                return;
              }
            }
            
            // æ‡‰ç”¨é€£æ“Šè¢«å‹•ï¼šæœ‰æ©Ÿç‡å¤šæ”»æ“Š1æ¬¡ï¼ˆåƒ…åœ¨åŠæŠ€å¾Œï¼‰
            if (skill.flow === 'sword') {
              const passiveEffects = getSwordPassiveEffects(companion);
              if (passiveEffects.doubleAttackChance > 0 && Math.random() < passiveEffects.doubleAttackChance) {
                // æª¢æŸ¥ç›®æ¨™æ˜¯å¦é‚„æ´»è‘—
                if (newTargetEnemy.stats.hp > 0) {
                  const result = calculateSkillDamage(skill, companion, newTargetEnemy);
                  const doubleDamage = result.damage;
                  const doubleIsCrit = result.isCrit;
                  
                  newTargetEnemy.stats.hp = Math.max(0, newTargetEnemy.stats.hp - doubleDamage);
                  const doubleCritMsg = doubleIsCrit ? 'ï¼ˆæœƒå¿ƒä¸€æ“Šï¼ï¼‰' : '';
                  pushBattleLog(`${companion.name}é€£æ“ŠæŠ€å·§è§¸ç™¼ï¼é¡å¤–é€ æˆ ${doubleDamage} å‚·å®³ï¼${doubleCritMsg}`);
                  
                  // é€£æ“Šä¹Ÿè§¸ç™¼å¸è¡€
                  if (passiveEffects.lifestealRate > 0 && doubleDamage > 0) {
                    const doubleLifesteal = Math.max(1, Math.round(doubleDamage * passiveEffects.lifestealRate));
                    companion.stats.hp = Math.min(companion.stats.maxHp, companion.stats.hp + doubleLifesteal);
                    pushBattleLog(`${companion.name}å—œè¡€åŠè¡“å›å¾©äº† ${doubleLifesteal} HPï¼`);
                  }
                  
                  renderBattleDialog();
                  
                  if (newTargetEnemy.stats.hp <= 0) {
                    pushBattleLog(`${newTargetEnemy.name} è¢«æ“Šå€’ï¼`);
                    const allDefeated = battle.enemies.every(e => e.stats.hp <= 0);
                    if (allDefeated) {
                      setTimeout(() => {
                        concludeBattle(true);
                      }, 800);
                      return;
                    }
                  }
                }
              }
            }
          } else {
            pushBattleLog(`${companion.name}è©¦åœ–æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œä½†ç›®æ¨™å·²æ­»äº¡ã€‚`);
          }
        } else {
          pushBattleLog(`${companion.name}è©¦åœ–æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œä½†æ²’æœ‰å¯æ”»æ“Šçš„ç›®æ¨™ã€‚`);
        }
      }
      
      // æ¸…é™¤æ¨èº«æ–¬çš„è‡¨æ™‚HPæ¶ˆè€—å€¼
      battle.tempHpCost = 0;
    }
  } else if (skill.kind === 'debuff') {
    // DebuffæŠ€èƒ½ï¼ˆä¸‹æ¯’ç­‰ï¼‰
    if (skill.id && skill.id.startsWith('poison_attack')) {
      // ä¸‹æ¯’æŠ€èƒ½
      let targetIndex = battle.selectedEnemyIndex;
      
      // å¦‚æœæ²’æœ‰é¸æ“‡ç›®æ¨™ï¼Œè‡ªå‹•é¸æ“‡ç¬¬ä¸€å€‹æ´»è‘—çš„æ•µäºº
      if (targetIndex === null || targetIndex < 0 || targetIndex >= battle.enemies.length) {
        const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
        if (aliveEnemies.length === 0) {
          pushBattleLog(`${companion.name}ç„¡æ³•ä½¿ç”¨ã€Œ${skill.name}ã€ï¼šæ²’æœ‰å¯æ”»æ“Šçš„ç›®æ¨™ã€‚`);
          companion.stats.mp += mpCost; // é€€å›MP
          return;
        }
        targetIndex = battle.enemies.indexOf(aliveEnemies[0]);
        battle.selectedEnemyIndex = targetIndex;
      }
      
      const targetEnemy = battle.enemies[targetIndex];
      if (!targetEnemy || targetEnemy.stats.hp <= 0) {
        pushBattleLog(`${companion.name}ç„¡æ³•ä½¿ç”¨ã€Œ${skill.name}ã€ï¼šç›®æ¨™å·²æ­»äº¡ã€‚`);
        companion.stats.mp += mpCost; // é€€å›MP
        return;
      }
      
      // è¨ˆç®—æ–½æ³•è€…çš„æ•æ·å€¼
      const totalAttrs = getCompanionTotalAttributes(companion);
      const casterAgility = totalAttrs.agility;
      
      // è¨ˆç®—ä¸­æ¯’å‚·å®³ï¼ˆæ ¹æ“šæŠ€èƒ½ç­‰ç´šçš„æ¯”ç‡ï¼‰
      const poisonDamage = Math.max(1, Math.floor(casterAgility * (skill.poisonRatio || 0.3)));
      const poisonDuration = skill.poisonDuration || 3;
      
      // åˆå§‹åŒ– enemyDebuffs
      if (!battle.enemyDebuffs) {
        battle.enemyDebuffs = {};
      }
      
      // è¨­ç½®ä¸­æ¯’ç‹€æ…‹ï¼ˆå¦‚æœå·²ç¶“æœ‰ä¸­æ¯’ç‹€æ…‹ï¼Œé‡ç½®æŒçºŒæ™‚é–“å’Œå‚·å®³ï¼Œè€Œä¸æ˜¯ç´¯åŠ ï¼‰
      if (!battle.enemyDebuffs[targetIndex]) {
        battle.enemyDebuffs[targetIndex] = {};
      }
      
      const hadPoison = battle.enemyDebuffs[targetIndex].poison ? true : false;
      battle.enemyDebuffs[targetIndex].poison = {
        duration: poisonDuration, // é‡ç½®æŒçºŒæ™‚é–“
        damage: poisonDamage, // ä½¿ç”¨æ–°çš„å‚·å®³å€¼
        casterAgility: casterAgility
      };
      
      pushBattleLog(`${companion.name}å°${targetEnemy.name}æ–½æ”¾ã€Œ${skill.name}ã€ï¼`);
      
      // ç«‹å³æ‡‰ç”¨ä¸€æ¬¡ä¸­æ¯’å‚·å®³ï¼ˆæ–½åŠ çš„é‚£ä¸€å›åˆå°±ç”Ÿæ•ˆï¼‰
      const oldHp = targetEnemy.stats.hp;
      targetEnemy.stats.hp = Math.max(0, targetEnemy.stats.hp - poisonDamage);
      const immediateDamage = oldHp - targetEnemy.stats.hp;
      if (immediateDamage > 0) {
        pushBattleLog(`â†’ ${targetEnemy.name}ç«‹å³å—åˆ°ä¸­æ¯’å‚·å®³ ${immediateDamage} é»ï¼`);
      }
      
      if (hadPoison) {
        pushBattleLog(`â†’ ${targetEnemy.name}çš„æ¯’è¢«åˆ·æ–°ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${poisonDuration}å›åˆä¸­ï¼Œæ¯å›åˆçµæŸæ™‚å—åˆ° ${poisonDamage} å‚·å®³ï¼ˆä¸å—é˜²å®ˆå½±éŸ¿ï¼‰ã€‚`);
      } else {
        pushBattleLog(`â†’ ${targetEnemy.name}ä¸­æ¯’äº†ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${poisonDuration}å›åˆä¸­ï¼Œæ¯å›åˆçµæŸæ™‚å—åˆ° ${poisonDamage} å‚·å®³ï¼ˆä¸å—é˜²å®ˆå½±éŸ¿ï¼‰ã€‚`);
      }
      
      renderBattleDialog();
    } else {
      pushBattleLog(`${companion.name}ä½¿ç”¨äº†æœªçŸ¥çš„debuffæŠ€èƒ½ï¼š${skill.name}ã€‚`);
    }
  } else if (skill.kind === 'support') {
    // è¼”åŠ©æŠ€èƒ½ï¼ˆè­·ç›¾ã€æ·¨åŒ–ç­‰ï¼‰
    
    // æª¢æŸ¥æ˜¯å¦ç‚ºæ·¨åŒ–æŠ€èƒ½
    const isPurifySkill = skill.id && (skill.id === 'purify_1' || skill.id === 'mass_purify_1');
    
    if (isPurifySkill) {
      // æ·¨åŒ–æŠ€èƒ½ï¼šè§£é™¤å‹æ–¹debuff
      companion.stats.mp -= mpCost;
      
      if (skill.aoe) {
        // å…¨é«”æ·¨åŒ–ï¼šè§£é™¤æ‰€æœ‰å‹æ–¹çš„æ‰€æœ‰debuff
        pushBattleLog(`${companion.name}æ–½æ”¾ã€Œ${skill.name}ã€ï¼`);
        let purifiedCount = 0;
        
        if (!battle.friendlyDebuffs) {
          battle.friendlyDebuffs = { hero: {}, companions: {} };
        }
        
        // è§£é™¤å‹‡è€…çš„debuff
        if (battle.friendlyDebuffs.hero && state.hero && state.hero.stats.hp > 0) {
          const heroDebuffCount = Object.keys(battle.friendlyDebuffs.hero).length;
          if (heroDebuffCount > 0) {
            battle.friendlyDebuffs.hero = {};
            purifiedCount++;
            pushBattleLog(`â†’ å‹‡è€…çš„æ‰€æœ‰debuffè¢«è§£é™¤ï¼`);
          }
        }
        
        // è§£é™¤æ‰€æœ‰åŒä¼´çš„debuff
        if (battle.friendlyDebuffs.companions) {
          const companionIndices = Object.keys(battle.friendlyDebuffs.companions).map(s => parseInt(s));
          companionIndices.forEach(companionIndex => {
            if (companionIndex >= 0 && companionIndex < state.companions.length) {
              const comp = state.companions[companionIndex];
              if (comp && comp.stats.hp > 0 && battle.friendlyDebuffs.companions[companionIndex]) {
                const debuffCount = Object.keys(battle.friendlyDebuffs.companions[companionIndex]).length;
                if (debuffCount > 0) {
                  delete battle.friendlyDebuffs.companions[companionIndex];
                  purifiedCount++;
                  pushBattleLog(`â†’ ${comp.name}çš„æ‰€æœ‰debuffè¢«è§£é™¤ï¼`);
                }
              }
            }
          });
        }
        
        if (purifiedCount === 0) {
          pushBattleLog(`â†’ æ²’æœ‰å‹æ–¹å—åˆ°debuffå½±éŸ¿ã€‚`);
        }
      } else {
        // å–®é«”æ·¨åŒ–ï¼šè§£é™¤ä¸€å€‹å‹æ–¹çš„æ‰€æœ‰debuff
        let targetCharacter = null;
        let targetName = '';
        
        if (battle.selectedEnemyIndex === -1) {
          // ç›®æ¨™æ˜¯å‹‡è€…
          targetCharacter = state.hero;
          targetName = 'å‹‡è€…';
        } else if (battle.selectedEnemyIndex !== null && battle.selectedEnemyIndex <= -2) {
          // ç›®æ¨™æ˜¯åŒä¼´
          const companionIndex = Math.abs(battle.selectedEnemyIndex) - 2;
          const allCompanions = (state.companions || []).filter(c => c && c.stats);
          if (companionIndex >= 0 && companionIndex < allCompanions.length) {
            targetCharacter = allCompanions[companionIndex];
            targetName = targetCharacter.name;
          }
        } else if (target === 'hero') {
          // å¾targetåƒæ•¸ç¢ºå®šç›®æ¨™
          targetCharacter = state.hero;
          targetName = 'å‹‡è€…';
        } else if (target === 'companion') {
          // é¸æ“‡ç¬¬ä¸€å€‹æœ‰debuffçš„åŒä¼´ï¼Œæˆ–è‡ªå·±
          if (battle.friendlyDebuffs && battle.friendlyDebuffs.companions) {
            const companionIndex = state.companions.indexOf(companion);
            if (companionIndex >= 0 && battle.friendlyDebuffs.companions[companionIndex] && Object.keys(battle.friendlyDebuffs.companions[companionIndex]).length > 0) {
              targetCharacter = companion;
              targetName = companion.name;
            } else if (battle.friendlyDebuffs.hero && Object.keys(battle.friendlyDebuffs.hero).length > 0) {
              targetCharacter = state.hero;
              targetName = 'å‹‡è€…';
            } else {
              // é¸æ“‡ç¬¬ä¸€å€‹æœ‰debuffçš„åŒä¼´
              const companionIndices = Object.keys(battle.friendlyDebuffs.companions || {}).map(s => parseInt(s));
              for (const idx of companionIndices) {
                if (idx >= 0 && idx < state.companions.length && battle.friendlyDebuffs.companions[idx] && Object.keys(battle.friendlyDebuffs.companions[idx]).length > 0) {
                  targetCharacter = state.companions[idx];
                  targetName = targetCharacter.name;
                  break;
                }
              }
            }
          } else if (battle.friendlyDebuffs && battle.friendlyDebuffs.hero && Object.keys(battle.friendlyDebuffs.hero).length > 0) {
            targetCharacter = state.hero;
            targetName = 'å‹‡è€…';
          }
        }
        
        if (!targetCharacter || targetCharacter.stats.hp <= 0) {
          pushBattleLog(`${companion.name}ç„¡æ³•ä½¿ç”¨ã€Œ${skill.name}ã€ï¼šç›®æ¨™ç„¡æ•ˆã€‚`);
          companion.stats.mp += mpCost; // é€€å›MP
          return;
        }
        
        pushBattleLog(`${companion.name}å°${targetName}æ–½æ”¾ã€Œ${skill.name}ã€ï¼`);
        
        if (!battle.friendlyDebuffs) {
          battle.friendlyDebuffs = { hero: {}, companions: {} };
        }
        
        const isTargetHero = targetCharacter === state.hero;
        if (isTargetHero) {
          if (battle.friendlyDebuffs.hero) {
            const debuffCount = Object.keys(battle.friendlyDebuffs.hero).length;
            if (debuffCount > 0) {
              battle.friendlyDebuffs.hero = {};
              pushBattleLog(`â†’ ${targetName}çš„æ‰€æœ‰debuffè¢«è§£é™¤ï¼`);
            } else {
              pushBattleLog(`â†’ ${targetName}æ²’æœ‰debuffç‹€æ…‹ã€‚`);
            }
          } else {
            pushBattleLog(`â†’ ${targetName}æ²’æœ‰debuffç‹€æ…‹ã€‚`);
          }
        } else {
          const companionIndex = state.companions.indexOf(targetCharacter);
          if (companionIndex >= 0) {
            if (!battle.friendlyDebuffs.companions[companionIndex]) {
              pushBattleLog(`â†’ ${targetName}æ²’æœ‰debuffç‹€æ…‹ã€‚`);
            } else {
              const debuffCount = Object.keys(battle.friendlyDebuffs.companions[companionIndex]).length;
              if (debuffCount > 0) {
                delete battle.friendlyDebuffs.companions[companionIndex];
                pushBattleLog(`â†’ ${targetName}çš„æ‰€æœ‰debuffè¢«è§£é™¤ï¼`);
              } else {
                pushBattleLog(`â†’ ${targetName}æ²’æœ‰debuffç‹€æ…‹ã€‚`);
              }
            }
          }
        }
      }
      
      renderBattleDialog();
      return;
    }
    
    // å¦‚æœæ˜¯å…¨é«”è¼”åŠ©æŠ€èƒ½ï¼ˆè­·ç›¾ç­‰ï¼‰
    if (skill.aoe) {
      companion.stats.mp -= mpCost;
      pushBattleLog(`${companion.name}æ–½æ”¾ã€Œ${skill.name}ã€ï¼`);
      
      // è¨ˆç®—è­·ç›¾å€¼
      const totalAttrs = getCompanionTotalAttributes(companion);
      const recovery = totalAttrs.recovery;
      const shieldAmount = skill.power + Math.floor(recovery / 2);
      
      // çµ¦è‡ªå·±æ·»åŠ è­·ç›¾
      if (companion.stats.hp > 0) {
        companion.stats.shield = (companion.stats.shield || 0) + shieldAmount;
        pushBattleLog(`â†’ å°è‡ªå·±æ–½åŠ  ${shieldAmount} è­·ç›¾ï¼`);
      }
      
      // çµ¦å‹‡è€…æ·»åŠ è­·ç›¾ï¼ˆå¦‚æœé‚„æ´»è‘—ï¼‰
      if (state.hero && state.hero.stats.hp > 0) {
        state.hero.stats.shield = (state.hero.stats.shield || 0) + shieldAmount;
        pushBattleLog(`â†’ å°å‹‡è€…æ–½åŠ  ${shieldAmount} è­·ç›¾ï¼`);
      }
      
      // çµ¦å…¶ä»–åŒä¼´æ·»åŠ è­·ç›¾
      const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0 && c !== companion);
      activeCompanions.forEach(comp => {
        comp.stats.shield = (comp.stats.shield || 0) + shieldAmount;
        pushBattleLog(`â†’ å°${comp.name}æ–½åŠ  ${shieldAmount} è­·ç›¾ï¼`);
      });
    } else {
      // å–®é«”è¼”åŠ©æŠ€èƒ½
      let targetCharacter = null;
      let targetName = '';
      
      if (battle.selectedEnemyIndex === -1) {
        // ç›®æ¨™æ˜¯è‡ªå·±
        targetCharacter = companion;
        targetName = 'è‡ªå·±';
      } else if (battle.selectedEnemyIndex !== null && battle.selectedEnemyIndex <= -2) {
        // ç›®æ¨™æ˜¯åŒä¼´
        const companionIndex = Math.abs(battle.selectedEnemyIndex) - 2;
        const allCompanions = (state.companions || []).filter(c => c && c.stats);
        if (companionIndex >= 0 && companionIndex < allCompanions.length) {
          targetCharacter = allCompanions[companionIndex];
          targetName = targetCharacter.name;
        }
      } else if (battle.selectedEnemyIndex === null && target === 'hero') {
        // ç›®æ¨™æ˜¯å‹‡è€…
        targetCharacter = state.hero;
        targetName = 'å‹‡è€…';
      }
      
      if (!targetCharacter || targetCharacter.stats.hp <= 0) {
        pushBattleLog(`${companion.name}è©¦åœ–æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œä½†ç›®æ¨™ç„¡æ•ˆã€‚`);
        return;
      }
      
      companion.stats.mp -= mpCost;
      
      // è¨ˆç®—è­·ç›¾å€¼
      const totalAttrs = getCompanionTotalAttributes(companion);
      const recovery = totalAttrs.recovery;
      const shieldAmount = skill.power + Math.floor(recovery / 2);
      
      // çµ¦ç›®æ¨™æ·»åŠ è­·ç›¾
      targetCharacter.stats.shield = (targetCharacter.stats.shield || 0) + shieldAmount;
      pushBattleLog(`${companion.name}æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œå°${targetName}æ–½åŠ  ${shieldAmount} è­·ç›¾ï¼`);
    }
    
    renderBattleDialog();
    return;
  } else if (skill.kind === 'heal') {
    // æ²»ç™‚æŠ€èƒ½
    if (skill.aoe) {
      // å…¨é«”å›å¾©æŠ€èƒ½
      let totalHeal = 0;
      pushBattleLog(`${companion.name}æ–½æ”¾ã€Œ${skill.name}ã€ï¼`);
      
      // æ²»ç–—å‹‡è€…ï¼ˆå¿…é ˆé‚„æ´»è‘—ï¼Œæ™®é€šå›å¾©é­”æ³•ç„¡æ³•å¾©æ´»å·²æ­»äº¡çš„è§’è‰²ï¼‰
      if (state.hero && state.hero.stats.hp > 0) {
        const healAmount = calculateHealingFor(skill, companion);
        const oldHp = state.hero.stats.hp;
        state.hero.stats.hp = Math.ceil(Math.min(state.hero.stats.maxHp, state.hero.stats.hp + healAmount));
        const actualHealed = Math.ceil(state.hero.stats.hp - oldHp);
        pushBattleLog(`â†’ å°å‹‡è€…å›å¾© ${actualHealed} HPï¼ˆ${oldHp} â†’ ${state.hero.stats.hp}ï¼‰`);
        totalHeal += actualHealed;
        // è§¸ç™¼ç¥è–è­·ç›¾æ•ˆæœï¼ˆå¦‚æœæ˜¯ç¥è–è­·ç›¾æŠ€èƒ½ï¼‰
        applySacredShieldEffect(skill, companion, state.hero);
      }
      
      // æ²»ç–—æ‰€æœ‰åŒä¼´ï¼ˆåŒ…æ‹¬è‡ªå·±ï¼‰
      const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
      activeCompanions.forEach(comp => {
        const healAmount = calculateHealingFor(skill, companion);
        const oldHp = comp.stats.hp;
        comp.stats.hp = Math.ceil(Math.min(comp.stats.maxHp, comp.stats.hp + healAmount));
        const actualHealed = Math.ceil(comp.stats.hp - oldHp);
        pushBattleLog(`â†’ å°${comp.name}å›å¾© ${actualHealed} HPï¼ˆ${oldHp} â†’ ${comp.stats.hp}ï¼‰`);
        totalHeal += actualHealed;
        // è§¸ç™¼ç¥è–è­·ç›¾æ•ˆæœï¼ˆå¦‚æœæ˜¯ç¥è–è­·ç›¾æŠ€èƒ½ï¼‰
        applySacredShieldEffect(skill, companion, comp);
      });
      
      pushBattleLog(`ç¸½å…±å›å¾© ${totalHeal} HPï¼`);
    } else {
      // å–®é«”å›å¾©æŠ€èƒ½
      const isReviveSkill = skill.id === 'revive_companion';
    let healTarget = null;
      
      if (isReviveSkill) {
        // å¾©æ´»è¡“ï¼šæ ¹æ“š selectedEnemyIndex æˆ– companionAction é¸æ“‡ç›®æ¨™
        const allCompanions = (state.companions || []).filter(c => c && c.stats);
        if (battle.selectedEnemyIndex !== null && battle.selectedEnemyIndex <= -2) {
          // å¾ selectedEnemyIndex è¨ˆç®—åŒä¼´ç´¢å¼•ï¼š-2 -> 0, -3 -> 1, -4 -> 2, ...
          const companionIndex = Math.abs(battle.selectedEnemyIndex) - 2;
          if (companionIndex >= 0 && companionIndex < allCompanions.length) {
            healTarget = allCompanions[companionIndex];
          }
        } else if (battle.companionAction && battle.companionAction.companionIndex !== undefined) {
          // å¾ companionAction ç²å–åŒä¼´ç´¢å¼•
          const companionIndex = battle.companionAction.companionIndex;
          if (companionIndex >= 0 && companionIndex < allCompanions.length) {
            healTarget = allCompanions[companionIndex];
          }
        }
        
        // å¾©æ´»è¡“åªèƒ½å°å·²æ­»äº¡çš„åŒä¼´ä½¿ç”¨
        if (healTarget && healTarget.stats.hp <= 0) {
          const revivePercent = skill.revivePercent || 0.3;
          const reviveHp = Math.max(1, Math.floor(healTarget.stats.maxHp * revivePercent));
          healTarget.stats.hp = reviveHp;
          pushBattleLog(`${companion.name}æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œå¾©æ´»äº†${healTarget.name}ï¼Œå›å¾© ${reviveHp} HPï¼ˆ${healTarget.stats.maxHp}çš„${Math.round(revivePercent * 100)}%ï¼‰ï¼`);
        } else if (healTarget && healTarget.stats.hp > 0) {
          // ç›®æ¨™é‚„æ´»è‘—ï¼Œç„¡æ³•ä½¿ç”¨å¾©æ´»è¡“
          pushBattleLog(`${companion.name}è©¦åœ–æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œä½†${healTarget.name}é‚„æ´»è‘—ï¼Œç„¡æ³•å¾©æ´»ã€‚`);
        } else {
          // å¦‚æœæ²’æœ‰æ‰¾åˆ°ç›®æ¨™ï¼Œè¨˜éŒ„éŒ¯èª¤
          pushBattleLog(`${companion.name}è©¦åœ–æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œä½†æ‰¾ä¸åˆ°å¯å¾©æ´»çš„ç›®æ¨™ã€‚`);
        }
      } else {
        // æ™®é€šæ²»ç™‚æŠ€èƒ½
    if (target === 'hero') {
      healTarget = state.hero;
    } else if (target === 'companion') {
      healTarget = companion;
    }
    
    // æ™®é€šå›å¾©é­”æ³•ç„¡æ³•å¾©æ´»å·²æ­»äº¡çš„è§’è‰²
    if (healTarget && healTarget.stats.hp > 0) {
      const baseValue = skill.power || 0;
      const totalAttrs = getCompanionTotalAttributes(companion);
      const recovery = totalAttrs.recovery || 0;
      const healAmount = baseValue + Math.floor(recovery / 3);
      const actualHeal = Math.ceil(healAmount);
      const oldHp = healTarget.stats.hp;
      healTarget.stats.hp = Math.ceil(Math.min(healTarget.stats.maxHp, healTarget.stats.hp + actualHeal));
      const actualHealed = Math.ceil(healTarget.stats.hp - oldHp);
      
      const targetName = healTarget === state.hero ? 'å‹‡è€…' : companion.name;
      pushBattleLog(`${companion.name}æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œå°${targetName}å›å¾© ${actualHealed} HPï¼`);
      // è§¸ç™¼ç¥è–è­·ç›¾æ•ˆæœï¼ˆå¦‚æœæ˜¯ç¥è–è­·ç›¾æŠ€èƒ½ï¼‰
      applySacredShieldEffect(skill, companion, healTarget);
      // è§¸ç™¼é˜²æ­»è­·ç›¾æ•ˆæœï¼ˆå¦‚æœæ˜¯é˜²æ­»è­·ç›¾æŠ€èƒ½ï¼‰
      applyDeathWardEffect(skill, companion, healTarget);
      // è§¸ç™¼ç¥è–å›éŸ¿æ•ˆæœ
      applyHealingEchoEffect(skill, companion, healTarget, actualHealed);
    } else if (healTarget && healTarget.stats.hp <= 0) {
      // ç›®æ¨™å·²æ­»äº¡ï¼Œç„¡æ³•å›å¾©
      const targetName = healTarget === state.hero ? 'å‹‡è€…' : companion.name;
      pushBattleLog(`${companion.name}æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œä½†${targetName}å·²æ­»äº¡ï¼Œç„¡æ³•å›å¾©ã€‚`);
    } else {
      // å¦‚æœæ²’æœ‰æ‰¾åˆ°ç›®æ¨™ï¼Œè¨˜éŒ„éŒ¯èª¤
      pushBattleLog(`${companion.name}è©¦åœ–æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œä½†æ‰¾ä¸åˆ°ç›®æ¨™ã€‚`);
        }
      }
    }
  } else if (skill.kind === 'buff') {
    // è™•ç†å‚·å®³æ¸›å…æŠ€èƒ½
    if (skill.damageReduction !== undefined) {
      if (!battle.companionBuffs) {
        battle.companionBuffs = {};
      }
      // ä¿ç•™ç°æœ‰çš„ç´¢å¼•æ ¼å¼buffï¼ˆå¦‚ignoreDefenseï¼‰
      const existingIndexBuffs = {};
      Object.keys(battle.companionBuffs).forEach(key => {
        const index = parseInt(key);
        if (!isNaN(index) && battle.companionBuffs[index]) {
          existingIndexBuffs[index] = { ...battle.companionBuffs[index] };
        }
      });
      battle.companionBuffs = { ...existingIndexBuffs };
      const damageReduction = skill.damageReduction;
      battle.companionBuffs.guard = Math.max(battle.companionBuffs.guard || 0, damageReduction);
      // è¨­ç½®å˜²è«·ç›®æ¨™ï¼š100%å¸å¼•æ‰€æœ‰å–®é«”æ”»æ“Š
      battle.tauntTarget = { type: 'companion', character: companion };
      pushBattleLog(`${companion.name}å°è‡ªå·±æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œé€™å›åˆå—åˆ°å‚·å®³æ¸›å°‘ ${Math.round(damageReduction * 100)}%ï¼Œä¸¦å¸å¼•æ‰€æœ‰æ•µäººçš„å–®é«”æ”»æ“Šï¼`);
    } else {
      // åŸæœ‰çš„buffæŠ€èƒ½è™•ç†
      if (!battle.companionBuffs) {
        battle.companionBuffs = {};
      }
      // ä¿ç•™ç°æœ‰çš„ç´¢å¼•æ ¼å¼buffï¼ˆå¦‚ignoreDefenseï¼‰
      const existingIndexBuffs = {};
      Object.keys(battle.companionBuffs).forEach(key => {
        const index = parseInt(key);
        if (!isNaN(index) && battle.companionBuffs[index]) {
          existingIndexBuffs[index] = { ...battle.companionBuffs[index] };
        }
      });
      battle.companionBuffs = { ...existingIndexBuffs };
      const guardBoost = Math.min(0.8, 0.3 + (skill.power || 0.3));
      battle.companionBuffs.guard = Math.max(battle.companionBuffs.guard || 0, guardBoost);
      pushBattleLog(`${companion.name}æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œé˜²ç¦¦å¤§å¹…æå‡ã€‚`);
    }
  }
  
  // æ›´æ–°UIé¡¯ç¤ºï¼ˆç¢ºä¿å‚·å®³å’Œç‹€æ…‹è®ŠåŒ–è¢«é¡¯ç¤ºï¼‰
  renderBattleDialog();
  
  battle.selectedEnemyIndex = null;
}

// æ•µäººç›´æ¥åŸ·è¡Œæ™®é€šæ”»æ“Š
function performEnemyBasicAttackDirectly(enemy, target, enemyIndex) {
  if (!enemy || !target || target.stats.hp <= 0) return;
  
  const battle = state.ui.battle;
  let attack = enemy.attributes.attack;
  
  // æª¢æŸ¥æ˜¯å¦æœ‰æ”»æ“ŠåŠ›æ¸›å°‘debuffï¼ˆè…æ“Šï¼‰
  if (battle && battle.enemyDebuffs) {
    const enemyIndex = battle.enemies.indexOf(enemy);
    if (enemyIndex >= 0 && battle.enemyDebuffs[enemyIndex] && battle.enemyDebuffs[enemyIndex].attackDown) {
      const attackDown = battle.enemyDebuffs[enemyIndex].attackDown;
      // æ‡‰ç”¨æ”»æ“ŠåŠ›æ¸›å°‘æ•ˆæœï¼šæ¸›å°‘1/3æ”»æ“ŠåŠ›
      attack = Math.max(0, Math.floor(attack * (1 - attackDown.ratio)));
    }
  }
  
  let damage = 0;
  
  if (target === state.hero) {
    // æ”»æ“Šå‹‡è€…
    const totalAttrs = getHeroTotalAttributes(target);
    const defense = totalAttrs.defense + getEquipmentDefense(target);
    damage = Math.max(1, Math.round(attack - defense));
    
    // æª¢æŸ¥é–ƒé¿
    const dodgeRate = getEquipmentDodge(target);
    if (dodgeRate > 0 && Math.random() < dodgeRate) {
      pushBattleLog(`${enemy.name} æ”»æ“Šè¢«é–ƒé¿ï¼`);
      return;
    }
    
    let finalDamage = damage;
    // æª¢æŸ¥é˜²å®ˆbuff
    if (battle.heroBuffs.guard > 0) {
      finalDamage = Math.round(damage * (1 - battle.heroBuffs.guard));
      battle.heroBuffs.guard = 0;
      // æ¸…é™¤å˜²è«·ç›®æ¨™
      if (battle.tauntTarget && battle.tauntTarget.type === 'hero') {
        battle.tauntTarget = null;
      }
    }
    
    // å…ˆæ‰£é™¤è­·ç›¾
    ({ finalDamage } = absorbShield(target, finalDamage, 'è­·ç›¾'));

    // æª¢æŸ¥é˜²æ­»è­·ç›¾æ•ˆæœ
    const battle = state.ui.battle;
    let shouldTriggerDeathWard = false;
    if (target === state.hero && battle.heroBuffs.deathWard) {
      shouldTriggerDeathWard = true;
    } else if (state.companions && state.companions.includes(target)) {
      const companionIndex = state.companions.indexOf(target);
      if (battle.companionBuffs[companionIndex] && battle.companionBuffs[companionIndex].deathWard) {
        shouldTriggerDeathWard = true;
      }
    }
    
    // å¦‚æœæœƒæ­»äº¡ä¸”æ“æœ‰é˜²æ­»è­·ç›¾ï¼Œè§¸ç™¼æ•ˆæœ
    if (shouldTriggerDeathWard && target.stats.hp - finalDamage <= 0 && target.stats.hp > 0) {
      target.stats.hp = 1;
      pushBattleLog(`â†’ é˜²æ­»è­·ç›¾æ•ˆæœè§¸ç™¼ï¼${target === state.hero ? 'å‹‡è€…' : target.name}çš„ç”Ÿå‘½å€¼ä¿ç•™ç‚º1ï¼`);
      // ç§»é™¤é˜²æ­»è­·ç›¾buff
      if (target === state.hero) {
        battle.heroBuffs.deathWard = false;
      } else {
        const companionIndex = state.companions.indexOf(target);
        if (companionIndex >= 0 && battle.companionBuffs[companionIndex]) {
          battle.companionBuffs[companionIndex].deathWard = false;
        }
      }
    } else {
      target.stats.hp = Math.max(0, target.stats.hp - finalDamage);
    }
    pushBattleLog(`${enemy.name} æ”»æ“Šé€ æˆ ${finalDamage > 0 ? finalDamage : 0} å‚·å®³ï¼`);
    
    // è§¸ç™¼è¢«æ”»æ“Šæ™‚çš„è¢«å‹•æŠ€èƒ½ï¼ˆå®ˆè­·æ„å¿—ç­‰ï¼‰
    if (finalDamage > 0) {
      triggerOnHitPassiveEffects(target, finalDamage);
    }
  } else if (target === getActiveCompanion()) {
    // æ”»æ“ŠåŒä¼´
    const totalAttrs = getCompanionTotalAttributes(target);
    const defense = totalAttrs.defense;
    damage = Math.max(1, Math.round(attack - defense));
    
    let finalDamage = damage;
    // æª¢æŸ¥åŒä¼´é˜²å®ˆbuff
    if (battle.companionBuffs && battle.companionBuffs.guard > 0) {
      finalDamage = Math.round(damage * (1 - battle.companionBuffs.guard));
      battle.companionBuffs.guard = 0;
      // æ¸…é™¤å˜²è«·ç›®æ¨™
      if (battle.tauntTarget && battle.tauntTarget.type === 'companion' && battle.tauntTarget.character === target) {
        battle.tauntTarget = null;
      }
    }
    
    // å…ˆæ‰£é™¤è­·ç›¾
    ({ finalDamage } = absorbShield(target, finalDamage, 'è­·ç›¾'));

    // æª¢æŸ¥é˜²æ­»è­·ç›¾æ•ˆæœ
    let shouldTriggerDeathWard = false;
    if (battle.companionBuffs && battle.companionBuffs[state.companions.indexOf(target)]) {
      const companionIndex = state.companions.indexOf(target);
      if (battle.companionBuffs[companionIndex].deathWard) {
        shouldTriggerDeathWard = true;
      }
    }
    
    // å¦‚æœæœƒæ­»äº¡ä¸”æ“æœ‰é˜²æ­»è­·ç›¾ï¼Œè§¸ç™¼æ•ˆæœ
    if (shouldTriggerDeathWard && target.stats.hp - finalDamage <= 0 && target.stats.hp > 0) {
      target.stats.hp = 1;
      pushBattleLog(`â†’ é˜²æ­»è­·ç›¾æ•ˆæœè§¸ç™¼ï¼${target.name}çš„ç”Ÿå‘½å€¼ä¿ç•™ç‚º1ï¼`);
      // ç§»é™¤é˜²æ­»è­·ç›¾buff
      const companionIndex = state.companions.indexOf(target);
      if (companionIndex >= 0 && battle.companionBuffs[companionIndex]) {
        battle.companionBuffs[companionIndex].deathWard = false;
      }
    } else {
      target.stats.hp = Math.max(0, target.stats.hp - finalDamage);
    }
    pushBattleLog(`${enemy.name} æ”»æ“Š${target.name}é€ æˆ ${finalDamage > 0 ? finalDamage : 0} å‚·å®³ï¼`);
    
    // è§¸ç™¼è¢«æ”»æ“Šæ™‚çš„è¢«å‹•æŠ€èƒ½ï¼ˆå®ˆè­·æ„å¿—ç­‰ï¼‰
    if (finalDamage > 0) {
      triggerOnHitPassiveEffects(target, finalDamage);
    }
  }
}

// æ•µäººç›´æ¥åŸ·è¡ŒæŠ€èƒ½
function performEnemySkillDirectly(enemy, skill, target, enemyIndex) {
  if (!enemy || !skill || !target || target.stats.hp <= 0) return;
  
  const battle = state.ui.battle;
  const mpCost = skill.mpCost || 0;
  enemy.stats.mp = Math.max(0, enemy.stats.mp - mpCost);
  
  if (skill.kind === 'attack') {
    if (skill.aoe) {
      // å…¨é«”æ”»æ“Šï¼šå°æ‰€æœ‰å°è±¡ï¼ˆè‹±é›„å’Œæ‰€æœ‰åŒä¼´ï¼‰é€ æˆå‚·å®³
      pushBattleLog(`${enemy.name} æ–½æ”¾ã€Œ${skill.name}ã€ï¼`);
      
      let totalDamage = 0;
      
      // å°è‹±é›„é€ æˆå‚·å®³
      if (state.hero.stats.hp > 0) {
        const { damage, isCrit } = calculateSkillDamage(skill, enemy, state.hero);
        let finalDamage = damage;
        // æª¢æŸ¥é˜²å®ˆbuff
        if (battle.heroBuffs.guard > 0) {
          finalDamage = Math.round(damage * (1 - battle.heroBuffs.guard));
          battle.heroBuffs.guard = 0;
          // æ¸…é™¤å˜²è«·ç›®æ¨™
          if (battle.tauntTarget && battle.tauntTarget.type === 'hero') {
            battle.tauntTarget = null;
          }
        }
        
        // å…ˆæ‰£é™¤è­·ç›¾
        ({ finalDamage } = absorbShield(state.hero, finalDamage, 'â†’ å‹‡è€…'));

        const oldHp = state.hero.stats.hp;
        state.hero.stats.hp = Math.max(0, state.hero.stats.hp - finalDamage);
        totalDamage += finalDamage;
        const critMsg = isCrit ? 'ï¼ˆæœƒå¿ƒä¸€æ“Šï¼ï¼‰' : '';
        pushBattleLog(`â†’ å°å‹‡è€…é€ æˆ ${finalDamage > 0 ? finalDamage : 0} å‚·å®³${critMsg}`);
        
        // è§¸ç™¼è¢«æ”»æ“Šæ™‚çš„è¢«å‹•æŠ€èƒ½ï¼ˆå®ˆè­·æ„å¿—ç­‰ï¼‰
        if (finalDamage > 0) {
          triggerOnHitPassiveEffects(state.hero, finalDamage);
        }
        
        if (state.hero.stats.hp <= 0) {
          pushBattleLog(`â†’ å‹‡è€… è¢«æ“Šå€’ï¼`);
          // è¨˜éŒ„å‚·å®³ä¿¡æ¯ï¼ˆç”¨æ–¼æ­»äº¡çµ±è¨ˆï¼‰
          state.ui.deathInfo = {
            cause: 'skill',
            attacker: enemy.name,
            damage: damage,
            skill: skill.name,
            isCrit: isCrit,
          };
        }
      }
      
      // å°æ‰€æœ‰åŒä¼´é€ æˆå‚·å®³
      const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
      activeCompanions.forEach((companion) => {
        const { damage, isCrit } = calculateSkillDamage(skill, enemy, companion);
        let finalDamage = damage;
        // æª¢æŸ¥åŒä¼´é˜²å®ˆbuff
        if (battle.companionBuffs && battle.companionBuffs.guard > 0) {
          finalDamage = Math.round(damage * (1 - battle.companionBuffs.guard));
          battle.companionBuffs.guard = 0;
          // æ¸…é™¤å˜²è«·ç›®æ¨™
          if (battle.tauntTarget && battle.tauntTarget.type === 'companion' && battle.tauntTarget.character === companion) {
            battle.tauntTarget = null;
          }
        }
        
        // å…ˆæ‰£é™¤è­·ç›¾
        ({ finalDamage } = absorbShield(companion, finalDamage, `â†’ ${companion.name}`));

        const oldHp = companion.stats.hp;
        companion.stats.hp = Math.max(0, companion.stats.hp - finalDamage);
        totalDamage += finalDamage;
        const critMsg = isCrit ? 'ï¼ˆæœƒå¿ƒä¸€æ“Šï¼ï¼‰' : '';
        pushBattleLog(`â†’ å°${companion.name}é€ æˆ ${finalDamage} å‚·å®³${critMsg}`);
        
        // è§¸ç™¼è¢«æ”»æ“Šæ™‚çš„è¢«å‹•æŠ€èƒ½ï¼ˆå®ˆè­·æ„å¿—ç­‰ï¼‰
        if (finalDamage > 0) {
          triggerOnHitPassiveEffects(companion, finalDamage);
        }
        
        if (companion.stats.hp <= 0) {
          pushBattleLog(`â†’ ${companion.name} è¢«æ“Šå€’ï¼`);
        }
      });
      
      // é¡¯ç¤ºç¸½å‚·å®³
      if (totalDamage > 0) {
        pushBattleLog(`ç¸½å…±é€ æˆ ${totalDamage} å‚·å®³ï¼`);
      }
      
      // æ›´æ–°UIé¡¯ç¤º
      renderBattleDialog();
    } else {
      // å–®é«”æ”»æ“Š
      const { damage, isCrit } = calculateSkillDamage(skill, enemy, target);
      let finalDamage = damage;
      
      // æª¢æŸ¥é˜²å®ˆbuff
      if (target === state.hero) {
        if (battle.heroBuffs.guard > 0) {
          finalDamage = Math.round(damage * (1 - battle.heroBuffs.guard));
          battle.heroBuffs.guard = 0;
          // æ¸…é™¤å˜²è«·ç›®æ¨™
          if (battle.tauntTarget && battle.tauntTarget.type === 'hero') {
            battle.tauntTarget = null;
          }
        }
        
        ({ finalDamage } = absorbShield(target, finalDamage, 'è­·ç›¾'));
      } else {
        const activeCompanion = getActiveCompanion();
        if (target === activeCompanion && battle.companionBuffs && battle.companionBuffs.guard > 0) {
          finalDamage = Math.round(damage * (1 - battle.companionBuffs.guard));
          battle.companionBuffs.guard = 0;
          if (battle.tauntTarget && battle.tauntTarget.type === 'companion' && battle.tauntTarget.character === target) {
            battle.tauntTarget = null;
          }
        }

        ({ finalDamage } = absorbShield(target, finalDamage, 'è­·ç›¾'));
      }
      
      target.stats.hp = Math.max(0, target.stats.hp - finalDamage);
      const critMsg = isCrit ? 'ï¼ˆæœƒå¿ƒä¸€æ“Šï¼ï¼‰' : '';
      const activeCompanion = getActiveCompanion();
      const targetName = target === state.hero ? 'å‹‡è€…' : (target === activeCompanion ? target.name : target.name);
      pushBattleLog(`${enemy.name} æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œå°${targetName}é€ æˆ ${finalDamage} å‚·å®³ï¼${critMsg}`);
      
      // è§¸ç™¼è¢«æ”»æ“Šæ™‚çš„è¢«å‹•æŠ€èƒ½ï¼ˆå®ˆè­·æ„å¿—ç­‰ï¼‰
      if (finalDamage > 0) {
        triggerOnHitPassiveEffects(target, finalDamage);
      }
      
      // è¨˜éŒ„å‚·å®³ä¿¡æ¯ï¼ˆç”¨æ–¼æ­»äº¡çµ±è¨ˆï¼‰
      if (target === state.hero && state.hero.stats.hp <= 0) {
        state.ui.deathInfo = {
          cause: 'skill',
          attacker: enemy.name,
          damage: finalDamage,
          skill: skill.name,
          isCrit: isCrit,
        };
      }
    }
  } else if (skill.kind === 'heal') {
    // æ•µäººæ²»ç™‚è‡ªå·±
    const baseValue = skill.power || 0;
    const recovery = enemy.attributes.recovery || 0;
    const healAmount = baseValue + Math.floor(recovery / 3);
    enemy.stats.hp = Math.min(enemy.stats.maxHp, enemy.stats.hp + Math.round(healAmount));
    pushBattleLog(`${enemy.name} æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œå›å¾©äº†ç”Ÿå‘½ï¼`);
  } else if (skill.kind === 'debuff') {
    // DebuffæŠ€èƒ½ï¼ˆä¸‹æ¯’ç­‰ï¼‰
    if (skill.id && skill.id.startsWith('poison_attack')) {
      // ä¸‹æ¯’æŠ€èƒ½ï¼šå°å‹æ–¹ç›®æ¨™ä¸‹æ¯’
      if (!target || target.stats.hp <= 0) {
        pushBattleLog(`${enemy.name}ç„¡æ³•ä½¿ç”¨ã€Œ${skill.name}ã€ï¼šç›®æ¨™ç„¡æ•ˆã€‚`);
        return;
      }
      
      // è¨ˆç®—æ–½æ³•è€…çš„æ•æ·å€¼
      const casterAgility = enemy.attributes.agility || 0;
      
      // è¨ˆç®—ä¸­æ¯’å‚·å®³ï¼ˆæ ¹æ“šæŠ€èƒ½ç­‰ç´šçš„æ¯”ç‡ï¼‰
      const poisonDamage = Math.max(1, Math.floor(casterAgility * (skill.poisonRatio || 0.3)));
      const poisonDuration = skill.poisonDuration || 3;
      
      // åˆå§‹åŒ– friendlyDebuffs
      if (!battle.friendlyDebuffs) {
        battle.friendlyDebuffs = { hero: {}, companions: {} };
      }
      
      // ç¢ºå®šç›®æ¨™é¡å‹
      const isHero = target === state.hero;
      const targetName = isHero ? 'å‹‡è€…' : target.name;
      
      if (isHero) {
        // å°å‹‡è€…ä¸‹æ¯’
        if (!battle.friendlyDebuffs.hero) {
          battle.friendlyDebuffs.hero = {};
        }
        const hadPoison = battle.friendlyDebuffs.hero.poison ? true : false;
        battle.friendlyDebuffs.hero.poison = {
          duration: poisonDuration,
          damage: poisonDamage,
          casterAgility: casterAgility
        };
        
        pushBattleLog(`${enemy.name}å°${targetName}æ–½æ”¾ã€Œ${skill.name}ã€ï¼`);
        
        // ç«‹å³æ‡‰ç”¨ä¸€æ¬¡ä¸­æ¯’å‚·å®³ï¼ˆæ–½åŠ çš„é‚£ä¸€å›åˆå°±ç”Ÿæ•ˆï¼Œå…ˆæ‰£é™¤è­·ç›¾ï¼‰
        let remainingDamage = poisonDamage;
        ({ finalDamage: remainingDamage } = absorbShield(state.hero, remainingDamage, 'â†’ å‹‡è€…'));
        if (remainingDamage > 0) {
          const oldHp = state.hero.stats.hp;
          state.hero.stats.hp = Math.max(0, state.hero.stats.hp - remainingDamage);
          const immediateDamage = oldHp - state.hero.stats.hp;
          if (immediateDamage > 0) {
            pushBattleLog(`â†’ ${targetName}ç«‹å³å—åˆ°ä¸­æ¯’å‚·å®³ ${immediateDamage}ï¼`);
          }
        }

        if (hadPoison) {
          pushBattleLog(`â†’ ${targetName}çš„æ¯’è¢«åˆ·æ–°ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${poisonDuration}å›åˆä¸­ï¼Œæ¯å›åˆçµæŸæ™‚å—åˆ° ${poisonDamage} å‚·å®³ï¼ˆä¸å—é˜²å®ˆå½±éŸ¿ï¼‰ã€‚`);
        } else {
          pushBattleLog(`â†’ ${targetName}ä¸­æ¯’äº†ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${poisonDuration}å›åˆä¸­ï¼Œæ¯å›åˆçµæŸæ™‚å—åˆ° ${poisonDamage} å‚·å®³ï¼ˆä¸å—é˜²å®ˆå½±éŸ¿ï¼‰ã€‚`);
        }
      } else {
        // å°åŒä¼´ä¸‹æ¯’
        const companionIndex = state.companions.indexOf(target);
        if (companionIndex >= 0) {
          if (!battle.friendlyDebuffs.companions[companionIndex]) {
            battle.friendlyDebuffs.companions[companionIndex] = {};
          }
          const hadPoison = battle.friendlyDebuffs.companions[companionIndex].poison ? true : false;
          battle.friendlyDebuffs.companions[companionIndex].poison = {
            duration: poisonDuration,
            damage: poisonDamage,
            casterAgility: casterAgility
          };
          
          pushBattleLog(`${enemy.name}å°${targetName}æ–½æ”¾ã€Œ${skill.name}ã€ï¼`);
          
          // ç«‹å³æ‡‰ç”¨ä¸€æ¬¡ä¸­æ¯’å‚·å®³ï¼ˆæ–½åŠ çš„é‚£ä¸€å›åˆå°±ç”Ÿæ•ˆï¼Œå…ˆæ‰£é™¤è­·ç›¾ï¼‰
          let remainingDamage = poisonDamage;
          ({ finalDamage: remainingDamage } = absorbShield(target, remainingDamage, `â†’ ${targetName}`));
          if (remainingDamage > 0) {
            const oldHp = target.stats.hp;
            target.stats.hp = Math.max(0, target.stats.hp - remainingDamage);
            const immediateDamage = oldHp - target.stats.hp;
            if (immediateDamage > 0) {
              pushBattleLog(`â†’ ${targetName}ç«‹å³å—åˆ°ä¸­æ¯’å‚·å®³ ${immediateDamage}ï¼`);
              // è§¸ç™¼è¢«æ”»æ“Šæ™‚çš„è¢«å‹•æŠ€èƒ½ï¼ˆå¾©ä»‡æ„å¿—ç­‰ï¼‰
              triggerOnHitPassiveEffects(target, immediateDamage);
            }
          }
          
          if (hadPoison) {
            pushBattleLog(`â†’ ${targetName}çš„æ¯’è¢«åˆ·æ–°ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${poisonDuration}å›åˆä¸­ï¼Œæ¯å›åˆçµæŸæ™‚å—åˆ° ${poisonDamage} å‚·å®³ï¼ˆä¸å—é˜²å®ˆå½±éŸ¿ï¼‰ã€‚`);
          } else {
            pushBattleLog(`â†’ ${targetName}ä¸­æ¯’äº†ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${poisonDuration}å›åˆä¸­ï¼Œæ¯å›åˆçµæŸæ™‚å—åˆ° ${poisonDamage} å‚·å®³ï¼ˆä¸å—é˜²å®ˆå½±éŸ¿ï¼‰ã€‚`);
          }
        }
      }
    }
  }
  
  // è™•ç†æ”»æ“ŠæŠ€èƒ½é™„å¸¶çš„debuffæ•ˆæœï¼ˆå†°çƒæ¸›é€Ÿã€é…¸æ€§ç®­æ¸›é˜²ï¼‰
  if (skill.kind === 'attack') {
    // å†°çƒï¼šé€ æˆæ¸›é€Ÿæ•ˆæœ
    if (skill.id && skill.id.startsWith('iceball_') && skill.slowDuration && skill.slowRatio) {
      if (!battle.friendlyDebuffs) {
        battle.friendlyDebuffs = { hero: {}, companions: {} };
      }
      
      const isHero = target === state.hero;
      const targetName = isHero ? 'å‹‡è€…' : target.name;
      
      if (isHero) {
        if (!battle.friendlyDebuffs.hero) {
          battle.friendlyDebuffs.hero = {};
        }
        const hadSlow = battle.friendlyDebuffs.hero.slow ? true : false;
        battle.friendlyDebuffs.hero.slow = {
          duration: skill.slowDuration,
          ratio: skill.slowRatio
        };
        
        if (hadSlow) {
          pushBattleLog(`â†’ ${targetName}çš„æ¸›é€Ÿæ•ˆæœè¢«åˆ·æ–°ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.slowDuration}å›åˆä¸­ï¼Œé€Ÿåº¦æ¸›å°‘ ${Math.round(skill.slowRatio * 100)}%ã€‚`);
        } else {
          pushBattleLog(`â†’ ${targetName}è¢«å†°å‡æ¸›é€Ÿï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.slowDuration}å›åˆä¸­ï¼Œé€Ÿåº¦æ¸›å°‘ ${Math.round(skill.slowRatio * 100)}%ã€‚`);
        }
      } else {
        const companionIndex = state.companions.indexOf(target);
        if (companionIndex >= 0) {
          if (!battle.friendlyDebuffs.companions[companionIndex]) {
            battle.friendlyDebuffs.companions[companionIndex] = {};
          }
          const hadSlow = battle.friendlyDebuffs.companions[companionIndex].slow ? true : false;
          battle.friendlyDebuffs.companions[companionIndex].slow = {
            duration: skill.slowDuration,
            ratio: skill.slowRatio
          };
          
          if (hadSlow) {
            pushBattleLog(`â†’ ${targetName}çš„æ¸›é€Ÿæ•ˆæœè¢«åˆ·æ–°ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.slowDuration}å›åˆä¸­ï¼Œé€Ÿåº¦æ¸›å°‘ ${Math.round(skill.slowRatio * 100)}%ã€‚`);
          } else {
            pushBattleLog(`â†’ ${targetName}è¢«å†°å‡æ¸›é€Ÿï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.slowDuration}å›åˆä¸­ï¼Œé€Ÿåº¦æ¸›å°‘ ${Math.round(skill.slowRatio * 100)}%ã€‚`);
          }
        }
      }
    }
    
    // é…¸æ€§ç®­ï¼šé€ æˆé˜²å®ˆå€¼æ¸›å°‘æ•ˆæœ
    if (skill.id && skill.id.startsWith('acid_arrow_') && skill.defenseDownDuration && skill.defenseDownRatio) {
      if (!battle.friendlyDebuffs) {
        battle.friendlyDebuffs = { hero: {}, companions: {} };
      }
      
      const isHero = target === state.hero;
      const targetName = isHero ? 'å‹‡è€…' : target.name;
      
      if (isHero) {
        if (!battle.friendlyDebuffs.hero) {
          battle.friendlyDebuffs.hero = {};
        }
        const hadDefenseDown = battle.friendlyDebuffs.hero.defenseDown ? true : false;
        battle.friendlyDebuffs.hero.defenseDown = {
          duration: skill.defenseDownDuration,
          ratio: skill.defenseDownRatio
        };
        
        if (hadDefenseDown) {
          pushBattleLog(`â†’ ${targetName}çš„é˜²å®ˆå€¼æ¸›å°‘æ•ˆæœè¢«åˆ·æ–°ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.defenseDownDuration}å›åˆä¸­ï¼Œé˜²å®ˆå€¼æ¸›å°‘ ${Math.round(skill.defenseDownRatio * 100)}%ã€‚`);
        } else {
          pushBattleLog(`â†’ ${targetName}çš„é˜²å®ˆå€¼è¢«è…è•æ¸›å°‘ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.defenseDownDuration}å›åˆä¸­ï¼Œé˜²å®ˆå€¼æ¸›å°‘ ${Math.round(skill.defenseDownRatio * 100)}%ã€‚`);
        }
      } else {
        const companionIndex = state.companions.indexOf(target);
        if (companionIndex >= 0) {
          if (!battle.friendlyDebuffs.companions[companionIndex]) {
            battle.friendlyDebuffs.companions[companionIndex] = {};
          }
          const hadDefenseDown = battle.friendlyDebuffs.companions[companionIndex].defenseDown ? true : false;
          battle.friendlyDebuffs.companions[companionIndex].defenseDown = {
            duration: skill.defenseDownDuration,
            ratio: skill.defenseDownRatio
          };
          
          if (hadDefenseDown) {
            pushBattleLog(`â†’ ${targetName}çš„é˜²å®ˆå€¼æ¸›å°‘æ•ˆæœè¢«åˆ·æ–°ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.defenseDownDuration}å›åˆä¸­ï¼Œé˜²å®ˆå€¼æ¸›å°‘ ${Math.round(skill.defenseDownRatio * 100)}%ã€‚`);
          } else {
            pushBattleLog(`â†’ ${targetName}çš„é˜²å®ˆå€¼è¢«è…è•æ¸›å°‘ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.defenseDownDuration}å›åˆä¸­ï¼Œé˜²å®ˆå€¼æ¸›å°‘ ${Math.round(skill.defenseDownRatio * 100)}%ã€‚`);
          }
        }
      }
    }
  }
}

// ä½¿ç”¨é“å…·ï¼ˆç›´æ¥åŸ·è¡Œï¼Œç›®å‰ä¸éœ€è¦ï¼Œä½†ä¿ç•™æ¥å£ï¼‰
function useBattleItemDirectly(itemId, target) {
  const battle = state.ui.battle;
  if (!battle) return;
  
  const hero = state.hero;
  const companion = state.companion;
  const inventoryItem = hero.items.find((entry) => entry.id === itemId);
  if (!inventoryItem || inventoryItem.qty <= 0) return;
  
  const item = ITEM_LOOKUP.get(itemId);
  if (!item) return;
  
  // ç¢ºå®šç›®æ¨™
  let targetCharacter = hero;
  let targetName = 'ä½ ';
  if (target === 'companion' && companion) {
    targetCharacter = companion;
    targetName = companion.name;
  }
  
  // æ‡‰ç”¨é“å…·æ•ˆæœä¸¦è¨˜éŒ„æ¢å¾©å€¼
  let healAmount = 0;
  let mpAmount = 0;
  const oldHp = targetCharacter.stats.hp;
  const oldMp = targetCharacter.stats.mp;
  
  if (item.type === 'heal') {
    const newHp = Math.min(targetCharacter.stats.maxHp, targetCharacter.stats.hp + item.value);
    healAmount = Math.ceil(newHp - oldHp);
    targetCharacter.stats.hp = Math.ceil(newHp);
  } else if (item.type === 'mp') {
    const newMp = Math.min(targetCharacter.stats.maxMp, targetCharacter.stats.mp + item.value);
    mpAmount = Math.ceil(newMp - oldMp);
    targetCharacter.stats.mp = Math.ceil(newMp);
  } else if (item.type === 'full') {
    healAmount = Math.ceil(targetCharacter.stats.maxHp - oldHp);
    mpAmount = Math.ceil(targetCharacter.stats.maxMp - oldMp);
    targetCharacter.stats.hp = Math.ceil(targetCharacter.stats.maxHp);
    targetCharacter.stats.mp = Math.ceil(targetCharacter.stats.maxMp);
  }
  
  // æ¶ˆè€—é“å…·
  inventoryItem.qty -= 1;
  
  // é¡¯ç¤ºè¨Šæ¯
  const targetDisplay = target === 'companion' ? targetName : 'è‡ªå·±';
  let logMsg = `å‹‡è€…å°${targetDisplay}ä½¿ç”¨ ${item.name}ã€‚`;
  
  if (healAmount > 0 || mpAmount > 0) {
    const effects = [];
    if (healAmount > 0) effects.push(`å›å¾© ${healAmount} HP`);
    if (mpAmount > 0) effects.push(`å›å¾© ${mpAmount} MP`);
    logMsg += ` ${effects.join('ã€')}ï¼`;
  }
  
  pushBattleLog(logMsg);
}

function endHeroTurn() {
  const battle = state.ui.battle;
  if (!battle) return;
  
  // å¦‚æœå‹‡è€…å·²ç¶“é¸æ“‡äº†è¡Œå‹•ï¼Œé–‹å§‹åŸ·è¡Œè¡Œå‹•éšŠåˆ—
  if (battle.heroAction) {
    battle.menu = 'root';
    battle.selectedEnemyIndex = null;
    battle.pendingSkill = null;
    executeActionQueue();
  } else if (state.hero && state.hero.stats.hp <= 0) {
    // å¦‚æœå‹‡è€…æ­»äº¡ä¸”æ²’æœ‰è¡Œå‹•ï¼ˆéˆé­‚è§€æˆ°ï¼‰ï¼Œä¹Ÿè¦åŸ·è¡Œè¡Œå‹•éšŠåˆ—ï¼ˆè®“åŒä¼´å’Œæ•µäººç¹¼çºŒè¡Œå‹•ï¼‰
    battle.menu = 'root';
    battle.selectedEnemyIndex = null;
    battle.pendingSkill = null;
    executeActionQueue();
  }
}

// åŒä¼´è‡ªå‹•æˆ°é¬¥
function companionAct() {
  const battle = state.ui.battle;
  if (!battle || battle.turn !== 'companion') return;
  const companion = state.companion;
  if (!companion || companion.stats.hp <= 0) {
    // åŒä¼´å·²æ­»ï¼Œç›´æ¥è¿›å…¥æ•Œäººå›åˆ
    battle.turn = 'enemy';
    renderBattleDialog();
    setTimeout(enemyAct, 400);
    return;
  }
  
  const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
  if (aliveEnemies.length === 0) {
    concludeBattle(true);
    return;
  }
  
  const hero = state.hero;
  
  // ç²å–æ‰€æœ‰å¯ç”¨æŠ€èƒ½ï¼ˆæ’é™¤è¢«å‹•æŠ€èƒ½ï¼Œä¸”MPè¶³å¤ ï¼Œä¸”æŠ€èƒ½å·²å•Ÿç”¨ï¼‰
  const availableSkills = companion.skills
    .map(id => SKILL_LOOKUP.get(id))
    .filter(skill => skill && skill.kind !== 'passive' && (skill.mpCost || 0) <= companion.stats.mp && isSkillEnabled(skill.id, companion));
  
  if (availableSkills.length === 0 || companion.stats.mp <= 0) {
    // æ²’æœ‰å¯ç”¨æŠ€èƒ½æˆ–MPä¸è¶³ï¼Œä½¿ç”¨æ™®é€šæ”»æ“Š
    performCompanionBasicAttack(companion, battle);
    return;
  }
  
  // 0. æª¢æŸ¥å¾©æ´»éœ€æ±‚ï¼ˆæœ€é«˜å„ªå…ˆç´šï¼‰ï¼šåªæœ‰æœ‰äººæ­»äº¡æ™‚æ‰æœƒä½¿ç”¨å¾©æ´»è¡“
  const reviveSkills = availableSkills.filter(skill => skill.id === 'revive_companion');
  if (reviveSkills.length > 0) {
    // æª¢æŸ¥æ˜¯å¦æœ‰æ­»äº¡çš„åŒä¼´
    const allCompanions = (state.companions || []).filter(c => c && c.stats);
    const deadCompanions = allCompanions.filter(c => c.stats.hp <= 0);
    
    // å¦‚æœæœ‰æ­»äº¡çš„åŒä¼´ï¼Œå„ªå…ˆå¾©æ´»åŒä¼´
    if (deadCompanions.length > 0) {
      // éš¨æ©Ÿé¸æ“‡ä¸€å€‹æ­»äº¡çš„åŒä¼´å¾©æ´»
      const targetCompanion = deadCompanions[Math.floor(Math.random() * deadCompanions.length)];
      const companionIndex = allCompanions.indexOf(targetCompanion);
      if (companionIndex >= 0) {
        // å¾©æ´»è¡“ä½¿ç”¨æ©Ÿç‡è¼ƒé«˜ï¼ˆ80%ï¼‰ï¼Œå› ç‚ºå¾©æ´»å¾ˆé‡è¦
        const roll = Math.random();
        if (roll < 0.8) {
          const reviveSkill = reviveSkills[0];
          performCompanionSkill(companion, reviveSkill, battle);
          return;
        }
      }
    }
  }
  
  // 1. æª¢æŸ¥æ˜¯å¦éœ€è¦æ²»ç™‚ï¼ˆåªæœ‰è¡€é‡å°‘æ–¼50%æ™‚æ‰æœƒä½¿ç”¨æ²»ç™‚ï¼‰
  // åŒæ™‚æœ‰å…©å€‹äººå°‘æ–¼50%æ™‚ï¼Œæ²»ç™‚æ¯”ä¾‹è¼ƒä½çš„äºº
  const companionHpPercent = companion.stats.hp / companion.stats.maxHp;
  const heroHpPercent = hero.stats.hp / hero.stats.maxHp;
  
  // æª¢æŸ¥æ‰€æœ‰è§’è‰²çš„HPç™¾åˆ†æ¯”
  const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
  const allCharacters = [
    { type: 'hero', hpPercent: heroHpPercent, character: hero },
    { type: 'companion', hpPercent: companionHpPercent, character: companion },
  ];
  
  activeCompanions.forEach(comp => {
    if (comp !== companion) {
      const compHpPercent = comp.stats.hp / comp.stats.maxHp;
      allCharacters.push({ type: 'companion', hpPercent: compHpPercent, character: comp });
    }
  });
  
  // åªè€ƒæ…®HP < 50%çš„è§’è‰²
  const lowHpCharacters = allCharacters.filter(c => c.character.stats.hp > 0 && c.hpPercent < 0.5);
  
  if (lowHpCharacters.length > 0) {
    // å°‹æ‰¾æ²»ç™‚æŠ€èƒ½ï¼ˆæ’é™¤å¾©æ´»è¡“ï¼Œå› ç‚ºå¾©æ´»è¡“å·²ç¶“åœ¨ä¸Šé¢è™•ç†äº†ï¼‰
    const healSkills = availableSkills.filter(skill => skill.kind === 'heal' && skill.id !== 'revive_companion');
    if (healSkills.length > 0) {
      // é¸æ“‡HPç™¾åˆ†æ¯”æœ€ä½çš„ç›®æ¨™ï¼ˆå„ªå…ˆæ²»ç™‚æœ€å±éšªçš„è§’è‰²ï¼‰
      const lowestTarget = lowHpCharacters.reduce((min, c) => 
        c.hpPercent < min.hpPercent ? c : min
      );
      
      // å¦‚æœæœ‰å–®é«”æ²»ç™‚æŠ€èƒ½ï¼Œä½¿ç”¨å–®é«”æ²»ç™‚
      const singleHealSkills = healSkills.filter(skill => !skill.aoe);
      if (singleHealSkills.length > 0) {
        const healSkill = singleHealSkills[0];
        const target = lowestTarget.type === 'hero' ? 'hero' : 'companion';
      performCompanionSkill(companion, healSkill, battle);
      return;
      }
      
      // å¦‚æœæœ‰ç¾¤é«”æ²»ç™‚æŠ€èƒ½ä¸”æœ‰å¤šäººHP < 50%ï¼Œä½¿ç”¨ç¾¤é«”æ²»ç™‚
      const aoeHealSkills = healSkills.filter(skill => skill.aoe);
      if (aoeHealSkills.length > 0 && lowHpCharacters.length >= 2) {
        const healSkill = aoeHealSkills[0];
        performCompanionSkill(companion, healSkill, battle);
        return;
      }
    }
  }
  
  // 2. æª¢æŸ¥æ•µäººæ•¸é‡ï¼Œå¦‚æœè¶…é3å€‹ï¼Œå„ªå…ˆä½¿ç”¨å…¨é«”æ”»æ“ŠæŠ€èƒ½
  if (aliveEnemies.length > 3) {
    const aoeSkills = availableSkills.filter(skill => 
      skill.kind === 'attack' && skill.aoe
    );
    if (aoeSkills.length > 0) {
      const aoeSkill = aoeSkills[0]; // ä½¿ç”¨ç¬¬ä¸€å€‹å…¨é«”æŠ€èƒ½
      performCompanionSkill(companion, aoeSkill, battle);
      return;
    }
  }
  
  // 3. æ ¹æ“šåŒä¼´é¡å‹é¸æ“‡æŠ€èƒ½
  const companionType = COMPANION_TYPES[companion.companionTypeId];
  if (companionType) {
    const heroType = companionType.heroType;
    
    // æ”»æ“Šå‹ï¼ˆåŠå£«ã€ç›œè³Šï¼‰ï¼šå„ªå…ˆä½¿ç”¨æ”»æ“ŠæŠ€èƒ½
    if (heroType === 'attacker' || heroType === 'agile') {
      const attackSkills = availableSkills.filter(skill => 
        skill.kind === 'attack' && (skill.flow === 'sword' || skill.flow === 'agility')
      );
      if (attackSkills.length > 0) {
        const attackSkill = attackSkills[Math.floor(Math.random() * attackSkills.length)];
        performCompanionSkill(companion, attackSkill, battle);
        return;
      }
    }
    
    // é­”æ³•å‹ï¼ˆé­”æ³•å¸«ï¼‰ï¼šå„ªå…ˆä½¿ç”¨é­”æ³•æ”»æ“ŠæŠ€èƒ½
    if (heroType === 'mage') {
      const magicSkills = availableSkills.filter(skill => 
        skill.kind === 'attack' && skill.flow === 'magic'
      );
      if (magicSkills.length > 0) {
        const magicSkill = magicSkills[Math.floor(Math.random() * magicSkills.length)];
        performCompanionSkill(companion, magicSkill, battle);
        return;
      }
    }
    
    // é˜²å®ˆå‹ï¼ˆé¨å£«ï¼‰ï¼šå¯ä»¥ä½¿ç”¨é­”æ³•æˆ–åŠæŠ€æŠ€èƒ½
    if (heroType === 'defender') {
      const magicOrDefenseSkills = availableSkills.filter(skill => 
        skill.kind === 'attack' && (skill.flow === 'magic' || skill.flow === 'sword')
      );
      if (magicOrDefenseSkills.length > 0) {
        const defenseSkill = magicOrDefenseSkills[Math.floor(Math.random() * magicOrDefenseSkills.length)];
        performCompanionSkill(companion, defenseSkill, battle);
        return;
      }
    }
  }
  
  // 4. å¦‚æœæœ‰ä»»ä½•æ”»æ“ŠæŠ€èƒ½ï¼Œéš¨æ©Ÿé¸æ“‡ä¸€å€‹ä½¿ç”¨
  const attackSkills = availableSkills.filter(skill => skill.kind === 'attack');
  if (attackSkills.length > 0) {
    const randomAttackSkill = attackSkills[Math.floor(Math.random() * attackSkills.length)];
    performCompanionSkill(companion, randomAttackSkill, battle);
    return;
  }
  
  // 5. æ²’æœ‰åˆé©çš„æŠ€èƒ½ï¼Œä½¿ç”¨æ™®é€šæ”»æ“Š
  performCompanionBasicAttack(companion, battle);
}

// åŒä¼´æ™®é€šæ”»æ“Š
function performCompanionBasicAttack(companion, battle) {
  const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
  if (aliveEnemies.length === 0) {
    concludeBattle(true);
    return;
  }
  
  // éš¨æ©Ÿé¸æ“‡ä¸€å€‹æ•µäºº
  const targetEnemy = aliveEnemies[Math.floor(Math.random() * aliveEnemies.length)];
  const targetIndex = battle.enemies.indexOf(targetEnemy);
  
  // è¨ˆç®—å‚·å®³
  const totalAttrs = getCompanionTotalAttributes(companion);
  const attack = totalAttrs.attack;
  const defense = targetEnemy.attributes ? targetEnemy.attributes.defense : (targetEnemy.defense || 0);
  let damage = Math.max(1, Math.round(attack - defense));
  
  // æª¢æŸ¥æœƒå¿ƒä¸€æ“Š
  const critChance = Math.min(5, Math.floor(totalAttrs.attack / 5));
  const isCrit = Math.random() * 100 < critChance;
  if (isCrit) {
    damage = Math.round(damage * 2);
  }
  
  damage = applyDamageToEnemyUnified(targetEnemy, damage, companion);
  const critMsg = isCrit ? 'ï¼ˆæœƒå¿ƒä¸€æ“Šï¼ï¼‰' : '';
  pushLog(`${companion.name}æ”»æ“Š${targetEnemy.name}ï¼Œé€ æˆ ${damage} å‚·å®³ï¼${critMsg}`);

  renderBattleDialog();
  
  // æª¢æŸ¥æ˜¯å¦æ“Šå€’æ‰€æœ‰æ•µäºº
  const allDefeated = battle.enemies.every(e => e.stats.hp <= 0);
  if (allDefeated) {
    setTimeout(() => concludeBattle(true), 800);
    return;
  }
  
  // åŒä¼´å›åˆçµæŸï¼Œé€²å…¥æ•µäººå›åˆ
  battle.turn = 'enemy';
  setTimeout(enemyAct, 800);
}

// åŒä¼´ä½¿ç”¨æŠ€èƒ½
function performCompanionSkill(companion, skill, battle) {
  const mpCost = skill.mpCost || 0;
  companion.stats.mp = Math.max(0, companion.stats.mp - mpCost);
  
  const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
  if (aliveEnemies.length === 0) {
    concludeBattle(true);
    return;
  }
  
  if (skill.kind === 'attack') {
    if (skill.aoe) {
      // å…¨é«”æ”»æ“Š
      let totalDamage = 0;
      let hasCrit = false;
      aliveEnemies.forEach((enemy) => {
        let { damage, isCrit } = calculateSkillDamage(skill, companion, enemy);
        // çµ±ä¸€æ‡‰ç”¨å‚·å®³ï¼ˆåŒ…å«å¾©ä»‡æ„å¿—æ•ˆæœï¼‰
        damage = applyDamageToEnemyUnified(enemy, damage, companion);
        totalDamage += damage;
        if (isCrit) hasCrit = true;
      });
      const critMsg = hasCrit ? 'ï¼ˆæœƒå¿ƒä¸€æ“Šï¼ï¼‰' : '';
      pushBattleLog(`${companion.name}æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œé€ æˆ ${totalDamage} ç¸½å‚·å®³ï¼${critMsg}`);
    } else {
      // å–®é«”æ”»æ“Šï¼Œéš¨æ©Ÿé¸æ“‡ç›®æ¨™
      const targetEnemy = aliveEnemies[Math.floor(Math.random() * aliveEnemies.length)];
      const targetIndex = battle.enemies.indexOf(targetEnemy);
      let { damage, isCrit } = calculateSkillDamage(skill, companion, targetEnemy);
      // çµ±ä¸€æ‡‰ç”¨å‚·å®³ï¼ˆåŒ…å«å¾©ä»‡æ„å¿—æ•ˆæœï¼‰
      damage = applyDamageToEnemyUnified(targetEnemy, damage, companion);
      const critMsg = isCrit ? 'ï¼ˆæœƒå¿ƒä¸€æ“Šï¼ï¼‰' : '';
      pushLog(`${companion.name}æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œå°${targetEnemy.name}é€ æˆ ${damage} å‚·å®³ï¼${critMsg}`);
    }
  } else if (skill.kind === 'heal') {
    // æª¢æŸ¥æ˜¯å¦æ˜¯å¾©æ´»è¡“
    const isReviveSkill = skill.id === 'revive_companion';
    
    if (isReviveSkill) {
      // å¾©æ´»è¡“ï¼šåªå°å·²æ­»äº¡çš„åŒä¼´ä½¿ç”¨
      const allCompanions = (state.companions || []).filter(c => c && c.stats);
      const deadCompanions = allCompanions.filter(c => c.stats.hp <= 0);
      
      if (deadCompanions.length === 0) {
        pushBattleLog(`${companion.name}è©¦åœ–æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œä½†æ²’æœ‰å¯å¾©æ´»çš„ç›®æ¨™ã€‚`);
        return;
      }
      
      // é¸æ“‡ä¸€å€‹æ­»äº¡çš„åŒä¼´å¾©æ´»ï¼ˆå¦‚æœactionä¸­æœ‰æŒ‡å®šcompanionIndexï¼Œä½¿ç”¨æŒ‡å®šçš„ï¼›å¦å‰‡éš¨æ©Ÿé¸æ“‡ï¼‰
      let targetCompanion = null;
      if (battle.companionAction && battle.companionAction.companionIndex !== undefined) {
        const companionIndex = battle.companionAction.companionIndex;
        if (companionIndex >= 0 && companionIndex < allCompanions.length) {
          const candidate = allCompanions[companionIndex];
          if (candidate && candidate.stats.hp <= 0) {
            targetCompanion = candidate;
          }
        }
      }
      
      // å¦‚æœæ²’æœ‰æŒ‡å®šç›®æ¨™æˆ–æŒ‡å®šç›®æ¨™ç„¡æ•ˆï¼Œéš¨æ©Ÿé¸æ“‡ä¸€å€‹æ­»äº¡çš„åŒä¼´
      if (!targetCompanion) {
        targetCompanion = deadCompanions[Math.floor(Math.random() * deadCompanions.length)];
      }
      
      if (targetCompanion) {
        const revivePercent = skill.revivePercent || 0.3;
        const reviveHp = Math.max(1, Math.floor(targetCompanion.stats.maxHp * revivePercent));
        targetCompanion.stats.hp = reviveHp;
        pushBattleLog(`${companion.name}æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œå¾©æ´»äº†${targetCompanion.name}ï¼Œå›å¾© ${reviveHp} HPï¼ˆ${targetCompanion.stats.maxHp}çš„${Math.round(revivePercent * 100)}%ï¼‰ï¼`);
      }
    } else {
      // æ™®é€šæ²»ç™‚æŠ€èƒ½ï¼Œæ™ºèƒ½é¸æ“‡ç›®æ¨™ï¼ˆå„ªå…ˆé¸æ“‡HPç™¾åˆ†æ¯”æœ€ä½çš„é‚„æ´»è‘—çš„è§’è‰²ï¼‰
    // æ™®é€šå›å¾©é­”æ³•ç„¡æ³•å¾©æ´»å·²æ­»äº¡çš„è§’è‰²
    const hero = state.hero;
    const allAliveCharacters = [];
    
    // åªè€ƒæ…®é‚„æ´»è‘—çš„è§’è‰²
    if (hero && hero.stats.hp > 0) {
      allAliveCharacters.push({
        character: hero,
        hpPercent: hero.stats.hp / hero.stats.maxHp,
        name: 'å‹‡è€…'
      });
    }
    
    const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
    activeCompanions.forEach(comp => {
      allAliveCharacters.push({
        character: comp,
        hpPercent: comp.stats.hp / comp.stats.maxHp,
        name: comp.name
      });
    });
    
    if (allAliveCharacters.length === 0) {
      pushBattleLog(`${companion.name}æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œä½†æ²’æœ‰å¯æ²»ç™‚çš„ç›®æ¨™ã€‚`);
      return;
    }
    
    // é¸æ“‡HPç™¾åˆ†æ¯”æœ€ä½çš„ç›®æ¨™ï¼ˆå„ªå…ˆæ²»ç™‚æœ€å±éšªçš„è§’è‰²ï¼‰
    const lowestTarget = allAliveCharacters.reduce((min, c) => 
      c.hpPercent < min.hpPercent ? c : min
    );
    
    const target = lowestTarget.character;
    const baseValue = skill.power || 0;
    const totalAttrs = getCompanionTotalAttributes(companion);
    const recovery = totalAttrs.recovery || 0;
    const healAmount = baseValue + Math.floor(recovery / 3);
    const actualHeal = Math.round(healAmount);
    const oldHp = target.stats.hp;
    target.stats.hp = Math.ceil(Math.min(target.stats.maxHp, target.stats.hp + actualHeal));
    const actualHealed = Math.ceil(target.stats.hp - oldHp);
    
      const targetName = target === hero ? 'å‹‡è€…' : target.name;
    pushLog(`${companion.name}æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œå°${targetName}å›å¾© ${actualHealed} HPï¼`);
    }
  }
  
  renderBattleDialog();
  
  // æª¢æŸ¥æ˜¯å¦æ“Šå€’æ‰€æœ‰æ•µäºº
  const allDefeated = battle.enemies.every(e => e.stats.hp <= 0);
  if (allDefeated) {
    setTimeout(() => concludeBattle(true), 800);
    return;
  }
  
  // åŒä¼´å›åˆçµæŸï¼Œé€²å…¥æ•µäººå›åˆ
  battle.turn = 'enemy';
  setTimeout(enemyAct, 800);
}

function enemyAct() {
  const battle = state.ui.battle;
  if (!battle || battle.turn !== 'enemy') return;
  const hero = state.hero;
  
  // æ‰€æœ‰æ´»è‘—çš„æ•µäººè¼ªæµæ”»æ“Š
  const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
  if (aliveEnemies.length === 0) {
    concludeBattle(true);
    return;
  }
  
  let enemyIndex = 0;
  const processEnemyAttack = () => {
    if (enemyIndex >= aliveEnemies.length) {
      // æ‰€æœ‰æ•µäººéƒ½æ”»æ“Šå®Œç•¢ï¼Œå›åˆ°è‹±é›„å›åˆ
      battle.turn = 'hero';
      renderBattleDialog();
      return;
    }
    
    const enemy = aliveEnemies[enemyIndex];
    const enemyIndexInBattle = battle.enemies.indexOf(enemy);
    
    // æ•µäººAIï¼š30%æ©Ÿç‡ä½¿ç”¨æŠ€èƒ½ï¼ˆå¦‚æœæœ‰MPï¼‰
    const useSkill = enemy.stats.mp > 0 && enemy.skills && enemy.skills.length > 0 && Math.random() < 0.3;
    
    if (useSkill) {
      // é¸æ“‡ä¸€å€‹å¯ç”¨æŠ€èƒ½
      const availableSkills = enemy.skills
        .map(id => SKILL_LOOKUP.get(id))
        .filter(skill => skill && skill.kind !== 'passive' && (skill.mpCost || 0) <= enemy.stats.mp);
      
      if (availableSkills.length > 0) {
        const skill = availableSkills[Math.floor(Math.random() * availableSkills.length)];
        const mpCost = skill.mpCost || 0;
        enemy.stats.mp = Math.max(0, enemy.stats.mp - mpCost);
        
        if (skill.kind === 'attack') {
          if (skill.aoe) {
            // å…¨é«”æ”»æ“Šï¼šå°æ‰€æœ‰å°è±¡ï¼ˆè‹±é›„å’Œæ‰€æœ‰åŒä¼´ï¼‰é€ æˆå‚·å®³
            pushLog(`${enemy.name} æ–½æ”¾ã€Œ${skill.name}ã€ï¼`);
            
            let totalDamage = 0;
            
            // å°è‹±é›„é€ æˆå‚·å®³
            if (hero.stats.hp > 0) {
              const { damage, isCrit } = calculateSkillDamage(skill, enemy, hero);
              // Bug fix: æ•µäºº AOE æ”»æ“Šä¹Ÿè¦æª¢æŸ¥å‹‡è€…è­·ç›¾
              const { finalDamage } = absorbShield(hero, damage, 'â†’ å‹‡è€…', pushLog);
              hero.stats.hp = Math.max(0, hero.stats.hp - finalDamage);
              totalDamage += finalDamage;
              const critMsg = isCrit ? 'ï¼ˆæœƒå¿ƒä¸€æ“Šï¼ï¼‰' : '';
              pushLog(`â†’ å°å‹‡è€…é€ æˆ ${finalDamage > 0 ? finalDamage : 0} å‚·å®³${critMsg}`);

              if (hero.stats.hp <= 0) {
                pushLog(`â†’ å‹‡è€… è¢«æ“Šå€’ï¼`);
                state.ui.deathInfo = {
                  cause: 'skill',
                  attacker: enemy.name,
                  damage: finalDamage,
                  skill: skill.name,
                  isCrit: isCrit,
                };
              }
            }

            // å°æ‰€æœ‰åŒä¼´é€ æˆå‚·å®³
            const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
            activeCompanions.forEach((companion) => {
              const { damage, isCrit } = calculateSkillDamage(skill, enemy, companion);
              const { finalDamage } = absorbShield(companion, damage, `â†’ ${companion.name}`, pushLog);

              companion.stats.hp = Math.max(0, companion.stats.hp - finalDamage);
              totalDamage += finalDamage;
              const critMsg = isCrit ? 'ï¼ˆæœƒå¿ƒä¸€æ“Šï¼ï¼‰' : '';
              pushLog(`â†’ å°${companion.name}é€ æˆ ${finalDamage > 0 ? finalDamage : 0} å‚·å®³${critMsg}`);

              // è§¸ç™¼è¢«æ”»æ“Šæ™‚çš„è¢«å‹•æŠ€èƒ½ï¼ˆå®ˆè­·æ„å¿—ç­‰ï¼‰
              if (finalDamage > 0) {
                triggerOnHitPassiveEffects(companion, finalDamage);
              }

              if (companion.stats.hp <= 0) {
                pushLog(`â†’ ${companion.name} è¢«æ“Šå€’ï¼`);
              }
            });
            
            // é¡¯ç¤ºç¸½å‚·å®³
            if (totalDamage > 0) {
              pushLog(`ç¸½å…±é€ æˆ ${totalDamage} å‚·å®³ï¼`);
            }
          } else {
            // å–®é«”æ”»æ“Š
            const { damage, isCrit } = calculateSkillDamage(skill, enemy, hero);
            let { finalDamage } = absorbShield(hero, damage, 'è­·ç›¾', pushLog);
            
            hero.stats.hp = Math.max(0, hero.stats.hp - finalDamage);
            const critMsg = isCrit ? 'ï¼ˆæœƒå¿ƒä¸€æ“Šï¼ï¼‰' : '';
            pushLog(`${enemy.name} æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œé€ æˆ ${finalDamage > 0 ? finalDamage : 0} å‚·å®³ï¼${critMsg}`);
            
            // è§¸ç™¼è¢«æ”»æ“Šæ™‚çš„è¢«å‹•æŠ€èƒ½ï¼ˆå®ˆè­·æ„å¿—ç­‰ï¼‰
            if (finalDamage > 0) {
              triggerOnHitPassiveEffects(hero, finalDamage);
            }
            
            // è¨˜éŒ„å‚·å®³ä¿¡æ¯ï¼ˆç”¨æ–¼æ­»äº¡çµ±è¨ˆï¼‰
            if (hero.stats.hp <= 0) {
              state.ui.deathInfo = {
                cause: 'skill',
                attacker: enemy.name,
                damage: damage,
                skill: skill.name,
                isCrit: isCrit,
              };
            }
            
            // è™•ç†æ”»æ“ŠæŠ€èƒ½é™„å¸¶çš„debuffæ•ˆæœï¼ˆå†°çƒæ¸›é€Ÿã€é…¸æ€§ç®­æ¸›é˜²ï¼‰
            // å†°çƒï¼šé€ æˆæ¸›é€Ÿæ•ˆæœ
            if (skill.id && skill.id.startsWith('iceball_') && skill.slowDuration && skill.slowRatio) {
              if (!battle.friendlyDebuffs) {
                battle.friendlyDebuffs = { hero: {}, companions: {} };
              }
              if (!battle.friendlyDebuffs.hero) {
                battle.friendlyDebuffs.hero = {};
              }
              
              const hadSlow = battle.friendlyDebuffs.hero.slow ? true : false;
              battle.friendlyDebuffs.hero.slow = {
                duration: skill.slowDuration,
                ratio: skill.slowRatio
              };
              
              if (hadSlow) {
                pushLog(`â†’ å‹‡è€…çš„æ¸›é€Ÿæ•ˆæœè¢«åˆ·æ–°ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.slowDuration}å›åˆä¸­ï¼Œé€Ÿåº¦æ¸›å°‘ ${Math.round(skill.slowRatio * 100)}%ã€‚`);
              } else {
                pushLog(`â†’ å‹‡è€…è¢«å†°å‡æ¸›é€Ÿï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.slowDuration}å›åˆä¸­ï¼Œé€Ÿåº¦æ¸›å°‘ ${Math.round(skill.slowRatio * 100)}%ã€‚`);
              }
            }
            
            // é…¸æ€§ç®­ï¼šé€ æˆé˜²å®ˆå€¼æ¸›å°‘æ•ˆæœ
            if (skill.id && skill.id.startsWith('acid_arrow_') && skill.defenseDownDuration && skill.defenseDownRatio) {
              if (!battle.friendlyDebuffs) {
                battle.friendlyDebuffs = { hero: {}, companions: {} };
              }
              if (!battle.friendlyDebuffs.hero) {
                battle.friendlyDebuffs.hero = {};
              }
              
              const hadDefenseDown = battle.friendlyDebuffs.hero.defenseDown ? true : false;
              battle.friendlyDebuffs.hero.defenseDown = {
                duration: skill.defenseDownDuration,
                ratio: skill.defenseDownRatio
              };
              
              if (hadDefenseDown) {
                pushLog(`â†’ å‹‡è€…çš„é˜²å®ˆå€¼æ¸›å°‘æ•ˆæœè¢«åˆ·æ–°ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.defenseDownDuration}å›åˆä¸­ï¼Œé˜²å®ˆå€¼æ¸›å°‘ ${Math.round(skill.defenseDownRatio * 100)}%ã€‚`);
              } else {
                pushLog(`â†’ å‹‡è€…çš„é˜²å®ˆå€¼è¢«è…è•æ¸›å°‘ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${skill.defenseDownDuration}å›åˆä¸­ï¼Œé˜²å®ˆå€¼æ¸›å°‘ ${Math.round(skill.defenseDownRatio * 100)}%ã€‚`);
              }
            }
          }
        } else if (skill.kind === 'heal') {
          // æ²»ç™‚è‡ªå·±ï¼šå›ºå®šå€¼ + å›å¾©åŠ›/3
          const baseValue = skill.power || 0; // powerä½œç‚ºå›ºå®šå€¼
          const recovery = enemy.attributes.recovery || 0;
          const healAmount = baseValue + Math.floor(recovery / 3);
          enemy.stats.hp = Math.min(enemy.stats.maxHp, enemy.stats.hp + Math.round(healAmount));
          pushLog(`${enemy.name} æ–½æ”¾ã€Œ${skill.name}ã€ï¼Œå›å¾©äº†ç”Ÿå‘½ï¼`);
        } else if (skill.kind === 'debuff') {
          // DebuffæŠ€èƒ½ï¼ˆä¸‹æ¯’ç­‰ï¼‰
          if (skill.id && skill.id.startsWith('poison_attack')) {
            // ä¸‹æ¯’æŠ€èƒ½ï¼šå°è‹±é›„ä¸‹æ¯’
            if (hero.stats.hp > 0) {
              const casterAgility = enemy.attributes.agility || 0;
              const poisonDamage = Math.max(1, Math.floor(casterAgility * (skill.poisonRatio || 0.3)));
              const poisonDuration = skill.poisonDuration || 3;
              
              if (!battle.friendlyDebuffs) {
                battle.friendlyDebuffs = { hero: {}, companions: {} };
              }
              if (!battle.friendlyDebuffs.hero) {
                battle.friendlyDebuffs.hero = {};
              }
              
              const hadPoison = battle.friendlyDebuffs.hero.poison ? true : false;
              battle.friendlyDebuffs.hero.poison = {
                duration: poisonDuration,
                damage: poisonDamage,
                casterAgility: casterAgility
              };
              
              pushLog(`${enemy.name}å°å‹‡è€…æ–½æ”¾ã€Œ${skill.name}ã€ï¼`);
              
              // ç«‹å³æ‡‰ç”¨ä¸€æ¬¡ä¸­æ¯’å‚·å®³ï¼ˆæ–½åŠ çš„é‚£ä¸€å›åˆå°±ç”Ÿæ•ˆï¼Œå…ˆæ‰£é™¤è­·ç›¾ï¼‰
              let remainingDamage = poisonDamage;
              ({ finalDamage: remainingDamage } = absorbShield(hero, remainingDamage, 'â†’ å‹‡è€…', pushLog));
              if (remainingDamage > 0) {
                const oldHp = hero.stats.hp;
                hero.stats.hp = Math.max(0, hero.stats.hp - remainingDamage);
                
                // è§¸ç™¼è¢«æ”»æ“Šæ™‚çš„è¢«å‹•æŠ€èƒ½ï¼ˆå®ˆè­·æ„å¿—ç­‰ï¼‰
                if (remainingDamage > 0) {
                  triggerOnHitPassiveEffects(hero, remainingDamage);
                }
                const immediateDamage = oldHp - hero.stats.hp;
                if (immediateDamage > 0) {
                  pushLog(`â†’ å‹‡è€…ç«‹å³å—åˆ°ä¸­æ¯’å‚·å®³ ${immediateDamage}ï¼`);
                }
              }
              
              if (hadPoison) {
                pushLog(`â†’ å‹‡è€…çš„æ¯’è¢«åˆ·æ–°ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${poisonDuration}å›åˆä¸­ï¼Œæ¯å›åˆçµæŸæ™‚å—åˆ° ${poisonDamage} å‚·å®³ï¼ˆä¸å—é˜²å®ˆå½±éŸ¿ï¼‰ã€‚`);
              } else {
                pushLog(`â†’ å‹‡è€…ä¸­æ¯’äº†ï¼å°‡åœ¨æ¥ä¸‹ä¾†çš„${poisonDuration}å›åˆä¸­ï¼Œæ¯å›åˆçµæŸæ™‚å—åˆ° ${poisonDamage} å‚·å®³ï¼ˆä¸å—é˜²å®ˆå½±éŸ¿ï¼‰ã€‚`);
              }
            }
          }
        }
      } else {
        // æ²’æœ‰å¯ç”¨æŠ€èƒ½ï¼Œä½¿ç”¨æ™®é€šæ”»æ“Š
        performEnemyBasicAttack(enemy, hero, battle);
      }
    } else {
      // æ™®é€šæ”»æ“Š
      performEnemyBasicAttack(enemy, hero, battle);
    }
    
    renderBattleDialog();
    
    // æª¢æŸ¥æ˜¯å¦æ‰€æœ‰è§’è‰²éƒ½æ­»äº¡ï¼Œåªæœ‰å…¨éƒ¨æ­»äº¡æ‰çµæŸæˆ°é¬¥
    if (areAllCharactersDead()) {
      pushLog('æ‰€æœ‰è§’è‰²éƒ½å€’ä¸‹äº†ã€‚');
      setTimeout(() => concludeBattle(false), 800);
      return;
    }
    
    enemyIndex += 1;
    setTimeout(processEnemyAttack, 400);
  };
  
  processEnemyAttack();
}

function performEnemyBasicAttack(enemy, hero, battle) {
  // ç‰©ç†å‚·å®³ = (æ”»æ“ŠåŠ› + æŠ€èƒ½åŠ å€¼) - (é˜²å®ˆåŠ› + è£å‚™é˜²ç¦¦åŠ›)
  // æ™®é€šæ”»æ“Šæ²’æœ‰æŠ€èƒ½åŠ å€¼ï¼Œæ‰€ä»¥æŠ€èƒ½åŠ å€¼ç‚º0
  let attack = enemy.attributes.attack;
  
  // æª¢æŸ¥æ˜¯å¦æœ‰æ”»æ“ŠåŠ›æ¸›å°‘debuffï¼ˆè…æ“Šï¼‰
  if (battle && battle.enemyDebuffs) {
    const enemyIndex = battle.enemies.indexOf(enemy);
    if (enemyIndex >= 0 && battle.enemyDebuffs[enemyIndex] && battle.enemyDebuffs[enemyIndex].attackDown) {
      const attackDown = battle.enemyDebuffs[enemyIndex].attackDown;
      // æ‡‰ç”¨æ”»æ“ŠåŠ›æ¸›å°‘æ•ˆæœï¼šæ¸›å°‘1/3æ”»æ“ŠåŠ›
      attack = Math.max(0, Math.floor(attack * (1 - attackDown.ratio)));
    }
  }
  
  const skillBonus = 0; // æ™®é€šæ”»æ“Šæ²’æœ‰æŠ€èƒ½åŠ å€¼
  const totalAttrs = getHeroTotalAttributes(hero);
  const defense = totalAttrs.defense + getEquipmentDefense(hero);
  const damage = Math.max(1, Math.round((attack + skillBonus) - defense));
  
  // æª¢æŸ¥é–ƒé¿ï¼ˆåƒ…ç›¾ç‰Œæä¾›ï¼‰
  const dodgeRate = getEquipmentDodge(hero);
  if (dodgeRate > 0 && Math.random() < dodgeRate) {
    pushLog(`${enemy.name} æ”»æ“Šè¢«é–ƒé¿ï¼`);
    return;
  }
  
  let finalDamage = damage;
  if (battle.heroBuffs.guard > 0) {
    finalDamage = Math.round(damage * (1 - battle.heroBuffs.guard));
    battle.heroBuffs.guard = 0;
    // æ¸…é™¤å˜²è«·ç›®æ¨™
    if (battle.tauntTarget && battle.tauntTarget.type === 'hero') {
      battle.tauntTarget = null;
    }
  }
  
  // å…ˆæ‰£é™¤è­·ç›¾
  ({ finalDamage } = absorbShield(hero, finalDamage, 'è­·ç›¾', pushLog));

  hero.stats.hp = Math.max(0, hero.stats.hp - finalDamage);
  pushLog(`${enemy.name} æ”»æ“Šé€ æˆ ${finalDamage > 0 ? finalDamage : 0} å‚·å®³ï¼`);
  
  // è¨˜éŒ„å‚·å®³ä¿¡æ¯ï¼ˆç”¨æ–¼æ­»äº¡çµ±è¨ˆï¼‰
  if (hero.stats.hp <= 0) {
    state.ui.deathInfo = {
      cause: 'attack',
      attacker: enemy.name,
      damage: finalDamage,
      skill: null,
      isCrit: false,
    };
  }
}

function concludeBattle(victory) {
  const battle = state.ui.battle;
  if (!battle) return;
  const hero = state.hero;
  
  // è¨ˆç®—ç¶“é©—å€¼ï¼šæ‰€æœ‰è¢«æ“Šå€’çš„æ€ªç‰©çš„ç¶“é©—å€¼ç¸½å’Œ
  let xpGain = 0;
  battle.enemies.forEach(enemy => {
    if (enemy.stats.hp <= 0 && enemy.xp) {
      xpGain += enemy.xp;
    }
  });
  
  // è¨ˆç®—é‡‘å¹£ï¼šæ‰€æœ‰è¢«æ“Šå€’çš„æ€ªç‰©çš„ goldDrop ç¸½å’Œï¼ˆæ‰£é™¤å·²è¢«å·å–çš„éƒ¨åˆ†ï¼‰
  let goldGain = 0;
  battle.enemies.forEach(enemy => {
    if (enemy.stats.hp <= 0 && enemy.goldDrop) {
      const stolenGold = enemy.stolenGold || 0;
      const remainingGold = Math.max(0, enemy.goldDrop - stolenGold);
      goldGain += remainingGold;
    }
  });
  
  // åˆ¤æ–·æˆ°é¬¥é¡å‹
  const isElite = battle.multiplier >= 1.5;
  const isBoss = battle.multiplier >= 2.5 || battle.enemies.some(enemy => {
    const template = ENEMY_DECK.find(e => e.id === enemy.id);
    return template && template.monsterType === 'boss';
  });
  
  // æ‡‰ç”¨æˆ°é¬¥é¡å‹åŠ æˆï¼šèè‹±æˆ°+30%ï¼Œé­”ç‹æˆ°+60%
  if (isBoss) {
    // é­”ç‹æˆ°ï¼šç¶“é©—å€¼å’Œé‡‘å¹£å¤š60%
    xpGain = Math.round(xpGain * 1.6);
    goldGain = Math.round(goldGain * 1.6);
  } else if (isElite) {
    // èè‹±æˆ°ï¼šç¶“é©—å€¼å’Œé‡‘å¹£å¤š30%
    xpGain = Math.round(xpGain * 1.3);
    goldGain = Math.round(goldGain * 1.3);
  }
  
  // æ‡‰ç”¨æ•æ·å‹è¢«å‹•æŠ€èƒ½ï¼šé‡‘å¹£ç²å¾—æå‡
  const agilityEffects = getAgilityPassiveEffects(hero);
  if (agilityEffects.goldBoost > 0) {
    goldGain = Math.ceil(goldGain * (1 + agilityEffects.goldBoost));
  }
  
  if (victory) {
    // æˆ°é¬¥å‹åˆ©æ™‚ï¼Œå…ˆæª¢æŸ¥æ˜¯å¦é‚„æœ‰æ´»è‘—çš„è§’è‰²
    const hasAliveCharacters = !areAllCharactersDead();
    
    if (hasAliveCharacters) {
      // å¦‚æœæœ‰äººé‚„æ´»è‘—ï¼Œå¾©æ´»æ‰€æœ‰æ­»äº¡çš„è§’è‰²ï¼ˆä»¥HP1å¾©æ´»ï¼‰
      // å¾©æ´»æ‰€æœ‰æ­»äº¡çš„åŒä¼´
      state.companions.forEach(companion => {
        if (companion && companion.stats && companion.stats.hp <= 0) {
          companion.stats.hp = 1;
          pushBattleLog(`${companion.name} ä»¥ HP1 çš„ç‹€æ…‹å¾©æ´»ã€‚`);
        }
      });
      
      // å¾©æ´»æ­»äº¡çš„å‹‡è€…
      if (hero && hero.stats && hero.stats.hp <= 0) {
        hero.stats.hp = 1;
        pushBattleLog(`å‹‡è€…ä»¥ HP1 çš„ç‹€æ…‹å¾©æ´»ã€‚`);
      }
    }
    
    // æ”¶é›†æ‰è½ç‰©å“
    const droppedItems = [];
    const droppedEquipment = [];
    
    // è£å‚™æ‰è½ï¼ˆåŸºç¤20%æ¦‚ç‡ï¼Œæ‡‰ç”¨æ•æ·å‹è¢«å‹•æŠ€èƒ½æå‡ï¼‰
    const currentTier = state.world.stage;
    const baseEquipmentDropRate = 0.2;
    const equipmentDropRate = Math.min(1.0, baseEquipmentDropRate * (1 + agilityEffects.dropRateBoost));
    if (Math.random() < equipmentDropRate) {
      // åªæ‰è½ç•¶å‰éšå±¤çš„è£å‚™ï¼ˆtier 1-6ï¼‰ï¼Œä¸åŒ…æ‹¬ç¾…å¾·è£å‚™ï¼ˆtier 99ï¼‰
      const tierEquipment = EQUIPMENT.filter(eq => eq.tier === currentTier && eq.tier !== 99);
      if (tierEquipment.length > 0) {
        const equipment = tierEquipment[Math.floor(Math.random() * tierEquipment.length)];
        const isOwned = hero.equipmentInventory && hero.equipmentInventory.includes(equipment.id);
        droppedEquipment.push({
          id: equipment.id,
          name: equipment.name,
          isOwned,
        });
      }
    }
    
    // é“å…·æ‰è½ï¼šä¸€èˆ¬æ€ªç‰©5%ï¼Œç²¾è‹±10%ï¼Œé­”ç‹20%
      const isElite = battle.multiplier >= 1.5;
      const isBoss = battle.multiplier >= 2.5;
      
    let baseItemDropRate;
    if (isBoss) {
      baseItemDropRate = 0.2; // é­”ç‹20%
    } else if (isElite) {
      baseItemDropRate = 0.1; // ç²¾è‹±10%
    } else {
      baseItemDropRate = 0.05; // ä¸€èˆ¬æ€ªç‰©5%
    }
    
    const itemDropRate = Math.min(1.0, baseItemDropRate * (1 + agilityEffects.dropRateBoost));
    if (Math.random() < itemDropRate) {
      limitInventorySize();
      const currentItemCount = hero.items.filter(item => item.qty > 0).length;
      
      if (currentItemCount < 8) {
        let droppedItemId;
        let itemQty = 1;
        
        // æ ¹æ“šç•¶å‰tieræ±ºå®šæ‰è½é“å…·çš„tier
        const currentTier = state.world.stage;
        
        // å›å¾©é“å…·åªæœƒæ‰è½è©²éšçš„é“å…·ï¼Œä½†æœ‰20%çš„æ©Ÿç‡æœƒæ‰è½é«˜ä¸€éšçš„ç‰©å“
        let dropTier = currentTier;
        if (Math.random() < 0.2 && currentTier < 6) {
          dropTier = currentTier + 1; // 20%æ©Ÿç‡æ‰è½é«˜ä¸€éš
        }
        dropTier = Math.min(dropTier, 6); // æœ€é«˜ä¸è¶…é6éš
        
        if (isBoss) {
          if (Math.random() < 0.3) {
            droppedItemId = 'elixir';
          } else {
            // æ‰è½è©²éšæˆ–é«˜ä¸€éšçš„é“å…·
            const herbTier = dropTier;
            const etherTier = dropTier;
            droppedItemId = Math.random() < 0.5 ? `herb_${herbTier}` : `ether_${etherTier}`;
            itemQty = randomRange(1, 2);
          }
        } else if (isElite) {
          if (Math.random() < 0.2) {
            droppedItemId = 'elixir';
          } else {
            droppedItemId = Math.random() < 0.6 ? `herb_${dropTier}` : `ether_${dropTier}`;
            itemQty = randomRange(1, 2);
          }
        } else {
          droppedItemId = Math.random() < 0.6 ? `herb_${dropTier}` : `ether_${dropTier}`;
        }
        
        const droppedItem = ITEM_LOOKUP.get(droppedItemId);
        if (droppedItem) {
          droppedItems.push({
            id: droppedItemId,
            name: droppedItem.name,
            qty: itemQty,
          });
        }
      }
    }
    
    // ä¿å­˜äº‹ä»¶çå‹µä¿¡æ¯ï¼ˆåœ¨æ¸…ç©ºbattleä¹‹å‰ï¼‰
    const eventRewardEquipment = battle.option ? battle.option.eventRewardEquipment : null;
    const eventRewardIsSuperior = battle.option ? battle.option.eventRewardIsSuperior : false;
    const eventRewardGold = battle.option ? battle.option.eventRewardGold : null;
    
    // å¦‚æœæœ‰äººé‚„æ´»è‘—ï¼Œç›´æ¥æ‡‰ç”¨çå‹µä¸¦å¾©æ´»æ‰€æœ‰äººï¼Œä¸é¡¯ç¤ºçµç®—ç•«é¢
    if (hasAliveCharacters) {
      // æ‡‰ç”¨ç¶“é©—å€¼å’Œé‡‘å¹£
      if (hero.stats.gold == null) hero.stats.gold = 0;
      hero.stats.gold += goldGain;
      hero.stats.xp += xpGain;
      pushLog(`${battle.option ? battle.option.label : 'æˆ°é¬¥'} å‹åˆ©ï¼šç²å¾— ${xpGain} EXP / ${goldGain} é‡‘å¹£ã€‚`);
      
      // æª¢æŸ¥æ˜¯å¦æœ‰äº‹ä»¶çå‹µé‡‘å¹£ï¼ˆå¾è²¡å¯¶åº«äº‹ä»¶ï¼‰
      if (eventRewardGold) {
        hero.stats.gold += eventRewardGold;
        pushLog(`è²¡å¯¶åº«çå‹µï¼šç²å¾— ${eventRewardGold} é‡‘å¹£ï¼`);
      }
      
      // æ‡‰ç”¨è£å‚™æ‰è½ï¼ˆæ”¾å…¥é“å…·è¢‹ï¼‰
      droppedEquipment.forEach(eq => {
        if (!hero.equipmentInventory) {
          hero.equipmentInventory = [];
        }
        
        const itemId = `equipment_${eq.id}`;
        const hasInBag = hero.items.some(entry => entry.id === itemId && entry.qty > 0);
        const isOwned = hero.equipmentInventory.includes(eq.id) || hasInBag;
        
        if (!isOwned) {
          limitInventorySize();
          const currentItemCount = hero.items.filter(item => item.qty > 0).length;
          
          if (currentItemCount >= 8) {
            state.ui.itemChoice = {
              newEquipment: eq,
              message: `ç²å¾—è£å‚™ï¼š${eq.name}ï¼Œä½†é“å…·æ¬„å·²æ»¿ï¼ˆ8/8ï¼‰ã€‚è«‹é¸æ“‡è¦ä¸Ÿæ£„çš„é“å…·ï¼š`,
              items: hero.items.filter(entry => entry.qty > 0).slice(0, 8),
            };
            renderAll();
            return;
          }
          
          let itemEntry = hero.items.find(entry => entry.id === itemId);
          if (itemEntry) {
            itemEntry.qty += 1;
          } else {
            hero.items.push({ id: itemId, qty: 1 });
          }
          pushLog(`ç²å¾—è£å‚™ï¼š${eq.name}ï¼ˆå·²æ”¾å…¥é“å…·è¢‹ï¼‰ï¼`);
        } else {
          pushLog(`ç²å¾—è£å‚™ï¼š${eq.name}ï¼ˆå·²æ“æœ‰ï¼‰ã€‚`);
        }
      });
      
      // æ‡‰ç”¨é“å…·æ‰è½
      droppedItems.forEach(item => {
        limitInventorySize();
        const currentItemCount = hero.items.filter(entry => entry.qty > 0).length;
        
        let itemEntry = hero.items.find(entry => entry.id === item.id && entry.qty > 0);
        const needsNewSlot = !itemEntry && currentItemCount >= 8;
        
        if (needsNewSlot) {
          state.ui.itemChoice = {
            newItem: item,
            message: `ç²å¾—é“å…·ï¼š${item.name}ï¼Œä½†é“å…·æ¬„å·²æ»¿ï¼ˆ8/8ï¼‰ã€‚è«‹é¸æ“‡è¦ä¸Ÿæ£„çš„é“å…·ï¼š`,
            items: hero.items.filter(entry => entry.qty > 0).slice(0, 8),
          };
          renderAll();
          return;
        }
        
        if (itemEntry) {
          itemEntry.qty += item.qty;
        } else {
          hero.items.push({ id: item.id, qty: item.qty });
        }
        
        if (item.qty > 1) {
          pushLog(`ç²å¾—é“å…·ï¼š${item.name} Ã—${item.qty}ï¼`);
        } else {
          pushLog(`ç²å¾—é“å…·ï¼š${item.name}ï¼`);
        }
      });
      
      // è™•ç†äº‹ä»¶çå‹µè£å‚™
      if (eventRewardEquipment) {
        const rewardEquipment = eventRewardEquipment;
        const isSuperior = eventRewardIsSuperior;
        
        if (isSuperior) {
          if (!hero.superiorEquipment) {
            hero.superiorEquipment = {};
          }
          hero.superiorEquipment[rewardEquipment.id] = rewardEquipment;
          
          const itemId = `equipment_${rewardEquipment.id}`;
          limitInventorySize();
          const currentItemCount = hero.items.filter(item => item.qty > 0).length;
          if (currentItemCount >= 8) {
            state.ui.itemChoice = {
              newEquipment: rewardEquipment,
              message: `ç²å¾—ç²¾è‰¯è£å‚™ï¼š${rewardEquipment.name}ï¼Œä½†é“å…·æ¬„å·²æ»¿ï¼ˆ8/8ï¼‰ã€‚è«‹é¸æ“‡è¦ä¸Ÿæ£„çš„é“å…·ï¼š`,
              items: hero.items.filter(entry => entry.qty > 0).slice(0, 8),
            };
            renderAll();
            return;
          }
          let itemEntry = hero.items.find(entry => entry.id === itemId);
          if (itemEntry) {
            itemEntry.qty += 1;
          } else {
            hero.items.push({ id: itemId, qty: 1 });
          }
          pushLog(`æˆ°é¬¥å‹åˆ©ï¼ç²å¾—ç²¾è‰¯è£å‚™ï¼š${rewardEquipment.name}ï¼ˆå·²æ”¾å…¥é“å…·è¢‹ï¼‰ï¼`);
        } else {
          if (!hero.equipmentInventory) {
            hero.equipmentInventory = [];
          }
          const itemId = `equipment_${rewardEquipment.id}`;
          const hasInBag = hero.items.some(entry => entry.id === itemId && entry.qty > 0);
          const isOwned = hero.equipmentInventory.includes(rewardEquipment.id) || hasInBag;
          
          if (!isOwned) {
            limitInventorySize();
            const currentItemCount = hero.items.filter(item => item.qty > 0).length;
            if (currentItemCount >= 8) {
              state.ui.itemChoice = {
                newEquipment: rewardEquipment,
                message: `ç²å¾—è£å‚™ï¼š${rewardEquipment.name}ï¼Œä½†é“å…·æ¬„å·²æ»¿ï¼ˆ8/8ï¼‰ã€‚è«‹é¸æ“‡è¦ä¸Ÿæ£„çš„é“å…·ï¼š`,
                items: hero.items.filter(entry => entry.qty > 0).slice(0, 8),
              };
              renderAll();
              return;
            }
            let itemEntry = hero.items.find(entry => entry.id === itemId);
            if (itemEntry) {
              itemEntry.qty += 1;
            } else {
              hero.items.push({ id: itemId, qty: 1 });
            }
            pushLog(`æˆ°é¬¥å‹åˆ©ï¼ç²å¾—è£å‚™ï¼š${rewardEquipment.name}ï¼ˆå·²æ”¾å…¥é“å…·è¢‹ï¼‰ï¼`);
          } else {
            pushLog(`æˆ°é¬¥å‹åˆ©ï¼ç²å¾—è£å‚™ï¼š${rewardEquipment.name}ï¼ˆå·²æ“æœ‰ï¼‰ã€‚`);
          }
        }
      }
      
      // æ‡‰ç”¨é˜²å®ˆå‹è¢«å‹•æŠ€èƒ½ï¼šæˆ°é¬¥å¾Œæ¢å¾©HP
      const defenderEffects = getDefenderPassiveEffects(hero);
      if (defenderEffects.postBattleHpRegen > 0 && hero.stats.hp > 0) {
        const regenAmount = Math.ceil(hero.stats.maxHp * defenderEffects.postBattleHpRegen);
        const oldHp = hero.stats.hp;
        hero.stats.hp = Math.min(hero.stats.maxHp, hero.stats.hp + regenAmount);
        const actualRegen = hero.stats.hp - oldHp;
        if (actualRegen > 0) {
          pushLog(`æˆ°å¾Œæ¢å¾©ï¼šå›å¾©äº† ${actualRegen} HPã€‚`);
        }
      }
      
      // æ‡‰ç”¨é­”æ³•å‹è¢«å‹•æŠ€èƒ½ï¼šæˆ°é¬¥å¾Œæ¢å¾©MP
      const magicEffects = getMagicPassiveEffects(hero);
      if (magicEffects.postBattleMpRegen > 0 && hero.stats.hp > 0) {
        const regenAmount = Math.ceil(hero.stats.maxMp * magicEffects.postBattleMpRegen);
        const oldMp = hero.stats.mp;
        hero.stats.mp = Math.min(hero.stats.maxMp, hero.stats.mp + regenAmount);
        const actualRegen = hero.stats.mp - oldMp;
        if (actualRegen > 0) {
          pushLog(`æˆ°å¾Œå›é­”ï¼šå›å¾©äº† ${actualRegen} MPã€‚`);
        }
      }
      
      // æª¢æŸ¥å‡ç´š
      checkLevelUp();
      
      // å¦‚æœæ‰“å€’é­”ç‹ï¼Œè¨˜éŒ„å·²æ“Šæ•—çš„é­”ç‹ä¸¦å…è¨±é¸æ“‡æ–°åŒä¼´
      if (isBoss) {
        // ç¢ºä¿ defeatedBosses é™£åˆ—å·²åˆå§‹åŒ–
        if (!state.defeatedBosses) {
          state.defeatedBosses = [];
        }
        battle.enemies.forEach(enemy => {
          if (enemy.stats.hp <= 0) {
            const bossTemplate = ENEMY_DECK.find(e => e.id === enemy.id);
            if (bossTemplate && bossTemplate.monsterType === 'boss') {
              if (!state.defeatedBosses.some(b => b.id === bossTemplate.id)) {
                state.defeatedBosses.push({
                  id: bossTemplate.id,
                  name: bossTemplate.name,
                  tier: bossTemplate.tier,
                });
              }
            }
          }
        });
        
        if (state.ui.levelUp) {
          state.ui.bossRewardPending = true;
          // æ¸…é™¤æ‰€æœ‰buff/debuffçŠ¶æ€
          if (battle.enemyDebuffs) {
            battle.enemyDebuffs = {};
          }
          if (battle.friendlyDebuffs) {
            battle.friendlyDebuffs = { hero: {}, companions: {} };
          }
          if (battle.aura) {
            battle.aura = null;
          }
          if (hero && hero.stats) {
            hero.stats.shield = 0;
          }
          if (state.companions) {
            state.companions.forEach(companion => {
              if (companion && companion.stats) {
                companion.stats.shield = 0;
              }
            });
          }
          // æ¸…ç©ºæˆ°é¬¥ç‹€æ…‹ï¼Œä½†ä¿ç•™bossRewardPendingæ¨™è¨˜
          state.ui.battle = null;
          renderAll();
          return;
        }
        
        handleBossReward();
      } else {
        // éé­”ç‹æˆ°é¬¥ï¼Œæª¢æŸ¥æ˜¯å¦ç‚ºäº‹ä»¶ä¸­çš„æˆ°é¬¥
        if (battle.option && battle.option.nodeIndex !== undefined) {
          pushLog('æˆ°é¬¥çµæŸï¼Œè¿”å›äº‹ä»¶ã€‚');
        } else {
          advanceToNextNode();
        }
      }
      
      // æ¸…é™¤æ‰€æœ‰buff/debuffçŠ¶æ€
      if (battle.enemyDebuffs) {
        battle.enemyDebuffs = {};
      }
      if (battle.friendlyDebuffs) {
        battle.friendlyDebuffs = { hero: {}, companions: {} };
      }
      if (battle.aura) {
        battle.aura = null;
      }
      if (hero && hero.stats) {
        hero.stats.shield = 0;
      }
      if (state.companions) {
        state.companions.forEach(companion => {
          if (companion && companion.stats) {
            companion.stats.shield = 0;
          }
        });
      }
      
      // æ¸…ç©ºæˆ°é¬¥ç‹€æ…‹ï¼Œä¸é¡¯ç¤ºçµç®—ç•«é¢
      state.ui.battle = null;
      renderAll();
      return;
    }
    
    // å¦‚æœæ‰€æœ‰äººéƒ½æ­»äº¡ï¼Œé¡¯ç¤ºçµç®—ç•«é¢ï¼ˆæ­£å¸¸æµç¨‹ï¼‰
    // ä¿å­˜æˆ°é¬¥çµæœï¼Œé¡¯ç¤ºæ‰è½ç‰©å“å°è©±æ¡†
    state.ui.battleResult = {
      victory: true,
      xpGain,
      goldGain,
      droppedItems,
      droppedEquipment,
      effect: () => {
        // æ‡‰ç”¨ç¶“é©—å€¼å’Œé‡‘å¹£
        if (hero.stats.gold == null) hero.stats.gold = 0;
        hero.stats.gold += goldGain;
        hero.stats.xp += xpGain;
        pushLog(`${battle.option ? battle.option.label : 'æˆ°é¬¥'} å‹åˆ©ï¼šç²å¾— ${xpGain} EXP / ${goldGain} é‡‘å¹£ã€‚`);
        
        // æª¢æŸ¥æ˜¯å¦æœ‰äº‹ä»¶çå‹µé‡‘å¹£ï¼ˆå¾è²¡å¯¶åº«äº‹ä»¶ï¼‰
        if (eventRewardGold) {
          hero.stats.gold += eventRewardGold;
          pushLog(`è²¡å¯¶åº«çå‹µï¼šç²å¾— ${eventRewardGold} é‡‘å¹£ï¼`);
        }
        
        // æ‡‰ç”¨è£å‚™æ‰è½ï¼ˆæ”¾å…¥é“å…·è¢‹ï¼‰
        droppedEquipment.forEach(eq => {
          if (!hero.equipmentInventory) {
            hero.equipmentInventory = [];
          }
          
          // æª¢æŸ¥æ˜¯å¦å·²æ“æœ‰ï¼ˆåœ¨åº«å­˜æˆ–é“å…·è¢‹ä¸­ï¼‰
          const itemId = `equipment_${eq.id}`;
          const hasInBag = hero.items.some(entry => entry.id === itemId && entry.qty > 0);
          const isOwned = hero.equipmentInventory.includes(eq.id) || hasInBag;
          
          if (!isOwned) {
            // æª¢æŸ¥é“å…·æ¬„æ˜¯å¦å·²æ»¿
            limitInventorySize();
            const currentItemCount = hero.items.filter(item => item.qty > 0).length;
            
            if (currentItemCount >= 8) {
              // é“å…·æ¬„å·²æ»¿ï¼Œéœ€è¦é¸æ“‡ä¸Ÿæ£„
              state.ui.itemChoice = {
                newEquipment: eq,
                message: `ç²å¾—è£å‚™ï¼š${eq.name}ï¼Œä½†é“å…·æ¬„å·²æ»¿ï¼ˆ8/8ï¼‰ã€‚è«‹é¸æ“‡è¦ä¸Ÿæ£„çš„é“å…·ï¼š`,
                items: hero.items.filter(entry => entry.qty > 0).slice(0, 8),
              };
              renderAll();
              return;
            }
            
            // å°‡è£å‚™æ”¾å…¥é“å…·è¢‹
            let itemEntry = hero.items.find(entry => entry.id === itemId);
            if (itemEntry) {
              itemEntry.qty += 1;
            } else {
              hero.items.push({ id: itemId, qty: 1 });
            }
            pushLog(`ç²å¾—è£å‚™ï¼š${eq.name}ï¼ˆå·²æ”¾å…¥é“å…·è¢‹ï¼‰ï¼`);
          } else {
            pushLog(`ç²å¾—è£å‚™ï¼š${eq.name}ï¼ˆå·²æ“æœ‰ï¼‰ã€‚`);
          }
        });
        
        // æ‡‰ç”¨é“å…·æ‰è½ï¼ˆéœ€è¦æª¢æŸ¥æ˜¯å¦è¶…éä¸Šé™ï¼‰
        droppedItems.forEach(item => {
          limitInventorySize();
          const currentItemCount = hero.items.filter(entry => entry.qty > 0).length;
          
          // æª¢æŸ¥æ˜¯å¦éœ€è¦æ–°å¢é“å…·é¡å‹ï¼ˆå¦‚æœé“å…·æ¬„å·²æ»¿ä¸”è©²é“å…·é¡å‹ä¸å­˜åœ¨ï¼‰
          let itemEntry = hero.items.find(entry => entry.id === item.id && entry.qty > 0);
          const needsNewSlot = !itemEntry && currentItemCount >= 8;
          
          if (needsNewSlot) {
            // é“å…·æ¬„å·²æ»¿ä¸”éœ€è¦æ–°æ§½ä½ï¼Œéœ€è¦é¸æ“‡ä¸Ÿæ£„
            state.ui.itemChoice = {
              newItem: item,
              message: `ç²å¾—é“å…·ï¼š${item.name}ï¼Œä½†é“å…·æ¬„å·²æ»¿ï¼ˆ8/8ï¼‰ã€‚è«‹é¸æ“‡è¦ä¸Ÿæ£„çš„é“å…·ï¼š`,
              items: hero.items.filter(entry => entry.qty > 0).slice(0, 8),
            };
            renderAll();
            return;
          }
          
          // æ­£å¸¸æ·»åŠ é“å…·
          if (itemEntry) {
            itemEntry.qty += item.qty;
          } else {
            hero.items.push({ id: item.id, qty: item.qty });
          }
          
          if (item.qty > 1) {
            pushLog(`ç²å¾—é“å…·ï¼š${item.name} Ã—${item.qty}ï¼`);
          } else {
            pushLog(`ç²å¾—é“å…·ï¼š${item.name}ï¼`);
          }
        });
        
        // æª¢æŸ¥æ˜¯å¦æœ‰äº‹ä»¶çå‹µè£å‚™ï¼ˆå¾å†’éšªé€²å…¥æ¢ç´¢äº‹ä»¶ï¼‰
        if (eventRewardEquipment) {
          const rewardEquipment = eventRewardEquipment;
          const isSuperior = eventRewardIsSuperior;
          
          if (isSuperior) {
            // ç²¾è‰¯è£å‚™ï¼šä¿å­˜åˆ°superiorEquipment
            if (!hero.superiorEquipment) {
              hero.superiorEquipment = {};
            }
            hero.superiorEquipment[rewardEquipment.id] = rewardEquipment;
            
            // æ”¾å…¥é“å…·è¢‹
            const itemId = `equipment_${rewardEquipment.id}`;
            limitInventorySize();
            const currentItemCount = hero.items.filter(item => item.qty > 0).length;
            if (currentItemCount >= 8) {
              state.ui.itemChoice = {
                newEquipment: rewardEquipment,
                message: `ç²å¾—ç²¾è‰¯è£å‚™ï¼š${rewardEquipment.name}ï¼Œä½†é“å…·æ¬„å·²æ»¿ï¼ˆ8/8ï¼‰ã€‚è«‹é¸æ“‡è¦ä¸Ÿæ£„çš„é“å…·ï¼š`,
                items: hero.items.filter(entry => entry.qty > 0).slice(0, 8),
              };
              renderAll();
              return;
            }
            let itemEntry = hero.items.find(entry => entry.id === itemId);
            if (itemEntry) {
              itemEntry.qty += 1;
            } else {
              hero.items.push({ id: itemId, qty: 1 });
            }
            pushLog(`æˆ°é¬¥å‹åˆ©ï¼ç²å¾—ç²¾è‰¯è£å‚™ï¼š${rewardEquipment.name}ï¼ˆå·²æ”¾å…¥é“å…·è¢‹ï¼‰ï¼`);
          } else {
            // ä¸€èˆ¬è£å‚™ï¼šæ”¾å…¥é“å…·è¢‹
            if (!hero.equipmentInventory) {
              hero.equipmentInventory = [];
            }
            const itemId = `equipment_${rewardEquipment.id}`;
            const hasInBag = hero.items.some(entry => entry.id === itemId && entry.qty > 0);
            const isOwned = hero.equipmentInventory.includes(rewardEquipment.id) || hasInBag;
            
            if (!isOwned) {
              limitInventorySize();
              const currentItemCount = hero.items.filter(item => item.qty > 0).length;
              if (currentItemCount >= 8) {
                state.ui.itemChoice = {
                  newEquipment: rewardEquipment,
                  message: `ç²å¾—è£å‚™ï¼š${rewardEquipment.name}ï¼Œä½†é“å…·æ¬„å·²æ»¿ï¼ˆ8/8ï¼‰ã€‚è«‹é¸æ“‡è¦ä¸Ÿæ£„çš„é“å…·ï¼š`,
                  items: hero.items.filter(entry => entry.qty > 0).slice(0, 8),
                };
                renderAll();
                return;
              }
              let itemEntry = hero.items.find(entry => entry.id === itemId);
              if (itemEntry) {
                itemEntry.qty += 1;
              } else {
                hero.items.push({ id: itemId, qty: 1 });
              }
              pushLog(`æˆ°é¬¥å‹åˆ©ï¼ç²å¾—è£å‚™ï¼š${rewardEquipment.name}ï¼ˆå·²æ”¾å…¥é“å…·è¢‹ï¼‰ï¼`);
            } else {
              pushLog(`æˆ°é¬¥å‹åˆ©ï¼ç²å¾—è£å‚™ï¼š${rewardEquipment.name}ï¼ˆå·²æ“æœ‰ï¼‰ã€‚`);
            }
          }
        }
        
        // å¦‚æœåŸ·è¡Œåˆ°é€™è£¡ï¼Œè¡¨ç¤ºæ‰€æœ‰äººéƒ½æ­»äº¡ï¼ˆå› ç‚ºå¦‚æœæœ‰äººæ´»è‘—ï¼Œå·²ç¶“åœ¨ä¸Šé¢è™•ç†ä¸¦è¿”å›äº†ï¼‰
        // ä¸éœ€è¦å¾©æ´»ï¼Œç›´æ¥é¡¯ç¤ºçµç®—ç•«é¢
        
        // æ‡‰ç”¨é˜²å®ˆå‹è¢«å‹•æŠ€èƒ½ï¼šæˆ°é¬¥å¾Œæ¢å¾©HP
        const defenderEffects = getDefenderPassiveEffects(hero);
        if (defenderEffects.postBattleHpRegen > 0 && hero.stats.hp > 0) {
          const regenAmount = Math.ceil(hero.stats.maxHp * defenderEffects.postBattleHpRegen);
          const oldHp = hero.stats.hp;
          hero.stats.hp = Math.min(hero.stats.maxHp, hero.stats.hp + regenAmount);
          const actualRegen = hero.stats.hp - oldHp;
          if (actualRegen > 0) {
            pushLog(`æˆ°å¾Œæ¢å¾©ï¼šå›å¾©äº† ${actualRegen} HPã€‚`);
          }
        }
        
        // æ‡‰ç”¨é­”æ³•å‹è¢«å‹•æŠ€èƒ½ï¼šæˆ°é¬¥å¾Œæ¢å¾©MP
        const magicEffects = getMagicPassiveEffects(hero);
        if (magicEffects.postBattleMpRegen > 0 && hero.stats.hp > 0) {
          const regenAmount = Math.ceil(hero.stats.maxMp * magicEffects.postBattleMpRegen);
          const oldMp = hero.stats.mp;
          hero.stats.mp = Math.min(hero.stats.maxMp, hero.stats.mp + regenAmount);
          const actualRegen = hero.stats.mp - oldMp;
          if (actualRegen > 0) {
            pushLog(`æˆ°å¾Œå›é­”ï¼šå›å¾©äº† ${actualRegen} MPã€‚`);
          }
        }
        
        // å…ˆæª¢æŸ¥å‡ç´šï¼ˆç„¡è«–æ˜¯å¦ç‚ºé­”ç‹æˆ°é¬¥ï¼‰
        checkLevelUp();
        
        // å¦‚æœæ‰“å€’é­”ç‹ï¼Œè¨˜éŒ„å·²æ“Šæ•—çš„é­”ç‹ä¸¦å…è¨±é¸æ“‡æ–°åŒä¼´ï¼ˆåœ¨å‡ç´šå®Œæˆå¾Œï¼‰
        if (isBoss) {
          // è¨˜éŒ„å·²æ“Šæ•—çš„é­”ç‹
          if (!state.defeatedBosses) {
            state.defeatedBosses = [];
          }
          battle.enemies.forEach(enemy => {
            if (enemy.stats.hp <= 0) {
              const bossTemplate = ENEMY_DECK.find(e => e.id === enemy.id);
              if (bossTemplate && bossTemplate.monsterType === 'boss') {
                // æª¢æŸ¥æ˜¯å¦å·²ç¶“è¨˜éŒ„éï¼ˆé¿å…é‡è¤‡ï¼‰
                if (!state.defeatedBosses.some(b => b.id === bossTemplate.id)) {
                  state.defeatedBosses.push({
                    id: bossTemplate.id,
                    name: bossTemplate.name,
                    tier: bossTemplate.tier,
                  });
                }
              }
            }
          });
          
          // å¦‚æœæ­£åœ¨å‡ç´šï¼Œç­‰å¾…å‡ç´šå®Œæˆå¾Œå†è™•ç†é­”ç‹çå‹µ
          if (state.ui.levelUp) {
            // æ¨™è¨˜é€™æ˜¯é­”ç‹æˆ°é¬¥å¾Œçš„è™•ç†ï¼Œå‡ç´šå®Œæˆå¾Œæœƒç¹¼çºŒ
            state.ui.bossRewardPending = true;
            return; // ç­‰å¾…å‡ç´šå®Œæˆ
          }
          
          // å‡ç´šå®Œæˆå¾Œï¼Œè™•ç†é­”ç‹çå‹µ
          handleBossReward();
            } else {
          // éé­”ç‹æˆ°é¬¥ï¼Œæª¢æŸ¥æ˜¯å¦ç‚ºäº‹ä»¶ä¸­çš„æˆ°é¬¥
          // å¦‚æœæˆ°é¬¥é¸é …æœ‰ nodeIndex å±¬æ€§ï¼Œè¡¨ç¤ºé€™æ˜¯å¾äº‹ä»¶ä¸­è§¸ç™¼çš„æˆ°é¬¥
          // äº‹ä»¶ä¸­çš„æˆ°é¬¥çµæŸå¾Œä¸æ‡‰è©²è‡ªå‹•å‰é€²åˆ°ä¸‹ä¸€å€‹ç¯€é»
          if (battle.option && battle.option.nodeIndex !== undefined) {
            // äº‹ä»¶ä¸­çš„æˆ°é¬¥ï¼Œä¸è‡ªå‹•å‰é€²
            pushLog('æˆ°é¬¥çµæŸï¼Œè¿”å›äº‹ä»¶ã€‚');
          } else {
            // æ­£å¸¸ç¯€é»æˆ°é¬¥ï¼Œé€²å…¥ä¸‹ä¸€å€‹ç¯€é»
        advanceToNextNode();
          }
        }
      },
    };
    
    // æ¸…é™¤æ‰€æœ‰buff/debuffçŠ¶æ€
    // æ¸…é™¤æ•Œäººçš„debuff
    if (battle.enemyDebuffs) {
      battle.enemyDebuffs = {};
    }
    
    // æ¸…é™¤å‹æ–¹çš„debuff
    if (battle.friendlyDebuffs) {
      battle.friendlyDebuffs = { hero: {}, companions: {} };
    }
    
    // æ¸…é™¤å…‰ç¯æ•ˆæœ
    if (battle.aura) {
      battle.aura = null;
    }
    
    // æ¸…é™¤å‹‡è€…çš„æŠ¤ç›¾
    if (hero && hero.stats) {
      hero.stats.shield = 0;
    }
    
    // æ¸…é™¤æ‰€æœ‰åŒä¼´çš„æŠ¤ç›¾
    if (state.companions) {
      state.companions.forEach(companion => {
        if (companion && companion.stats) {
          companion.stats.shield = 0;
        }
      });
    }
    
    state.ui.battle = null;
    renderAll();
  } else {
    // æˆ°é¬¥å¤±æ•—ï¼šåªè¦æœ‰äººé‚„æ´»è‘—ï¼Œæ‰€æœ‰æ­»äº¡çš„äººæœƒä»¥HP1å¾©æ´»ï¼Œç¹¼çºŒéŠæˆ²
    const hero = state.hero;
    
    // æª¢æŸ¥æ˜¯å¦æœ‰äººé‚„æ´»è‘—
    const hasAliveCharacters = !areAllCharactersDead();
    
    if (hasAliveCharacters) {
      // æœ‰äººé‚„æ´»è‘—ï¼Œå¾©æ´»æ‰€æœ‰æ­»äº¡çš„äººåˆ°HP1
      // å¾©æ´»æ­»äº¡çš„å‹‡è€…
    if (hero && hero.stats.hp <= 0) {
      hero.stats.hp = 1;
      pushLog(`å‹‡è€…ä»¥ HP1 çš„ç‹€æ…‹å¾©æ´»ã€‚`);
      }
      
      // å¾©æ´»æ‰€æœ‰æ­»äº¡çš„åŒä¼´
      state.companions.forEach(companion => {
        if (companion && companion.stats.hp <= 0) {
          companion.stats.hp = 1;
          pushLog(`${companion.name} ä»¥ HP1 çš„ç‹€æ…‹å¾©æ´»ã€‚`);
        }
      });
      
      // æ¸…é™¤æ‰€æœ‰buff/debuffçŠ¶æ€
      // æ¸…é™¤æ•Œäººçš„debuff
      if (battle.enemyDebuffs) {
        battle.enemyDebuffs = {};
      }
      
      // æ¸…é™¤å‹æ–¹çš„debuff
      if (battle.friendlyDebuffs) {
        battle.friendlyDebuffs = { hero: {}, companions: {} };
      }
      
      // æ¸…é™¤å…‰ç¯æ•ˆæœ
      if (battle.aura) {
        battle.aura = null;
      }
      
      // æ¸…é™¤å‰‘æ„buff
      if (battle.heroBuffs) {
        battle.heroBuffs.swordIntent = null;
      }
      if (battle.companionBuffs) {
        Object.keys(battle.companionBuffs).forEach(key => {
          const companionIndex = parseInt(key);
          if (!isNaN(companionIndex) && battle.companionBuffs[companionIndex]) {
            battle.companionBuffs[companionIndex].swordIntent = null;
          }
        });
      }
      
      // æ¸…é™¤å‹‡è€…çš„æŠ¤ç›¾
      if (hero && hero.stats) {
        hero.stats.shield = 0;
      }
      
      // æ¸…é™¤æ‰€æœ‰åŒä¼´çš„æŠ¤ç›¾
      if (state.companions) {
        state.companions.forEach(companion => {
          if (companion && companion.stats) {
            companion.stats.shield = 0;
          }
        });
      }
      
      // æ¸…ç©ºæˆ°é¬¥ç‹€æ…‹ï¼Œç¹¼çºŒéŠæˆ²
      state.ui.battle = null;
      pushLog('æˆ°é¬¥çµæŸï¼Œæ‰€æœ‰äººä»¥ HP1 å¾©æ´»ï¼Œç¹¼çºŒå†’éšªã€‚');
      renderAll();
      return;
    }
    
    // å¦‚æœå‹‡è€…æ²’æœ‰æ­»äº¡ä½†æˆ°é¬¥å¤±æ•—ï¼ˆç†è«–ä¸Šä¸æ‡‰è©²ç™¼ç”Ÿï¼Œä½†ä¿ç•™ä½œç‚ºå®‰å…¨æªæ–½ï¼‰
    // æ‰€æœ‰è§’è‰²éƒ½æˆ°æ•—ï¼Œæœ¬æ¬¡å†’éšªçµæŸ
    pushLog('æ‰€æœ‰è§’è‰²éƒ½æˆ°æ•—ï¼Œæœ¬æ¬¡å†’éšªçµæŸã€‚');
    
    // æ”¶é›†éŠæˆ²çµ±è¨ˆä¿¡æ¯ï¼ˆåœ¨æ¸…ç©º battle ä¹‹å‰ï¼‰
    const gameStats = {
      level: hero ? hero.stats.level : 1,
      stage: state.world ? state.world.stage : 1,
      currentNodeIndex: state.world ? state.world.currentNodeIndex : 0,
      gold: hero ? hero.stats.gold : 0,
      companionsCount: (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0).length,
      skillsCount: hero && hero.skills ? hero.skills.length : 0,
      equipmentCount: hero && hero.equipmentInventory ? hero.equipmentInventory.length : 0,
    };
    
    // å¦‚æœæ²’æœ‰æ­»äº¡ä¿¡æ¯ï¼Œå‰µå»ºé»˜èªçš„ï¼ˆåœ¨æ¸…ç©º battle ä¹‹å‰ï¼‰
    if (!state.ui.deathInfo && battle && battle.enemies && battle.enemies.length > 0) {
      const aliveEnemies = battle.enemies.filter(e => e.stats.hp > 0);
      const lastEnemy = aliveEnemies.length > 0 ? aliveEnemies[0] : battle.enemies[0];
      state.ui.deathInfo = {
        cause: 'unknown',
        attacker: lastEnemy ? lastEnemy.name : 'æœªçŸ¥',
        damage: 0,
        skill: null,
        isCrit: false,
      };
    }
    
    // ä¿å­˜çµ±è¨ˆä¿¡æ¯
    state.ui.gameStats = gameStats;
    
    // æ¸…é™¤æ‰€æœ‰buff/debuffçŠ¶æ€
    // æ¸…é™¤æ•Œäººçš„debuff
    if (battle.enemyDebuffs) {
      battle.enemyDebuffs = {};
    }
    
    // æ¸…é™¤å‹æ–¹çš„debuff
    if (battle.friendlyDebuffs) {
      battle.friendlyDebuffs = { hero: {}, companions: {} };
    }
    
    // æ¸…é™¤å…‰ç¯æ•ˆæœ
    if (battle.aura) {
      battle.aura = null;
    }
    
    // æ¸…é™¤å‰‘æ„buff
    if (battle.heroBuffs) {
      battle.heroBuffs.swordIntent = null;
    }
    if (battle.companionBuffs) {
      Object.keys(battle.companionBuffs).forEach(key => {
        const companionIndex = parseInt(key);
        if (!isNaN(companionIndex) && battle.companionBuffs[companionIndex]) {
          battle.companionBuffs[companionIndex].swordIntent = null;
        }
      });
    }
    
    // æ¸…é™¤å‹‡è€…çš„æŠ¤ç›¾
    if (hero && hero.stats) {
      hero.stats.shield = 0;
    }
    
    // æ¸…é™¤æ‰€æœ‰åŒä¼´çš„æŠ¤ç›¾
    if (state.companions) {
      state.companions.forEach(companion => {
        if (companion && companion.stats) {
          companion.stats.shield = 0;
        }
      });
    }
    
    // æ¸…ç©ºæˆ°é¬¥ç‹€æ…‹
    state.ui.battle = null;
    
    // é¡¯ç¤ºæ­»äº¡çµ±è¨ˆç•Œé¢
    handleGameOver();
    renderAll();
  }
}

function handleEvent(option) {
  const hero = state.hero;
  const currentTier = state.world.stage;
  
  // æª¢æŸ¥æ˜¯å¦ç‚ºæŠ€èƒ½è¨“ç·´å¸«äº‹ä»¶
  if (option.eventType === 'skillTrainer') {
    handleSkillTrainerEvent(option);
    return;
  }
  
  // æª¢æŸ¥æ˜¯å¦ç‚ºå¿ƒç†æ²»ç™‚æ‰€äº‹ä»¶
  if (option.eventType === 'personalityTherapy') {
    handlePersonalityTherapyEvent(option);
    return;
  }
  
  // æª¢æŸ¥æ˜¯å¦ç‚ºè·æ¥­é€²éšäº‹ä»¶
  if (option.eventType === 'classAdvancement') {
    handleClassAdvancementEvent(option);
    return;
  }
  
  // æª¢æŸ¥æ˜¯å¦ç‚ºç¾…å¾·è£å‚™äº‹ä»¶
  if (option.eventType === 'rodEquipment') {
    handleRodEquipmentEvent(option);
    return;
  }
  
  // æª¢æŸ¥æ˜¯å¦ç‚ºå‹‡è€…ä¹‹è¡€äº‹ä»¶
  if (option.eventType === 'heroBlood') {
    handleHeroBloodEvent(option);
    return;
  }
  
  // åˆ¤æ–­äº‹ä»¶ç±»å‹ï¼š50%å¥½äº‹ï¼Œ30%åäº‹ï¼Œ20%é€‰æ‹©å‹ï¼ˆæœ‰å¥½æœ‰åï¼‰
  const eventTypeRoll = Math.random();
  const eventRoll = Math.random();
  let eventResult = null;
  
  let eventType = 'good'; // 'good', 'bad', 'choice'
  if (eventTypeRoll < 0.5) {
    eventType = 'good'; // 50%å¥½äº‹
  } else if (eventTypeRoll < 0.8) {
    eventType = 'bad'; // 30%åäº‹
  } else {
    eventType = 'choice'; // 20%é€‰æ‹©å‹
  }
  
  if (eventType === 'good') {
    // å¥½äº‹äº‹ä»¶ï¼ˆ50%æ¦‚ç‡ï¼‰
    // éšæœºé€‰æ‹©äº‹ä»¶ç±»å‹ï¼ˆæ‰©å±•æ›´å¤šäº‹ä»¶ï¼‰
    if (eventRoll < 0.10) {
    // 8%ï¼šç¥ç¦äº‹ä»¶ - ä¸¤æ­¥æµç¨‹ï¼šå…ˆé€‰æ‹©èƒ½åŠ›åŠ æˆï¼Œå†é€‰æ‹©è§’è‰²
    const companions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
    const attrIncrease = Math.max(2, Math.floor(currentTier * 1.5)); // ä¸é˜¶å±‚æ•°æˆæ­£æ¯”ï¼Œæœ€å°‘2ç‚¹
    
    // ç¬¬ä¸€æ­¥ï¼šéšæœºé€‰æ‹©3ç§ä¸åŒçš„èƒ½åŠ›åŠ æˆ
    const allAttributes = [...ATTRIBUTES];
    const selectedAttributes = [];
    for (let i = 0; i < 3 && allAttributes.length > 0; i++) {
      const randomIndex = Math.floor(Math.random() * allAttributes.length);
      selectedAttributes.push(allAttributes.splice(randomIndex, 1)[0]);
    }
    
    // åˆ›å»ºç¬¬ä¸€æ­¥é€‰æ‹©ï¼ˆé€‰æ‹©èƒ½åŠ›åŠ æˆï¼‰
    const attributeChoices = selectedAttributes.map((attr) => {
      return {
        hint: `é¸æ“‡${attr.name}åŠ æˆ`,
        label: `å¢åŠ  ${attrIncrease} ${attr.name}`,
        resultTitle: '',
        resultMessage: '',
        // ä¸æ‰§è¡Œæ•ˆæœï¼Œè€Œæ˜¯è¿›å…¥ä¸‹ä¸€æ­¥
        nextStep: {
          type: 'choice',
          title: 'ç¥è–çš„ç¥ç¦',
          message: `ä½ é¸æ“‡äº†${attr.name}åŠ æˆã€‚ç¾åœ¨é¸æ“‡è¦ç¥ç¦çš„è§’è‰²ï¼š`,
          selectedAttribute: attr, // ä¿å­˜é€‰æ‹©çš„èƒ½åŠ›
          attrIncrease: attrIncrease, // ä¿å­˜åŠ æˆæ•°å€¼
          choices: (() => {
            const characterChoices = [];
            
            // å‹‡è€…é€‰é¡¹
            characterChoices.push({
              hint: `ç¥ç¦å‹‡è€…`,
              label: `å‹‡è€…ï¼šå¢åŠ  ${attrIncrease} ${attr.name}`,
              resultTitle: 'ç²å¾—ç¥ç¦',
              resultMessage: `ä½ é¸æ“‡äº†ç¥ç¦å‹‡è€…ï¼Œ${attr.name}å¢åŠ äº† ${attrIncrease} é»ï¼\nå‹‡è€…çš„${attr.name}æ°¸ä¹…æå‡äº† ${attrIncrease} é»ã€‚`,
              effect: () => {
                if (!hero.attributes) {
                  hero.attributes = { attack: 0, vitality: 0, defense: 0, recovery: 0, magic: 0, agility: 0 };
                }
                hero.attributes[attr.id] = (hero.attributes[attr.id] || 0) + attrIncrease;
                pushLog(`${option.label}ï¼šç¥ç¦å‹‡è€…ï¼Œ${attr.name} å¢åŠ äº† ${attrIncrease}ã€‚`);
              },
            });
            
            // åŒä¼´é€‰é¡¹
            companions.forEach((companion) => {
              characterChoices.push({
                hint: `ç¥ç¦${companion.name}`,
                label: `${companion.name}ï¼šå¢åŠ  ${attrIncrease} ${attr.name}`,
                resultTitle: 'ç²å¾—ç¥ç¦',
                resultMessage: `ä½ é¸æ“‡äº†ç¥ç¦${companion.name}ï¼Œ${attr.name}å¢åŠ äº† ${attrIncrease} é»ï¼\n${companion.name}çš„${attr.name}æ°¸ä¹…æå‡äº† ${attrIncrease} é»ã€‚`,
                effect: () => {
                  if (!companion.attributes) {
                    companion.attributes = { attack: 5, vitality: 5, defense: 5, recovery: 5, magic: 5, agility: 5 };
                  }
                  companion.attributes[attr.id] = (companion.attributes[attr.id] || 0) + attrIncrease;
                  pushLog(`${option.label}ï¼šç¥ç¦${companion.name}ï¼Œ${attr.name} å¢åŠ äº† ${attrIncrease}ã€‚`);
                },
              });
            });
            
            return characterChoices;
          })(),
        },
      };
    });
    
    eventResult = {
      type: 'choice',
      title: 'ç¥è–çš„ç¥ç¦',
      message: 'ä½ ç™¼ç¾äº†ä¸€å€‹æ•£ç™¼è‘—ç¥è–å…‰èŠ’çš„ç¥­å£‡ã€‚é¦–å…ˆé¸æ“‡ä¸€ç¨®èƒ½åŠ›åŠ æˆï¼Œç„¶å¾Œé¸æ“‡è¦ç¥ç¦çš„è§’è‰²ã€‚ç¥ç¦çš„åŠ›é‡èˆ‡ç•¶å‰éšå±¤æˆæ­£æ¯”ã€‚',
      choices: attributeChoices,
    };
    } else if (eventRoll < 0.18) {
    // 5%ï¼šé­é‡æˆ˜æ–—äº‹ä»¶ - å¯ä»¥é€‰æ‹©é‡åˆ°ç²¾è‹±æ€ªæˆ–ä¹‹å‰çš„é­”ç‹
    const defeatedBosses = (state.defeatedBosses || []).filter(b => b && b.id);
    const choices = [];
    
    // æ£€æŸ¥æ˜¯å¦å·²ç»è·å¾—ç²¾è‰¯è£…å¤‡
    const hasSuperiorEquipment = hero.superiorEquipment && Object.keys(hero.superiorEquipment).length > 0;
    
    // ç²¾è‹±æ€ªé€‰é¡¹
    choices.push({
      hint: 'æŒ‘æˆ°èè‹±æ€ª',
      label: 'æŒ‘æˆ°èè‹±æ€ªï¼ˆç¶“é©—å€¼å’Œé‡‘å¹£+30%ï¼‰',
      resultTitle: 'é­é‡èè‹±æ€ª',
      resultMessage: 'ä½ é¸æ“‡äº†æŒ‘æˆ°èè‹±æ€ªï¼æº–å‚™æˆ°é¬¥ï¼',
      effect: () => {
        // å‰µå»ºç²¾è‹±æˆ°é¬¥é¸é …
        const eliteOption = {
          type: 'elite',
          label: option.label || 'é­é‡èè‹±æ€ª',
          nodeIndex: state.world.currentNodeIndex,
        };
        // å•Ÿå‹•ç²¾è‹±æˆ°é¬¥ï¼ˆmultiplier = 1.6ï¼‰
        startBattle(eliteOption, 1.6);
        pushLog(`${option.label}ï¼šé¸æ“‡äº†æŒ‘æˆ°èè‹±æ€ªã€‚`);
      },
    });
    
    // é­”ç‹é€‰é¡¹ï¼šæ€»æ˜¯æ˜¾ç¤ºï¼ˆå·²å‡»è´¥çš„é­”ç‹æˆ–å½“å‰/ä¹‹å‰é˜¶å±‚çš„é­”ç‹ï¼‰
      let bossToFight = null;
      
    if (defeatedBosses.length > 0) {
      // å¦‚æœæœ‰å‡»è´¥çš„é­”ç‹ï¼Œä¼˜å…ˆæ˜¾ç¤ºå·²å‡»è´¥çš„é­”ç‹
        bossToFight = defeatedBosses[Math.floor(Math.random() * defeatedBosses.length)];
    } else {
      // å¦‚æœæ²¡æœ‰å‡»è´¥çš„é­”ç‹ï¼Œé€‰æ‹©å½“å‰æˆ–ä¹‹å‰é˜¶å±‚çš„é­”ç‹
        const bossTier = state.world.stage;
        const bossPool = ENEMY_DECK.filter(
          (enemy) => enemy.monsterType === 'boss' && enemy.tier <= bossTier
        );
        if (bossPool.length > 0) {
          const randomBossTemplate = bossPool[Math.floor(Math.random() * bossPool.length)];
          bossToFight = {
            id: randomBossTemplate.id,
            name: randomBossTemplate.name,
            tier: randomBossTemplate.tier,
          };
        }
      }
    
    // å¦‚æœæœ‰å¯æˆ˜æ–—çš„é­”ç‹ï¼Œæ·»åŠ é­”ç‹é€‰é¡¹
    if (bossToFight) {
      
      if (bossToFight) {
        choices.push({
          hint: `æŒ‘æˆ°${bossToFight.name}`,
          label: `æŒ‘æˆ°${bossToFight.name}ï¼ˆç¶“é©—å€¼å’Œé‡‘å¹£+60%ï¼‰`,
          resultTitle: `é­é‡${bossToFight.name}`,
          resultMessage: `ä½ é¸æ“‡äº†æŒ‘æˆ°${bossToFight.name}ï¼æº–å‚™æˆ°é¬¥ï¼`,
          effect: () => {
            // å‰µå»ºé­”ç‹æˆ°é¬¥é¸é …
            const bossOption = {
              type: 'boss',
              label: option.label || `é­é‡${bossToFight.name}`,
              nodeIndex: state.world.currentNodeIndex,
              bossId: bossToFight.id, // æŒ‡å®šè¦æˆ°é¬¥çš„é­”ç‹ID
            };
            // å•Ÿå‹•é­”ç‹æˆ°é¬¥ï¼ˆmultiplier = 2.5ï¼‰
            startBattle(bossOption, 2.5);
            pushLog(`${option.label}ï¼šé¸æ“‡äº†æŒ‘æˆ°${bossToFight.name}ã€‚`);
          },
        });
      }
    }
    
    // å®‰å…¨ç¦»å¼€é€‰é¡¹
    choices.push({
      hint: 'è¬¹æ…åœ°é›¢é–‹',
      label: 'å®‰å…¨é›¢é–‹ï¼ˆç„¡æ•ˆæœï¼‰',
      resultTitle: 'å®‰å…¨é›¢é–‹',
      resultMessage: 'ä½ é¸æ“‡äº†è¬¹æ…åœ°é›¢é–‹ï¼Œé›–ç„¶æ²’æœ‰ç²å¾—ä»»ä½•æ±è¥¿ï¼Œä½†ä¹Ÿæ²’æœ‰é‡åˆ°å±éšªã€‚',
      effect: () => {
        pushLog(`${option.label}ï¼šé¸æ“‡äº†å®‰å…¨é›¢é–‹ã€‚`);
      },
    });
    
    eventResult = {
      type: 'choice',
      title: 'å±éšªçš„é­é‡',
      message: 'ä½ æ„Ÿè¦ºåˆ°ä¸€è‚¡å¼·å¤§çš„æ°£æ¯ï¼å‰æ–¹ä¼¼ä¹æœ‰å¼·å¤§çš„æ•µäººã€‚ä½ å¯ä»¥é¸æ“‡æŒ‘æˆ°èè‹±æ€ªï¼Œæˆ–è€…æŒ‘æˆ°é­”ç‹ã€‚',
      choices: choices,
    };
    } else if (eventRoll < 0.28) {
    // 7%ï¼šåŒä¼´é€‰æ‹©äº‹ä»¶ - é€‰æ‹©ç‰¹å®šåŒä¼´æå‡èƒ½åŠ›å€¼ï¼ˆä¸é˜¶å±‚æ•°æˆæ­£æ¯”ï¼‰
    const companions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
    if (companions.length > 0) {
      const attrIncrease = Math.max(2, Math.floor(currentTier * 1.2)); // ä¸é˜¶å±‚æ•°æˆæ­£æ¯”ï¼Œæœ€å°‘2ç‚¹
      const randomAttr = ATTRIBUTES[Math.floor(Math.random() * ATTRIBUTES.length)];
      
      const companionChoices = companions.map((companion) => {
        return {
          hint: `é¸æ“‡${companion.name}`,
          label: `${companion.name}ï¼šå¢åŠ  ${attrIncrease} ${randomAttr.name}`,
          resultTitle: 'èƒ½åŠ›æå‡',
          resultMessage: `ä½ é¸æ“‡äº†${companion.name}ï¼Œ${randomAttr.name}å¢åŠ äº† ${attrIncrease} é»ï¼\n${companion.name}çš„${randomAttr.name}æ°¸ä¹…æå‡äº† ${attrIncrease} é»ã€‚`,
          effect: () => {
            if (!companion.attributes) {
              companion.attributes = { attack: 5, vitality: 5, defense: 5, recovery: 5, magic: 5, agility: 5 };
            }
            companion.attributes[randomAttr.id] = (companion.attributes[randomAttr.id] || 0) + attrIncrease;
            pushLog(`${option.label}ï¼šé¸æ“‡äº†${companion.name}ï¼Œ${randomAttr.name} å¢åŠ äº† ${attrIncrease}ã€‚`);
          },
        };
      });
      
      eventResult = {
        type: 'choice',
        title: 'åŒä¼´è¨“ç·´',
        message: `ä½ é‡åˆ°äº†ä¸€ä½è¨“ç·´å¸«ï¼Œä»–é¡˜æ„ç‚ºå…¶ä¸­ä¸€ä½åŒä¼´æå‡${randomAttr.name}ã€‚è¨“ç·´çš„æ•ˆæœèˆ‡ç•¶å‰éšå±¤æˆæ­£æ¯”ã€‚`,
        choices: companionChoices,
      };
    } else {
      // å¦‚æœæ²¡æœ‰åŒä¼´ï¼Œå›é€€åˆ°æ™®é€šäº‹ä»¶
      eventRoll = 0.5; // é‡æ–°åˆ†é…
    }
    } else if (eventRoll < 0.36) {
    // 10%ï¼šé‡‘é’± vs æ¢å¤é“å…·ï¼ˆå¢å¼ºé‡‘é’±å¥–åŠ±ï¼‰
    const goldAmount = 30 * currentTier + randomRange(0, 15 * currentTier); // å¢å¼ºé‡‘é’±å¥–åŠ±
    const itemTier = Math.min(currentTier, 6);
    const itemType = Math.random() < 0.5 ? 'heal' : 'mp';
    const itemId = itemType === 'heal' ? `herb_${itemTier}` : `ether_${itemTier}`;
    const item = ITEM_LOOKUP.get(itemId);
    
    eventResult = {
      type: 'choice',
      title: 'ç™¼ç¾å¯¶ç®±',
      message: 'ä½ ç™¼ç¾äº†ä¸€å€‹å¯¶ç®±ï¼Œè£¡é¢ä¼¼ä¹æœ‰å…©ç¨®ä¸åŒçš„æ±è¥¿ã€‚ä½ åªèƒ½é¸æ“‡å…¶ä¸­ä¸€å€‹ã€‚',
      choices: [
        {
          hint: 'é¸æ“‡å·¦é‚Šçš„è¢‹å­',
          label: `ç²å¾— ${goldAmount} é‡‘å¹£`,
          resultTitle: 'æ‰“é–‹è¢‹å­',
          resultMessage: `ä½ æ‰“é–‹äº†å·¦é‚Šçš„è¢‹å­ï¼Œç™¼ç¾è£¡é¢è£æ»¿äº†é‡‘å¹£ï¼\nç²å¾— ${goldAmount} é‡‘å¹£ã€‚`,
          effect: () => {
            hero.stats.gold += goldAmount;
            pushLog(`${option.label}ï¼šé¸æ“‡äº†å·¦é‚Šçš„è¢‹å­ï¼Œç²å¾— ${goldAmount} é‡‘å¹£ã€‚`);
          },
        },
        {
          hint: 'é¸æ“‡å³é‚Šçš„ç›’å­',
          label: `ç²å¾— ${item ? item.name : 'é“å…·'}`,
          resultTitle: 'æ‰“é–‹ç›’å­',
          resultMessage: `ä½ æ‰“é–‹äº†å³é‚Šçš„ç›’å­ï¼Œç™¼ç¾è£¡é¢æœ‰ä¸€å€‹é“å…·ï¼\nç²å¾— ${item ? item.name : 'é“å…·'}ã€‚`,
          effect: () => {
            if (item) {
              limitInventorySize();
              const currentItemCount = hero.items.filter(i => i.qty > 0).length;
              if (currentItemCount >= 8) {
                state.ui.itemChoice = {
                  newItem: { id: itemId, name: item.name, qty: 1 },
                  message: `ç²å¾—é“å…·ï¼š${item.name}ï¼Œä½†é“å…·æ¬„å·²æ»¿ï¼ˆ8/8ï¼‰ã€‚è«‹é¸æ“‡è¦ä¸Ÿæ£„çš„é“å…·ï¼š`,
                  items: hero.items.filter(entry => entry.qty > 0).slice(0, 8),
                };
                renderAll();
                return;
              }
              let itemEntry = hero.items.find(entry => entry.id === itemId);
              if (itemEntry) {
                itemEntry.qty += 1;
              } else {
                hero.items.push({ id: itemId, qty: 1 });
              }
              pushLog(`${option.label}ï¼šé¸æ“‡äº†å³é‚Šçš„ç›’å­ï¼Œç²å¾— ${item.name}ã€‚`);
            }
          },
        },
      ],
    };
    } else if (eventRoll < 0.48) {
    // 10%ï¼šå¢åŠ HPæœ€å¤§å€¼ vs å¢åŠ MPæœ€å¤§å€¼ï¼ˆå¢å¼ºæ•ˆæœï¼‰
    // ä¾ç…§éšæ®µæ•¸æ”¾å¤§æ•ˆæœï¼šåŸºç¤å€¼ Ã— ç•¶å‰éšæ®µ
    const hpIncreaseBase = 15; // å¢å¼ºåŸºç¡€å€¼
    const mpIncreaseBase = 8; // å¢å¼ºåŸºç¡€å€¼
    const hpIncrease = hpIncreaseBase * currentTier;
    const mpIncrease = mpIncreaseBase * currentTier;
    
    eventResult = {
      type: 'choice',
      title: 'ç¥ç§˜ç¥­å£‡',
      message: 'ä½ ç™¼ç¾äº†ä¸€å€‹ç¥ç§˜çš„ç¥­å£‡ï¼Œä¸Šé¢æœ‰å…©å€‹ä¸åŒçš„ç¬¦æ–‡ã€‚è§¸æ‘¸å…¶ä¸­ä¸€å€‹å¯èƒ½æœƒå¸¶ä¾†æ°¸ä¹…çš„åŠ›é‡ã€‚',
      choices: [
        {
          hint: 'è§¸æ‘¸ç´…è‰²çš„ç¬¦æ–‡',
          label: `å¢åŠ  ${hpIncrease} æœ€å¤§HP`,
          resultTitle: 'è§¸æ‘¸ç´…è‰²ç¬¦æ–‡',
          resultMessage: `ä½ è§¸æ‘¸äº†ç´…è‰²çš„ç¬¦æ–‡ï¼Œä¸€è‚¡æº«æš–çš„åŠ›é‡æ¹§å…¥ä½ çš„èº«é«”ï¼\nä½ çš„æœ€å¤§HPå¢åŠ äº† ${hpIncrease} é»ï¼Œä¸¦ä¸”å®Œå…¨æ¢å¾©äº†é«”åŠ›ã€‚`,
          effect: () => {
            hero.stats.maxHp += hpIncrease;
            hero.stats.hp += hpIncrease; // åŒæ™‚æ¢å¾©HP
            pushLog(`${option.label}ï¼šè§¸æ‘¸äº†ç´…è‰²ç¬¦æ–‡ï¼Œæœ€å¤§HPå¢åŠ äº† ${hpIncrease}ã€‚`);
          },
        },
        {
          hint: 'è§¸æ‘¸è—è‰²çš„ç¬¦æ–‡',
          label: `å¢åŠ  ${mpIncrease} æœ€å¤§MP`,
          resultTitle: 'è§¸æ‘¸è—è‰²ç¬¦æ–‡',
          resultMessage: `ä½ è§¸æ‘¸äº†è—è‰²çš„ç¬¦æ–‡ï¼Œä¸€è‚¡æ¸…æ¶¼çš„é­”åŠ›æµéå…¨èº«ï¼\nä½ çš„æœ€å¤§MPå¢åŠ äº† ${mpIncrease} é»ï¼Œä¸¦ä¸”å®Œå…¨æ¢å¾©äº†é­”åŠ›ã€‚`,
          effect: () => {
            hero.stats.maxMp += mpIncrease;
            hero.stats.mp += mpIncrease; // åŒæ™‚æ¢å¾©MP
            pushLog(`${option.label}ï¼šè§¸æ‘¸äº†è—è‰²ç¬¦æ–‡ï¼Œæœ€å¤§MPå¢åŠ äº† ${mpIncrease}ã€‚`);
          },
        },
      ],
    };
    } else if (eventRoll < 0.62) {
    // 13%ï¼šæ›´é«˜é˜¶è£…å¤‡ vs éšæœºèƒ½åŠ›æå‡ï¼ˆæœ‰é£é™©ï¼Œä½†é™·é˜±æœ‰è¡¥å¿ï¼‰
    const equipmentTier = Math.min(currentTier + 1, 6);
    const tierEquipment = EQUIPMENT.filter(eq => eq.tier === equipmentTier);
    const equipment = tierEquipment.length > 0 
      ? tierEquipment[Math.floor(Math.random() * tierEquipment.length)]
      : null;
    
    const attributes = ['attack', 'defense', 'magic', 'agility'];
    const randomAttr = attributes[Math.floor(Math.random() * attributes.length)];
    const attrIncrease = Math.max(2, Math.floor(currentTier * 1.2)); // å¢å¼ºèƒ½åŠ›æå‡ï¼Œä¸é˜¶å±‚æ•°æˆæ­£æ¯”
    const attrName = ATTRIBUTES.find(a => a.id === randomAttr)?.name || randomAttr;
    
    // è£…å¤‡é€‰é¡¹æœ‰30%æ¦‚ç‡æ˜¯é™·é˜±ï¼Œä½†é™·é˜±ä¼šæä¾›æ›´å¥½çš„è£…å¤‡ä½œä¸ºè¡¥å¿
    const isEquipmentTrap = Math.random() < 0.3;
    const hpLoss = Math.floor(hero.stats.hp / 3); // æ‰£1/3 HP
    const trapDamage = Math.max(1, hero.stats.hp - hpLoss); // è‡³å°‘å‰©1 HP
    
    // å¦‚æœè§¦å‘é™·é˜±ï¼Œæä¾›æ›´å¥½çš„è£…å¤‡ä½œä¸ºè¡¥å¿
    let compensationEquipment = null;
    if (isEquipmentTrap) {
      const compensationTier = Math.min(currentTier + 2, 6); // æ›´é«˜é˜¶çš„è£…å¤‡
      const compensationTierEquipment = EQUIPMENT.filter(eq => eq.tier === compensationTier);
      if (compensationTierEquipment.length > 0) {
        compensationEquipment = compensationTierEquipment[Math.floor(Math.random() * compensationTierEquipment.length)];
      }
    }
        
        eventResult = {
      type: 'choice',
      title: 'å¤è€éºè·¡',
      message: 'ä½ ç™¼ç¾äº†ä¸€å€‹å¤è€çš„éºè·¡ï¼Œè£¡é¢æœ‰ä¸€å€‹ç™¼å…‰çš„å¯¶ç®±å’Œä¸€å€‹ç¥ç§˜çš„ç¥­å£‡ã€‚',
      choices: [
        {
          hint: 'æ‰“é–‹ç™¼å…‰çš„å¯¶ç®±',
          label: equipment ? `ç²å¾— ${equipment.name}` : 'ç²å¾—è£å‚™ï¼ˆç„¡å¯ç”¨ï¼‰',
          resultTitle: isEquipmentTrap ? (compensationEquipment ? 'è§¸ç™¼é™·é˜±ï¼Œä½†ç™¼ç¾æ›´å¥½çš„è£å‚™ï¼' : 'è§¸ç™¼é™·é˜±ï¼') : 'æ‰“é–‹å¯¶ç®±',
          resultMessage: isEquipmentTrap 
            ? (compensationEquipment 
              ? `ä½ æ‰“é–‹äº†å¯¶ç®±ï¼Œè§¸ç™¼äº†é™·é˜±ï¼é›–ç„¶å—åˆ°äº†ä¸€äº›å‚·å®³ï¼Œä½†ç™¼ç¾äº†æ›´å¥½çš„è£å‚™ï¼\nHPæ¸›å°‘äº†ç´„1/3ï¼Œç²å¾— ${compensationEquipment.name}ã€‚`
              : `ä½ æ‰“é–‹äº†å¯¶ç®±ï¼Œä½†è£¡é¢æœ‰ä¸€å€‹é™·é˜±ï¼\nä½ å—åˆ°äº†å‚·å®³ï¼ŒHPæ¸›å°‘äº†ç´„1/3ã€‚`)
            : equipment 
              ? `ä½ æ‰“é–‹äº†å¯¶ç®±ï¼Œç™¼ç¾è£¡é¢æœ‰ä¸€ä»¶è£å‚™ï¼\nç²å¾— ${equipment.name}ã€‚`
              : 'ä½ æ‰“é–‹äº†å¯¶ç®±ï¼Œä½†è£¡é¢æ˜¯ç©ºçš„ã€‚',
          effect: () => {
            if (isEquipmentTrap) {
              hero.stats.hp = Math.max(1, hero.stats.hp - hpLoss);
              pushLog(`${option.label}ï¼šæ‰“é–‹å¯¶ç®±è§¸ç™¼äº†é™·é˜±ï¼ŒHPæ¸›å°‘äº†ç´„1/3ï¼ˆå‰©é¤˜ ${hero.stats.hp} HPï¼‰ã€‚`);
              if (hero.stats.hp <= 0) {
                pushLog('å‹‡è€…å€’ä¸‹ï¼Œæœ¬æ¬¡å†’éšªçµæŸã€‚');
                handleGameOver();
                return;
              }
              // é™·é˜±è¡¥å¿ï¼šæä¾›æ›´å¥½çš„è£…å¤‡
              if (compensationEquipment) {
                if (!hero.equipmentInventory) {
                  hero.equipmentInventory = [];
                }
                const itemId = `equipment_${compensationEquipment.id}`;
                const hasInBag = hero.items.some(entry => entry.id === itemId && entry.qty > 0);
                const isOwned = hero.equipmentInventory.includes(compensationEquipment.id) || hasInBag;
                
                if (!isOwned) {
                  limitInventorySize();
                  const currentItemCount = hero.items.filter(item => item.qty > 0).length;
                  if (currentItemCount >= 8) {
                    state.ui.itemChoice = {
                      newEquipment: compensationEquipment,
                      message: `è§¸ç™¼é™·é˜±å¾Œç™¼ç¾äº†æ›´å¥½çš„è£å‚™ï¼š${compensationEquipment.name}ï¼Œä½†é“å…·æ¬„å·²æ»¿ï¼ˆ8/8ï¼‰ã€‚è«‹é¸æ“‡è¦ä¸Ÿæ£„çš„é“å…·ï¼š`,
                      items: hero.items.filter(entry => entry.qty > 0).slice(0, 8),
                    };
                    renderAll();
                    return;
                  }
                  let itemEntry = hero.items.find(entry => entry.id === itemId);
                  if (itemEntry) {
                    itemEntry.qty += 1;
                  } else {
                    hero.items.push({ id: itemId, qty: 1 });
                  }
                  pushLog(`é›–ç„¶è§¸ç™¼äº†é™·é˜±ï¼Œä½†ç™¼ç¾äº†æ›´å¥½çš„è£å‚™ï¼š${compensationEquipment.name}ï¼ˆå·²æ”¾å…¥é“å…·è¢‹ï¼‰ï¼`);
                } else {
                  pushLog(`é›–ç„¶è§¸ç™¼äº†é™·é˜±ï¼Œä½†ç™¼ç¾äº†æ›´å¥½çš„è£å‚™ï¼š${compensationEquipment.name}ï¼ˆå·²æ“æœ‰ï¼‰ã€‚`);
                }
              }
            } else if (equipment) {
            if (!hero.equipmentInventory) {
              hero.equipmentInventory = [];
            }
            const itemId = `equipment_${equipment.id}`;
            const hasInBag = hero.items.some(entry => entry.id === itemId && entry.qty > 0);
            const isOwned = hero.equipmentInventory.includes(equipment.id) || hasInBag;
            
            if (!isOwned) {
              limitInventorySize();
              const currentItemCount = hero.items.filter(item => item.qty > 0).length;
              if (currentItemCount >= 8) {
                state.ui.itemChoice = {
                  newEquipment: equipment,
                  message: `ç²å¾—è£å‚™ï¼š${equipment.name}ï¼Œä½†é“å…·æ¬„å·²æ»¿ï¼ˆ8/8ï¼‰ã€‚è«‹é¸æ“‡è¦ä¸Ÿæ£„çš„é“å…·ï¼š`,
                  items: hero.items.filter(entry => entry.qty > 0).slice(0, 8),
                };
                renderAll();
                return;
              }
              let itemEntry = hero.items.find(entry => entry.id === itemId);
              if (itemEntry) {
                itemEntry.qty += 1;
              } else {
                hero.items.push({ id: itemId, qty: 1 });
              }
                pushLog(`${option.label}ï¼šæ‰“é–‹å¯¶ç®±ç²å¾— ${equipment.name}ï¼ˆå·²æ”¾å…¥é“å…·è¢‹ï¼‰ã€‚`);
            } else {
                pushLog(`${option.label}ï¼šæ‰“é–‹å¯¶ç®±ï¼Œä½†å·²æ“æœ‰ ${equipment.name}ã€‚`);
              }
            }
          },
        },
        {
          hint: 'è§¸æ‘¸ç¥ç§˜çš„ç¥­å£‡',
          label: `å¢åŠ  ${attrIncrease} ${attrName}`,
          resultTitle: 'è§¸æ‘¸ç¥­å£‡',
          resultMessage: `ä½ è§¸æ‘¸äº†ç¥­å£‡ï¼Œæ„Ÿå—åˆ°ä¸€è‚¡ç¥ç§˜çš„åŠ›é‡æ¹§å…¥é«”å…§ï¼\nä½ çš„${attrName}å¢åŠ äº† ${attrIncrease} é»ã€‚`,
          effect: () => {
            if (!hero.attributes) {
              hero.attributes = { attack: 0, defense: 0, magic: 0, agility: 0 };
            }
            hero.attributes[randomAttr] = (hero.attributes[randomAttr] || 0) + attrIncrease;
            pushLog(`${option.label}ï¼šè§¸æ‘¸äº†ç¥­å£‡ï¼Œ${attrName} å¢åŠ äº† ${attrIncrease}ã€‚`);
          },
        },
      ],
    };
    } else if (eventRoll < 0.76) {
    // 12%ï¼šæ¢å¤HP vs æ¢å¤MPï¼ˆåˆ†åˆ«è¡¥æ»¡ï¼‰
        eventResult = {
      type: 'choice',
      title: 'æ²»ç™‚å¸«çš„å°å±‹',
      message: 'ä½ é‡åˆ°äº†ä¸€ä½æ²»ç™‚å¸«ï¼Œä»–æä¾›äº†å…©ç¨®ä¸åŒçš„è—¥åŠ‘ã€‚',
      choices: [
        {
          hint: 'é¸æ“‡ç´…è‰²çš„è—¥åŠ‘',
          label: 'æ¢å¾©HP',
          resultTitle: 'é£²ç”¨ç´…è‰²è—¥åŠ‘',
          resultMessage: `ä½ é£²ç”¨äº†ç´…è‰²çš„è—¥åŠ‘ï¼Œæ„Ÿåˆ°é«”åŠ›å®Œå…¨æ¢å¾©ï¼\nHPå®Œå…¨æ¢å¾©äº†ã€‚`,
          effect: () => {
            hero.stats.hp = hero.stats.maxHp;
            pushLog(`${option.label}ï¼šé£²ç”¨äº†ç´…è‰²è—¥åŠ‘ï¼ŒHPå®Œå…¨æ¢å¾©ã€‚`);
          },
        },
        {
          hint: 'é¸æ“‡è—è‰²çš„è—¥åŠ‘',
          label: 'æ¢å¾©MP',
          resultTitle: 'é£²ç”¨è—è‰²è—¥åŠ‘',
          resultMessage: `ä½ é£²ç”¨äº†è—è‰²çš„è—¥åŠ‘ï¼Œæ„Ÿåˆ°é­”åŠ›å®Œå…¨æ¢å¾©ï¼\nMPå®Œå…¨æ¢å¾©äº†ã€‚`,
          effect: () => {
            hero.stats.mp = hero.stats.maxMp;
            pushLog(`${option.label}ï¼šé£²ç”¨äº†è—è‰²è—¥åŠ‘ï¼ŒMPå®Œå…¨æ¢å¾©ã€‚`);
          },
        },
      ],
    };
    } else if (eventRoll < 0.90) {
    // 15%ï¼šå†’é™©è¿›å…¥æ¢ç´¢ - åªä¼šé‡åˆ°ç²¾è‹±æ€ªï¼Œæˆ˜æ–—èƒœåˆ©åè·å¾—è£…å¤‡
    // åˆ›å»ºç²¾è‰¯è£…å¤‡çš„å‡½æ•°ï¼ˆä»å•†åº—ä»£ç å¤åˆ¶ï¼‰
    function createSuperiorEquipment(baseEq) {
      const superior = { ...baseEq };
      superior.id = `${baseEq.id}_superior`;
      superior.name = `ç²¾è‰¯ ${baseEq.name}`;
      superior.isSuperior = true;
      superior.baseEquipmentId = baseEq.id;
      
      if (superior.attack !== undefined) {
        superior.attack = Math.round(superior.attack * 1.5);
      }
      if (superior.defense !== undefined) {
        superior.defense = Math.round(superior.defense * 1.5);
      }
      if (superior.attributes) {
        const multipliedAttributes = {};
        Object.keys(superior.attributes).forEach(attr => {
          multipliedAttributes[attr] = Math.round(superior.attributes[attr] * 1.5);
        });
        superior.attributes = multipliedAttributes;
      }
      if (superior.hpBonus !== undefined) {
        superior.hpBonus = Math.round(superior.hpBonus * 1.5);
      }
      if (superior.mpBonus !== undefined) {
        superior.mpBonus = Math.round(superior.mpBonus * 1.5);
      }
      superior.price = (baseEq.price || (baseEq.tier * 50)) * 2;
      return superior;
    }
    
    // ç²¾è‹±æ€ªï¼šè·å¾—ä¸€èˆ¬è£…å¤‡
    const equipmentTier = Math.min(currentTier, 6);
    const tierEquipment = EQUIPMENT.filter(eq => eq.tier === equipmentTier);
    let rewardEquipment = null;
    let rewardEquipmentName = '';
    if (tierEquipment.length > 0) {
      rewardEquipment = tierEquipment[Math.floor(Math.random() * tierEquipment.length)];
      rewardEquipmentName = rewardEquipment.name;
    }
    
      eventResult = {
      type: 'choice',
      title: 'å±éšªçš„é¸æ“‡',
      message: 'ä½ ç™¼ç¾äº†ä¸€å€‹çœ‹èµ·ä¾†å¾ˆå±éšªçš„åœ°æ–¹ï¼Œè£¡é¢ä¼¼ä¹æœ‰å¯¶ç‰©ï¼Œä½†ä¹Ÿå¯èƒ½éš±è—è‘—å¼·å¤§çš„æ•µäººã€‚',
      choices: [
        {
          hint: 'å†’éšªé€²å…¥æ¢ç´¢',
          label: `æŒ‘æˆ°èè‹±æ€ªï¼ˆç²å¾—ä¸€èˆ¬è£å‚™ï¼š${rewardEquipmentName || 'è£å‚™'}ï¼‰`,
          resultTitle: 'é­é‡èè‹±æ€ªï¼',
          resultMessage: `ä½ å†’éšªé€²å…¥äº†å±éšªçš„åœ°æ–¹ï¼Œé­é‡äº†èè‹±æ€ªï¼\næˆ°é¬¥å‹åˆ©å¾Œå°‡ç²å¾—ä¸€èˆ¬è£å‚™ï¼š${rewardEquipmentName || 'è£å‚™'}ã€‚`,
        effect: () => {
            // ä¿å­˜å¥–åŠ±è£…å¤‡åˆ°æˆ˜æ–—é€‰é¡¹
            const battleOption = {
              type: 'elite',
              label: option.label || 'é­é‡èè‹±æ€ª',
              nodeIndex: state.world.currentNodeIndex,
              eventRewardEquipment: rewardEquipment, // ä¿å­˜å¥–åŠ±è£…å¤‡
              eventRewardIsSuperior: false, // ç²¾è‹±æ€ªåªç»™ä¸€èˆ¬è£…å¤‡
            };
            
            // å¯åŠ¨ç²¾è‹±æˆ˜æ–—
            startBattle(battleOption, 1.6);
            pushLog(`${option.label}ï¼šé¸æ“‡äº†å†’éšªé€²å…¥æ¢ç´¢ï¼Œé­é‡äº†èè‹±æ€ªï¼`);
          },
        },
        {
          hint: 'è¬¹æ…åœ°é›¢é–‹',
          label: 'å®‰å…¨é›¢é–‹ï¼ˆç„¡æ•ˆæœï¼‰',
          resultTitle: 'å®‰å…¨é›¢é–‹',
          resultMessage: 'ä½ é¸æ“‡äº†è¬¹æ…åœ°é›¢é–‹ï¼Œé›–ç„¶æ²’æœ‰ç²å¾—ä»»ä½•æ±è¥¿ï¼Œä½†ä¹Ÿæ²’æœ‰é‡åˆ°å±éšªã€‚',
          effect: () => {
            pushLog(`${option.label}ï¼šé¸æ“‡äº†å®‰å…¨é›¢é–‹ã€‚`);
          },
        },
      ],
    };
    } else if (eventRoll < 0.95) {
    // 15%ï¼šé‡‘é’± vs éšæœºèƒ½åŠ›æå‡ï¼ˆå¢å¼ºé‡‘é’±å’Œèƒ½åŠ›æå‡ï¼‰
    const goldAmount = 25 * currentTier + randomRange(0, 15 * currentTier); // å¢å¼ºé‡‘é’±å¥–åŠ±
    const attributes = ['attack', 'defense', 'magic', 'agility'];
    const randomAttr = attributes[Math.floor(Math.random() * attributes.length)];
    const attrIncrease = Math.max(2, Math.floor(currentTier * 1.2)); // å¢å¼ºèƒ½åŠ›æå‡ï¼Œä¸é˜¶å±‚æ•°æˆæ­£æ¯”
    const attrName = ATTRIBUTES.find(a => a.id === randomAttr)?.name || randomAttr;
    
    // èƒ½åŠ›æå‡æœ‰25%æ¦‚ç‡æ˜¯è´Ÿé¢æ•ˆæœï¼ˆå¤±å»å…¶ä»–å±æ€§ï¼‰
    const isNegative = Math.random() < 0.25;
    const negativeAttr = attributes.filter(a => a !== randomAttr)[Math.floor(Math.random() * (attributes.length - 1))];
    const negativeAttrName = ATTRIBUTES.find(a => a.id === negativeAttr)?.name || negativeAttr;
    const negativeAmount = Math.floor(attrIncrease / 2);
    
      eventResult = {
      type: 'choice',
      title: 'ç¥ç§˜å•†äºº',
      message: 'ä½ é‡åˆ°äº†ä¸€ä½ç¥ç§˜çš„å•†äººï¼Œä»–æä¾›å…©ç¨®ä¸åŒçš„äº¤æ˜“ã€‚',
      choices: [
        {
          hint: 'æ¥å—é‡‘å¹£äº¤æ˜“',
          label: `ç²å¾— ${goldAmount} é‡‘å¹£`,
          resultTitle: 'å®Œæˆäº¤æ˜“',
          resultMessage: `ä½ å®Œæˆäº†äº¤æ˜“ï¼Œå•†äººçµ¦äº†ä½ ä¸€è¢‹é‡‘å¹£ã€‚\nç²å¾— ${goldAmount} é‡‘å¹£ã€‚`,
        effect: () => {
            hero.stats.gold += goldAmount;
            pushLog(`${option.label}ï¼šæ¥å—äº†é‡‘å¹£äº¤æ˜“ï¼Œç²å¾— ${goldAmount} é‡‘å¹£ã€‚`);
          },
        },
        {
          hint: 'æ¥å—ç¥ç§˜è—¥åŠ‘',
          label: `å¢åŠ  ${attrIncrease} ${attrName}`,
          resultTitle: isNegative ? 'è—¥åŠ‘çš„å‰¯ä½œç”¨ï¼' : 'é£²ç”¨è—¥åŠ‘',
          resultMessage: isNegative
            ? `ä½ é£²ç”¨äº†ç¥ç§˜è—¥åŠ‘ï¼Œé›–ç„¶${attrName}å¢åŠ äº† ${attrIncrease} é»ï¼Œä½†ç”¢ç”Ÿäº†å‰¯ä½œç”¨ï¼\n${attrName} +${attrIncrease}ï¼Œ${negativeAttrName} -${negativeAmount}ã€‚`
            : `ä½ é£²ç”¨äº†ç¥ç§˜è—¥åŠ‘ï¼Œæ„Ÿå—åˆ°åŠ›é‡æ¹§å…¥é«”å…§ï¼\n${attrName} å¢åŠ äº† ${attrIncrease} é»ã€‚`,
          effect: () => {
            if (!hero.attributes) {
              hero.attributes = { attack: 0, defense: 0, magic: 0, agility: 0 };
            }
            hero.attributes[randomAttr] = (hero.attributes[randomAttr] || 0) + attrIncrease;
            if (isNegative) {
              hero.attributes[negativeAttr] = Math.max(0, (hero.attributes[negativeAttr] || 0) - negativeAmount);
              pushLog(`${option.label}ï¼šé£²ç”¨äº†è—¥åŠ‘ï¼Œ${attrName} +${attrIncrease}ï¼Œ${negativeAttrName} -${negativeAmount}ã€‚`);
          } else {
              pushLog(`${option.label}ï¼šé£²ç”¨äº†è—¥åŠ‘ï¼Œ${attrName} å¢åŠ äº† ${attrIncrease}ã€‚`);
            }
          },
        },
      ],
    };
    } else if (eventRoll < 0.98) {
    // 5%ï¼šé€‰æ‹©èƒ½åŠ›æå‡äº‹ä»¶ï¼ˆå¢å¼ºæ•ˆæœï¼‰
    const attrIncrease = Math.max(2, Math.floor(currentTier * 1.2)); // å¢å¼ºèƒ½åŠ›æå‡ï¼Œä¸é˜¶å±‚æ•°æˆæ­£æ¯”
    
    // åˆ›å»ºæ‰€æœ‰èƒ½åŠ›çš„é€‰é¡¹
    const attributeChoices = ATTRIBUTES.map((attr) => {
      return {
        hint: `æå‡${attr.name}`,
        label: `å¢åŠ  ${attrIncrease} ${attr.name}`,
        resultTitle: 'èƒ½åŠ›æå‡',
        resultMessage: `ä½ é¸æ“‡äº†æå‡${attr.name}ï¼Œæ„Ÿå—åˆ°åŠ›é‡æ¹§å…¥é«”å…§ï¼\n${attr.name}å¢åŠ äº† ${attrIncrease} é»ã€‚`,
        effect: () => {
          if (!hero.attributes) {
            hero.attributes = { attack: 0, vitality: 0, defense: 0, recovery: 0, magic: 0, agility: 0 };
          }
          hero.attributes[attr.id] = (hero.attributes[attr.id] || 0) + attrIncrease;
          pushLog(`${option.label}ï¼šé¸æ“‡äº†æå‡${attr.name}ï¼Œ${attr.name} å¢åŠ äº† ${attrIncrease}ã€‚`);
        },
      };
    });
    
      eventResult = {
      type: 'choice',
      title: 'ç¥ç§˜çš„åŠ›é‡',
      message: 'ä½ ç™¼ç¾äº†ä¸€å€‹æ•£ç™¼è‘—ç¥ç§˜å…‰èŠ’çš„ç¥­å£‡ï¼Œå¯ä»¥é¸æ“‡æå‡å…¶ä¸­ä¸€ç¨®èƒ½åŠ›ã€‚',
      choices: attributeChoices,
    };
  } else if (eventRoll < 0.92) {
    // 7%ï¼šç›´æ¥å‡çº§äº‹ä»¶ï¼ˆå¢å¼ºç»éªŒå€¼å¥–åŠ±ï¼‰
    // è®¡ç®—ç»™äºˆçš„ç»éªŒå€¼ï¼ˆè¶³å¤Ÿå‡1çº§ï¼Œæ ¹æ®å½“å‰ç­‰çº§è°ƒæ•´ï¼‰
    const currentLevel = hero.stats.level;
    const baseXpNeeded = hero.stats.nextLevelXp;
    // ç»™äºˆè¶³å¤Ÿçš„ç»éªŒå€¼æ¥å‡çº§ï¼Œå¹¶é¢å¤–ç»™ä¸€äº›ç»éªŒå€¼ï¼ˆå¯èƒ½è¿å‡å¤šçº§ï¼‰ï¼Œä¸é˜¶å±‚æ•°æˆæ­£æ¯”
    const xpBonus = baseXpNeeded + Math.floor(baseXpNeeded * (0.5 + currentTier * 0.15)); // å¢å¼ºç»éªŒå€¼å¥–åŠ±
    
    eventResult = {
      type: 'choice',
      title: 'ç¶“é©—ä¹‹æ³‰',
      message: 'ä½ ç™¼ç¾äº†ä¸€å£æ•£ç™¼è‘—ç¶“é©—å…‰èŠ’çš„æ³‰æ°´ï¼Œé£²ç”¨å¾Œå¯ä»¥ç²å¾—å¤§é‡ç¶“é©—å€¼ã€‚',
      choices: [
        {
          hint: 'é£²ç”¨ç¶“é©—ä¹‹æ³‰',
          label: 'ç²å¾—ç¶“é©—å€¼ä¸¦å‡ç´š',
          resultTitle: 'é£²ç”¨ç¶“é©—ä¹‹æ³‰',
          resultMessage: `ä½ é£²ç”¨äº†ç¶“é©—ä¹‹æ³‰ï¼Œæ„Ÿå—åˆ°å¤§é‡ç¶“é©—æ¹§å…¥é«”å…§ï¼\nç²å¾—äº† ${xpBonus} ç¶“é©—å€¼ã€‚`,
        effect: () => {
            const oldLevel = hero.stats.level;
            hero.stats.xp += xpBonus;
            // è§¸ç™¼å‡ç´šæª¢æŸ¥
            checkLevelUp();
            const newLevel = hero.stats.level;
            const levelsGained = newLevel - oldLevel;
            if (levelsGained > 0) {
              pushLog(`${option.label}ï¼šé£²ç”¨äº†ç¶“é©—ä¹‹æ³‰ï¼Œç²å¾—äº† ${xpBonus} ç¶“é©—å€¼ï¼Œå‡åˆ°äº† Lv ${newLevel}ï¼`);
          } else {
              pushLog(`${option.label}ï¼šé£²ç”¨äº†ç¶“é©—ä¹‹æ³‰ï¼Œç²å¾—äº† ${xpBonus} ç¶“é©—å€¼ã€‚`);
            }
          },
        },
        {
          hint: 'é›¢é–‹ï¼ˆç„¡æ•ˆæœï¼‰',
          label: 'é›¢é–‹',
          resultTitle: 'é›¢é–‹',
          resultMessage: 'ä½ é¸æ“‡äº†é›¢é–‹ï¼Œæ²’æœ‰ç²å¾—ä»»ä½•æ±è¥¿ã€‚',
          effect: () => {
            pushLog(`${option.label}ï¼šé¸æ“‡äº†é›¢é–‹ã€‚`);
          },
        },
      ],
    };
  } else if (eventRoll < 0.96) {
    // 4%ï¼šå¤§é‡é‡‘é’±äº‹ä»¶ï¼ˆä¸é˜¶å±‚æ•°æˆæ­£æ¯”ï¼‰- åœ¨æ”¶é›†é‡‘å¸å‰å…ˆè¿›è¡Œç²¾è‹±æ€ªæˆ˜æ–—
    const goldAmount = 50 * currentTier + randomRange(0, 30 * currentTier); // å¤§é‡é‡‘é’±å¥–åŠ±
    
    eventResult = {
      type: 'choice',
      title: 'è²¡å¯¶åº«',
      message: 'ä½ ç™¼ç¾äº†ä¸€å€‹éš±è—çš„è²¡å¯¶åº«ï¼Œè£¡é¢è£æ»¿äº†é‡‘å¹£ï¼ä½†å®ˆè­·è²¡å¯¶çš„èè‹±æ€ªå‡ºç¾äº†ï¼',
      choices: [
        {
          hint: 'æŒ‘æˆ°èè‹±æ€ªä¸¦æ”¶é›†é‡‘å¹£',
          label: `æŒ‘æˆ°èè‹±æ€ªï¼ˆå‹åˆ©å¾Œç²å¾— ${goldAmount} é‡‘å¹£ï¼‰`,
          resultTitle: 'é­é‡èè‹±æ€ª',
          resultMessage: `ä½ é¸æ“‡äº†æŒ‘æˆ°èè‹±æ€ªï¼æˆ°é¬¥å‹åˆ©å¾Œå°‡ç²å¾— ${goldAmount} é‡‘å¹£ã€‚`,
          effect: () => {
            // å‰µå»ºç²¾è‹±æˆ°é¬¥é¸é …ï¼Œä¸¦ä¿å­˜é‡‘å¹£çå‹µ
            const eliteOption = {
              type: 'elite',
              label: option.label || 'è²¡å¯¶åº«å®ˆè­·è€…',
              nodeIndex: state.world.currentNodeIndex,
              eventRewardGold: goldAmount, // ä¿å­˜é‡‘å¹£çå‹µ
            };
            // å•Ÿå‹•ç²¾è‹±æˆ°é¬¥ï¼ˆmultiplier = 1.6ï¼‰
            startBattle(eliteOption, 1.6);
            pushLog(`${option.label}ï¼šé¸æ“‡äº†æŒ‘æˆ°èè‹±æ€ªï¼Œæº–å‚™æˆ°é¬¥ï¼`);
          },
        },
        {
          hint: 'é›¢é–‹ï¼ˆç„¡æ•ˆæœï¼‰',
          label: 'é›¢é–‹',
          resultTitle: 'é›¢é–‹',
          resultMessage: 'ä½ é¸æ“‡äº†é›¢é–‹ï¼Œæ²’æœ‰ç²å¾—ä»»ä½•æ±è¥¿ã€‚',
          effect: () => {
            pushLog(`${option.label}ï¼šé¸æ“‡äº†é›¢é–‹ã€‚`);
          },
        },
      ],
    };
  } else {
    // 4%ï¼šå­¦ä¹ è¢«åŠ¨æŠ€èƒ½äº‹ä»¶
    const flows = ['sword', 'magic', 'recovery', 'defender', 'agility'];
    const availablePassives = [];
    
    // æ”¶é›†æ‰€æœ‰å¯ç”¨çš„è¢«åŠ¨æŠ€èƒ½
    flows.forEach(flow => {
      const passives = getTier1PassiveSkillsByFlow(flow);
      passives.forEach(skill => {
        // åªæ·»åŠ å‹‡è€…è¿˜æ²¡æœ‰å­¦ä¹ çš„è¢«åŠ¨æŠ€èƒ½
        if (!hero.skills.includes(skill.id)) {
          availablePassives.push(skill);
        }
      });
    });
    
    if (availablePassives.length > 0) {
      // éšæœºé€‰æ‹©3ä¸ªè¢«åŠ¨æŠ€èƒ½ä¾›é€‰æ‹©
      const selectedPassives = [];
      const shuffled = [...availablePassives].sort(() => Math.random() - 0.5);
      for (let i = 0; i < Math.min(3, shuffled.length); i++) {
        selectedPassives.push(shuffled[i]);
      }
      
      const skillChoices = selectedPassives.map((skill) => {
        const skillName = skill.name || skill.id;
        const skillDesc = skill.description || 'è¢«å‹•æŠ€èƒ½';
        return {
          hint: `å­¸ç¿’${skillName}`,
          label: `${skillName}ï¼š${skillDesc}`,
          resultTitle: 'å­¸æœƒæ–°æŠ€èƒ½',
          resultMessage: `ä½ å­¸æœƒäº†è¢«å‹•æŠ€èƒ½ã€Œ${skillName}ã€ï¼\n${skillDesc}`,
          effect: () => {
            learnSkill(skill);
            pushLog(`${option.label}ï¼šå­¸æœƒäº†è¢«å‹•æŠ€èƒ½ã€Œ${skillName}ã€ã€‚`);
          },
        };
      });
      
      eventResult = {
        type: 'choice',
        title: 'æŠ€èƒ½æ›¸',
        message: 'ä½ ç™¼ç¾äº†ä¸€æœ¬å¤è€çš„æŠ€èƒ½æ›¸ï¼Œå¯ä»¥å­¸ç¿’å…¶ä¸­ä¸€å€‹è¢«å‹•æŠ€èƒ½ã€‚',
        choices: skillChoices,
      };
    } else {
      // å¦‚æœæ²¡æœ‰å¯å­¦ä¹ çš„è¢«åŠ¨æŠ€èƒ½ï¼Œæ”¹ä¸ºç»™äºˆç»éªŒå€¼
      const xpBonus = Math.floor(hero.stats.nextLevelXp * (0.3 + currentTier * 0.1));
      eventResult = {
        type: 'good',
        title: 'æŠ€èƒ½æ›¸',
        message: `ä½ ç™¼ç¾äº†ä¸€æœ¬æŠ€èƒ½æ›¸ï¼Œä½†è£¡é¢è¨˜è¼‰çš„æŠ€èƒ½ä½ å·²ç¶“å…¨éƒ¨å­¸æœƒäº†ã€‚\nä½œç‚ºè£œå„Ÿï¼Œä½ ç²å¾—äº† ${xpBonus} ç¶“é©—å€¼ã€‚`,
        effect: () => {
          hero.stats.xp += xpBonus;
          checkLevelUp();
          pushLog(`${option.label}ï¼šæŠ€èƒ½æ›¸å·²å…¨éƒ¨å­¸æœƒï¼Œç²å¾— ${xpBonus} ç¶“é©—å€¼ä½œç‚ºè£œå„Ÿã€‚`);
        },
      };
    }
  }
  } else if (eventType === 'bad') {
    // åäº‹äº‹ä»¶ï¼ˆ30%æ¦‚ç‡ï¼‰
    // éšæœºé€‰æ‹©åäº‹ç±»å‹
    if (eventRoll < 0.15) {
      // 15%ï¼šé™·é˜±ï¼ˆæ‰£HPï¼‰
      const hpLoss = Math.floor(hero.stats.maxHp * 0.25); // æ‰£25%æœ€å¤§HP
      eventResult = {
        type: 'trap',
        title: 'é­é‡é™·é˜±ï¼',
        message: `ä½ ä¸å°å¿ƒè§¸ç™¼äº†é™·é˜±ï¼\nHPæ¸›å°‘äº† ${hpLoss} é»ï¼ˆç´„25%æœ€å¤§HPï¼‰ã€‚`,
        effect: () => {
          hero.stats.hp = Math.max(1, hero.stats.hp - hpLoss);
          pushLog(`${option.label}ï¼šé­é‡é™·é˜±ï¼ŒHPæ¸›å°‘äº† ${hpLoss} é»ï¼ˆå‰©é¤˜ ${hero.stats.hp} HPï¼‰ã€‚`);
          if (hero.stats.hp <= 0) {
            pushLog('å‹‡è€…å€’ä¸‹ï¼Œæœ¬æ¬¡å†’éšªçµæŸã€‚');
            handleGameOver();
            return;
          }
        },
      };
    } else if (eventRoll < 0.30) {
      // 15%ï¼šå¤±å»é‡‘é’±
      const goldLoss = Math.floor((hero.stats.gold || 0) * 0.3); // å¤±å»30%é‡‘é’±
      eventResult = {
        type: 'bad',
        title: 'é­é‡å°å·ï¼',
        message: `ä½ é‡åˆ°äº†å°å·ï¼Œè¢«å·èµ°äº†ä¸€äº›é‡‘å¹£ï¼\nå¤±å»äº† ${goldLoss} é‡‘å¹£ã€‚`,
        effect: () => {
          if (hero.stats.gold == null) hero.stats.gold = 0;
          hero.stats.gold = Math.max(0, hero.stats.gold - goldLoss);
          pushLog(`${option.label}ï¼šé­é‡å°å·ï¼Œå¤±å»äº† ${goldLoss} é‡‘å¹£ï¼ˆå‰©é¤˜ ${hero.stats.gold} é‡‘å¹£ï¼‰ã€‚`);
        },
      };
    } else if (eventRoll < 0.45) {
      // 15%ï¼šå¤±å»èƒ½åŠ›å€¼
      const attributes = ['attack', 'defense', 'magic', 'agility'];
      const randomAttr = attributes[Math.floor(Math.random() * attributes.length)];
      const attrLoss = Math.max(1, Math.floor(currentTier * 0.8)); // ä¸é˜¶å±‚æ•°æˆæ­£æ¯”
      const attrName = ATTRIBUTES.find(a => a.id === randomAttr)?.name || randomAttr;
      eventResult = {
        type: 'bad',
        title: 'å—åˆ°è©›å’’ï¼',
        message: `ä½ å—åˆ°äº†è©›å’’ï¼Œèƒ½åŠ›å€¼é™ä½äº†ï¼\n${attrName}æ¸›å°‘äº† ${attrLoss} é»ã€‚`,
        effect: () => {
          if (!hero.attributes) {
            hero.attributes = { attack: 0, vitality: 0, defense: 0, recovery: 0, magic: 0, agility: 0 };
          }
          hero.attributes[randomAttr] = Math.max(0, (hero.attributes[randomAttr] || 0) - attrLoss);
          pushLog(`${option.label}ï¼šå—åˆ°è©›å’’ï¼Œ${attrName} æ¸›å°‘äº† ${attrLoss} é»ã€‚`);
        },
      };
    } else if (eventRoll < 0.60) {
      // 15%ï¼šå¤±å»MP
      const mpLoss = Math.floor(hero.stats.maxMp * 0.4); // å¤±å»40%æœ€å¤§MP
      eventResult = {
        type: 'bad',
        title: 'é­”åŠ›æµå¤±ï¼',
        message: `ä½ æ„Ÿè¦ºåˆ°é­”åŠ›åœ¨æµå¤±ï¼\nMPæ¸›å°‘äº† ${mpLoss} é»ï¼ˆç´„40%æœ€å¤§MPï¼‰ã€‚`,
        effect: () => {
          hero.stats.mp = Math.max(0, hero.stats.mp - mpLoss);
          pushLog(`${option.label}ï¼šé­”åŠ›æµå¤±ï¼ŒMPæ¸›å°‘äº† ${mpLoss} é»ï¼ˆå‰©é¤˜ ${hero.stats.mp} MPï¼‰ã€‚`);
        },
      };
    } else if (eventRoll < 0.75) {
      // 15%ï¼šä¸¢å¤±é“å…·
      const itemsWithQty = hero.items.filter(item => item.qty > 0);
      if (itemsWithQty.length > 0) {
        const randomItem = itemsWithQty[Math.floor(Math.random() * itemsWithQty.length)];
        const item = ITEM_LOOKUP.get(randomItem.id);
        const lostQty = Math.min(randomItem.qty, Math.max(1, Math.floor(randomItem.qty / 2))); // ä¸¢å¤±ä¸€åŠæˆ–è‡³å°‘1ä¸ª
        eventResult = {
          type: 'bad',
          title: 'é“å…·éºå¤±ï¼',
          message: `ä½ ä¸å°å¿ƒéºå¤±äº†ä¸€äº›é“å…·ï¼\nå¤±å»äº† ${lostQty} å€‹ ${item ? item.name : 'é“å…·'}ã€‚`,
          effect: () => {
            randomItem.qty = Math.max(0, randomItem.qty - lostQty);
            if (randomItem.qty <= 0) {
              const index = hero.items.indexOf(randomItem);
              if (index > -1) {
                hero.items.splice(index, 1);
              }
            }
            pushLog(`${option.label}ï¼šéºå¤±äº† ${lostQty} å€‹ ${item ? item.name : 'é“å…·'}ã€‚`);
          },
        };
      } else {
        // å¦‚æœæ²¡æœ‰é“å…·ï¼Œæ”¹ä¸ºå¤±å»HP
        const hpLoss = Math.floor(hero.stats.maxHp * 0.2);
        eventResult = {
          type: 'bad',
          title: 'é­é‡è¥²æ“Šï¼',
          message: `ä½ é­é‡äº†è¥²æ“Šï¼\nHPæ¸›å°‘äº† ${hpLoss} é»ã€‚`,
          effect: () => {
            hero.stats.hp = Math.max(1, hero.stats.hp - hpLoss);
            pushLog(`${option.label}ï¼šé­é‡è¥²æ“Šï¼ŒHPæ¸›å°‘äº† ${hpLoss} é»ï¼ˆå‰©é¤˜ ${hero.stats.hp} HPï¼‰ã€‚`);
            if (hero.stats.hp <= 0) {
              pushLog('å‹‡è€…å€’ä¸‹ï¼Œæœ¬æ¬¡å†’éšªçµæŸã€‚');
              handleGameOver();
              return;
            }
          },
        };
      }
    } else if (eventRoll < 0.85) {
      // 10%ï¼šå¼ºåˆ¶æˆ˜æ–—ï¼ˆç²¾è‹±æ€ªï¼‰
      eventResult = {
        type: 'bad',
        title: 'é­é‡å¼·æ•µï¼',
        message: 'ä½ é­é‡äº†å¼·å¤§çš„æ•µäººï¼Œç„¡æ³•é€ƒé¿ï¼å¿…é ˆæˆ°é¬¥ï¼',
        effect: () => {
          const eliteOption = {
            type: 'elite',
            label: option.label || 'é­é‡å¼·æ•µ',
            nodeIndex: state.world.currentNodeIndex,
          };
          startBattle(eliteOption, 1.6);
          pushLog(`${option.label}ï¼šé­é‡å¼·æ•µï¼Œè¢«è¿«æˆ°é¬¥ï¼`);
        },
      };
    } else if (eventRoll < 0.95) {
      // 10%ï¼šä¸­æ¯’ï¼ˆæŒç»­æ‰£HPï¼‰
      const poisonDamage = Math.floor(hero.stats.maxHp * 0.15); // æ‰£15%æœ€å¤§HP
      eventResult = {
        type: 'bad',
        title: 'ä¸­æ¯’ï¼',
        message: `ä½ ä¸­æ¯’äº†ï¼\nHPæ¸›å°‘äº† ${poisonDamage} é»ï¼ˆç´„15%æœ€å¤§HPï¼‰ã€‚`,
        effect: () => {
          hero.stats.hp = Math.max(1, hero.stats.hp - poisonDamage);
          pushLog(`${option.label}ï¼šä¸­æ¯’ï¼ŒHPæ¸›å°‘äº† ${poisonDamage} é»ï¼ˆå‰©é¤˜ ${hero.stats.hp} HPï¼‰ã€‚`);
          if (hero.stats.hp <= 0) {
            pushLog('å‹‡è€…å€’ä¸‹ï¼Œæœ¬æ¬¡å†’éšªçµæŸã€‚');
            handleGameOver();
            return;
          }
        },
      };
    } else {
      // 5%ï¼šè™šå¼±ï¼ˆé™ä½æ”»å‡»åŠ›ï¼‰
      const attackLoss = Math.max(1, Math.floor(currentTier * 1.0)); // ä¸é˜¶å±‚æ•°æˆæ­£æ¯”
      eventResult = {
        type: 'bad',
        title: 'æ„Ÿåˆ°è™›å¼±ï¼',
        message: `ä½ æ„Ÿåˆ°è™›å¼±ï¼Œæ”»æ“ŠåŠ›é™ä½äº†ï¼\næ”»æ“ŠåŠ›æ¸›å°‘äº† ${attackLoss} é»ã€‚`,
        effect: () => {
          if (!hero.attributes) {
            hero.attributes = { attack: 0, vitality: 0, defense: 0, recovery: 0, magic: 0, agility: 0 };
          }
          hero.attributes.attack = Math.max(0, (hero.attributes.attack || 0) - attackLoss);
          pushLog(`${option.label}ï¼šæ„Ÿåˆ°è™›å¼±ï¼Œæ”»æ“ŠåŠ›æ¸›å°‘äº† ${attackLoss} é»ã€‚`);
        },
      };
    }
  } else if (eventType === 'choice') {
    // é€‰æ‹©å‹äº‹ä»¶ï¼ˆ20%æ¦‚ç‡ï¼‰- æœ‰å¥½æœ‰å
    // éšæœºé€‰æ‹©é€‰æ‹©å‹äº‹ä»¶ç±»å‹
    if (eventRoll < 0.25) {
      // 25%ï¼šç¥ç§˜å•†äººï¼ˆæœ‰å¥½æœ‰åçš„é€‰æ‹©ï¼‰
      const goldAmount = 30 * currentTier + randomRange(0, 20 * currentTier);
      const attrIncrease = Math.max(2, Math.floor(currentTier * 1.0));
      const attributes = ['attack', 'defense', 'magic', 'agility'];
      const randomAttr = attributes[Math.floor(Math.random() * attributes.length)];
      const attrName = ATTRIBUTES.find(a => a.id === randomAttr)?.name || randomAttr;
      
      // èƒ½åŠ›æå‡æœ‰30%æ¦‚ç‡æ˜¯è´Ÿé¢æ•ˆæœï¼ˆå¤±å»å…¶ä»–å±æ€§ï¼‰
      const isNegative = Math.random() < 0.3;
      const negativeAttr = attributes.filter(a => a !== randomAttr)[Math.floor(Math.random() * (attributes.length - 1))];
      const negativeAttrName = ATTRIBUTES.find(a => a.id === negativeAttr)?.name || negativeAttr;
      const negativeAmount = Math.floor(attrIncrease / 2);
      
      eventResult = {
        type: 'choice',
        title: 'ç¥ç§˜å•†äºº',
        message: 'ä½ é‡åˆ°äº†ä¸€ä½ç¥ç§˜çš„å•†äººï¼Œä»–æä¾›å…©ç¨®ä¸åŒçš„äº¤æ˜“ã€‚',
        choices: [
          {
            hint: 'æ¥å—é‡‘å¹£äº¤æ˜“ï¼ˆå¥½ï¼‰',
            label: `ç²å¾— ${goldAmount} é‡‘å¹£`,
            resultTitle: 'å®Œæˆäº¤æ˜“',
            resultMessage: `ä½ å®Œæˆäº†äº¤æ˜“ï¼Œå•†äººçµ¦äº†ä½ ä¸€è¢‹é‡‘å¹£ã€‚\nç²å¾— ${goldAmount} é‡‘å¹£ã€‚`,
            effect: () => {
              if (hero.stats.gold == null) hero.stats.gold = 0;
              hero.stats.gold += goldAmount;
              pushLog(`${option.label}ï¼šæ¥å—äº†é‡‘å¹£äº¤æ˜“ï¼Œç²å¾— ${goldAmount} é‡‘å¹£ã€‚`);
            },
          },
          {
            hint: isNegative ? 'æ¥å—ç¥ç§˜è—¥åŠ‘ï¼ˆæœ‰å¥½æœ‰åï¼‰' : 'æ¥å—ç¥ç§˜è—¥åŠ‘ï¼ˆå¥½ï¼‰',
            label: `å¢åŠ  ${attrIncrease} ${attrName}${isNegative ? `ï¼Œä½†æ¸›å°‘ ${negativeAmount} ${negativeAttrName}` : ''}`,
            resultTitle: isNegative ? 'è—¥åŠ‘çš„å‰¯ä½œç”¨ï¼' : 'é£²ç”¨è—¥åŠ‘',
            resultMessage: isNegative
              ? `ä½ é£²ç”¨äº†ç¥ç§˜è—¥åŠ‘ï¼Œé›–ç„¶${attrName}å¢åŠ äº† ${attrIncrease} é»ï¼Œä½†ç”¢ç”Ÿäº†å‰¯ä½œç”¨ï¼\n${attrName} +${attrIncrease}ï¼Œ${negativeAttrName} -${negativeAmount}ã€‚`
              : `ä½ é£²ç”¨äº†ç¥ç§˜è—¥åŠ‘ï¼Œæ„Ÿå—åˆ°åŠ›é‡æ¹§å…¥é«”å…§ï¼\n${attrName} å¢åŠ äº† ${attrIncrease} é»ã€‚`,
            effect: () => {
              if (!hero.attributes) {
                hero.attributes = { attack: 0, defense: 0, magic: 0, agility: 0 };
              }
              hero.attributes[randomAttr] = (hero.attributes[randomAttr] || 0) + attrIncrease;
              if (isNegative) {
                hero.attributes[negativeAttr] = Math.max(0, (hero.attributes[negativeAttr] || 0) - negativeAmount);
                pushLog(`${option.label}ï¼šé£²ç”¨äº†è—¥åŠ‘ï¼Œ${attrName} +${attrIncrease}ï¼Œ${negativeAttrName} -${negativeAmount}ã€‚`);
              } else {
                pushLog(`${option.label}ï¼šé£²ç”¨äº†è—¥åŠ‘ï¼Œ${attrName} å¢åŠ äº† ${attrIncrease}ã€‚`);
              }
            },
          },
        ],
      };
    } else if (eventRoll < 0.5) {
      // 25%ï¼šé£é™©æŠ•èµ„ï¼ˆæœ‰å¥½æœ‰åï¼‰
      const goldAmount = 50 * currentTier + randomRange(0, 30 * currentTier);
      const goldLoss = Math.floor((hero.stats.gold || 0) * 0.2);
      
      eventResult = {
        type: 'choice',
        title: 'é¢¨éšªæŠ•è³‡',
        message: 'ä½ é‡åˆ°äº†ä¸€å€‹æŠ•è³‡æ©Ÿæœƒï¼Œä½†å­˜åœ¨é¢¨éšªã€‚',
        choices: [
          {
            hint: 'æŠ•è³‡ï¼ˆå¯èƒ½ç²å¾—å¤§é‡é‡‘å¹£ï¼Œä¹Ÿå¯èƒ½å¤±å»ï¼‰',
            label: `æŠ•è³‡ï¼ˆå¯èƒ½ç²å¾— ${goldAmount} é‡‘å¹£ï¼Œæˆ–å¤±å» ${goldLoss} é‡‘å¹£ï¼‰`,
            resultTitle: Math.random() < 0.6 ? 'æŠ•è³‡æˆåŠŸï¼' : 'æŠ•è³‡å¤±æ•—ï¼',
            resultMessage: Math.random() < 0.6
              ? `ä½ çš„æŠ•è³‡æˆåŠŸäº†ï¼\nç²å¾— ${goldAmount} é‡‘å¹£ã€‚`
              : `ä½ çš„æŠ•è³‡å¤±æ•—äº†ï¼\nå¤±å» ${goldLoss} é‡‘å¹£ã€‚`,
            effect: () => {
              if (hero.stats.gold == null) hero.stats.gold = 0;
              const success = Math.random() < 0.6;
              if (success) {
                hero.stats.gold += goldAmount;
                pushLog(`${option.label}ï¼šæŠ•è³‡æˆåŠŸï¼Œç²å¾— ${goldAmount} é‡‘å¹£ã€‚`);
              } else {
                hero.stats.gold = Math.max(0, hero.stats.gold - goldLoss);
                pushLog(`${option.label}ï¼šæŠ•è³‡å¤±æ•—ï¼Œå¤±å» ${goldLoss} é‡‘å¹£ã€‚`);
              }
            },
          },
          {
            hint: 'é›¢é–‹ï¼ˆç„¡æ•ˆæœï¼‰',
            label: 'é›¢é–‹',
            resultTitle: 'é›¢é–‹',
            resultMessage: 'ä½ é¸æ“‡äº†é›¢é–‹ï¼Œæ²’æœ‰ç²å¾—ä»»ä½•æ±è¥¿ã€‚',
            effect: () => {
              pushLog(`${option.label}ï¼šé¸æ“‡äº†é›¢é–‹ã€‚`);
            },
          },
        ],
      };
    } else if (eventRoll < 0.75) {
      // 25%ï¼šç»éªŒä¸é£é™©ï¼ˆæœ‰å¥½æœ‰åï¼‰
      const xpBonus = Math.floor(hero.stats.nextLevelXp * (0.5 + currentTier * 0.1));
      const hpLoss = Math.floor(hero.stats.maxHp * 0.15);
      
      eventResult = {
        type: 'choice',
        title: 'å±éšªçš„è©¦ç…‰',
        message: 'ä½ ç™¼ç¾äº†ä¸€å€‹å±éšªçš„è©¦ç…‰ä¹‹åœ°ï¼Œå¯ä»¥ç²å¾—ç¶“é©—ä½†æœƒå—å‚·ã€‚',
        choices: [
          {
            hint: 'æ¥å—è©¦ç…‰ï¼ˆç²å¾—ç¶“é©—ä½†å¤±å»HPï¼‰',
            label: `æ¥å—è©¦ç…‰ï¼ˆç²å¾— ${xpBonus} ç¶“é©—ï¼Œå¤±å» ${hpLoss} HPï¼‰`,
            resultTitle: 'å®Œæˆè©¦ç…‰',
            resultMessage: `ä½ å®Œæˆäº†è©¦ç…‰ï¼Œç²å¾—äº†ç¶“é©—ä½†ä¹Ÿå—äº†å‚·ã€‚\nç²å¾— ${xpBonus} ç¶“é©—å€¼ï¼ŒHPæ¸›å°‘äº† ${hpLoss} é»ã€‚`,
            effect: () => {
              hero.stats.xp += xpBonus;
              hero.stats.hp = Math.max(1, hero.stats.hp - hpLoss);
              checkLevelUp();
              pushLog(`${option.label}ï¼šå®Œæˆäº†è©¦ç…‰ï¼Œç²å¾— ${xpBonus} ç¶“é©—ï¼ŒHPæ¸›å°‘äº† ${hpLoss} é»ã€‚`);
              if (hero.stats.hp <= 0) {
                pushLog('å‹‡è€…å€’ä¸‹ï¼Œæœ¬æ¬¡å†’éšªçµæŸã€‚');
                handleGameOver();
                return;
              }
            },
          },
          {
            hint: 'é›¢é–‹ï¼ˆç„¡æ•ˆæœï¼‰',
            label: 'é›¢é–‹',
            resultTitle: 'é›¢é–‹',
            resultMessage: 'ä½ é¸æ“‡äº†é›¢é–‹ï¼Œæ²’æœ‰ç²å¾—ä»»ä½•æ±è¥¿ã€‚',
            effect: () => {
              pushLog(`${option.label}ï¼šé¸æ“‡äº†é›¢é–‹ã€‚`);
            },
          },
        ],
      };
    } else if (eventRoll < 0.75) {
      // 25%ï¼šèƒ½åŠ›äº¤æ¢ï¼ˆæœ‰å¥½æœ‰åï¼‰
      const attrIncrease = Math.max(2, Math.floor(currentTier * 1.0));
      const attributes = ['attack', 'defense', 'magic', 'agility'];
      const randomAttr1 = attributes[Math.floor(Math.random() * attributes.length)];
      const randomAttr2 = attributes.filter(a => a !== randomAttr1)[Math.floor(Math.random() * (attributes.length - 1))];
      const attr1Name = ATTRIBUTES.find(a => a.id === randomAttr1)?.name || randomAttr1;
      const attr2Name = ATTRIBUTES.find(a => a.id === randomAttr2)?.name || randomAttr2;
      
      eventResult = {
        type: 'choice',
        title: 'èƒ½åŠ›è½‰æ›',
        message: 'ä½ ç™¼ç¾äº†ä¸€å€‹å¯ä»¥è½‰æ›èƒ½åŠ›çš„ç¥­å£‡ï¼Œä½†è½‰æ›æœƒå¸¶ä¾†æå¤±ã€‚',
        choices: [
          {
            hint: 'è½‰æ›èƒ½åŠ›ï¼ˆå¢åŠ ä¸€ç¨®èƒ½åŠ›ï¼Œæ¸›å°‘å¦ä¸€ç¨®ï¼‰',
            label: `è½‰æ›èƒ½åŠ›ï¼ˆ${attr1Name} +${attrIncrease}ï¼Œ${attr2Name} -${Math.floor(attrIncrease / 2)}ï¼‰`,
            resultTitle: 'èƒ½åŠ›è½‰æ›',
            resultMessage: `ä½ å®Œæˆäº†èƒ½åŠ›è½‰æ›ã€‚\n${attr1Name} +${attrIncrease}ï¼Œ${attr2Name} -${Math.floor(attrIncrease / 2)}ã€‚`,
            effect: () => {
              if (!hero.attributes) {
                hero.attributes = { attack: 0, defense: 0, magic: 0, agility: 0 };
              }
              hero.attributes[randomAttr1] = (hero.attributes[randomAttr1] || 0) + attrIncrease;
              hero.attributes[randomAttr2] = Math.max(0, (hero.attributes[randomAttr2] || 0) - Math.floor(attrIncrease / 2));
              pushLog(`${option.label}ï¼šè½‰æ›èƒ½åŠ›ï¼Œ${attr1Name} +${attrIncrease}ï¼Œ${attr2Name} -${Math.floor(attrIncrease / 2)}ã€‚`);
            },
          },
          {
            hint: 'é›¢é–‹ï¼ˆç„¡æ•ˆæœï¼‰',
            label: 'é›¢é–‹',
            resultTitle: 'é›¢é–‹',
            resultMessage: 'ä½ é¸æ“‡äº†é›¢é–‹ï¼Œæ²’æœ‰ç²å¾—ä»»ä½•æ±è¥¿ã€‚',
            effect: () => {
              pushLog(`${option.label}ï¼šé¸æ“‡äº†é›¢é–‹ã€‚`);
            },
          },
        ],
      };
    } else {
      // 25%ï¼šçŒœå¤§å°æ¸¸æˆï¼ˆæœ‰å¥½æœ‰åï¼‰
      const currentGold = hero.stats.gold || 0;
      const betAmount = Math.max(10, Math.floor(currentGold * 0.2)); // èµŒæ³¨ä¸ºå½“å‰é‡‘å¸çš„20%ï¼Œæœ€å°‘10é‡‘å¸
      const winAmount = Math.floor(betAmount * 2.5); // èµ¢äº†è·å¾—2.5å€
      
      // ç”Ÿæˆéšæœºæ•°å­—ï¼ˆ1-6ï¼Œæ¨¡æ‹Ÿéª°å­ï¼‰
      const diceRoll = Math.floor(Math.random() * 6) + 1;
      const isBig = diceRoll >= 4; // 4-6ä¸ºå¤§ï¼Œ1-3ä¸ºå°
      
      eventResult = {
        type: 'choice',
        title: 'è³­å ´',
        message: `ä½ é‡åˆ°äº†ä¸€å€‹ç¥ç§˜çš„è³­å ´ã€‚èŠå®¶æœƒæ“²ä¸€å€‹éª°å­ï¼ˆ1-6é»ï¼‰ï¼Œ4-6é»ç‚ºã€Œå¤§ã€ï¼Œ1-3é»ç‚ºã€Œå°ã€ã€‚\nè³­æ³¨ï¼š${betAmount} é‡‘å¹£\nå¦‚æœçŒœä¸­ï¼šç²å¾— ${winAmount} é‡‘å¹£\nå¦‚æœçŒœéŒ¯ï¼šå¤±å» ${betAmount} é‡‘å¹£`,
        choices: [
          {
            hint: 'çŒœå¤§ï¼ˆ4-6é»ï¼‰',
            label: `çŒœå¤§ï¼ˆè³­æ³¨ï¼š${betAmount} é‡‘å¹£ï¼‰`,
            resultTitle: diceRoll >= 4 ? 'çŒœä¸­äº†ï¼' : 'çŒœéŒ¯äº†ï¼',
            resultMessage: diceRoll >= 4
              ? `éª°å­çµæœï¼š${diceRoll}é»ï¼ˆå¤§ï¼‰\nä½ çŒœä¸­äº†ï¼ç²å¾— ${winAmount} é‡‘å¹£ï¼`
              : `éª°å­çµæœï¼š${diceRoll}é»ï¼ˆå°ï¼‰\nä½ çŒœéŒ¯äº†ï¼å¤±å» ${betAmount} é‡‘å¹£ã€‚`,
            effect: () => {
              if (hero.stats.gold == null) hero.stats.gold = 0;
              if (diceRoll >= 4) {
                hero.stats.gold += winAmount;
                pushLog(`${option.label}ï¼šçŒœå¤§ï¼Œéª°å­çµæœ ${diceRoll}é»ï¼ˆå¤§ï¼‰ï¼ŒçŒœä¸­äº†ï¼ç²å¾— ${winAmount} é‡‘å¹£ã€‚`);
              } else {
                hero.stats.gold = Math.max(0, hero.stats.gold - betAmount);
                pushLog(`${option.label}ï¼šçŒœå¤§ï¼Œéª°å­çµæœ ${diceRoll}é»ï¼ˆå°ï¼‰ï¼ŒçŒœéŒ¯äº†ï¼å¤±å» ${betAmount} é‡‘å¹£ã€‚`);
              }
            },
          },
          {
            hint: 'çŒœå°ï¼ˆ1-3é»ï¼‰',
            label: `çŒœå°ï¼ˆè³­æ³¨ï¼š${betAmount} é‡‘å¹£ï¼‰`,
            resultTitle: diceRoll <= 3 ? 'çŒœä¸­äº†ï¼' : 'çŒœéŒ¯äº†ï¼',
            resultMessage: diceRoll <= 3
              ? `éª°å­çµæœï¼š${diceRoll}é»ï¼ˆå°ï¼‰\nä½ çŒœä¸­äº†ï¼ç²å¾— ${winAmount} é‡‘å¹£ï¼`
              : `éª°å­çµæœï¼š${diceRoll}é»ï¼ˆå¤§ï¼‰\nä½ çŒœéŒ¯äº†ï¼å¤±å» ${betAmount} é‡‘å¹£ã€‚`,
            effect: () => {
              if (hero.stats.gold == null) hero.stats.gold = 0;
              if (diceRoll <= 3) {
                hero.stats.gold += winAmount;
                pushLog(`${option.label}ï¼šçŒœå°ï¼Œéª°å­çµæœ ${diceRoll}é»ï¼ˆå°ï¼‰ï¼ŒçŒœä¸­äº†ï¼ç²å¾— ${winAmount} é‡‘å¹£ã€‚`);
              } else {
                hero.stats.gold = Math.max(0, hero.stats.gold - betAmount);
                pushLog(`${option.label}ï¼šçŒœå°ï¼Œéª°å­çµæœ ${diceRoll}é»ï¼ˆå¤§ï¼‰ï¼ŒçŒœéŒ¯äº†ï¼å¤±å» ${betAmount} é‡‘å¹£ã€‚`);
              }
            },
          },
          {
            hint: 'é›¢é–‹ï¼ˆç„¡æ•ˆæœï¼‰',
            label: 'é›¢é–‹',
            resultTitle: 'é›¢é–‹',
            resultMessage: 'ä½ é¸æ“‡äº†é›¢é–‹ï¼Œæ²’æœ‰åƒèˆ‡è³­åšã€‚',
            effect: () => {
              pushLog(`${option.label}ï¼šé¸æ“‡äº†é›¢é–‹è³­å ´ã€‚`);
            },
          },
        ],
      };
    }
  }
  
  // ä¿å­˜äº‹ä»¶çµæœï¼Œé¡¯ç¤ºå°è©±æ¡†
  state.ui.eventResult = eventResult;
  renderAll();
}

function handleRest(option) {
  const hero = state.hero;
  if (!hero) return;
  
  // æ¢å¾©å‹‡è€…
  const heroHealHp = Math.round(hero.stats.maxHp * 0.3);
  const heroHealMp = Math.round(hero.stats.maxMp * 0.3);
  const oldHeroHp = hero.stats.hp;
  const oldHeroMp = hero.stats.mp;
  hero.stats.hp = Math.min(hero.stats.maxHp, hero.stats.hp + heroHealHp);
  hero.stats.mp = Math.min(hero.stats.maxMp, hero.stats.mp + heroHealMp);
  const actualHeroHp = hero.stats.hp - oldHeroHp;
  const actualHeroMp = hero.stats.mp - oldHeroMp;
  
  // æ¢å¾©æ‰€æœ‰åŒä¼´
  const companions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
  const companionHeals = [];
  
  companions.forEach(companion => {
    const companionHealHp = Math.round(companion.stats.maxHp * 0.3);
    const companionHealMp = Math.round(companion.stats.maxMp * 0.3);
    const oldCompanionHp = companion.stats.hp;
    const oldCompanionMp = companion.stats.mp;
    companion.stats.hp = Math.min(companion.stats.maxHp, companion.stats.hp + companionHealHp);
    companion.stats.mp = Math.min(companion.stats.maxMp, companion.stats.mp + companionHealMp);
    const actualCompanionHp = companion.stats.hp - oldCompanionHp;
    const actualCompanionMp = companion.stats.mp - oldCompanionMp;
    
    if (actualCompanionHp > 0 || actualCompanionMp > 0) {
      companionHeals.push({
        name: companion.name,
        hp: actualCompanionHp,
        mp: actualCompanionMp
      });
    }
  });
  
  // é¡¯ç¤ºæ¢å¾©è¨Šæ¯
  if (actualHeroHp > 0 || actualHeroMp > 0) {
    pushLog(`${option.label}ï¼šä½ æ¢å¾©äº† ${actualHeroHp} HP / ${actualHeroMp} MPã€‚`);
  }
  
  companionHeals.forEach(heal => {
    pushLog(`${heal.name}æ¢å¾©äº† ${heal.hp} HP / ${heal.mp} MPã€‚`);
  });
  
  if (companionHeals.length === 0 && (actualHeroHp === 0 && actualHeroMp === 0)) {
    pushLog(`${option.label}ï¼šä¼‘æ¯å¾Œï¼Œä½†æ‰€æœ‰äººéƒ½å·²ç¶“æ»¿ç‹€æ…‹ã€‚`);
  }
  
  renderAll();
}

function handleTown(option) {
  const hero = state.hero;
  if (!hero) return;
  
  // æ¢å¾©å‹‡è€… 30% HP/MP
  const heroHealHp = Math.round(hero.stats.maxHp * 0.3);
  const heroHealMp = Math.round(hero.stats.maxMp * 0.3);
  const oldHeroHp = hero.stats.hp;
  const oldHeroMp = hero.stats.mp;
  hero.stats.hp = Math.min(hero.stats.maxHp, hero.stats.hp + heroHealHp);
  hero.stats.mp = Math.min(hero.stats.maxMp, hero.stats.mp + heroHealMp);
  const actualHeroHp = hero.stats.hp - oldHeroHp;
  const actualHeroMp = hero.stats.mp - oldHeroMp;
  
  // æ¢å¾©æ‰€æœ‰åŒä¼´ 30% HP/MP
  const companions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
  const companionHeals = [];
  
  companions.forEach(companion => {
    const companionHealHp = Math.round(companion.stats.maxHp * 0.3);
    const companionHealMp = Math.round(companion.stats.maxMp * 0.3);
    const oldCompanionHp = companion.stats.hp;
    const oldCompanionMp = companion.stats.mp;
    companion.stats.hp = Math.min(companion.stats.maxHp, companion.stats.hp + companionHealHp);
    companion.stats.mp = Math.min(companion.stats.maxMp, companion.stats.mp + companionHealMp);
    const actualCompanionHp = companion.stats.hp - oldCompanionHp;
    const actualCompanionMp = companion.stats.mp - oldCompanionMp;
    
    if (actualCompanionHp > 0 || actualCompanionMp > 0) {
      companionHeals.push({
        name: companion.name,
        hp: actualCompanionHp,
        mp: actualCompanionMp
      });
    }
  });
  
  // é¡¯ç¤ºæ¢å¾©è¨Šæ¯
  if (actualHeroHp > 0 || actualHeroMp > 0) {
    pushLog(`é€²å…¥åŸå ¡ï¼šä½ æ¢å¾©äº† ${actualHeroHp} HP / ${actualHeroMp} MPã€‚`);
  }
  
  companionHeals.forEach(heal => {
    pushLog(`${heal.name}æ¢å¾©äº† ${heal.hp} HP / ${heal.mp} MPã€‚`);
  });
  
  if (companionHeals.length === 0 && (actualHeroHp === 0 && actualHeroMp === 0)) {
    pushLog(`é€²å…¥åŸå ¡ï¼šæ‰€æœ‰äººéƒ½å·²ç¶“æ»¿ç‹€æ…‹ã€‚`);
  }
  
  // é¡¯ç¤ºå•†åº—é¸å–®
  state.ui.shop = {
    open: true,
    type: 'equipment', // 'equipment' æˆ– 'supply'
  };
  renderAll();
}

// æ¸²æŸ“å•†åº—
function renderShop() {
  if (!state.ui.shop || !state.ui.shop.open) return;
  
  const hero = state.hero;
  if (!hero) return;
  
  const currentTier = state.world.stage;
  // åªé¡¯ç¤ºç•¶å‰tierçš„è£å‚™
  const tierEquipment = EQUIPMENT.filter(eq => eq.tier === currentTier);
  
  // æŒ‰é¡å‹åˆ†çµ„è£å‚™
  const equipmentByType = {
    weapon: [],
    armor: [],
    shield: [],
    accessory: [],
  };
  
  tierEquipment.forEach(eq => {
    if (equipmentByType[eq.type]) {
      equipmentByType[eq.type].push(eq);
    }
  });
  
  // æ¯å€‹é¡å‹éš¨æ©Ÿé¸æ“‡2å€‹è£å‚™
  const selectedEquipment = [];
  Object.keys(equipmentByType).forEach(type => {
    const typeEquipments = equipmentByType[type];
    if (typeEquipments.length > 0) {
      // éš¨æ©Ÿæ‰“äº‚ä¸¦é¸æ“‡å‰2å€‹
      const shuffled = [...typeEquipments].sort(() => Math.random() - 0.5);
      selectedEquipment.push(...shuffled.slice(0, 2));
    }
  });
  
  // éš¨æ©Ÿé¸æ“‡ä¸€å€‹è£å‚™ä½œç‚ºç²¾è‰¯è£å‚™ï¼ˆå¦‚æœè‡³å°‘æœ‰ä¸€å€‹è£å‚™ï¼‰
  let superiorEquipmentIndex = -1;
  if (selectedEquipment.length > 0) {
    superiorEquipmentIndex = Math.floor(Math.random() * selectedEquipment.length);
  }
  
  // å‰µå»ºç²¾è‰¯è£å‚™çš„å‡½æ•¸
  function createSuperiorEquipment(baseEq) {
    const superior = { ...baseEq };
    // å‰µå»ºæ–°çš„IDï¼Œæ¨™è¨˜ç‚ºç²¾è‰¯ç‰ˆæœ¬
    superior.id = `${baseEq.id}_superior`;
    superior.name = `ç²¾è‰¯ ${baseEq.name}`;
    superior.isSuperior = true;
    superior.baseEquipmentId = baseEq.id; // ä¿å­˜åŸå§‹è£å‚™ID
    
    // èƒ½åŠ›å€¼1.5å€ï¼ˆå››èˆäº”å…¥ï¼‰ï¼Œåƒ¹æ ¼2å€
    if (superior.attack !== undefined) {
      superior.attack = Math.round(superior.attack * 1.5);
    }
    if (superior.defense !== undefined) {
      superior.defense = Math.round(superior.defense * 1.5);
    }
    // å±¬æ€§åŠ æˆ1.5å€ï¼ˆå››èˆäº”å…¥ï¼‰
    if (superior.attributes) {
      const multipliedAttributes = {};
      Object.keys(superior.attributes).forEach(attr => {
        multipliedAttributes[attr] = Math.round(superior.attributes[attr] * 1.5);
      });
      superior.attributes = multipliedAttributes;
    }
    
    // HP/MPåŠ æˆ1.5å€ï¼ˆå››èˆäº”å…¥ï¼‰
    if (superior.hpBonus !== undefined) {
      superior.hpBonus = Math.round(superior.hpBonus * 1.5);
    }
    if (superior.mpBonus !== undefined) {
      superior.mpBonus = Math.round(superior.mpBonus * 1.5);
    }
    
    // æ›´æ–°èªªæ˜ï¼ŒåŒ…å«åŠ å€å¾Œçš„ HP/MP åŠ æˆï¼ˆåœ¨åŠ å€ä¹‹å¾Œæ›´æ–°ï¼‰
    let superiorDescription = baseEq.description;
    // ç§»é™¤åŸæœ‰çš„ HP/MP åŠ æˆæ¨™è¨˜ï¼ˆå¦‚æœæœ‰çš„è©±ï¼‰
    superiorDescription = superiorDescription.replace(/\s*\(HP\+\d+\s*MP\+\d+\)/g, '');
    superiorDescription = superiorDescription.replace(/\s*\(HP\+\d+\)/g, '');
    superiorDescription = superiorDescription.replace(/\s*\(MP\+\d+\)/g, '');
    // æ·»åŠ åŠ å€å¾Œçš„ HP/MP åŠ æˆ
    const superiorBonusText = [];
    if (superior.hpBonus !== undefined && superior.hpBonus > 0) {
      superiorBonusText.push(`HP+${superior.hpBonus}`);
    }
    if (superior.mpBonus !== undefined && superior.mpBonus > 0) {
      superiorBonusText.push(`MP+${superior.mpBonus}`);
    }
    if (superiorBonusText.length > 0) {
      superiorDescription += ` (${superiorBonusText.join(' ')})`;
    }
    superior.description = superiorDescription;
    
    // åƒ¹æ ¼åŠ å€
    superior.price = (baseEq.price || (baseEq.tier * 50)) * 2;
    
    return superior;
  }
  
  // ç”Ÿæˆå•†åº—è£å‚™åˆ—è¡¨
  const equipmentList = selectedEquipment.map((eq, index) => {
    // å¦‚æœæ˜¯ç²¾è‰¯è£å‚™ï¼Œå‰µå»ºç²¾è‰¯ç‰ˆæœ¬
    const displayEq = (index === superiorEquipmentIndex) 
      ? createSuperiorEquipment(eq) 
      : eq;
    
    const price = displayEq.price || (displayEq.tier * 50);
    const canAfford = hero.stats.gold >= price;
    // ä¸å†æ£€æŸ¥æ˜¯å¦æ‹¥æœ‰ï¼Œå…è®¸è´­ä¹°å¤šä¸ªç›¸åŒåç§°çš„è£…å¤‡ï¼ˆç²¾è‰¯è£…å¤‡è§†ä¸ºä¸åŒç‰©å“ï¼‰
    
    const stats = [];
    // é¡¯ç¤ºæ”»æ“ŠåŠ›ï¼ˆæ­¦å™¨ï¼‰
    if (displayEq.attack !== undefined) {
      stats.push(`æ”»æ“Š+${displayEq.attack}`);
    }
    // é¡¯ç¤ºé˜²ç¦¦åŠ›ï¼ˆé˜²å…·å’Œç›¾ç‰Œï¼Œé£¾å“ä¸é¡¯ç¤ºé˜²ç¦¦åŠ›ï¼‰
    if (displayEq.defense !== undefined && displayEq.type !== 'accessory') {
      stats.push(`é˜²ç¦¦+${displayEq.defense}`);
    }
    // é¡¯ç¤ºHP/MPåŠ æˆ
    if (displayEq.hpBonus !== undefined && displayEq.hpBonus > 0) {
      stats.push(`HP+${displayEq.hpBonus}`);
    }
    if (displayEq.mpBonus !== undefined && displayEq.mpBonus > 0) {
      stats.push(`MP+${displayEq.mpBonus}`);
    }
    // é¡¯ç¤ºå±¬æ€§åŠ æˆ
    if (displayEq.attributes) {
      Object.keys(displayEq.attributes).forEach(attr => {
        const attrName = ATTRIBUTES.find(a => a.id === attr)?.name || attr;
        stats.push(`${attrName}+${displayEq.attributes[attr]}`);
      });
    }
    
    const flowName = displayEq.flow ? `[${displayEq.flow}]` : '';
    const superiorTag = displayEq.isSuperior ? ' <span style="color: gold;">âœ¨ç²¾è‰¯</span>' : '';
    
    // ä¿å­˜ç²¾è‰¯è£å‚™ä¿¡æ¯åˆ°dataå±¬æ€§ï¼Œè³¼è²·æ™‚ä½¿ç”¨
    // å° JSON å­—ç¬¦ä¸²é€²è¡Œ HTML è½‰ç¾©ï¼Œé¿å…å¼•è™Ÿå°è‡´å±¬æ€§å€¼æˆªæ–·
    let equipmentDataId = displayEq.isSuperior ? JSON.stringify({
      isSuperior: true,
      baseId: displayEq.baseEquipmentId,
      superiorData: displayEq
    }) : displayEq.id;
    
    // HTML è½‰ç¾©å‡½æ•¸
    const escapeHtml = (str) => {
      if (typeof str !== 'string') return str;
      return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    };
    
    // å° equipmentDataId é€²è¡Œè½‰ç¾©ï¼ˆå¦‚æœæ˜¯ JSON å­—ç¬¦ä¸²ï¼‰
    const escapedEquipmentDataId = displayEq.isSuperior ? escapeHtml(equipmentDataId) : equipmentDataId;
    
    // ç²å–ç•¶å‰è£å‚™åœ¨è©²æ§½ä½ä¸Šçš„è£å‚™
    const slotMap = {
      weapon: 'weapon',
      shield: 'shield',
      armor: 'armor',
      accessory: 'accessory'
    };
    const slot = slotMap[displayEq.type];
    let currentEquipmentInfo = '';
    if (slot && hero.equipment && hero.equipment[slot]) {
      const currentEquipmentId = hero.equipment[slot];
      const currentEquipment = getEquipmentData(currentEquipmentId);
      if (currentEquipment) {
        const currentStats = [];
        if (currentEquipment.attack !== undefined) {
          currentStats.push(`æ”»æ“Š+${currentEquipment.attack}`);
        }
        if (currentEquipment.defense !== undefined && currentEquipment.type !== 'accessory') {
          currentStats.push(`é˜²ç¦¦+${currentEquipment.defense}`);
        }
        if (currentEquipment.dodge) {
          currentStats.push(`é–ƒé¿+${(currentEquipment.dodge * 100).toFixed(0)}%`);
        }
        if (currentEquipment.attributes) {
          Object.keys(currentEquipment.attributes).forEach(attr => {
            const attrName = ATTRIBUTES.find(a => a.id === attr)?.name || attr;
            currentStats.push(`${attrName}+${currentEquipment.attributes[attr]}`);
          });
        }
        const currentSuperiorTag = currentEquipment.isSuperior ? ' <span style="color: gold;">âœ¨ç²¾è‰¯</span>' : '';
        currentEquipmentInfo = `
          <div class="shop-current-equipment" style="margin-top: 8px; padding: 8px; background: rgba(0,0,0,0.3); border: 1px solid #666; font-size: 12px;">
            <div style="color: #aaa; margin-bottom: 4px;">ç›®å‰è£å‚™ï¼š</div>
            <div style="color: #f4b183;">${currentEquipment.name}${currentSuperiorTag}</div>
            ${currentStats.length > 0 ? `<div style="color: #aaa; font-size: 11px;">${currentStats.join(' ')}</div>` : ''}
          </div>
        `;
      }
    } else if (slot) {
      currentEquipmentInfo = `
        <div class="shop-current-equipment" style="margin-top: 8px; padding: 8px; background: rgba(0,0,0,0.3); border: 1px solid #666; font-size: 12px;">
          <div style="color: #aaa;">ç›®å‰è£å‚™ï¼šæœªè£å‚™</div>
        </div>
      `;
    }
    
    return `
      <div class="shop-item ${!canAfford ? 'unaffordable' : ''}">
        <div class="shop-item-name">${displayEq.name}${superiorTag} ${flowName}</div>
        <div class="shop-item-desc">${displayEq.description}</div>
        ${stats.length > 0 ? `<div class="shop-item-stats">${stats.join(' ')}</div>` : ''}
        ${currentEquipmentInfo}
        <div class="shop-item-price">${price} é‡‘å¹£</div>
        <button class="shop-buy-btn" data-equipment="${escapedEquipmentDataId}" data-price="${price}" 
                  ${!canAfford ? 'disabled' : ''}>
            è³¼è²·
          </button>
        <button class="shop-buy-btn" data-equipment="${escapedEquipmentDataId}" data-price="${price}" data-auto-equip="true"
                  ${!canAfford ? 'disabled' : ''}>
            è³¼è²·ä¸¦è£å‚™
          </button>
      </div>
    `;
  }).join('');
  
  // è£œçµ¦åˆ—è¡¨ï¼šåªé¡¯ç¤ºåˆ°é«˜ä¸€éšçš„é“å…·ï¼ˆæŒ‰tieræ’åºï¼‰
  const maxShopTier = Math.min(currentTier + 1, 6); // å•†åº—åªè³£åˆ°é«˜ä¸€éšï¼Œæœ€é«˜6éš
  const allItems = ITEMS.filter(item => 
    (item.type === 'heal' || item.type === 'mp') && item.tier <= maxShopTier
  ).sort((a, b) => {
    if (a.tier !== b.tier) return a.tier - b.tier;
    if (a.type !== b.type) return a.type === 'heal' ? -1 : 1;
    return 0;
  });
  
  const supplyList = allItems.map(item => {
    const price = item.price || 10;
    const canAfford = hero.stats.gold >= price;
    return `
      <div class="shop-item ${!canAfford ? 'unaffordable' : ''}">
        <div class="shop-item-name">${item.name}</div>
        <div class="shop-item-desc">${item.description}</div>
        <div class="shop-item-price">${price} é‡‘å¹£</div>
        <button class="shop-buy-btn" data-action="buy-item" data-item="${item.id}" data-price="${price}" 
                ${!canAfford ? 'disabled' : ''}>
          è³¼è²·
        </button>
      </div>
    `;
  }).join('');
  
  // å®Œå…¨æ¢å¾©é¸é …
  const fullHealOption = `
    <div class="shop-item">
      <div class="shop-item-name">å®Œå…¨æ¢å¾©</div>
      <div class="shop-item-desc">æ¢å¾©æ‰€æœ‰HPå’ŒMP</div>
      <div class="shop-item-price">200 é‡‘å¹£</div>
      <button class="shop-buy-btn" data-action="heal" data-price="200" 
              ${hero.stats.gold < 200 ? 'disabled' : ''}>
        è³¼è²·
      </button>
    </div>
  `;
  
  const supplyListWithFullHeal = supplyList + fullHealOption;
  
  // è³£å‡ºé“å…·åˆ—è¡¨ï¼ˆåŒ…æ‹¬é“å…·è¢‹ä¸­çš„è£å‚™ï¼‰
  // åªæ˜¾ç¤ºæ•°é‡å¤§äº0çš„ç‰©å“ï¼ˆä¸ä¿®æ”¹åŸæ•°ç»„ï¼Œä¿æŒé¡ºåºï¼‰
  const maxItems = 8;
  const items = hero.items.filter(item => item && item.qty > 0).slice(0, maxItems);
  const sellList = items.map(entry => {
    // æª¢æŸ¥æ˜¯å¦æ˜¯è£å‚™é“å…·
    if (entry.id.startsWith('equipment_')) {
      const equipmentId = entry.id.replace('equipment_', '');
      const equipment = getEquipmentData(equipmentId);
      if (!equipment) return '';
      // æª¢æŸ¥æ˜¯å¦ç‚ºç¾…å¾·è£å‚™ï¼ˆtier 99 æˆ– id ä»¥ rod_ é–‹é ­ï¼‰
      const isRodEquipment = equipment.tier === 99 || equipmentId.startsWith('rod_');
      const sellPrice = Math.floor((equipment.price || 50) / 2);
      return `
        <div class="shop-item">
          <div class="shop-item-name">${equipment.name}</div>
          <div class="shop-item-desc">${equipment.description}</div>
          <div class="shop-item-stats">æ•¸é‡ï¼š${entry.qty}</div>
          <div class="shop-item-price">${sellPrice} é‡‘å¹£/å€‹${isRodEquipment ? 'ï¼ˆç¾…å¾·è£å‚™ï¼‰' : ''}</div>
          <button class="shop-buy-btn" data-action="sell-equipment" data-equipment="${equipmentId}">
            è³£å‡º
          </button>
        </div>
      `;
    } else {
      const item = ITEM_LOOKUP.get(entry.id);
      if (!item) return '';
      // è³£å‡ºåƒ¹æ ¼ç‚ºè³¼è²·åƒ¹æ ¼çš„ä¸€åŠ
      const sellPrice = Math.floor((item.price || 10) / 2);
      return `
        <div class="shop-item">
          <div class="shop-item-name">${item.name}</div>
          <div class="shop-item-desc">${item.description}</div>
          <div class="shop-item-stats">æ•¸é‡ï¼š${entry.qty}</div>
          <div class="shop-item-price">${sellPrice} é‡‘å¹£/å€‹</div>
          <button class="shop-buy-btn" data-action="sell-item" data-item="${entry.id}">
            è³£å‡º
          </button>
        </div>
      `;
    }
  }).join('');
  
  // è³£å‡ºè£å‚™åº«å­˜ä¸­çš„è£å‚™ï¼ˆåªæ˜¾ç¤ºè¿˜åœ¨åº“å­˜ä¸­çš„è£…å¤‡ï¼‰
  const equipmentInventoryList = (hero.equipmentInventory || [])
    .filter(equipmentId => equipmentId != null) // è¿‡æ»¤æ‰nullå€¼
    .map(equipmentId => {
    const equipment = getEquipmentData(equipmentId);
    if (!equipment) return '';
      // æ£€æŸ¥æ˜¯å¦æ­£åœ¨è£…å¤‡ï¼Œå¦‚æœæ˜¯åˆ™ä¸åœ¨å–å‡ºåˆ—è¡¨ä¸­æ˜¾ç¤º
      const isEquipped = Object.values(hero.equipment || {}).includes(equipmentId);
      if (isEquipped) return '';
      // æ£€æŸ¥æ˜¯å¦åœ¨é“å…·è¢‹ä¸­ä¸”æ•°é‡ä¸º0ï¼Œå¦‚æœæ˜¯åˆ™ä¸åœ¨å–å‡ºåˆ—è¡¨ä¸­æ˜¾ç¤º
      const itemId = `equipment_${equipmentId}`;
      const itemEntry = hero.items.find(entry => entry.id === itemId);
      if (itemEntry && itemEntry.qty <= 0) return '';
      
    // æª¢æŸ¥æ˜¯å¦ç‚ºç¾…å¾·è£å‚™ï¼ˆtier 99 æˆ– id ä»¥ rod_ é–‹é ­ï¼‰
    const isRodEquipment = equipment.tier === 99 || equipmentId.startsWith('rod_');
    const sellPrice = Math.floor((equipment.price || 50) / 2);
    const superiorTag = equipment.isSuperior ? ' <span style="color: gold;">âœ¨ç²¾è‰¯</span>' : '';
    const rodTag = isRodEquipment ? ' <span style="color: #9fc5e8;">âš”ï¸ç¾…å¾·</span>' : '';
    return `
      <div class="shop-item">
        <div class="shop-item-name">${equipment.name}${superiorTag}${rodTag}</div>
        <div class="shop-item-desc">${equipment.description}</div>
        <div class="shop-item-price">${sellPrice} é‡‘å¹£${isRodEquipment ? 'ï¼ˆç¾…å¾·è£å‚™ï¼‰' : ''}</div>
        <button class="shop-buy-btn" data-action="sell-equipment" data-equipment="${equipmentId}">
          è³£å‡º
        </button>
      </div>
    `;
    })
    .filter(html => html !== '') // è¿‡æ»¤æ‰ç©ºå­—ç¬¦ä¸²
    .join('');
  
  const sellContent = (items.length > 0 || equipmentInventoryList) 
    ? sellList + equipmentInventoryList 
    : '<p>æ²’æœ‰å¯è³£å‡ºçš„é“å…·</p>';
  
  dom.modalLayer.classList.remove('hidden');
  dom.levelModal.innerHTML = `
    <h2>å•†åº—</h2>
    <div class="shop-tabs">
      <button class="shop-tab ${state.ui.shop.type === 'equipment' ? 'active' : ''}" 
              data-shop-type="equipment">è£å‚™ (Tier ${currentTier})</button>
      <button class="shop-tab ${state.ui.shop.type === 'supply' ? 'active' : ''}" 
              data-shop-type="supply">è£œçµ¦</button>
      <button class="shop-tab ${state.ui.shop.type === 'sell' ? 'active' : ''}" 
              data-shop-type="sell">è³£å‡º</button>
      <button class="shop-tab" data-action="close-shop">é—œé–‰</button>
    </div>
    <div class="shop-content">
      <p>é‡‘å¹£ï¼š${hero.stats.gold}</p>
      ${state.ui.shop.type === 'equipment' ? equipmentList : 
        state.ui.shop.type === 'supply' ? supplyListWithFullHeal : sellContent}
    </div>
  `;
}

// å°‡è£å‚™æ”¾å…¥é“å…·è¢‹
function moveEquipmentToBag(equipmentId, slot) {
  const hero = state.hero;
  if (!hero) return;
  
  // æˆ°é¬¥ä¸­ä¸èƒ½ç§»å‹•è£å‚™
  if (state.ui.battle) {
    pushLog('æˆ°é¬¥ä¸­ç„¡æ³•ç§»å‹•è£å‚™ï¼');
    return;
  }
  
  const equipment = getEquipmentData(equipmentId);
  if (!equipment) return;
  
  // å¦‚æœæ˜¯æ­£åœ¨è£å‚™çš„è£å‚™ï¼Œå…ˆå¸ä¸‹
  if (slot && hero.equipment[slot] === equipmentId) {
    hero.equipment[slot] = null;
  }
  
  // å¾è£å‚™åº«å­˜ä¸­ç§»é™¤
  if (hero.equipmentInventory && hero.equipmentInventory.includes(equipmentId)) {
    hero.equipmentInventory = hero.equipmentInventory.filter(id => id !== equipmentId);
  }
  
  // æª¢æŸ¥é“å…·æ¬„æ˜¯å¦å·²æ»¿
  limitInventorySize();
  const currentItemCount = hero.items.filter(item => item.qty > 0).length;
  if (currentItemCount >= 8) {
    pushLog('é“å…·æ¬„å·²æ»¿ï¼Œç„¡æ³•æ”¾å…¥é“å…·è¢‹ï¼');
    // æ”¾å›è£å‚™åº«å­˜
    if (!hero.equipmentInventory) hero.equipmentInventory = [];
    if (!hero.equipmentInventory.includes(equipmentId)) {
      hero.equipmentInventory.push(equipmentId);
    }
    if (slot && !hero.equipment[slot]) {
      hero.equipment[slot] = equipmentId;
    }
    renderAll();
    return;
  }
  
  // æ·»åŠ åˆ°é“å…·æ¬„ï¼ˆè£å‚™ä½œç‚ºç‰¹æ®Šé“å…·ï¼Œä½¿ç”¨equipment_å‰ç¶´ï¼‰
  const itemId = `equipment_${equipmentId}`;
  let itemEntry = hero.items.find(entry => entry.id === itemId);
  if (itemEntry) {
    itemEntry.qty += 1;
  } else {
    hero.items.push({ id: itemId, qty: 1 });
  }
  
  pushLog(`å°‡ ${equipment.name} æ”¾å…¥é“å…·è¢‹ã€‚`);
  renderAll();
}

// è³¼è²·è£å‚™
function buyEquipment(equipmentData, price, autoEquip = false) {
  const hero = state.hero;
  if (!hero) {
    return;
  }
  if (hero.stats.gold < price) {
    return;
  }
  
  // è§£æè£å‚™æ•¸æ“šï¼ˆå¯èƒ½æ˜¯ç²¾è‰¯è£å‚™çš„JSONå­—ç¬¦ä¸²ï¼‰
  let equipment = null;
  let equipmentId = null;
  let isSuperior = false;
  
  try {
    // å˜—è©¦è§£æJSONï¼ˆç²¾è‰¯è£å‚™ï¼‰
    const parsed = JSON.parse(equipmentData);
    if (parsed.isSuperior && parsed.superiorData) {
      isSuperior = true;
      equipment = parsed.superiorData;
      equipmentId = equipment.id; // ä½¿ç”¨ç²¾è‰¯è£å‚™çš„ID
    } else {
      equipmentId = parsed.baseId || equipmentData;
      equipment = getEquipmentData(equipmentId);
    }
  } catch (e) {
    // ä¸æ˜¯JSONï¼Œæ˜¯æ™®é€šè£å‚™ID
    equipmentId = equipmentData;
    equipment = getEquipmentData(equipmentId);
  }
  
  if (!equipment) {
    return;
  }
  
  // æª¢æŸ¥æ˜¯å¦å·²æ“æœ‰ï¼ˆç²¾è‰¯è£å‚™éœ€è¦æª¢æŸ¥åŸå§‹IDï¼‰
  if (!hero.equipmentInventory) {
    hero.equipmentInventory = [];
  }
  if (!hero.superiorEquipment) {
    hero.superiorEquipment = {}; // å­˜å„²ç²¾è‰¯è£å‚™æ•¸æ“š
  }
  
  // æª¢æŸ¥æ˜¯å¦åœ¨é“å…·è¢‹ä¸­
  const itemId = `equipment_${equipmentId}`;
  const hasInBag = hero.items.some(entry => entry.id === itemId && entry.qty > 0);
  
  // å…è¨±æ“æœ‰å¤šä¸ªç›¸åŒåç§°çš„è£…å¤‡ï¼ˆç²¾è‰¯è£…å¤‡è§†ä¸ºä¸åŒç‰©å“ï¼Œå› ä¸ºå®ƒä»¬æœ‰ä¸åŒçš„IDï¼‰
  // ä¸å†æ£€æŸ¥æ˜¯å¦å·²æ‹¥æœ‰ï¼Œå…è®¸é‡å¤è´­ä¹°
  
        if (hero.stats.gold == null) hero.stats.gold = 0;
  hero.stats.gold -= price;
  
  // å¦‚æœæ˜¯ç²¾è‰¯è£å‚™ï¼Œä¿å­˜åˆ°superiorEquipmentä¸­
  if (isSuperior) {
    hero.superiorEquipment[equipmentId] = equipment;
  }
  
  // å¦‚æœautoEquipç‚ºtrueï¼Œå˜—è©¦ç›´æ¥è£å‚™
  if (autoEquip) {
    const slot = equipment.type === 'weapon' ? 'weapon' :
                 equipment.type === 'shield' ? 'shield' :
                 equipment.type === 'armor' ? 'armor' :
                 equipment.type === 'accessory' ? 'accessory' : null;
    
    
    if (slot) {
      const oldEquipmentId = hero.equipment[slot];
      // å…ˆæ·»åŠ åˆ°åº«å­˜
      hero.equipmentInventory.push(equipmentId);
      // è£å‚™æ–°è£å‚™
      hero.equipment[slot] = equipmentId;
      pushLog(`è³¼è²·ä¸¦è£å‚™äº† ${equipment.name}ï¼ˆèŠ±è²» ${price} é‡‘å¹£ï¼‰ã€‚`);
      
      // å¦‚æœæœ‰èˆŠè£å‚™ï¼Œè‡ªå‹•è³£æ‰
      if (oldEquipmentId) {
        const oldEquipment = getEquipmentData(oldEquipmentId);
        if (oldEquipment) {
          const sellPrice = Math.floor((oldEquipment.price || 50) / 2);
          hero.stats.gold += sellPrice;
          pushLog(`è‡ªå‹•è³£æ‰äº†è¢«å–ä»£çš„ ${oldEquipment.name}ï¼Œç²å¾— ${sellPrice} é‡‘å¹£ã€‚`);
          
          // å¾è£å‚™åº«å­˜ä¸­ç§»é™¤èˆŠè£å‚™
          if (hero.equipmentInventory) {
            hero.equipmentInventory = hero.equipmentInventory.filter(id => id !== oldEquipmentId);
          }
          // å¦‚æœæ˜¯ç²¾è‰¯è£å‚™ï¼Œä¹Ÿè¦å¾superiorEquipmentä¸­ç§»é™¤
          if (oldEquipment.isSuperior && hero.superiorEquipment && hero.superiorEquipment[oldEquipmentId]) {
            delete hero.superiorEquipment[oldEquipmentId];
          }
        }
      }
      
      renderShop();
      renderAll();
      return;
    } else {
    }
  } else {
  }
  
  // åªè³¼è²·æ™‚ï¼Œç›´æ¥æ·»åŠ åˆ°è£å‚™åº«å­˜ï¼Œä¸é€²å…¥é“å…·è¢‹
  // ç¢ºä¿è£å‚™ä¸æœƒé€²å…¥é“å…·è¢‹
  if (!hero.equipmentInventory.includes(equipmentId)) {
    hero.equipmentInventory.push(equipmentId);
  }
  
  // é˜²ç¦¦æ€§æª¢æŸ¥ï¼šç¢ºä¿è£å‚™æ²’æœ‰è¢«éŒ¯èª¤åœ°æ·»åŠ åˆ°é“å…·è¢‹
  const itemEntry = hero.items.find(entry => entry.id === itemId);
  if (itemEntry && itemEntry.qty > 0) {
    // å¦‚æœç™¼ç¾è£å‚™åœ¨é“å…·è¢‹ä¸­ï¼Œç§»é™¤å®ƒï¼ˆé€™ä¸æ‡‰è©²ç™¼ç”Ÿï¼Œä½†ä½œç‚ºé˜²ç¦¦æªæ–½ï¼‰
    itemEntry.qty -= 1;
    if (itemEntry.qty <= 0) {
      hero.items = hero.items.filter(entry => entry.id !== itemId);
    }
  }
  
  pushLog(`è³¼è²·äº† ${equipment.name}ï¼ˆèŠ±è²» ${price} é‡‘å¹£ï¼Œå·²åŠ å…¥è£å‚™åº«å­˜ï¼‰ã€‚`);
  renderShop();
  renderAll();
}

// è³¼è²·é“å…·
function buyItem(itemId, price) {
  const hero = state.hero;
  if (!hero) return;
  
  const item = ITEM_LOOKUP.get(itemId);
  if (!item) {
    pushLog('é“å…·ä¸å­˜åœ¨ï¼');
    return;
  }
  
  if (hero.stats.gold < price) {
    pushLog('é‡‘å¹£ä¸è¶³ï¼');
    return;
  }
  
  // æª¢æŸ¥åº«å­˜æ˜¯å¦å·²æ»¿
  limitInventorySize();
  const currentItemCount = hero.items.filter(item => item.qty > 0).length;
  if (currentItemCount >= 8) {
    pushLog('é“å…·æ¬„å·²æ»¿ï¼è«‹å…ˆä¸Ÿæ£„æˆ–è³£å‡ºä¸€äº›é“å…·ã€‚');
    return;
  }
  
        if (hero.stats.gold == null) hero.stats.gold = 0;
  hero.stats.gold -= price;
  
  // æ·»åŠ åˆ°é“å…·æ¬„
  let itemEntry = hero.items.find(entry => entry.id === itemId);
  if (itemEntry) {
    itemEntry.qty += 1;
  } else {
    hero.items.push({ id: itemId, qty: 1 });
  }
  
  pushLog(`è³¼è²·äº† ${item.name}ï¼ˆèŠ±è²» ${price} é‡‘å¹£ï¼‰ã€‚`);
  renderShop();
  renderAll();
}

// è³¼è²·è£œçµ¦ï¼ˆå®Œå…¨æ¢å¾©ï¼‰
function buySupply(type, price = 200) {
  const hero = state.hero;
  if (!hero) return;
  
  if (type === 'heal') {
    if (hero.stats.gold >= price) {
        if (hero.stats.gold == null) hero.stats.gold = 0;
      hero.stats.gold -= price;
      hero.stats.hp = hero.stats.maxHp;
      hero.stats.mp = hero.stats.maxMp;
      pushLog(`è³¼è²·è£œçµ¦ä¸¦å®Œå…¨æ¢å¾©ï¼ˆèŠ±è²» ${price} é‡‘å¹£ï¼‰ã€‚`);
      renderShop();
      renderAll();
    } else {
      pushLog('é‡‘å¹£ä¸è¶³ï¼');
    }
  }
}

// è³£å‡ºé“å…·
// è™•ç†ä¸Ÿæ£„é“å…·ä»¥ç²å¾—æ–°é“å…·
function handleDropItemForNew(itemId) {
  const hero = state.hero;
  if (!hero || !state.ui.itemChoice) return;
  
  // ä¸Ÿæ£„é¸ä¸­çš„é“å…·
  dropItem(itemId);
  
  // æ·»åŠ æ–°é“å…·æˆ–è£å‚™
  if (state.ui.itemChoice.newItem) {
    const newItem = state.ui.itemChoice.newItem;
    let itemEntry = hero.items.find(entry => entry.id === newItem.id);
    if (itemEntry) {
      itemEntry.qty += newItem.qty;
    } else {
      hero.items.push({ id: newItem.id, qty: newItem.qty });
    }
    
    pushLog(`ç²å¾— ${newItem.name}${newItem.qty > 1 ? ` Ã—${newItem.qty}` : ''}ï¼`);
  } else if (state.ui.itemChoice.newEquipment) {
    const newEquipment = state.ui.itemChoice.newEquipment;
    const itemId = `equipment_${newEquipment.id}`;
    let itemEntry = hero.items.find(entry => entry.id === itemId);
    if (itemEntry) {
      itemEntry.qty += 1;
    } else {
      hero.items.push({ id: itemId, qty: 1 });
    }
    
    pushLog(`ç²å¾—è£å‚™ ${newEquipment.name}ï¼ˆå·²æ”¾å…¥é“å…·è¢‹ï¼‰ï¼`);
  }
  
  // æ¸…é™¤é¸æ“‡ç‹€æ…‹
  state.ui.itemChoice = null;
  renderAll();
}

// å”®è³£è£å‚™
function sellEquipment(equipmentId) {
  const hero = state.hero;
  if (!hero) return;
  
  const equipment = getEquipmentData(equipmentId);
  if (!equipment) return;
  
  // æª¢æŸ¥æ˜¯å¦æ­£åœ¨è£å‚™
  const isEquipped = Object.values(hero.equipment).includes(equipmentId);
  if (isEquipped) {
    pushLog('ç„¡æ³•å”®è³£æ­£åœ¨è£å‚™çš„è£å‚™ï¼è«‹å…ˆå¸ä¸‹ã€‚');
    renderShop();
    return;
  }
  
  // æª¢æŸ¥æ˜¯å¦åœ¨è£å‚™åº«å­˜ä¸­
  const hasInInventory = hero.equipmentInventory && hero.equipmentInventory.includes(equipmentId);
  
  // æª¢æŸ¥æ˜¯å¦åœ¨é“å…·è¢‹ä¸­
  const itemId = `equipment_${equipmentId}`;
  const itemEntry = hero.items.find(entry => entry.id === itemId && entry.qty > 0);
  const hasInBag = !!itemEntry;
  
  if (!hasInInventory && !hasInBag) {
    pushLog('ä½ æ²’æœ‰é€™ä»¶è£å‚™ï¼');
    renderShop();
    return;
  }
  
  // æª¢æŸ¥æ˜¯å¦ç‚ºç¾…å¾·è£å‚™ï¼ˆtier 99 æˆ– id ä»¥ rod_ é–‹é ­ï¼‰
  const isRodEquipment = equipment.tier === 99 || equipmentId.startsWith('rod_');
  
  // ç¾…å¾·è£å‚™å¯ä»¥è³£å‡ºï¼Œä½†åƒ¹æ ¼ç‚º 0ï¼ˆå› ç‚º price ç‚º 0ï¼‰
  const sellPrice = Math.floor((equipment.price || 50) / 2);
  
  // å¾è£å‚™åº«å­˜ä¸­ç§»é™¤ï¼ˆä½¿ç”¨ splice ä¿æŒé¡ºåºï¼‰
  if (hasInInventory) {
    const invIndex = hero.equipmentInventory.indexOf(equipmentId);
    if (invIndex > -1) {
      hero.equipmentInventory.splice(invIndex, 1);
    }
    // å¦‚æœæ˜¯ç²¾è‰¯è£å‚™ï¼Œä¹Ÿè¦å¾superiorEquipmentä¸­ç§»é™¤
    if (equipment.isSuperior && hero.superiorEquipment && hero.superiorEquipment[equipmentId]) {
      delete hero.superiorEquipment[equipmentId];
    }
  }
  
  // å¾é“å…·è¢‹ä¸­ç§»é™¤
  if (hasInBag) {
    itemEntry.qty -= 1;
    // å¦‚æœæ•¸é‡ç‚º0ï¼Œç«‹å³å¾æ•¸çµ„ä¸­ç§»é™¤ï¼ˆä½¿ç”¨ splice ä¿æŒé¡ºåºï¼‰
    if (itemEntry.qty <= 0) {
      const index = hero.items.findIndex(entry => entry.id === itemId);
      if (index > -1) {
        hero.items.splice(index, 1);
      }
    }
    // å¦‚æœæ˜¯ç²¾è‰¯è£å‚™ï¼Œä¹Ÿè¦å¾superiorEquipmentä¸­ç§»é™¤
    if (equipment.isSuperior && hero.superiorEquipment && hero.superiorEquipment[equipmentId]) {
      delete hero.superiorEquipment[equipmentId];
    }
  }
  
  if (hero.stats.gold == null) hero.stats.gold = 0;
  hero.stats.gold += sellPrice;
  pushLog(`å”®è³£äº† ${equipment.name}ï¼Œç²å¾— ${sellPrice} é‡‘å¹£ã€‚`);
  
  // ç¢ºä¿ä¿æŒåœ¨è³£å‡ºæ¨™ç±¤é 
  if (state.ui.shop) {
    state.ui.shop.type = 'sell';
  }
  
  // æ¸…ç†ç©ºçš„è£…å¤‡åº“å­˜å’Œæ•°é‡ä¸º0çš„ç‰©å“ï¼ˆä¿æŒé¡ºåºï¼‰
  if (hero.equipmentInventory) {
    hero.equipmentInventory = hero.equipmentInventory.filter(id => id != null);
  }
  // æ¸…ç†æ•°é‡ä¸º0çš„ç‰©å“ï¼Œç¡®ä¿ä¸ä¼šåœ¨å–å‡ºåˆ—è¡¨ä¸­æ˜¾ç¤º
  hero.items = hero.items.filter(entry => entry && entry.qty > 0);
  renderShop();
  renderAll();
}

function sellItem(itemId, price) {
  const hero = state.hero;
  if (!hero) return;
  
  const itemEntry = hero.items.find(entry => entry.id === itemId && entry.qty > 0);
  if (!itemEntry) {
    pushLog('æ²’æœ‰é€™å€‹é“å…·ï¼');
    renderShop();
    return;
  }
  
  const item = ITEM_LOOKUP.get(itemId);
  if (!item) {
    renderShop();
    return;
  }
  
  // è³£å‡ºåƒ¹æ ¼ç‚ºè³¼è²·åƒ¹æ ¼çš„ä¸€åŠ
  const sellPrice = price || Math.floor((item.price || 10) / 2);
  
  // æ¸›å°‘æ•¸é‡
  itemEntry.qty -= 1;
  
  // å¦‚æœæ•¸é‡ç‚º0ï¼Œå¾æ•¸çµ„ä¸­ç§»é™¤è©²ç‰©å“ï¼ˆä½¿ç”¨ splice ä¿æŒé¡ºåºï¼‰
  if (itemEntry.qty <= 0) {
    const index = hero.items.findIndex(entry => entry.id === itemId && entry.qty <= 0);
    if (index > -1) {
      hero.items.splice(index, 1);
    }
  }
  
  if (hero.stats.gold == null) hero.stats.gold = 0;
  hero.stats.gold += sellPrice;
  pushLog(`è³£å‡ºäº†${item.name}ï¼ˆç²å¾— ${sellPrice} é‡‘å¹£ï¼‰ã€‚`);
  
  // ç¢ºä¿ä¿æŒåœ¨è³£å‡ºæ¨™ç±¤é 
  if (state.ui.shop) {
    state.ui.shop.type = 'sell';
  }
  
  renderShop();
  renderAll();
}

function checkLevelUp() {
  const hero = state.hero;
  // ä¿å­˜æœ€åˆå‡ç´šå‰çš„æ•¸å€¼ï¼ˆç”¨æ–¼é¡¯ç¤ºï¼‰
  const initialOldLevel = hero.stats.level;
  const initialOldMaxHp = hero.stats.maxHp;
  const initialOldMaxMp = hero.stats.maxMp;
  const initialOldAttributes = { ...hero.attributes };
  
  let totalHpGain = 0;
  let totalMpGain = 0;
  let levelsGained = 0;
  
  // é€£çºŒå‡ç´šï¼Œç›´åˆ°ç¶“é©—å€¼ä¸è¶³
  while (hero.stats.xp >= hero.stats.nextLevelXp) {
    hero.stats.xp -= hero.stats.nextLevelXp;
    hero.stats.level += 1;
    levelsGained += 1;
    // æ¯å€‹ç­‰ç´šå¤š30%çš„éœ€æ±‚
    hero.stats.nextLevelXp = Math.round(hero.stats.nextLevelXp * 1.3);
    const hpGain = rollHpGrowth(hero);
    const mpGain = rollMpGrowth(hero);
    totalHpGain += hpGain;
    totalMpGain += mpGain;
    hero.stats.maxHp = Math.ceil(hero.stats.maxHp + hpGain);
    hero.stats.maxMp = Math.ceil(hero.stats.maxMp + mpGain);
    // å‡ç´šæ™‚ä¸æ¢å¾©HPï¼Œåªå¢åŠ æœ€å¤§HP
    // hero.stats.hp = hero.stats.maxHp; // å·²ç§»é™¤ï¼šå‡ç´šæ™‚ä¸å†æ¢å¾©HP
    // å‡ç´šæ™‚åªè£œå……æ–°å¢çš„MPæ•¸é‡
    hero.stats.mp = Math.ceil(Math.min(hero.stats.maxMp, hero.stats.mp + mpGain));
    
    // å±¬æ€§æå‡æ”¹ç‚ºç©å®¶é¸æ“‡ï¼Œä¸åœ¨é€™è£¡è‡ªå‹•æå‡
    // æ ¹æ“šè·æ¥­é¡å‹é¡å¤–åŠ æˆï¼ˆä¿ç•™ï¼Œå› ç‚ºé€™æ˜¯è·æ¥­ç‰¹æ€§ï¼‰
    if (hero.heroType && HERO_TYPES[hero.heroType]) {
      const type = HERO_TYPES[hero.heroType];
      Object.keys(type.levelUpBonus).forEach((attr) => {
        hero.attributes[attr] += type.levelUpBonus[attr];
      });
    }
    
    // æ¯é …å±¬æ€§éš¨æ©Ÿæˆé•·ï¼ˆheroGrowthMin åˆ° heroGrowthMaxï¼‰
    const heroGrowthMin = GAME_CONFIG.heroGrowthMin || 1;
    const heroGrowthMax = GAME_CONFIG.heroGrowthMax || 2.5;
    ATTRIBUTES.forEach((attr) => {
      // ç”Ÿæˆ heroGrowthMin åˆ° heroGrowthMax ä¹‹é–“çš„éš¨æ©Ÿå°æ•¸
      const randomGain = Math.random() * (heroGrowthMax - heroGrowthMin) + heroGrowthMin;
      hero.attributes[attr.id] = (hero.attributes[attr.id] || 0) + randomGain;
    });
    
    // 20ç´šè‡ªå‹•ç¿’å¾—å¾©æ´»è¡“
    if (hero.stats.level === 20) {
      const reviveSkill = SKILL_LOOKUP.get('revive_companion');
      if (reviveSkill && !hero.skills.includes('revive_companion')) {
        learnSkill(reviveSkill);
        pushLog(`å‡åˆ° Lv 20ï¼Œè‡ªå‹•ç¿’å¾—ã€Œ${reviveSkill.name}ã€ï¼`);
      }
    }
  }
  
  // å¦‚æœæœ‰å‡ç´šï¼Œé¡¯ç¤ºå‡ç´šç•«é¢
  if (levelsGained > 0) {
    pushLog(`å‡åˆ° Lv ${hero.stats.level}ï¼HP +${totalHpGain} / MP +${totalMpGain}${levelsGained > 1 ? `ï¼ˆé€£å‡${levelsGained}ç´šï¼‰` : ''}`);
    
    // æª¢æŸ¥æ˜¯å¦æ‡‰è©²ç²å¾—æŠ€èƒ½ï¼ˆæ¯å…©ç´šä¸€æ¬¡ï¼‰
    // æª¢æŸ¥å‡ç´šéç¨‹ä¸­æ˜¯å¦ç¶“éäº†ä»»ä½•å¶æ•¸ç­‰ç´š
    let shouldGetSkill = false;
    for (let level = initialOldLevel + 1; level <= hero.stats.level; level++) {
      if (level % 2 === 0) {
        shouldGetSkill = true;
        break;
      }
    }
    
    // è¨˜éŒ„éœ€è¦é¸æ“‡çš„å±¬æ€§ï¼ˆæ¯å‡ä¸€ç´šéœ€è¦é¸æ“‡ä¸€æ¬¡ï¼‰
    const attributeSelections = [];
    for (let level = initialOldLevel + 1; level <= hero.stats.level; level++) {
      const attributeBonus = Math.ceil(level / 20); // ç­‰ç´š/20ç„¡æ¢ä»¶é€²ä½
      attributeSelections.push({
        level: level,
        bonus: attributeBonus,
        selected: false, // æ˜¯å¦å·²é¸æ“‡
      });
    }
    
    state.ui.levelUp = {
      step: 'stats', // å…ˆé¡¯ç¤ºèƒ½åŠ›æå‡ï¼ˆHP/MP/è·æ¥­åŠ æˆï¼‰
      oldLevel: initialOldLevel,
      oldMaxHp: initialOldMaxHp,
      oldMaxMp: initialOldMaxMp,
      oldAttributes: initialOldAttributes,
      hpGain: totalHpGain,
      mpGain: totalMpGain,
      skillOptions: [],
      shouldGetSkill, // æ¨™è¨˜æ˜¯å¦æ‡‰è©²ç²å¾—æŠ€èƒ½
      isInitialAutoLevel: false, // æ¨™è¨˜é€™ä¸æ˜¯åˆå§‹è‡ªå‹•å‡ç´šï¼Œæ˜¯æˆ°é¬¥å¾Œçš„å‡ç´š
      attributeSelections: attributeSelections, // éœ€è¦é¸æ“‡çš„å±¬æ€§åˆ—è¡¨
      currentAttributeSelectionIndex: 0, // ç•¶å‰æ­£åœ¨é¸æ“‡çš„å±¬æ€§ç´¢å¼•
    };
    
    // å¦‚æœæ‡‰è©²ç²å¾—æŠ€èƒ½ï¼Œç”ŸæˆæŠ€èƒ½é¸é …
    if (shouldGetSkill) {
      state.ui.levelUp.skillOptions = rollSkillOptions();
    }
    
    // åŒæ­¥å‡ç´šæ‰€æœ‰åŒä¼´ï¼Œæ”¶é›†æ‰€æœ‰åŒä¼´çš„å‡ç´šä¿¡æ¯
    const activeCompanions = (state.companions || []).filter(c => c && c.stats);
    const companionUpgrades = [];
    
    // å‡ç´šæ‰€æœ‰åŒä¼´
    activeCompanions.forEach(companion => {
      const upgradeInfo = levelUpCompanion(companion, levelsGained);
      if (upgradeInfo) {
        companionUpgrades.push(upgradeInfo);
      }
    });
    
    // ä¿å­˜æ‰€æœ‰åŒä¼´çš„å‡ç´šä¿¡æ¯
    if (companionUpgrades.length > 0) {
      state.ui.levelUp.companionUpgrades = companionUpgrades;
      state.ui.levelUp.currentCompanionIndex = 0; // ç•¶å‰æ­£åœ¨è™•ç†çš„åŒä¼´ç´¢å¼•
    }
    
    renderAll();
  }
}

// åŒä¼´å‡ç´šç³»çµ±
function levelUpCompanion(companion, levelsGained) {
  if (!companion) return null;
  
  // ä¿å­˜å‡ç´šå‰çš„æ•¸å€¼ï¼ˆç”¨æ–¼é¡¯ç¤ºï¼‰
  const initialOldLevel = companion.stats.level;
  const initialOldMaxHp = companion.stats.maxHp;
  const initialOldMaxMp = companion.stats.maxMp;
  const initialOldAttributes = { ...companion.attributes };
  
  // è®“åŒä¼´ç­‰ç´šè·Ÿéš¨ä¸»è§’
  companion.stats.level = state.hero.stats.level;
  
  // è¨ˆç®—éœ€è¦å‡ç´šçš„ç­‰ç´šæ•¸
  const levelsToGain = companion.stats.level - initialOldLevel;
  if (levelsToGain <= 0) return null;
  
  let totalHpGain = 0;
  let totalMpGain = 0;
  
  // è¨˜éŒ„éœ€è¦é¸æ“‡çš„å±¬æ€§ï¼ˆæ¯å‡ä¸€ç´šéœ€è¦é¸æ“‡ä¸€æ¬¡ï¼‰
  const attributeSelections = [];
  // è¨˜éŒ„éœ€è¦é¸æ“‡çš„æŠ€èƒ½ï¼ˆæ¯ä¸‰ç´šæˆ–æ¯10ç´šï¼‰
  const skillSelections = [];
  
  for (let i = 0; i < levelsToGain; i++) {
    const currentLevel = initialOldLevel + i + 1;
    companion.stats.level = currentLevel;
    
    const hpGain = rollCompanionHpGrowth(companion);
    const mpGain = rollCompanionMpGrowth(companion);
    totalHpGain += hpGain;
    totalMpGain += mpGain;
    companion.stats.maxHp = Math.ceil(companion.stats.maxHp + hpGain);
    companion.stats.maxMp = Math.ceil(companion.stats.maxMp + mpGain);
    companion.stats.mp = Math.ceil(Math.min(companion.stats.maxMp, companion.stats.mp + mpGain));
    
    // è¨˜éŒ„éœ€è¦é¸æ“‡çš„å±¬æ€§ï¼ˆç­‰ç´š/20 ç„¡æ¢ä»¶é€²ä½ï¼‰
    const attributeBonus = Math.ceil(currentLevel / 20);
    attributeSelections.push({
      level: currentLevel,
      bonus: attributeBonus,
      selected: false,
    });
    
    // æ ¹æ“šåŒä¼´é¡å‹é¡å¤–åŠ æˆï¼ˆä½¿ç”¨åŒä¼´è‡ªå·±çš„é¡å‹åŠ æˆï¼‰- é€™å€‹ä¿ç•™è‡ªå‹•å¢åŠ 
    const companionType = COMPANION_TYPES[companion.companionTypeId];
    if (companionType && companionType.levelUpBonus) {
      Object.keys(companionType.levelUpBonus).forEach((attr) => {
        companion.attributes[attr] += companionType.levelUpBonus[attr];
      });
    }
    
    // æ‡‰ç”¨å€‹æ€§ä¿®æ­£ï¼ˆæ¯ç­‰ç´šåŠ æˆï¼Œä¿æŒå°æ•¸é»ï¼‰- é€™å€‹ä¿ç•™è‡ªå‹•å¢åŠ 
    const personalityId = companion.personalityId || 'balanced';
    const personality = COMPANION_PERSONALITIES[personalityId];
    if (personality && personality.attributeModifiers) {
      Object.keys(personality.attributeModifiers).forEach((attr) => {
        const modifier = personality.attributeModifiers[attr]; // ä¸å†æ¸›åŠ
        // ç›´æ¥ç´¯åŠ ä¿®æ­£å€¼ï¼Œä¿æŒå°æ•¸é»ï¼ˆä¸å››æ¨äº”å…¥ï¼‰
        companion.attributes[attr] = (companion.attributes[attr] || 0) + modifier;
      });
    }
    
    // æ¯é …å±¬æ€§éš¨æ©Ÿæˆé•·ï¼ˆcompanionGrowthMin åˆ° companionGrowthMaxï¼‰
    const companionGrowthMin = GAME_CONFIG.companionGrowthMin || 0.3;
    const companionGrowthMax = GAME_CONFIG.companionGrowthMax || 2.0;
    ATTRIBUTES.forEach((attr) => {
      // ç”Ÿæˆ companionGrowthMin åˆ° companionGrowthMax ä¹‹é–“çš„éš¨æ©Ÿå°æ•¸
      const randomGain = Math.random() * (companionGrowthMax - companionGrowthMin) + companionGrowthMin;
      companion.attributes[attr.id] = (companion.attributes[attr.id] || 0) + randomGain;
    });
    
    // æ¯ä¸‰ç´šç²å¾—ä¸€å€‹æŠ€èƒ½ï¼ˆæ”¹ç‚ºæ‰‹å‹•é¸æ“‡ï¼Œæœ¬è·æ¥­æŠ€èƒ½ï¼‰
    if (currentLevel % 3 === 0 && currentLevel >= 3) {
    const skillOptions = rollCompanionSkillOptions(companion);
    if (skillOptions.length > 0) {
        // è¨˜éŒ„éœ€è¦é¸æ“‡çš„æŠ€èƒ½ï¼ˆéš¨æ©Ÿé¸æ“‡4å€‹é¸é …ï¼‰
        const selectedOptions = [];
        const shuffled = [...skillOptions].sort(() => Math.random() - 0.5);
        for (let j = 0; j < Math.min(4, shuffled.length); j++) {
          selectedOptions.push(shuffled[j]);
        }
        skillSelections.push({
          level: currentLevel,
          type: 'class', // æœ¬è·æ¥­æŠ€èƒ½
          options: selectedOptions,
          selected: false,
        });
      }
    }
    
    // æ¯10ç´šï¼šç²å¾—å…¶ä»–è·æ¥­çš„è¢«å‹•æŠ€èƒ½ï¼ˆ10, 20, 30, 40, 50, 60...ï¼‰
    if (currentLevel % 10 === 0 && currentLevel >= 10) {
      const otherClassPassiveSkillOptions = rollOtherClassPassiveSkillOptions(companion);
      if (otherClassPassiveSkillOptions.length > 0) {
        // è¨˜éŒ„éœ€è¦é¸æ“‡çš„æŠ€èƒ½ï¼ˆéš¨æ©Ÿé¸æ“‡4å€‹é¸é …ï¼‰
        const selectedOptions = [];
        const shuffled = [...otherClassPassiveSkillOptions].sort(() => Math.random() - 0.5);
        for (let j = 0; j < Math.min(4, shuffled.length); j++) {
          selectedOptions.push(shuffled[j]);
        }
        skillSelections.push({
          level: currentLevel,
          type: 'other-class', // å…¶ä»–è·æ¥­è¢«å‹•æŠ€èƒ½
          options: selectedOptions,
          selected: false,
        });
      }
    }
  }
  
  // è¿”å›å‡ç´šä¿¡æ¯
  return {
    companion: companion, // ä¿å­˜åŒä¼´å¼•ç”¨
    oldLevel: initialOldLevel,
    oldMaxHp: initialOldMaxHp,
    oldMaxMp: initialOldMaxMp,
    oldAttributes: initialOldAttributes,
    hpGain: totalHpGain,
    mpGain: totalMpGain,
    attributeSelections: attributeSelections, // éœ€è¦é¸æ“‡çš„å±¬æ€§åˆ—è¡¨
    skillSelections: skillSelections, // éœ€è¦é¸æ“‡çš„æŠ€èƒ½åˆ—è¡¨
    currentAttributeSelectionIndex: 0, // ç•¶å‰æ­£åœ¨é¸æ“‡çš„å±¬æ€§ç´¢å¼•
    currentSkillSelectionIndex: 0, // ç•¶å‰æ­£åœ¨é¸æ“‡çš„æŠ€èƒ½ç´¢å¼•
  };
}

// ç‚ºåŒä¼´ç”ŸæˆæŠ€èƒ½é¸é …ï¼ˆåªè¿”å›è©²æµæ´¾çš„æŠ€èƒ½ï¼‰
function rollCompanionSkillOptions(companion) {
  if (!companion || !companion.heroType) return [];
  
  // æ ¹æ“šåŒä¼´é¡å‹ç¢ºå®šæµæ´¾
  const flowMap = {
    attacker: 'sword',
    defender: 'defender',
    mage: 'magic',
    healer: 'recovery',
    agile: 'agility',
    sage: ['magic', 'recovery'], // è³¢è€…å¯ä»¥å­¸ç¿’é­”æ³•å’Œå›å¾©å…©ç¨®æµæ´¾
    paladin: ['defender', 'recovery'], // è–é¨å£«å¯ä»¥å­¸ç¿’é˜²å®ˆå’Œå›å¾©å…©ç¨®æµæ´¾
    weaponmaster: ['sword', 'agility'], // æ­¦å™¨å¤§å¸«å¯ä»¥å­¸ç¿’åŠå£«å’Œç›œè³Šå…©ç¨®æµæ´¾
  };
  
  // ç²å–ä¸»è¦æµæ´¾ï¼ˆå¯èƒ½æ˜¯å–®ä¸€æµæ´¾æˆ–æµæ´¾æ•¸çµ„ï¼‰
  const primaryFlowOrFlows = flowMap[companion.heroType] || 'sword';
  const primaryFlows = Array.isArray(primaryFlowOrFlows) ? primaryFlowOrFlows : [primaryFlowOrFlows];
  
  const heroLevel = companion.stats.level;
  const owned = new Set(companion.skills);
  
  // å¾è©²æµæ´¾ï¼ˆæˆ–å¤šå€‹æµæ´¾ï¼‰ä¸­é¸æ“‡å¯ç”¨çš„æŠ€èƒ½
  const candidates = [];
  primaryFlows.forEach(primaryFlow => {
  SKILL_CHAINS.filter((chain) => chain.flow === primaryFlow).forEach((chain) => {
    // æ‰¾å‡ºè©²æŠ€èƒ½éˆä¸­å·²ç¶“å­¸æœƒçš„æœ€é«˜ç­‰ç´šæŠ€èƒ½
    let maxLearnedTier = 0;
    chain.steps.forEach((step) => {
      if (owned.has(step.id)) {
        maxLearnedTier = Math.max(maxLearnedTier, step.tier);
      }
    });
    
    chain.steps.forEach((step) => {
      // æª¢æŸ¥ç­‰ç´šè¦æ±‚
      if (heroLevel < step.requiredLevel) return;
      
      // æª¢æŸ¥æ˜¯å¦å·²æ“æœ‰
      if (owned.has(step.id)) return;
      
      // æª¢æŸ¥æ˜¯å¦å·²ç¶“å­¸æœƒäº†æ›´é«˜ç­‰ç´šçš„æŠ€èƒ½ï¼ˆä¸æ‡‰è©²å‡ºç¾æ›´ä½ç­‰ç´šçš„æŠ€èƒ½ï¼‰
      if (maxLearnedTier > 0 && step.tier < maxLearnedTier) {
        return; // å·²ç¶“å­¸æœƒäº†æ›´é«˜ç­‰ç´šçš„æŠ€èƒ½ï¼Œä¸æ‡‰è©²å†å‡ºç¾ä½ç­‰ç´šçš„æŠ€èƒ½
      }
      
      // æª¢æŸ¥æ˜¯å¦éœ€è¦å‰ä¸€éšï¼ˆé™¤äº†ç¬¬1éšï¼‰
      if (step.tier > 1) {
        const prevStep = chain.steps.find(s => s.tier === step.tier - 1);
        if (prevStep && !owned.has(prevStep.id)) {
          return; // éœ€è¦å‰ä¸€éšä½†æœªå­¸ç¿’
        }
      }
      
      // å¯ä»¥å­¸ç¿’ï¼ŒåŠ å…¥å€™é¸åˆ—è¡¨
      candidates.push({ 
        ...step, 
        flow: chain.flow, // ä½¿ç”¨å¯¦éš›çš„æµæ´¾ï¼Œè€Œä¸æ˜¯ primaryFlowï¼ˆå› ç‚ºå¯èƒ½æ˜¯å¤šæµæ´¾ï¼‰
        chainId: chain.id,
        aoe: chain.aoe || false,
      });
      });
    });
  });
  
  // è¿”å›æ‰€æœ‰å€™é¸æŠ€èƒ½ï¼ˆè®“èª¿ç”¨è€…é¸æ“‡ï¼‰
  return candidates;
}

// ç‚ºåŒä¼´ç”Ÿæˆå…¶ä»–è·æ¥­çš„æŠ€èƒ½é¸é …ï¼ˆæ’é™¤è‡ªå·±çš„æµæ´¾ã€å‹‡è€…æ–¬å’Œå‹‡è€…çš„æŠ€èƒ½ï¼‰
function rollOtherClassSkillOptions(companion) {
  if (!companion || !companion.heroType) return [];
  
  // æ ¹æ“šåŒä¼´é¡å‹ç¢ºå®šæµæ´¾
  const flowMap = {
    attacker: 'sword',
    defender: 'defender',
    mage: 'magic',
    healer: 'recovery',
    agile: 'agility',
    sage: ['magic', 'recovery'], // è³¢è€…å¯ä»¥å­¸ç¿’é­”æ³•å’Œå›å¾©å…©ç¨®æµæ´¾
    paladin: ['defender', 'recovery'], // è–é¨å£«å¯ä»¥å­¸ç¿’é˜²å®ˆå’Œå›å¾©å…©ç¨®æµæ´¾
    weaponmaster: ['sword', 'agility'], // æ­¦å™¨å¤§å¸«å¯ä»¥å­¸ç¿’åŠå£«å’Œç›œè³Šå…©ç¨®æµæ´¾
  };
  
  // ç²å–ä¸»è¦æµæ´¾ï¼ˆå¯èƒ½æ˜¯å–®ä¸€æµæ´¾æˆ–æµæ´¾æ•¸çµ„ï¼‰
  const primaryFlowOrFlows = flowMap[companion.heroType] || 'sword';
  const primaryFlows = Array.isArray(primaryFlowOrFlows) ? primaryFlowOrFlows : [primaryFlowOrFlows];
  
  const heroLevel = companion.stats.level;
  const owned = new Set(companion.skills);
  
  // ç²å–å‹‡è€…å·²å­¸ç¿’çš„æŠ€èƒ½IDé›†åˆï¼ˆç”¨æ–¼æ’é™¤ï¼‰
  const heroSkillIds = new Set();
  const hero = state.hero;
  if (hero && hero.skills && hero.skills.length > 0) {
    hero.skills.forEach((skillId) => {
      heroSkillIds.add(skillId);
    });
  }
  
  // å¾å…¶ä»–æµæ´¾ä¸­é¸æ“‡ä¸€å€‹å¯ç”¨çš„æŠ€èƒ½ï¼ˆæ’é™¤è‡ªå·±çš„æµæ´¾ã€å‹‡è€…æ–¬æµæ´¾å’Œè¢«å‹•æŠ€èƒ½ï¼Œä»¥åŠå‹‡è€…çš„æŠ€èƒ½ï¼‰
  const candidates = [];
  SKILL_CHAINS.filter((chain) => {
    // æ’é™¤è‡ªå·±çš„æµæ´¾ï¼ˆå¦‚æœæ˜¯å¤šæµæ´¾ï¼Œæ’é™¤æ‰€æœ‰ä¸»è¦æµæ´¾ï¼‰
    if (primaryFlows.includes(chain.flow)) return false;
    // æ’é™¤å‹‡è€…æ–¬æµæ´¾ï¼ˆflow === 'hero'ï¼‰
    if (chain.flow === 'hero') return false;
    return true;
  }).forEach((chain) => {
    // åªé¸æ“‡ç¬¬1éšæŠ€èƒ½ï¼ˆç°¡åŒ–é‚è¼¯ï¼Œé¿å…éœ€è¦å‰ç½®æŠ€èƒ½ï¼‰
    chain.steps.forEach((step) => {
      // åªé¸æ“‡ç¬¬1éšæŠ€èƒ½
      if (step.tier !== 1) return;
      
      // æª¢æŸ¥ç­‰ç´šè¦æ±‚
      if (heroLevel < step.requiredLevel) return;
      
      // æª¢æŸ¥æ˜¯å¦å·²æ“æœ‰
      if (owned.has(step.id)) return;
      
      // æ’é™¤å‹‡è€…çš„æŠ€èƒ½
      if (heroSkillIds.has(step.id)) return;
      
      // æ’é™¤è¢«å‹•æŠ€èƒ½
      if (step.kind === 'passive') return;
      
      // å¯ä»¥å­¸ç¿’ï¼ŒåŠ å…¥å€™é¸åˆ—è¡¨
      candidates.push({ 
        ...step, 
        flow: chain.flow,
        chainId: chain.id,
        aoe: chain.aoe || false,
      });
    });
  });
  
  // è¿”å›æ‰€æœ‰å€™é¸æŠ€èƒ½ï¼ˆè®“èª¿ç”¨è€…é¸æ“‡ï¼‰
  return candidates;
}

// ç‚ºåŒä¼´ç”Ÿæˆå…¶ä»–è·æ¥­çš„è¢«å‹•æŠ€èƒ½é¸é …ï¼ˆåªè¿”å›å…¶ä»–æµæ´¾çš„è¢«å‹•æŠ€èƒ½ï¼‰
function rollOtherClassPassiveSkillOptions(companion) {
  if (!companion || !companion.heroType) return [];
  
  // æ ¹æ“šåŒä¼´é¡å‹ç¢ºå®šæµæ´¾
  const flowMap = {
    attacker: 'sword',
    defender: 'defender',
    mage: 'magic',
    healer: 'recovery',
    agile: 'agility',
    sage: ['magic', 'recovery'], // è³¢è€…å¯ä»¥å­¸ç¿’é­”æ³•å’Œå›å¾©å…©ç¨®æµæ´¾
    paladin: ['defender', 'recovery'], // è–é¨å£«å¯ä»¥å­¸ç¿’é˜²å®ˆå’Œå›å¾©å…©ç¨®æµæ´¾
    weaponmaster: ['sword', 'agility'], // æ­¦å™¨å¤§å¸«å¯ä»¥å­¸ç¿’åŠå£«å’Œç›œè³Šå…©ç¨®æµæ´¾
  };
  
  // ç²å–ä¸»è¦æµæ´¾ï¼ˆå¯èƒ½æ˜¯å–®ä¸€æµæ´¾æˆ–æµæ´¾æ•¸çµ„ï¼‰
  const primaryFlowOrFlows = flowMap[companion.heroType] || 'sword';
  const primaryFlows = Array.isArray(primaryFlowOrFlows) ? primaryFlowOrFlows : [primaryFlowOrFlows];
  
  const heroLevel = companion.stats.level;
  const owned = new Set(companion.skills);
  
  // ç²å–å‹‡è€…å·²å­¸ç¿’çš„æŠ€èƒ½IDé›†åˆï¼ˆç”¨æ–¼æ’é™¤ï¼‰
  const heroSkillIds = new Set();
  const hero = state.hero;
  if (hero && hero.skills && hero.skills.length > 0) {
    hero.skills.forEach((skillId) => {
      heroSkillIds.add(skillId);
    });
  }
  
  // å¾å…¶ä»–æµæ´¾ä¸­é¸æ“‡ä¸€å€‹å¯ç”¨çš„è¢«å‹•æŠ€èƒ½ï¼ˆæ’é™¤è‡ªå·±çš„æµæ´¾ã€å‹‡è€…æ–¬æµæ´¾ï¼Œä»¥åŠå‹‡è€…çš„æŠ€èƒ½ï¼‰
  const candidates = [];
  SKILL_CHAINS.filter((chain) => {
    // æ’é™¤è‡ªå·±çš„æµæ´¾ï¼ˆå¦‚æœæ˜¯å¤šæµæ´¾ï¼Œæ’é™¤æ‰€æœ‰ä¸»è¦æµæ´¾ï¼‰
    if (primaryFlows.includes(chain.flow)) return false;
    // æ’é™¤å‹‡è€…æ–¬æµæ´¾ï¼ˆflow === 'hero'ï¼‰
    if (chain.flow === 'hero') return false;
    return true;
  }).forEach((chain) => {
    // åªé¸æ“‡ç¬¬1éšè¢«å‹•æŠ€èƒ½
    chain.steps.forEach((step) => {
      // åªé¸æ“‡ç¬¬1éšæŠ€èƒ½
      if (step.tier !== 1) return;
      
      // æª¢æŸ¥ç­‰ç´šè¦æ±‚
      if (heroLevel < step.requiredLevel) return;
      
      // æª¢æŸ¥æ˜¯å¦å·²æ“æœ‰
      if (owned.has(step.id)) return;
      
      // æ’é™¤å‹‡è€…çš„æŠ€èƒ½
      if (heroSkillIds.has(step.id)) return;
      
      // åªé¸æ“‡è¢«å‹•æŠ€èƒ½
      if (step.kind !== 'passive') return;
      
      // å¯ä»¥å­¸ç¿’ï¼ŒåŠ å…¥å€™é¸åˆ—è¡¨
      candidates.push({ 
        ...step, 
        flow: chain.flow,
        chainId: chain.id,
        aoe: chain.aoe || false,
      });
    });
  });
  
  return candidates;
}

// å‡ç´šåŒä¼´çš„æŠ€èƒ½éˆï¼ˆæ ¹æ“šchainIdå’Œç›®æ¨™tierï¼‰
function upgradeCompanionSkillChain(companion, chainId, targetTier) {
  if (!companion || !chainId || !targetTier) return null;
  
  const chain = SKILL_CHAINS.find(c => c.id === chainId);
  if (!chain) return null;
  
  // æ‰¾åˆ°ç›®æ¨™tierçš„æŠ€èƒ½
  const targetSkill = chain.steps.find(step => step.tier === targetTier);
  if (!targetSkill) return null;
  
  // æª¢æŸ¥ç­‰ç´šè¦æ±‚
  if (companion.stats.level < (targetSkill.requiredLevel || 0)) return null;
  
  // æª¢æŸ¥æ˜¯å¦å·²ç¶“å­¸ç¿’äº†æ›´é«˜éšçš„æŠ€èƒ½
  const hasHigherTier = chain.steps.some((step) => {
    if (step.tier > targetTier && companion.skills.includes(step.id)) {
      return true;
    }
    return false;
  });
  
  if (hasHigherTier) {
    // å·²ç¶“å­¸ç¿’äº†æ›´é«˜éšçš„æŠ€èƒ½ï¼Œä¸éœ€è¦å‡ç´š
    return null;
  }
  
  // è¿”å›ç›®æ¨™æŠ€èƒ½
  return {
    ...targetSkill,
    flow: chain.flow,
    chainId: chain.id,
    aoe: chain.aoe || false,
  };
}

function rollHpGrowth(hero) {
  // æ¯ç­‰ç´šæˆé•· = 3 + éš¨æ©Ÿ(0 åˆ° é«”åŠ›å€¼/7 å››æ¨äº”å…¥é€²ä½)ï¼Œæœ€å¾Œå–æ•´æ•¸
  const totalAttrs = getHeroTotalAttributes(hero);
  const vitality = totalAttrs.vitality;
  const maxRandom = Math.ceil(vitality / 7); // é«”åŠ›å€¼/7 å››æ¨äº”å…¥é€²ä½
  const randomValue = Math.floor(Math.random() * (maxRandom + 1)); // 0 åˆ° maxRandom ä¹‹é–“çš„éš¨æ©Ÿæ•´æ•¸
  return Math.floor(3 + randomValue); // 3 + éš¨æ©Ÿå€¼ï¼Œæœ€å¾Œå–æ•´æ•¸
}

function rollMpGrowth(hero) {
  // MPæˆé•· = éš¨æ©Ÿ(0 åˆ° (é­”åŠ›/15 + æ¢å¾©åŠ›/20) å‘ä¸Šå–æ•´)
  const totalAttrs = getHeroTotalAttributes(hero);
  const recovery = totalAttrs.recovery; // æ¢å¾©åŠ›
  const magic = totalAttrs.magic; // é­”åŠ›
  const maxRandom = Math.ceil(magic / 15 + recovery / 20); // é­”åŠ›/15 + æ¢å¾©åŠ›/20 å‘ä¸Šå–æ•´
  const randomValue = Math.floor(Math.random() * (maxRandom + 1)); // 0 åˆ° maxRandom ä¹‹é–“çš„éš¨æ©Ÿæ•´æ•¸
  return randomValue; // ç›´æ¥è¿”å›éš¨æ©Ÿå€¼
}

// åŒä¼´å°ˆç”¨çš„HP/MPæˆé•·å‡½æ•¸ï¼ˆä¸åŒ…å«è£å‚™åŠ æˆï¼‰
function rollCompanionHpGrowth(companion) {
  // æ¯ç­‰ç´šæˆé•· = 3 + éš¨æ©Ÿ(0 åˆ° é«”åŠ›å€¼/7 å››æ¨äº”å…¥é€²ä½)ï¼Œæœ€å¾Œå–æ•´æ•¸
  const totalAttrs = getCompanionTotalAttributes(companion);
  const vitality = totalAttrs.vitality;
  const maxRandom = Math.ceil(vitality / 7); // é«”åŠ›å€¼/7 å››æ¨äº”å…¥é€²ä½
  const randomValue = Math.floor(Math.random() * (maxRandom + 1)); // 0 åˆ° maxRandom ä¹‹é–“çš„éš¨æ©Ÿæ•´æ•¸
  return Math.floor(3 + randomValue); // 3 + éš¨æ©Ÿå€¼ï¼Œæœ€å¾Œå–æ•´æ•¸
}

function rollCompanionMpGrowth(companion) {
  // MPæˆé•· = 3 + éš¨æ©Ÿ(0 åˆ° (æ¢å¾©åŠ›/15 + é­”åŠ›/10) å‘ä¸Šå–æ•´)
  const totalAttrs = getCompanionTotalAttributes(companion);
  const recovery = totalAttrs.recovery; // æ¢å¾©åŠ›
  const magic = totalAttrs.magic; // é­”åŠ›
  const maxRandom = Math.ceil(recovery / 15 + magic / 10); // æ¢å¾©åŠ›/15 + é­”åŠ›/10 å‘ä¸Šå–æ•´
  const randomValue = Math.floor(Math.random() * (maxRandom + 1)); // 0 åˆ° maxRandom ä¹‹é–“çš„éš¨æ©Ÿæ•´æ•¸
  return 3 + randomValue; // 3 + éš¨æ©Ÿå€¼
}

function rollSkillOptions() {
  const hero = state.hero;
  const heroLevel = hero.stats.level;
  
  // æ ¹æ“šè‹±é›„é¡å‹ç¢ºå®šåˆå§‹æµæ´¾
  const initialFlowMap = {
    attacker: 'sword',
    mage: 'magic',
    healer: 'recovery',
    defender: 'defender', // é˜²å®ˆå‹ä½¿ç”¨åŠæŠ€
    agile: 'agility',
  };
  const initialFlow = hero.heroType ? (initialFlowMap[hero.heroType] || 'sword') : 'sword';
  
  // ä¸»è¦æµæ´¾å°±æ˜¯ä¸€é–‹å§‹å†’éšªæ‰€é¸çš„æµæ´¾
  const primaryFlow = initialFlow;
  
  const options = [];
  const flows = ['sword', 'defender', 'recovery', 'magic', 'agility', 'hero'];
  const otherFlows = flows.filter(f => f !== primaryFlow);
  let attempts = 0;
  const maxAttempts = 500;

  // 1. é¸æ“‡æµæ´¾é¡å‹çš„ä¸»å‹•æŠ€èƒ½ï¼ˆprimaryFlowçš„ä¸»åŠ¨æŠ€èƒ½ï¼‰
  let candidate = null;
  attempts = 0;
  while (!candidate && attempts < maxAttempts) {
    attempts++;
    candidate = getRandomSkillByFlow(primaryFlow, heroLevel, 'active', hero);
    if (candidate && !options.some((opt) => opt.id === candidate.id)) {
      options.push(candidate);
      candidate = null;
      break;
    }
    candidate = null;
  }

  // 2. ä¸€å€‹è¢«å‹•æŠ€èƒ½ï¼ˆå¯ä»¥æ˜¯ä»»ä½•æµæ´¾ï¼‰
  attempts = 0;
  while (!candidate && attempts < maxAttempts) {
    attempts++;
    const flow = flows[Math.floor(Math.random() * flows.length)];
    candidate = getRandomSkillByFlow(flow, heroLevel, 'passive', hero);
    if (candidate && !options.some((opt) => opt.id === candidate.id)) {
      options.push(candidate);
      candidate = null;
      break;
    }
    candidate = null;
  }

  // 3. è‡³å°‘ä¸€å€‹æ˜¯åˆ¥çš„é¡å‹çš„æŠ€èƒ½ï¼ˆéprimaryFlowï¼‰
  attempts = 0;
  while (!candidate && attempts < maxAttempts) {
    attempts++;
    const flow = otherFlows[Math.floor(Math.random() * otherFlows.length)];
    candidate = getRandomSkillByFlow(flow, heroLevel, null, hero); // ä¸é™åˆ¶é¡å‹
    if (candidate && !options.some((opt) => opt.id === candidate.id)) {
      options.push(candidate);
      candidate = null;
      break;
    }
    candidate = null;
  }

  // 4. ä¸€å€‹å·²ç¶“å­¸éæŠ€èƒ½çš„æ›´é«˜ç´šç‰ˆ
  attempts = 0;
  const owned = new Set(hero.skills);
  const higherTierCandidates = [];
  
  // æ‰¾å‡ºæ‰€æœ‰å·²å­¸æŠ€èƒ½çš„æ›´é«˜ç‰ˆæœ¬
  hero.skills.forEach((skillId) => {
    const learnedSkill = SKILL_LOOKUP.get(skillId);
    if (!learnedSkill || !learnedSkill.chainId) return;
    
    const chain = SKILL_CHAINS.find(c => c.id === learnedSkill.chainId);
    if (!chain) return;
    
    // æ‰¾å‡ºè©²æŠ€èƒ½éˆä¸­å·²å­¸çš„æœ€é«˜tier
    let maxLearnedTier = 0;
    chain.steps.forEach((step) => {
      if (owned.has(step.id)) {
        maxLearnedTier = Math.max(maxLearnedTier, step.tier);
      }
    });
    
    // æ‰¾å‡ºæ›´é«˜tierçš„æŠ€èƒ½
    chain.steps.forEach((step) => {
      // æª¢æŸ¥ç­‰ç´šè¦æ±‚
      if (heroLevel < step.requiredLevel) return;
      
      // æª¢æŸ¥æ˜¯å¦å·²æ“æœ‰
      if (owned.has(step.id)) return;
      
      // å¿…é ˆæ˜¯æ›´é«˜tierçš„æŠ€èƒ½
      if (step.tier <= maxLearnedTier) return;
      
      // æª¢æŸ¥æ˜¯å¦éœ€è¦å‰ä¸€éšï¼ˆé™¤äº†ç¬¬1éšï¼‰
      if (step.tier > 1) {
        const prevStep = chain.steps.find(s => s.tier === step.tier - 1);
        if (prevStep && !owned.has(prevStep.id)) {
          return; // éœ€è¦å‰ä¸€éšä½†æœªå­¸ç¿’
        }
      }
      
      // å¯ä»¥å­¸ç¿’ï¼ŒåŠ å…¥å€™é¸åˆ—è¡¨
      higherTierCandidates.push({
        ...step,
        flow: chain.flow,
        chainId: chain.id,
        aoe: chain.aoe || false,
      });
    });
  });
  
  // å¾å€™é¸åˆ—è¡¨ä¸­éš¨æ©Ÿé¸æ“‡ä¸€å€‹
  if (higherTierCandidates.length > 0) {
    const selected = higherTierCandidates[Math.floor(Math.random() * higherTierCandidates.length)];
    if (!options.some((opt) => opt.id === selected.id)) {
      options.push(selected);
    } else {
      // å¦‚æœé¸ä¸­çš„æŠ€èƒ½å·²ç¶“åœ¨é¸é …ä¸­ï¼Œå˜—è©¦é¸æ“‡å¦ä¸€å€‹
      const remaining = higherTierCandidates.filter(c => !options.some((opt) => opt.id === c.id));
      if (remaining.length > 0) {
        options.push(remaining[Math.floor(Math.random() * remaining.length)]);
      }
    }
  }
  
  // å¦‚æœæ²’æœ‰æ‰¾åˆ°æ›´é«˜ç‰ˆæœ¬çš„æŠ€èƒ½ï¼Œè£œä¸€å€‹éš¨æ©ŸæŠ€èƒ½
  if (options.length < 4) {
    attempts = 0;
    while (options.length < 4 && attempts < maxAttempts) {
      attempts++;
      const flow = flows[Math.floor(Math.random() * flows.length)];
      candidate = getRandomSkillByFlow(flow, heroLevel, null, hero); // ä¸é™åˆ¶é¡å‹
      if (candidate && !options.some((opt) => opt.id === candidate.id)) {
      options.push(candidate);
        candidate = null;
    } else {
        candidate = null;
      }
    }
  }

  return options;
}

function pickFlow(primaryFlow, initialFlow, options) {
  const flows = ['sword', 'defender', 'recovery', 'magic', 'agility', 'hero'];
  
  // è¨ˆç®—æ¬Šé‡ï¼šåˆå§‹æµæ´¾ï¼ˆæ‰€é€‰æµæ´¾ï¼‰æ¯”å…¶å®ƒæµæ´¾å¤š400%çš„å‡ºç¾æ©Ÿç‡ï¼ˆäº”å€ï¼‰
  // å¦‚æœå…¶ä»–æµæ´¾çš„åŸºç¡€æƒé‡æ˜¯1ï¼Œåˆå§‹æµæ´¾æ˜¯5.0
  const weights = flows.map((flow) => {
    if (flow === initialFlow) {
      // åˆå§‹æµæ´¾ï¼ˆæ‰€é€‰æµæ´¾ï¼‰ï¼š5.0å€æƒé‡ï¼ˆäº”å€ï¼‰
      return 5.0;
    } else {
      // å…¶ä»–æµæ´¾ï¼š1.0å€æƒé‡
      return 1.0;
    }
  });

  // ç¢ºä¿æ¬Šé‡ç¸½å’Œç‚º1
  const totalWeight = weights.reduce((sum, w) => sum + w, 0);
  const normalizedWeights = weights.map(w => w / totalWeight);

  const ensureOther =
    options.length >= 2 && !options.some((opt) => opt.flow !== initialFlow);
  if (ensureOther) {
    const others = flows.filter((flow) => flow !== initialFlow);
    return others[Math.floor(Math.random() * others.length)];
  }

  const roll = Math.random();
  let accumulator = 0;
  for (let i = 0; i < flows.length; i += 1) {
    accumulator += normalizedWeights[i];
    if (roll <= accumulator) return flows[i];
  }
  return flows[flows.length - 1];
}

// æ ¹æ“šç­‰ç´šå’Œå·²å­¸ç¿’æŠ€èƒ½ç²å–å¯å­¸ç¿’çš„æŠ€èƒ½
function getRandomSkillByFlow(flow, heroLevel, skillType = null, hero = null) {
  // skillType: 'active' åªè¿”å›ä¸»å‹•æŠ€èƒ½, 'passive' åªè¿”å›è¢«å‹•æŠ€èƒ½, null è¿”å›æ‰€æœ‰
  const candidates = [];
  const heroRef = hero || state.hero;
  const owned = new Set(heroRef.skills);
  
  // æ‰¾å‡ºå·²ç¶“å­¸ç¿’éçš„æŠ€èƒ½éˆIDï¼ˆç”¨æ–¼å¢åŠ å‡ºç¾ç‡ï¼‰
  const learnedChainIds = new Set();
  heroRef.skills.forEach((skillId) => {
    const skill = SKILL_LOOKUP.get(skillId);
    if (skill && skill.chainId) {
      learnedChainIds.add(skill.chainId);
    }
  });
  
  // å¾æŠ€èƒ½éˆä¸­ç¯©é¸å¯å­¸ç¿’çš„æŠ€èƒ½
  SKILL_CHAINS.filter((chain) => chain.flow === flow).forEach((chain) => {
    // æ‰¾å‡ºè©²æŠ€èƒ½éˆä¸­å·²ç¶“å­¸æœƒçš„æœ€é«˜ç­‰ç´šæŠ€èƒ½
    let maxLearnedTier = 0;
    chain.steps.forEach((step) => {
      if (owned.has(step.id)) {
        maxLearnedTier = Math.max(maxLearnedTier, step.tier);
      }
    });
    
    chain.steps.forEach((step) => {
      // æª¢æŸ¥ç­‰ç´šè¦æ±‚
      if (heroLevel < step.requiredLevel) return;
      
      // æª¢æŸ¥æ˜¯å¦å·²æ“æœ‰
      if (owned.has(step.id)) return;
      
      // æª¢æŸ¥æ˜¯å¦å·²ç¶“å­¸æœƒäº†æ›´é«˜ç­‰ç´šçš„æŠ€èƒ½ï¼ˆä¸æ‡‰è©²å‡ºç¾æ›´ä½ç­‰ç´šçš„æŠ€èƒ½ï¼‰
      if (maxLearnedTier > 0 && step.tier < maxLearnedTier) {
        return; // å·²ç¶“å­¸æœƒäº†æ›´é«˜ç­‰ç´šçš„æŠ€èƒ½ï¼Œä¸æ‡‰è©²å†å‡ºç¾ä½ç­‰ç´šçš„æŠ€èƒ½
      }
      
      // æª¢æŸ¥æŠ€èƒ½é¡å‹
      if (skillType === 'active' && step.kind === 'passive') return;
      if (skillType === 'passive' && step.kind !== 'passive') return;
      
      // æª¢æŸ¥æ˜¯å¦éœ€è¦å‰ä¸€éšï¼ˆé™¤äº†ç¬¬1éšï¼‰
      if (step.tier > 1) {
        const prevStep = chain.steps.find(s => s.tier === step.tier - 1);
        if (prevStep && !owned.has(prevStep.id)) {
          return; // éœ€è¦å‰ä¸€éšä½†æœªå­¸ç¿’
        }
      }
      
      // è¨ˆç®—æ¬Šé‡ï¼šå¦‚æœè©²æŠ€èƒ½éˆå·²ç¶“æœ‰å­¸ç¿’éçš„æŠ€èƒ½ï¼Œæ¬Šé‡å¢åŠ 50%
      const weight = learnedChainIds.has(chain.id) ? 1.5 : 1.0;
      
      // å¯ä»¥å­¸ç¿’ï¼ŒåŠ å…¥å€™é¸åˆ—è¡¨ï¼ˆå¸¶æ¬Šé‡ï¼‰
      candidates.push({ 
        ...step, 
        flow, 
        chainId: chain.id,
        aoe: chain.aoe || false,
        weight, // æ·»åŠ æ¬Šé‡
      });
    });
  });
  
  if (candidates.length === 0) return null;
  
  // ä½¿ç”¨æ¬Šé‡éš¨æ©Ÿé¸æ“‡
  const totalWeight = candidates.reduce((sum, c) => sum + c.weight, 0);
  let roll = Math.random() * totalWeight;
  let accumulator = 0;
  for (const candidate of candidates) {
    accumulator += candidate.weight;
    if (roll <= accumulator) {
      // ç§»é™¤æ¬Šé‡å±¬æ€§ï¼ˆä¸éœ€è¦è¿”å›ï¼‰
      const { weight, ...result } = candidate;
      return result;
    }
  }
  
  // å¦‚æœæ¬Šé‡é¸æ“‡å¤±æ•—ï¼Œä½¿ç”¨æœ€å¾Œä¸€å€‹å€™é¸ï¼ˆä¸æ‡‰è©²ç™¼ç”Ÿï¼‰
  const { weight, ...result } = candidates[candidates.length - 1];
  return result;
}

function advanceRoute() {
  state.world.stage += 1;
  state.world.nodes = generateRoute(state.world.stage);
  // renderBackground æœƒæ ¹æ“š stage è‡ªå‹•è¨­ç½®æ­£ç¢ºçš„ currentArea
  renderBackground();
}

function generateRoute(stage) {
  const nodes = [];
  const TOTAL_NODES = 20; // æ¯å€‹éšæ®µ20å€‹ç¯€é»
  const TOTAL_STAGES = 6; // ç¸½å…±6å€‹éšæ®µ
  
  // ç¢ºä¿stageåœ¨1-6ç¯„åœå…§
  const currentStage = Math.min(TOTAL_STAGES, Math.max(1, stage));
  
  for (let i = 0; i < TOTAL_NODES; i += 1) {
    const isLast = i === TOTAL_NODES - 1;
    const isTownNode = i === 6 || i === 16; // ç¬¬7ã€17å€‹ç¯€é»ï¼ˆ0-basedæ˜¯6ã€16ï¼‰
    
    if (isLast) {
      // æœ€å¾Œä¸€å€‹ç¯€é»æ˜¯é­”ç‹ï¼ˆå°æ‡‰ç•¶å‰stageçš„tierï¼‰
      const bossOption = createBossOption(i, currentStage);
      nodes.push({
        id: `node-boss-stage${currentStage}-${i}`,
        label: `ç¬¬${currentStage}éšæ®µé­”ç‹`,
        type: 'boss',
        description: 'æœ€çµ‚æ±ºæˆ°ï¼æ“Šæ•—é­”ç‹å®Œæˆæœ¬éšæ®µã€‚',
        hint: 'æœ€çµ‚æ±ºæˆ°',
        flowHint: 'sword',
        options: [bossOption],
      });
    } else if (isTownNode) {
      // åŸé®ç¯€é»
      nodes.push({
        id: `node-town-stage${currentStage}-${i}`,
        label: `ç¬¬${currentStage}éšæ®µåŸé®`,
        type: 'town',
        description: 'å¯ä»¥åœ¨é€™è£¡è³¼è²·è£œçµ¦å“ã€‚',
        hint: 'å¯è£œçµ¦',
        flowHint: 'recovery',
        options: [
          {
            label: 'é€²å…¥åŸé®',
            type: 'town',
            description: 'è³¼è²·è£œçµ¦å“ä¸¦æ¢å¾©',
            hint: 'å¯è£œçµ¦',
            flowHint: 'recovery',
          },
        ],
      });
    } else {
      // æ™®é€šç¯€é»ï¼Œæœ‰3å€‹é¸é …
      const options = generateNodeOptions(i, currentStage);
      const primaryType = weightedPick(NODE_TYPES, Math.floor(i / 3) + 1);
      
      nodes.push({
        id: `node-stage${currentStage}-${i}-${Date.now()}`,
        label: `ç¬¬${currentStage}éšæ®µ ç¬¬ ${i + 1} å€åŸŸ`,
        type: primaryType.id,
        description: `ç¬¬${currentStage}éšæ®µçš„ç¬¬ ${i + 1} å€‹å€åŸŸï¼Œé¸æ“‡ä½ çš„è·¯ç·šã€‚`,
        hint: buildNodeHint(primaryType.id),
        flowHint: pickFlowHint(primaryType.id),
        options,
      });
    }
  }
  
  return nodes;
}

function generateNodeOptions(nodeIndex, stage) {
  const options = [];
  // éæ¿¾æ‰ rest å’Œ town é¸é …
  const pool = NODE_TYPES.filter((t) => t.id !== 'rest' && t.id !== 'town');
  
  // ç¢ºä¿è‡³å°‘æœ‰ä¸€å€‹æˆ°é¬¥é¸é …ï¼ˆé ç”Ÿæˆæ€ªç‰©ä¿¡æ¯ï¼‰
  const battleOption = createBattleOption(nodeIndex, stage);
  options.push(battleOption);
  
  // ç¬¬å…­éšå±¤ç¬¬äºŒå€‹ç¯€é»ï¼ˆnodeIndex === 1ï¼‰å¼·åˆ¶æ·»åŠ ç¾…å¾·è£å‚™äº‹ä»¶ï¼ˆå”¯ä¸€é¸é …ï¼‰
  const isRodEquipmentNode = stage === 6 && nodeIndex === 1;
  if (isRodEquipmentNode) {
    const rodEquipmentOption = {
      label: 'ç¾…å¾·è£å‚™',
      type: 'event',
      description: 'ç™¼ç¾äº†å‚³èªªä¸­å‹‡è€…ç¾…å¾·ç•™ä¸‹çš„è£å‚™ï¼Œå¯ä»¥é¸æ“‡å…¶ä¸­ä¸€ä»¶ã€‚',
      hint: 'ç¾…å¾·è£å‚™',
      flowHint: 'hero',
      eventType: 'rodEquipment', // æ¨™è¨˜ç‚ºç¾…å¾·è£å‚™äº‹ä»¶
    };
    // æ¸…ç©ºå…¶ä»–é¸é …ï¼Œåªä¿ç•™ç¾…å¾·è£å‚™äº‹ä»¶
    options.length = 0;
    options.push(rodEquipmentOption);
    return options; // ç›´æ¥è¿”å›ï¼Œä¸ç”Ÿæˆå…¶ä»–é¸é …
  }
  
  // ç¬¬äº”éšå±¤ç¬¬äºŒå€‹ç¯€é»ï¼ˆnodeIndex === 1ï¼‰å¼·åˆ¶æ·»åŠ å‹‡è€…ä¹‹è¡€äº‹ä»¶ï¼ˆå”¯ä¸€é¸é …ï¼‰
  const isHeroBloodNode = stage === 5 && nodeIndex === 1;
  if (isHeroBloodNode) {
    const heroBloodOption = {
      label: 'å‹‡è€…ä¹‹è¡€',
      type: 'event',
      description: 'ç™¼ç¾äº†ä¸€è™•å¤è€çš„ç¥­å£‡ï¼Œä¸Šé¢æµæ·Œè‘—ä¸‰ç¨®ä¸åŒçš„å‹‡è€…ä¹‹è¡€ã€‚',
      hint: 'å‹‡è€…ä¹‹è¡€',
      flowHint: 'hero',
      eventType: 'heroBlood', // æ¨™è¨˜ç‚ºå‹‡è€…ä¹‹è¡€äº‹ä»¶
    };
    // æ¸…ç©ºå…¶ä»–é¸é …ï¼Œåªä¿ç•™å‹‡è€…ä¹‹è¡€äº‹ä»¶
    options.length = 0;
    options.push(heroBloodOption);
    return options; // ç›´æ¥è¿”å›ï¼Œä¸ç”Ÿæˆå…¶ä»–é¸é …
  }
  
  // ç¬¬å››éšå±¤ç¬¬äºŒå€‹ç¯€é»ï¼ˆnodeIndex === 1ï¼‰å¼·åˆ¶æ·»åŠ è·æ¥­é€²éšäº‹ä»¶ï¼ˆå”¯ä¸€é¸é …ï¼‰
  const isClassAdvancementNode = stage === 4 && nodeIndex === 1;
  if (isClassAdvancementNode) {
    const classAdvancementOption = {
      label: 'è·æ¥­é€²éš',
      type: 'event',
      description: 'é‡åˆ°äº†ä¸€ä½è·æ¥­å°å¸«ï¼Œå¯ä»¥å¹«åŠ©åŒä¼´é€²éšåˆ°æ›´é«˜ç´šçš„è·æ¥­ã€‚',
      hint: 'è·æ¥­é€²éš',
      flowHint: 'sword',
      eventType: 'classAdvancement', // æ¨™è¨˜ç‚ºè·æ¥­é€²éšäº‹ä»¶
    };
    // æ¸…ç©ºå…¶ä»–é¸é …ï¼Œåªä¿ç•™è·æ¥­é€²éšäº‹ä»¶
    options.length = 0;
    options.push(classAdvancementOption);
    return options; // ç›´æ¥è¿”å›ï¼Œä¸ç”Ÿæˆå…¶ä»–é¸é …
  }
  
  // ç¬¬ä¸‰éšå±¤é–‹å§‹ï¼Œç¬¬ä¸€å€‹ç¯€é»ï¼ˆnodeIndex === 0ï¼‰å¼·åˆ¶æ·»åŠ æŠ€èƒ½è¨“ç·´å¸«å’Œå¿ƒç†æ²»ç™‚æ‰€é¸é …
  const isSkillTrainerNode = stage >= 3 && nodeIndex === 0;
  if (isSkillTrainerNode) {
    const skillTrainerOption = {
      label: 'æŠ€èƒ½è¨“ç·´å¸«',
      type: 'event',
      description: 'é‡åˆ°äº†ä¸€ä½æŠ€èƒ½è¨“ç·´å¸«ï¼Œå¯ä»¥å¹«åŠ©åŒä¼´é‡æ–°è¨“ç·´æŠ€èƒ½ã€‚',
      hint: 'æŠ€èƒ½è¨“ç·´',
      flowHint: 'sword',
      eventType: 'skillTrainer', // æ¨™è¨˜ç‚ºæŠ€èƒ½è¨“ç·´å¸«äº‹ä»¶
    };
    const therapyOption = {
      label: 'å¿ƒç†æ²»ç™‚æ‰€',
      type: 'event',
      description: 'é‡åˆ°äº†ä¸€é–“å¿ƒç†æ²»ç™‚æ‰€ï¼Œå¯ä»¥å¹«åŠ©åŒä¼´æ”¹è®Šå€‹æ€§ã€‚',
      hint: 'æ”¹è®Šå€‹æ€§',
      flowHint: 'recovery',
      eventType: 'personalityTherapy', // æ¨™è¨˜ç‚ºå¿ƒç†æ²»ç™‚æ‰€äº‹ä»¶
    };
    // æ¸…ç©ºå…¶ä»–é¸é …ï¼Œåªä¿ç•™é€™å…©å€‹äº‹ä»¶é¸é …
    options.length = 0;
    options.push(skillTrainerOption);
    options.push(therapyOption);
    return options; // ç›´æ¥è¿”å›ï¼Œä¸ç”Ÿæˆå…¶ä»–é¸é …
  }
  
  // åœ¨3çš„å€æ•¸çš„ç¯€é»ï¼ˆç¯€é»ç´¢å¼•2, 5, 8, 11, 14, 17ï¼Œå°æ‡‰ç¬¬3, 6, 9, 12, 15, 18å€‹ç¯€é»ï¼‰æ·»åŠ ä¼‘æ¯é¸é …
  // æ³¨æ„ï¼šç¯€é»6å’Œ16æ˜¯åŸé®ï¼ˆå°æ‡‰ç¬¬7å’Œ17å€‹ç¯€é»ï¼‰ï¼Œæ‰€ä»¥è·³é
  const isRestNode = (nodeIndex + 1) % 3 === 0 && nodeIndex !== 6 && nodeIndex !== 16;
  if (isRestNode) {
    const restOption = createOptionFromType({ id: 'rest', label: 'ä¼‘æ¯è·¯ç·š' }, nodeIndex, stage);
    options.push(restOption);
  }
  
  // ç”Ÿæˆå…¶ä»–é¸é …ï¼ˆå¦‚æœæ²’æœ‰ä¼‘æ¯é¸é …ï¼Œéœ€è¦2å€‹ï¼›å¦‚æœæœ‰ä¼‘æ¯é¸é …ï¼Œéœ€è¦1å€‹ï¼‰
  // å¦‚æœå·²ç¶“æœ‰æŠ€èƒ½è¨“ç·´å¸«äº‹ä»¶ï¼Œæ¸›å°‘ä¸€å€‹é¸é …
  const targetOptionsCount = isRestNode ? 1 : 2;
  const targetOptionsCountAdjusted = isSkillTrainerNode ? (targetOptionsCount - 1) : targetOptionsCount;
  const availableTypes = pool.filter((t) => t.id !== 'battle' && t.id !== 'rest' && t.id !== 'town');
  const selectedTypes = [];
  
  // ç¢ºå®šæ˜¯å¦ç”Ÿæˆ event é¸é …ï¼ˆåªç”Ÿæˆä¸€å€‹ï¼Œ50%æ©Ÿç‡ï¼Œä½†å¦‚æœå·²ç¶“æœ‰æŠ€èƒ½è¨“ç·´å¸«äº‹ä»¶å‰‡ä¸ç”Ÿæˆï¼‰
  const hasEvent = !isSkillTrainerNode && Math.random() < 0.5;
  let eventGenerated = false;
  
  // å¦‚æœè¦æœ‰ eventï¼Œå…ˆé¸ä¸€å€‹ event
  if (hasEvent && availableTypes.some(t => t.id === 'event')) {
    selectedTypes.push(availableTypes.find(t => t.id === 'event'));
    eventGenerated = true;
  }
  
  // å¡«å……å‰©é¤˜é¸é …ï¼ˆæ’é™¤ eventï¼Œå› ç‚ºåªèƒ½æœ‰ä¸€å€‹ï¼‰
  const remainingTypes = availableTypes.filter((t) => !eventGenerated || t.id !== 'event');
  while (selectedTypes.length < targetOptionsCount) {
    if (remainingTypes.length === 0) break;
    const type = weightedPick(remainingTypes, stage);
    if (!selectedTypes.some(t => t.id === type.id)) {
      selectedTypes.push(type);
    } else if (remainingTypes.length === 1) {
      // å¦‚æœåªå‰©ä¸€ç¨®é¡å‹ï¼Œç›´æ¥ä½¿ç”¨
      selectedTypes.push(remainingTypes[0]);
      break;
    } else {
      // é¿å…ç„¡é™å¾ªç’°ï¼Œå¾å€™é¸åˆ—è¡¨ä¸­ç§»é™¤å·²é¸ä¸­çš„é¡å‹
      const index = remainingTypes.findIndex(t => t.id === type.id);
      if (index >= 0) {
        remainingTypes.splice(index, 1);
      } else {
        // å¦‚æœæ‰¾ä¸åˆ°ï¼Œèªªæ˜æ‰€æœ‰é¡å‹éƒ½å·²é¸ä¸­ï¼Œè·³å‡ºå¾ªç’°
        break;
      }
    }
  }
  
  // å°‡é¸ä¸­çš„é¡å‹è½‰æ›ç‚ºé¸é …
  selectedTypes.forEach(type => {
    options.push(createOptionFromType(type, nodeIndex, stage));
  });
  
  return options;
}

// å‰µå»ºæˆ°é¬¥é¸é …ä¸¦é ç”Ÿæˆæ€ªç‰©ä¿¡æ¯ï¼ˆçµ±ä¸€å‡½æ•¸ï¼Œæ”¯æŒæ™®é€šå’Œç²¾è‹±æˆ°é¬¥ï¼‰
function createBattleOption(nodeIndex, stage, isElite = false) {
  const hero = state.hero;
  const heroLevel = hero ? hero.stats.level : 1;
  const multiplier = isElite ? 1.6 : 1; // ç²¾è‹±æˆ°é¬¥ multiplier 1.6ï¼Œæ™®é€šæˆ°é¬¥ 1
  
  // ä½¿ç”¨ç•¶å‰éšæ®µçš„stageä½œç‚ºtierï¼ˆå„ªå…ˆä½¿ç”¨å‚³å…¥çš„stageåƒæ•¸ï¼‰
  const tier = Math.min(6, Math.max(1, stage || (state.world && state.world.stage ? state.world.stage : 1)));
  
  // å…ˆæª¢æŸ¥æ˜¯å¦æœ‰è¶³å¤ çš„æ€ªç‰©é¡å‹
  const normalPool = ENEMY_DECK.filter(
    (enemy) => enemy.tier === tier && enemy.monsterType !== 'boss'
  );
  
  if (normalPool.length === 0) {
    // å¦‚æœè©²éšæ®µæ²’æœ‰æ™®é€šæ€ªç‰©ï¼Œè¿”å›nullï¼Œè®“èª¿ç”¨è€…è™•ç†
    return null;
  }
  
  // é ç”Ÿæˆæ€ªç‰©åˆ—è¡¨
  const enemies = [];
  let monsterInfo = '';
  
  // æ ¹æ“šé…ç½®æ±ºå®šæ•µäººæ•¸é‡ç¯„åœ
  const stageConfig = GAME_CONFIG.stageMonsterCounts[tier] || GAME_CONFIG.stageMonsterCounts[6];
  const minEnemies = stageConfig.min;
  const maxEnemies = stageConfig.max;
    
    // ç²¾è‹±æˆ°é¬¥ä½¿ç”¨æœ€å¤§å€¼ï¼Œæ™®é€šæˆ°é¬¥ä½¿ç”¨éš¨æ©Ÿæ•¸é‡ï¼ˆèˆ‡å¯¦éš›æˆ°é¬¥ä¸€è‡´ï¼‰
    const enemyCount = isElite ? maxEnemies : randomRange(minEnemies, maxEnemies);
    
    // é ç”Ÿæˆæ€ªç‰©ï¼ˆå¯¦éš›æˆ°é¬¥æ™‚æœƒé‡æ–°ç”Ÿæˆï¼Œé€™è£¡åªæ˜¯ç‚ºäº†é¡¯ç¤ºï¼‰
  // ç¢ºä¿åªä½¿ç”¨è©²éšæ®µçš„æ™®é€šæ€ªç‰©ï¼ˆä¸æ˜¯bossï¼‰ï¼Œç²¾è‹±åªæ˜¯ç­‰ç´šé«˜
    for (let i = 0; i < enemyCount; i++) {
    try {
      const enemy = pickEnemy(stage, multiplier, nodeIndex, false); // å‚³å…¥ false è¡¨ç¤ºä¸æ˜¯bossæˆ°
      enemies.push(enemy);
    } catch (error) {
      // å¦‚æœå‡ºéŒ¯ï¼Œå˜—è©¦ä½¿ç”¨è©²éšæ®µçš„ç¬¬ä¸€å€‹å¯ç”¨æ€ªç‰©
      if (normalPool.length > 0) {
        const fallbackEnemy = normalPool[Math.floor(Math.random() * normalPool.length)];
        const fallbackEnemyInstance = createEnemy(fallbackEnemy, heroLevel, isElite, stage);
        enemies.push(fallbackEnemyInstance);
      } else {
        // å¦‚æœé€£å›é€€æ€ªç‰©éƒ½æ²’æœ‰ï¼Œè¿”å›null
        return null;
      }
    }
    }
    
    // çµ±è¨ˆæ€ªç‰©ï¼ˆæŒ‰åç¨±åˆ†çµ„ï¼Œä¸å€åˆ†ç­‰ç´šï¼‰
    const monsterGroups = {};
    enemies.forEach(enemy => {
      const key = enemy.name;
      if (!monsterGroups[key]) {
        monsterGroups[key] = { name: enemy.name, count: 0 };
      }
      monsterGroups[key].count++;
    });
    
    // ç”Ÿæˆé¡¯ç¤ºä¿¡æ¯ï¼ˆåªé¡¯ç¤ºåç¨±å’Œæ•¸é‡ï¼Œä¸é¡¯ç¤ºç­‰ç´šï¼‰
    monsterInfo = Object.values(monsterGroups).map(group => {
      return group.count > 1 ? `${group.name} Ã—${group.count}` : `${group.name}`;
    }).join('ã€');
  
  return {
    label: isElite ? 'èè‹±è·¯ç·š' : 'æˆ°é¬¥è·¯ç·š',
    type: isElite ? 'elite' : 'battle',
    description: isElite ? `é­é‡å¼·æ•µï¼š${monsterInfo}ã€‚` : `é­é‡æ•µäººï¼š${monsterInfo}ã€‚`,
    hint: isElite ? 'æ¨è–¦æº–å‚™å……åˆ†' : 'æ“Šæ•—æ•µäºº',
    flowHint: 'sword',
    preGeneratedEnemies: enemies, // é ç”Ÿæˆçš„æ€ªç‰©åˆ—è¡¨ï¼Œç”¨æ–¼å¯¦éš›æˆ°é¬¥
  };
}

// å‰µå»ºç²¾è‹±æˆ°é¬¥é¸é …ä¸¦é ç”Ÿæˆæ€ªç‰©ä¿¡æ¯ï¼ˆä½¿ç”¨çµ±ä¸€å‡½æ•¸ï¼‰
function createEliteBattleOption(nodeIndex, stage) {
  return createBattleOption(nodeIndex, stage, true);
}

// å‰µå»ºé­”ç‹æˆ°é¬¥é¸é …ä¸¦é ç”Ÿæˆæ€ªç‰©ä¿¡æ¯
function createBossOption(nodeIndex, stage) {
  const hero = state.hero;
  const heroLevel = hero ? hero.stats.level : 1;
  const multiplier = 2.5; // é­”ç‹æˆ°é¬¥
  
  // ä½¿ç”¨å‚³å…¥çš„stageåƒæ•¸ä½œç‚ºtierï¼ˆå„ªå…ˆä½¿ç”¨å‚³å…¥çš„åƒæ•¸ï¼Œç¢ºä¿æ­£ç¢ºï¼‰
  // å¦‚æœæ²’æœ‰å‚³å…¥stageï¼Œå‰‡ä½¿ç”¨state.world.stage
  const currentStage = stage || (state.world && state.world.stage ? state.world.stage : 1);
  const tier = Math.min(6, Math.max(1, currentStage));
  
  
  const bossPool = ENEMY_DECK.filter(
    (enemy) => enemy.tier === tier && enemy.monsterType === 'boss'
  );
  
  
  // é ç”Ÿæˆé­”ç‹
  const enemies = [];
  let bossEnemy;
  
  if (bossPool.length > 0) {
    const bossTemplate = bossPool[0]; // æ¯å€‹éšå±¤åªæœ‰ä¸€å€‹BOSS
    bossEnemy = createEnemy(bossTemplate, heroLevel, true, tier);
  } else {
    // å¦‚æœæ²’æœ‰æ‰¾åˆ°å°æ‡‰éšå±¤çš„BOSSï¼Œè¨˜éŒ„éŒ¯èª¤ä¸¦ä½¿ç”¨é»˜èªBOSS
    // å˜—è©¦é™éšå°‹æ‰¾ï¼ˆä½†é€™ä¸æ‡‰è©²ç™¼ç”Ÿï¼Œå› ç‚ºæ¯å€‹éšæ®µéƒ½æ‡‰è©²æœ‰å°æ‡‰çš„BOSSï¼‰
    for (let fallbackTier = tier - 1; fallbackTier >= 1; fallbackTier--) {
      const fallbackBossPool = ENEMY_DECK.filter(
        (enemy) => enemy.tier === fallbackTier && enemy.monsterType === 'boss'
      );
      if (fallbackBossPool.length > 0) {
        bossEnemy = createEnemy(fallbackBossPool[0], heroLevel, true, fallbackTier);
        break;
      }
    }
    // å¦‚æœé‚„æ˜¯æ‰¾ä¸åˆ°ï¼Œä½¿ç”¨ç¶ é¾ä½œç‚ºé»˜èªboss
    if (!bossEnemy) {
      const defaultBoss = ENEMY_DECK.find(e => e.id === 'green_dragon');
      if (defaultBoss) {
        bossEnemy = createEnemy(defaultBoss, heroLevel, true, defaultBoss.tier);
      }
    }
  }
  
  if (bossEnemy) {
    enemies.push(bossEnemy);
    
    // æª¢æŸ¥é…ç½®ä¸­æ˜¯å¦æœ‰è©²é­”ç‹çš„éƒ¨ä¸‹
    const bossId = bossEnemy.id;
    const bossMinionsConfig = GAME_CONFIG.bossMinions || {};
    const minionIds = bossMinionsConfig[bossId];
    
    if (minionIds && Array.isArray(minionIds) && minionIds.length > 0) {
      // ç‚ºæ¯å€‹éƒ¨ä¸‹IDå‰µå»ºæ€ªç‰©
      minionIds.forEach(minionId => {
        const minionTemplate = ENEMY_DECK.find(e => e.id === minionId);
        if (minionTemplate) {
          // éƒ¨ä¸‹ä½¿ç”¨æ™®é€šç­‰ç´šï¼ˆä¸æ˜¯ç²¾è‹±ï¼‰
          const minionEnemy = createEnemy(minionTemplate, heroLevel, false, tier);
          enemies.push(minionEnemy);
        } else {
        }
      });
    }
  }
  
  return {
    label: 'æŒ‘æˆ°é­”ç‹',
    type: 'boss',
    description: `é­é‡é­”ç‹ï¼š${bossEnemy ? bossEnemy.name : 'é­”ç‹'}${enemies.length > 1 ? `ï¼ˆå¸¶æœ‰ ${enemies.length - 1} å€‹éƒ¨ä¸‹ï¼‰` : ''}ã€‚`,
    hint: 'é«˜é›£åº¦æˆ°é¬¥',
    flowHint: 'sword',
    preGeneratedEnemies: enemies, // é ç”Ÿæˆçš„æ€ªç‰©åˆ—è¡¨ï¼Œç”¨æ–¼å¯¦éš›æˆ°é¬¥
  };
}

function createOptionFromType(type, nodeIndex, stage) {
  // ç¢ºä¿ stage åƒæ•¸æœ‰æ•ˆï¼Œå¦‚æœæ²’æœ‰å‚³å…¥å‰‡å¾ state.world ç²å–
  const currentStage = stage || (state.world && state.world.stage ? state.world.stage : 1);
  
  let label = type.label;
  let description = describeNode(type.id);
  let hint = buildNodeHint(type.id);
  
  if (type.id === 'battle') {
    label = 'æˆ°é¬¥è·¯ç·š';
    description = 'é­é‡æ•µäººï¼Œç²å¾— EXP èˆ‡æˆ°åˆ©å“ã€‚';
    hint = 'æ“Šæ•—æ•µäºº';
  } else if (type.id === 'elite') {
    // ç²¾è‹±è·¯ç·šéœ€è¦ä½¿ç”¨ createEliteBattleOption ç”Ÿæˆæ€ªç‰©ä¿¡æ¯
    const eliteOption = createEliteBattleOption(nodeIndex, currentStage);
    // å¦‚æœç„¡æ³•ç”Ÿæˆç²¾è‹±é¸é …ï¼ˆä¾‹å¦‚è©²éšæ®µæ²’æœ‰æ€ªç‰©ï¼‰ï¼Œè¿”å›æ™®é€šæˆ°é¬¥é¸é …
    if (!eliteOption) {
      return createBattleOption(nodeIndex, currentStage);
    }
    return eliteOption;
  } else if (type.id === 'event') {
    label = 'æ¢ç´¢è·¯ç·š';
    description = 'éš¨æ©Ÿäº‹ä»¶ï¼Œé‚‚é€… NPC æˆ–é™·é˜±ã€‚';
    hint = 'é¢¨éšªèˆ‡é©šå–œä¸¦å­˜';
  } else if (type.id === 'rest') {
    label = 'ä¼‘æ¯è·¯ç·š';
    description = 'ç‡Ÿç«ä¼‘æ¯ï¼Œæ¢å¾©éƒ¨åˆ†é«”åŠ›ã€‚';
    hint = 'å›å¾©ç«™';
  } else if (type.id === 'town') {
    label = 'è£œçµ¦è·¯ç·š';
    description = 'å°é®è£œçµ¦ï¼Œå¯æ¶ˆè€—é‡‘å¹£æ¢å¾©ã€‚';
    hint = 'å¯è£œçµ¦';
  }
  
  return {
    label,
    type: type.id,
    description,
    hint,
    flowHint: pickFlowHint(type.id),
  };
}

function weightedPick(list, stage) {
  const weights = list.map((item) => {
    if (item.id === 'battle') return 0.4 + stage * 0.02;
    if (item.id === 'elite') return 0.15 + stage * 0.01;
    if (item.id === 'event') return 0.2;
    if (item.id === 'rest') return 0.15;
    if (item.id === 'town') return 0.1;
    return 0.1;
  });
  const total = weights.reduce((sum, w) => sum + w, 0);
  const roll = Math.random() * total;
  let acc = 0;
  for (let i = 0; i < list.length; i += 1) {
    acc += weights[i];
    if (roll <= acc) return list[i];
  }
  return list[list.length - 1];
}

function describeNode(type) {
  switch (type) {
    case 'battle':
      return 'æ™®é€šæˆ°é¬¥ï¼Œç²å¾— EXP èˆ‡æˆ°åˆ©å“ã€‚';
    case 'elite':
      return 'å¼·æ•µå‡ºç¾ï¼Œé¢¨éšªé«˜ä½†çå‹µæ›´ä½³ã€‚';
    case 'event':
      return 'éš¨æ©Ÿäº‹ä»¶ï¼Œé‚‚é€… NPC æˆ–é™·é˜±ã€‚';
    case 'rest':
      return 'ç‡Ÿç«ä¼‘æ¯ï¼Œæ¢å¾©éƒ¨åˆ†é«”åŠ›ã€‚';
    case 'town':
      return 'å°é®è£œçµ¦ï¼Œå¯æ¶ˆè€—é‡‘å¹£æ¢å¾©ã€‚';
    default:
      return 'æœªçŸ¥å†’éšªã€‚';
  }
}

function buildNodeHint(type) {
  if (type === 'battle') return 'æ“Šæ•—æ•µäººå–å¾—è³‡æº';
  if (type === 'elite') return 'æ¨è–¦æº–å‚™å……åˆ†';
  if (type === 'event') return 'é¢¨éšªèˆ‡é©šå–œä¸¦å­˜';
  if (type === 'rest') return 'å›å¾©ç«™';
  if (type === 'town') return 'å¯è£œçµ¦';
  return '';
}

function pickFlowHint(type) {
  if (type === 'battle') {
    return ['sword', 'magic'][Math.floor(Math.random() * 2)];
  }
  if (type === 'elite') {
    return Math.random() > 0.5 ? 'sword' : 'magic';
  }
  if (type === 'event' || type === 'rest') {
    return 'recovery';
  }
  return 'general';
}

function randomRange(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function pushLog(message) {
  state.log.push(message);
  if (state.log.length > MAX_LOG_ENTRIES) {
    state.log.shift();
  }
  renderLog();
}

// æ¸²æŸ“æˆ°é¬¥æ—¥èªŒ
function renderBattleLog() {
  if (!dom.battleLog) return;
  
  const battle = state.ui.battle;
  if (!battle) {
    dom.battleLog.innerHTML = '';
    return;
  }
  
  const battleLogs = battle.battleLog || [];
  const currentTurn = battle.turnCount || 0;
  
  // åªé¡¯ç¤ºæœ€è¿‘2å€‹å›åˆçš„æ—¥èªŒï¼ˆç•¶å‰å›åˆå’Œä¸Šä¸€å›åˆï¼‰
  const minTurnToShow = Math.max(0, currentTurn - 1);
  const filteredLogs = battleLogs.filter(log => {
    const logTurn = (typeof log === 'string' ? Math.max(0, currentTurn - 1) : (log.turn || 0));
    return logTurn >= minTurnToShow;
  });
  
  // å°‡æœ€æ–°çš„æ¶ˆæ¯æ”¾åœ¨ä¸Šé¢ï¼ˆåè½‰é †åºï¼‰
  // è™•ç†logæ ¼å¼ï¼šå¯èƒ½æ˜¯å­—ç¬¦ä¸²ï¼ˆèˆŠæ ¼å¼ï¼‰æˆ–å°è±¡ï¼ˆæ–°æ ¼å¼ï¼‰
  const processedLogs = filteredLogs.map(log => {
    if (typeof log === 'string') {
      return log;
    } else if (log && log.message) {
      return log.message;
    }
    return String(log);
  });
  
  const reversedLogs = [...processedLogs].reverse();
  const displayLogs = reversedLogs; // é¡¯ç¤ºæ‰€æœ‰æœ€è¿‘2å›åˆçš„æ—¥èªŒï¼Œä¸é™åˆ¶æ•¸é‡
  
  dom.battleLog.innerHTML = `
    <div class="battle-stat-box">
      <p class="battle-stat-label">æˆ°é¬¥ç´€éŒ„</p>
      <div class="battle-log-list">
        ${displayLogs.length > 0 
          ? displayLogs.map(log => `<p class="battle-log-entry">${log}</p>`).join('')
          : '<p class="battle-log-entry">æˆ°é¬¥å°šæœªé–‹å§‹</p>'
        }
      </div>
    </div>
  `;
  
  // è‡ªå‹•æ»¾å‹•åˆ°é ‚éƒ¨ï¼ˆé¡¯ç¤ºæœ€æ–°æ¶ˆæ¯ï¼‰
  const logListElement = dom.battleLog.querySelector('.battle-log-list');
  if (logListElement) {
    // ä½¿ç”¨ requestAnimationFrame ç¢ºä¿ DOM æ›´æ–°å®Œæˆå¾Œå†æ»¾å‹•
    requestAnimationFrame(() => {
      logListElement.scrollTop = 0;
    });
  }
}

function pushBattleLog(message) {
  // åªè¨˜éŒ„åˆ°æˆ°é¬¥æ—¥èªŒï¼Œä¸è¨˜éŒ„åˆ°å†’éšªæ—¥èªŒ
  const battle = state.ui.battle;
  if (battle) {
    battle.battleLog = battle.battleLog || [];
    const currentTurn = battle.turnCount || 0;
    
    // æª¢æŸ¥æ˜¯å¦æœ‰èˆŠæ ¼å¼çš„logï¼ˆå­—ç¬¦ä¸²ï¼‰ï¼Œå¦‚æœæœ‰å‰‡è½‰æ›ç‚ºæ–°æ ¼å¼ï¼ˆå°è±¡ï¼‰
    // åªåœ¨ç¬¬ä¸€æ¬¡é‡åˆ°èˆŠæ ¼å¼æ™‚è½‰æ›ï¼Œé¿å…é‡è¤‡è½‰æ›
    let hasOldFormat = false;
    for (let i = 0; i < battle.battleLog.length; i++) {
      if (typeof battle.battleLog[i] === 'string') {
        hasOldFormat = true;
        break;
      }
    }
    
    if (hasOldFormat) {
      // å°‡èˆŠæ ¼å¼çš„logï¼ˆå­—ç¬¦ä¸²ï¼‰è½‰æ›ç‚ºæ–°æ ¼å¼ï¼ˆå°è±¡ï¼‰
      battle.battleLog = battle.battleLog.map(log => {
        if (typeof log === 'string') {
          // èˆŠæ ¼å¼ï¼šå­—ç¬¦ä¸²ï¼Œå‡è¨­æ˜¯ç•¶å‰å›åˆæˆ–ä¸Šä¸€å›åˆ
          return {
            message: log,
            turn: Math.max(0, currentTurn - 1)
          };
        }
        return log;
      });
    }
    
    // è¨˜éŒ„æ¶ˆæ¯å’Œå°æ‡‰çš„å›åˆæ•¸
    battle.battleLog.push({
      message: message,
      turn: currentTurn
    });
    
    // ä¿ç•™æœ€è¿‘2å€‹å›åˆçš„å®Œæ•´æˆ°é¬¥è¨˜éŒ„
    // åªä¿ç•™ç•¶å‰å›åˆå’Œä¸Šä¸€å›åˆçš„logï¼ˆä¿ç•™2å›åˆï¼šcurrentTurn-1, currentTurnï¼‰
    const minTurnToKeep = Math.max(0, currentTurn - 1);
    
    // ç§»é™¤éæ—©çš„logï¼ˆå¾é ­é–‹å§‹ç§»é™¤ï¼Œå› ç‚ºlogæ˜¯æŒ‰æ™‚é–“é †åºæ·»åŠ çš„ï¼‰
    while (battle.battleLog.length > 0) {
      const firstLog = battle.battleLog[0];
      const logTurn = (typeof firstLog === 'string' ? Math.max(0, currentTurn - 1) : (firstLog.turn || 0));
      if (logTurn < minTurnToKeep) {
        battle.battleLog.shift();
      } else {
        break;
      }
    }
    
    // æ›´æ–°æˆ°é¬¥æ—¥èªŒé¡¯ç¤º
    renderBattleLog();
  }
}

// æª¢æŸ¥æŠ€èƒ½æ˜¯å¦å•Ÿç”¨ï¼ˆé è¨­å•Ÿç”¨ï¼‰
// companion: å¯é¸ï¼Œå¦‚æœæä¾›å‰‡æª¢æŸ¥è©²åŒä¼´çš„æŠ€èƒ½å•Ÿç”¨ç‹€æ…‹
function isSkillEnabled(skillId, companion = null) {
  if (!skillId) return false;
  
  // å¦‚æœæ˜¯åŒä¼´çš„æŠ€èƒ½ï¼Œæª¢æŸ¥åŒä¼´çš„æŠ€èƒ½å•Ÿç”¨ç‹€æ…‹
  if (companion && companion.skillEnabled) {
    const enabled = companion.skillEnabled[skillId];
    // å¦‚æœé…ç½®ä¸­æ²’æœ‰è©²æŠ€èƒ½ï¼Œé è¨­ç‚ºå•Ÿç”¨
    if (enabled === undefined) return true;
    // è¿”å›é…ç½®ä¸­çš„å€¼ï¼ˆtrue/falseï¼‰
    return enabled !== false;
  }
  
  // éåŒä¼´æŠ€èƒ½ï¼ˆè‹±é›„æŠ€èƒ½ï¼‰é è¨­å…¨éƒ¨å•Ÿç”¨
  return true;
}

function getActiveSkills() {
  return state.hero.skills
    .map((id) => SKILL_LOOKUP.get(id))
    .filter((skill) => skill && skill.kind && skill.kind !== 'passive' && isSkillEnabled(skill.id));
}

// ç²å–åŒä¼´çš„ä¸»å‹•æŠ€èƒ½
function getCompanionActiveSkills() {
  const activeCompanion = getActiveCompanion();
  if (!activeCompanion) return [];
  return activeCompanion.skills
    .map((id) => SKILL_LOOKUP.get(id))
    .filter((skill) => skill && skill.kind && skill.kind !== 'passive' && isSkillEnabled(skill.id, activeCompanion));
}

function showStartMenu() {
  if (!dom.startScreen) {
    return;
  }
  state.ui.startMenu = true;
  dom.startScreen.classList.remove('hidden');
  updateStartMenuButtons();
}

function hideStartMenu() {
  state.ui.startMenu = false;
  dom.startScreen.classList.add('hidden');
}

function updateStartMenuButtons() {
  const save = loadSavedGame();
  const hasSave = Boolean(save && save.hero && save.world);
  if (dom.continueBtn) {
    dom.continueBtn.disabled = !hasSave;
  }
  if (dom.saveInfo) {
    if (!hasSave) {
      dom.saveInfo.textContent = 'å°šç„¡æš«å­˜å†’éšª';
    } else {
      const level = save.hero?.stats?.level ?? '?';
      const stage = save.world?.stage ?? '?';
      const time = save.timestamp
        ? new Date(save.timestamp).toLocaleString()
        : 'æœªçŸ¥æ™‚é–“';
      dom.saveInfo.textContent = `Lv ${level} / éšæ®µ ${stage}ã€€ä¸Šæ¬¡ç´€éŒ„ï¼š${time}`;
    }
  }
}

function startNewAdventure() {
  console.log('[BUTTON] startNewAdventure() è¢«é»æ“Š');
  clearSavedGame();
  
  // åˆå§‹åŒ–å·²è·å¾—çš„åœ£ç‰©æ•°ç»„
  state.obtainedRelics = [];
  
  // ç”Ÿæˆæ‰€æœ‰åœ£ç‰©ï¼ˆ6é˜¶æ®µÃ—6æµæ´¾ï¼Œæ€»å…±36ä¸ªï¼‰
  generateAllRelics();
  
  // æ ¹æ®èµ·å§‹é˜¶æ®µè‡ªåŠ¨è·å¾—ä¹‹å‰é˜¶æ®µçš„åœ£ç‰©
  const startStage = GAME_CONFIG.startStage || 1;
  if (startStage > 1) {
    const autoObtainedRelics = [];
    // ä¸ºæ¯ä¸ªä¹‹å‰çš„é˜¶æ®µéšæœºé€‰æ‹©ä¸€ä¸ªåœ£ç‰©
    for (let stage = 1; stage < startStage; stage++) {
      const stageRelics = state.relics.filter(r => r.stage === stage);
      if (stageRelics.length > 0) {
        // éšæœºé€‰æ‹©ä¸€ä¸ªåœ£ç‰©
        const randomRelic = stageRelics[Math.floor(Math.random() * stageRelics.length)];
        if (!state.obtainedRelics.includes(randomRelic.id)) {
          state.obtainedRelics.push(randomRelic.id);
          autoObtainedRelics.push({ stage, relic: randomRelic });
          const attrName = ATTRIBUTES.find(a => a.id === randomRelic.attributeType)?.name || randomRelic.attributeType;
          const flowName = FLOWS[randomRelic.flow]?.label || randomRelic.flow;
          console.log(`[RELIC] è‡ªå‹•ç²å¾—éšæ®µ ${stage} çš„åœ£ç‰©ï¼š${randomRelic.name} (${flowName}, ${attrName}+${randomRelic.attributeBonus})`);
        }
      }
    }
    // å­˜å‚¨è‡ªåŠ¨è·å¾—çš„åœ£ç‰©ä¿¡æ¯ï¼Œç¨ååœ¨æ¸¸æˆå¼€å§‹æ—¶æ˜¾ç¤º
    state.ui.autoObtainedRelics = autoObtainedRelics;
  }
  
  // éš±è—é–‹å§‹é¸å–®ï¼ˆå¼·åˆ¶è¨­ç½®ï¼‰
  state.ui.startMenu = false;
  if (dom.startScreen) {
    dom.startScreen.classList.add('hidden');
    dom.startScreen.style.display = 'none';
  }
  // é¡¯ç¤ºè·æ¥­é¡å‹é¸æ“‡è¦–çª—
  state.ui.heroTypeSelection = true;
  dom.modalLayer.classList.remove('hidden');
  dom.levelModal.innerHTML = renderHeroTypeSelection();
  // ç¢ºä¿æ¨¡æ…‹è¦–çª—åœ¨é–‹å§‹é¸å–®ä¹‹ä¸Š
  renderLevelModal();
}

// ç”Ÿæˆæ‰€æœ‰åœ£ç‰©ï¼ˆ6é˜¶æ®µÃ—6æµæ´¾ï¼Œæ€»å…±36ä¸ªï¼‰
function generateAllRelics() {
  const flows = ['sword', 'defender', 'recovery', 'magic', 'agility', 'hero'];
  const attributeTypes = ['attack', 'vitality', 'recovery', 'magic', 'agility'];
  const attributeToFlowMap = {
    attack: ['sword'],
    vitality: ['recovery', 'defender'],
    recovery: ['recovery', 'defender'],
    magic: ['magic'],
    agility: ['agility'],
  };
  
  state.relics = [];
  
  for (let stage = 1; stage <= 6; stage++) {
    for (const flow of flows) {
      // æ ¹æ®æµæ´¾ç¡®å®šå±æ€§ç±»å‹
      let attributeType = 'attack';
      if (flow === 'sword') attributeType = 'attack';
      else if (flow === 'defender' || flow === 'recovery') {
        // ä½“åŠ›æˆ–æ¢å¤éšæœºé€‰æ‹©
        attributeType = Math.random() < 0.5 ? 'vitality' : 'recovery';
      } else if (flow === 'magic') attributeType = 'magic';
      else if (flow === 'agility') attributeType = 'agility';
      else if (flow === 'hero') attributeType = 'attack'; // è‹±é›„ç³»é»˜è®¤åŠ›é‡
      
      const relic = window.RelicSystem.generateRelic(stage, flow, attributeType, SKILL_CHAINS);
      state.relics.push(relic);
    }
  }
  
  // åˆå§‹åŒ–å·²è·å¾—çš„åœ£ç‰©æ•°ç»„ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
  if (!state.obtainedRelics) {
    state.obtainedRelics = [];
  }
  
  console.log(`[RELIC] ç”Ÿæˆäº† ${state.relics.length} ä¸ªåœ£ç‰©`);
}

function continueAdventure() {
  console.log('[BUTTON] continueAdventure() è¢«é»æ“Š');
  const save = loadSavedGame();
  if (!save || !save.hero || !save.world) {
    // å¦‚æœæ²’æœ‰æš«å­˜ï¼Œä¸åŸ·è¡Œä»»ä½•æ“ä½œ
    console.log('[BUTTON] continueAdventure: æ²’æœ‰æ‰¾åˆ°æš«å­˜è¨˜éŒ„');
    return;
  }
  state.hero = {
    ...save.hero,
    stats: {
      ...save.hero.stats,
      gold: save.hero.stats && save.hero.stats.gold != null ? save.hero.stats.gold : 0,
    },
    items:
      save.hero.items && save.hero.items.length > 0
        ? save.hero.items
        : STARTING_ITEMS.map((entry) => ({ ...entry })),
    equipment: save.hero.equipment || {
      weapon: 'wooden_stick',
      shield: null,
      armor: 'cloth_armor',
      accessory: null,
    },
    equipmentInventory: save.hero.equipmentInventory || [],
    superiorEquipment: save.hero.superiorEquipment || {},
  };
  state.world = {
    ...save.world,
    stage: save.world.stage || 1,
    nodes:
      Array.isArray(save.world.nodes) && save.world.nodes.length > 0
        ? save.world.nodes
        : generateRoute(save.world.stage || 1),
    currentNodeIndex: save.world.currentNodeIndex || 0,
  };
  state.log = save.log || [];
  state.companions = save.companions || (save.companion ? [save.companion] : []);
  // ç¢ºä¿æ‰€æœ‰åŒä¼´éƒ½æœ‰ skillEnabled å­—æ®µï¼ˆå…¼å®¹èˆŠå­˜æª”ï¼‰
  state.companions.forEach(companion => {
    if (companion && !companion.skillEnabled) {
      companion.skillEnabled = {};
    }
  });
  state.ui.levelUp = save.levelUp || null;
  state.ui.battle = null;
  
  // åŠ è½½åœ£ç‰©æ•°æ®
  if (save.relics && Array.isArray(save.relics)) {
    state.relics = save.relics;
  } else {
    // å¦‚æœæ²¡æœ‰ä¿å­˜çš„åœ£ç‰©ï¼Œé‡æ–°ç”Ÿæˆ
    generateAllRelics();
  }
  
  // åŠ è½½å·²è·å¾—çš„åœ£ç‰©
  state.obtainedRelics = save.obtainedRelics || [];
  
  hideStartMenu();
  pushLog('ä½ ç¹¼çºŒäº†æœªå®Œæˆçš„å†’éšªã€‚');
  renderAll();
}

function openSettings() {
  state.ui.settings = true;
  dom.modalLayer.classList.remove('hidden');
  dom.levelModal.innerHTML = renderSettingsDialog();
  renderLevelModal();
}

function renderSettingsDialog() {
  const difficulty = state.settings.difficulty || 'normal';
  
  return `
    <div class="settings-dialog">
      <h2>éŠæˆ²è¨­å®š</h2>
      <div class="settings-content">
        <div class="setting-item" style="margin-bottom: 20px;">
          <label style="display: block; margin-bottom: 8px; font-size: 16px; font-weight: bold;">é›£åº¦ï¼š</label>
          <div style="display: flex; gap: 15px; margin-top: 10px; flex-wrap: wrap;">
            <label style="display: flex; align-items: center; gap: 5px; cursor: pointer; user-select: none; padding: 8px 12px; border: 2px solid ${difficulty === 'normal' ? 'var(--accent)' : '#666'}; border-radius: 4px; background: ${difficulty === 'normal' ? 'rgba(100, 200, 100, 0.2)' : 'transparent'};">
              <input type="radio" name="difficulty" value="normal" ${difficulty === 'normal' ? 'checked' : ''} style="cursor: pointer; margin: 0;">
              <span style="font-size: 14px;">ä¸€èˆ¬</span>
          </label>
            <label style="display: flex; align-items: center; gap: 5px; cursor: pointer; user-select: none; padding: 8px 12px; border: 2px solid ${difficulty === 'hard' ? 'var(--accent)' : '#666'}; border-radius: 4px; background: ${difficulty === 'hard' ? 'rgba(255, 200, 100, 0.2)' : 'transparent'};">
              <input type="radio" name="difficulty" value="hard" ${difficulty === 'hard' ? 'checked' : ''} style="cursor: pointer; margin: 0;">
              <span style="font-size: 14px;">é›£</span>
            </label>
            <label style="display: flex; align-items: center; gap: 5px; cursor: pointer; user-select: none; padding: 8px 12px; border: 2px solid ${difficulty === 'hell' ? 'var(--accent)' : '#666'}; border-radius: 4px; background: ${difficulty === 'hell' ? 'rgba(255, 100, 100, 0.2)' : 'transparent'};">
              <input type="radio" name="difficulty" value="hell" ${difficulty === 'hell' ? 'checked' : ''} style="cursor: pointer; margin: 0;">
              <span style="font-size: 14px;">åœ°ç„</span>
            </label>
        </div>
          <p class="setting-description" style="margin-top: 10px; font-size: 12px; color: #aaa;">
            é›£åº¦è¶Šé«˜ï¼Œæ•µäººçš„å±¬æ€§åŠ æˆè¶Šé«˜ï¼ˆå½±éŸ¿æ‰€æœ‰éšå±¤çš„æ€ªç‰©ï¼‰
          </p>
        </div>
      </div>
      <div class="settings-buttons">
        <button class="primary-btn" data-action="save-settings">å„²å­˜è¨­å®š</button>
        <button class="ghost-btn" data-action="cancel-settings">å–æ¶ˆ</button>
      </div>
    </div>
  `;
}

function saveSettings() {
  const difficultyInputs = document.querySelectorAll('input[name="difficulty"]');
  
  // ç²å–é¸ä¸­çš„é›£åº¦
  if (difficultyInputs.length > 0) {
    const selectedDifficulty = Array.from(difficultyInputs).find(input => input.checked);
    if (selectedDifficulty && ['normal', 'hard', 'hell'].includes(selectedDifficulty.value)) {
      state.settings.difficulty = selectedDifficulty.value;
    }
  }
  
  // åªä¿å­˜é›£åº¦è¨­å®šåˆ° localStorage
  if (typeof localStorage !== 'undefined') {
    localStorage.setItem('gameSettings', JSON.stringify({ difficulty: state.settings.difficulty }));
  }
  
  state.ui.settings = null;
  dom.modalLayer.classList.add('hidden');
  dom.levelModal.innerHTML = '';
  pushLog('è¨­å®šå·²å„²å­˜ã€‚');
  renderAll();
}

function cancelSettings() {
  state.ui.settings = null;
  dom.modalLayer.classList.add('hidden');
  dom.levelModal.innerHTML = '';
  renderAll();
}

// è¼‰å…¥è¨­å®šï¼ˆåªè¼‰å…¥é›£åº¦è¨­å®šï¼‰
function loadSettings() {
  // åˆå§‹åŒ–é›£åº¦ç‚ºé»˜èªå€¼
  state.settings.difficulty = 'normal';
  
  // å¾localStorageè®€å–ç”¨æˆ¶è¨­å®šçš„é›£åº¦ï¼ˆå¦‚æœæœ‰çš„è©±ï¼‰
  if (typeof localStorage !== 'undefined') {
    const saved = localStorage.getItem('gameSettings');
    if (saved) {
      try {
        const savedSettings = JSON.parse(saved);
        // åªä¿ç•™ç”¨æˆ¶è¨­å®šçš„é›£åº¦
        if (savedSettings.difficulty !== undefined && ['normal', 'hard', 'hell'].includes(savedSettings.difficulty)) {
          state.settings.difficulty = savedSettings.difficulty;
        }
      } catch (e) {
      }
    }
  }
}

// é‡æ–°è¨ˆç®—ä¸¦æ‡‰ç”¨æ‰€æœ‰è¢«å‹•æŠ€èƒ½çš„HP/MPåŠ æˆ
function applyPassiveSkillBonuses(character) {
  if (!character || !character.skills) return;
  
  // ç²å–é˜²å®ˆå‹è¢«å‹•æŠ€èƒ½çš„HPåŠ æˆ
  const defenderEffects = getDefenderPassiveEffects(character);
  const hpBonus = defenderEffects.hpBonus || 0;
  
  // ç²å–é­”æ³•å‹è¢«å‹•æŠ€èƒ½çš„MPåŠ æˆ
  const magicEffects = getMagicPassiveEffects(character);
  const mpBonus = magicEffects.mpBonus || 0;
  
  // ä¿å­˜ç•¶å‰çš„HP/MPæ¯”ä¾‹
  const hpPercent = character.stats.hp / character.stats.maxHp;
  const mpPercent = character.stats.mp / character.stats.maxMp;
  
  // è¨ˆç®—ç•¶å‰æ‡‰è©²æœ‰çš„è¢«å‹•æŠ€èƒ½åŠ æˆç¸½é¡
  // ç”±æ–¼è¢«å‹•æŠ€èƒ½åŠ æˆæ˜¯åœ¨å­¸ç¿’æŠ€èƒ½æ™‚é€æ­¥æ‡‰ç”¨çš„ï¼Œæˆ‘å€‘éœ€è¦ç¢ºä¿å®ƒå€‘è¢«æ­£ç¢ºæ‡‰ç”¨
  // é€™è£¡æˆ‘å€‘å‡è¨­ç•¶å‰çš„maxHp/maxMpå·²ç¶“åŒ…å«äº†è¢«å‹•æŠ€èƒ½åŠ æˆ
  // æ‰€ä»¥æˆ‘å€‘ä¸éœ€è¦é‡æ–°è¨ˆç®—ï¼Œåªéœ€è¦ç¢ºä¿å®ƒå€‘æ˜¯æ­£ç¢ºçš„å³å¯
  
  // å¯¦éš›ä¸Šï¼Œåœ¨ learnSkill å‡½æ•¸ä¸­å·²ç¶“è™•ç†äº†è¢«å‹•æŠ€èƒ½çš„åŠ æˆ
  // é€™å€‹å‡½æ•¸çš„ä¸»è¦ç›®çš„æ˜¯ç¢ºä¿åœ¨è‡ªå‹•å‡ç´šå®Œæˆå¾Œï¼Œæ‰€æœ‰è¢«å‹•æŠ€èƒ½çš„åŠ æˆéƒ½è¢«æ­£ç¢ºæ‡‰ç”¨
  // ç”±æ–¼è¢«å‹•æŠ€èƒ½åŠ æˆæ˜¯åœ¨å­¸ç¿’æŠ€èƒ½æ™‚é€æ­¥æ‡‰ç”¨çš„ï¼Œé€™è£¡æˆ‘å€‘ä¸éœ€è¦åšé¡å¤–çš„è™•ç†
  // åªéœ€è¦ç¢ºä¿ç•¶å‰å€¼æ­£ç¢ºå³å¯
  
  // ç‚ºäº†å®‰å…¨èµ·è¦‹ï¼Œæˆ‘å€‘ä¸æ”¹è®Šç•¶å‰çš„maxHp/maxMp
  // å› ç‚ºå®ƒå€‘æ‡‰è©²å·²ç¶“åŒ…å«äº†è¢«å‹•æŠ€èƒ½åŠ æˆï¼ˆåœ¨å­¸ç¿’æŠ€èƒ½æ™‚å·²ç¶“æ‡‰ç”¨ï¼‰
}

// è‡ªå‹•å‡ç´šåˆ°ç›®æ¨™ç­‰ç´š
function autoLevelUpToTarget(targetLevel) {
  if (!state.hero || targetLevel <= state.hero.stats.level) return;
  
  const levelsToGain = targetLevel - state.hero.stats.level;
  const hero = state.hero;
  const startLevel = hero.stats.level;
  
  // é€æ­¥å‡ç´šæ¯å€‹ç­‰ç´š
  for (let i = 1; i <= levelsToGain; i++) {
    const currentLevel = startLevel + i;
    hero.stats.level = currentLevel;
    
    // æ¯ç´šå¢åŠ HPå’ŒMP
    const hpGain = rollHpGrowth(hero);
    const mpGain = rollMpGrowth(hero);
    hero.stats.maxHp = Math.ceil(hero.stats.maxHp + hpGain);
    hero.stats.maxMp = Math.ceil(hero.stats.maxMp + mpGain);
    hero.stats.mp = Math.ceil(Math.min(hero.stats.maxMp, hero.stats.mp + mpGain));
    
    // å±¬æ€§æå‡æ”¹ç‚ºç©å®¶é¸æ“‡ï¼Œè‡ªå‹•å‡ç´šæ™‚æ ¹æ“šè·æ¥­é¡å‹æ™ºèƒ½é¸æ“‡å±¬æ€§
    const attributeBonus = Math.ceil(currentLevel / 20); // ç­‰ç´š/20ç„¡æ¢ä»¶é€²ä½
    // æ ¹æ“šè·æ¥­é¡å‹å„ªå…ˆé¸æ“‡æˆé•·å€¼é«˜çš„å±¬æ€§
    let selectedAttr = null;
    if (hero.heroType && HERO_TYPES[hero.heroType]) {
      const type = HERO_TYPES[hero.heroType];
      const levelUpBonus = type.levelUpBonus || {};
      // æ‰¾å‡ºæˆé•·å€¼æœ€é«˜çš„å±¬æ€§
      const sortedAttrs = Object.entries(levelUpBonus)
        .sort((a, b) => b[1] - a[1])
        .map(([attrId]) => attrId);
      if (sortedAttrs.length > 0) {
        // 70%æ©Ÿç‡é¸æ“‡æˆé•·å€¼æœ€é«˜çš„å±¬æ€§ï¼Œ30%æ©Ÿç‡é¸æ“‡ç¬¬äºŒé«˜çš„å±¬æ€§
        const index = Math.random() < 0.7 ? 0 : Math.min(1, sortedAttrs.length - 1);
        selectedAttr = ATTRIBUTES.find(attr => attr.id === sortedAttrs[index]);
      }
    }
    // å¦‚æœæ²’æœ‰æ‰¾åˆ°åˆé©çš„å±¬æ€§ï¼Œéš¨æ©Ÿé¸æ“‡
    if (!selectedAttr) {
      selectedAttr = ATTRIBUTES[Math.floor(Math.random() * ATTRIBUTES.length)];
    }
    hero.attributes[selectedAttr.id] = (hero.attributes[selectedAttr.id] || 0) + attributeBonus;
    
    // æ ¹æ“šè·æ¥­é¡å‹é¡å¤–åŠ æˆ
    if (hero.heroType && HERO_TYPES[hero.heroType]) {
      const type = HERO_TYPES[hero.heroType];
      Object.keys(type.levelUpBonus).forEach((attr) => {
        hero.attributes[attr] += type.levelUpBonus[attr];
      });
    }
    
    // æ¯é …å±¬æ€§éš¨æ©Ÿæˆé•·ï¼ˆheroGrowthMin åˆ° heroGrowthMaxï¼‰
    const heroGrowthMin = GAME_CONFIG.heroGrowthMin || 1;
    const heroGrowthMax = GAME_CONFIG.heroGrowthMax || 2.5;
    ATTRIBUTES.forEach((attr) => {
      // ç”Ÿæˆ heroGrowthMin åˆ° heroGrowthMax ä¹‹é–“çš„éš¨æ©Ÿå°æ•¸
      const randomGain = Math.random() * (heroGrowthMax - heroGrowthMin) + heroGrowthMin;
      hero.attributes[attr.id] = (hero.attributes[attr.id] || 0) + randomGain;
    });
    
    // æ¯å…©ç´šç²å¾—ä¸€å€‹æŠ€èƒ½ï¼ˆè‡ªå‹•é¸æ“‡ï¼‰
    if (currentLevel % 2 === 0 && currentLevel >= 2) {
      const skillOptions = rollSkillOptions();
      if (skillOptions.length > 0) {
        // æ™ºèƒ½é¸æ“‡æŠ€èƒ½ï¼šå„ªå…ˆé¸æ“‡æœ¬æµæ´¾çš„æŠ€èƒ½
        const initialFlowMap = {
          attacker: 'sword',
          mage: 'magic',
          healer: 'recovery',
          defender: 'defender',
          agile: 'agility',
        };
        const initialFlow = hero.heroType ? (initialFlowMap[hero.heroType] || 'sword') : 'sword';
        const primaryFlow = initialFlow;
        
        // éæ¿¾å¯ç”¨æŠ€èƒ½
        const availableSkills = skillOptions.filter(skill => {
          return currentLevel >= (skill.requiredLevel || 0);
        });
        
        let selectedSkill = null;
        if (availableSkills.length > 0) {
          // 70%æ©Ÿç‡é¸æ“‡è©²æµæ´¾çš„æŠ€èƒ½
          if (Math.random() < 0.7) {
            const primaryFlowSkills = availableSkills.filter(skill => {
              const skillObj = SKILL_LOOKUP.get(skill.id);
              return skillObj && skillObj.flow === primaryFlow;
            });
            if (primaryFlowSkills.length > 0) {
              selectedSkill = primaryFlowSkills[Math.floor(Math.random() * primaryFlowSkills.length)];
            }
          }
          
          // å¦‚æœæ²’æœ‰æ‰¾åˆ°è©²æµæ´¾çš„æŠ€èƒ½ï¼Œæˆ–30%æ©Ÿç‡ï¼Œéš¨æ©Ÿé¸æ“‡
          if (!selectedSkill) {
            selectedSkill = availableSkills[Math.floor(Math.random() * availableSkills.length)];
          }
          
          if (selectedSkill) {
            learnSkill(selectedSkill);
            pushLog(`è‡ªå‹•å­¸æœƒäº†ã€Œ${selectedSkill.name}ã€ï¼`);
          }
        }
      }
    }
  }
  
  // è¨­ç½®ç¶“é©—å€¼ç‚º0ï¼ˆå·²ç¶“å‡ç´šå®Œæˆï¼‰
  hero.stats.xp = 0;
  
  // æ›´æ–°ä¸‹ä¸€ç´šç¶“é©—å€¼éœ€æ±‚ï¼ˆæ ¹æ“šç•¶å‰ç­‰ç´šè¨ˆç®—ï¼‰
  hero.stats.nextLevelXp = 10;
  for (let i = 1; i < targetLevel; i++) {
    hero.stats.nextLevelXp = Math.round(hero.stats.nextLevelXp * 1.3);
  }
  
  // é‡æ–°è¨ˆç®—ä¸¦æ‡‰ç”¨æ‰€æœ‰è¢«å‹•æŠ€èƒ½çš„HP/MPåŠ æˆï¼ˆç¢ºä¿æ­£ç¢ºæ‡‰ç”¨ï¼‰
  applyPassiveSkillBonuses(hero);
  
  // HP/MPè£œæ»¿
  hero.stats.hp = hero.stats.maxHp;
  hero.stats.mp = hero.stats.maxMp;
  
  pushLog(`è‡ªå‹•å‡ç´šåˆ° Lv ${targetLevel}ï¼`);
  
  // åŒæ­¥å‡ç´šæ‰€æœ‰åŒä¼´åˆ°åŒæ¨£çš„ç­‰ç´š
  const activeCompanions = (state.companions || []).filter(c => c && c.stats);
  activeCompanions.forEach(companion => {
    if (companion.stats.level < targetLevel) {
      const companionLevelsToGain = targetLevel - companion.stats.level;
      const upgradeInfo = levelUpCompanion(companion, companionLevelsToGain);
      // è‡ªå‹•è™•ç†å±¬æ€§é¸æ“‡å’ŒæŠ€èƒ½é¸æ“‡ï¼ˆè‡ªå‹•å‡ç´šæ™‚è‡ªå‹•é¸æ“‡ï¼‰
      if (upgradeInfo) {
        autoProcessCompanionUpgrade(upgradeInfo);
      }
      // åŒä¼´çš„HP/MPä¹Ÿè£œæ»¿
      companion.stats.hp = companion.stats.maxHp;
      companion.stats.mp = companion.stats.maxMp;
    }
  });
}

// è‡ªå‹•è™•ç†ä¼™ä¼´å‡ç´šï¼ˆç”¨æ–¼åˆå§‹å‡ç´šå’Œè‡ªå‹•å‡ç´šï¼Œéš¨æ©Ÿé¸æ“‡å±¬æ€§å’ŒæŠ€èƒ½ï¼‰
function autoProcessCompanionUpgrade(compUpgrade) {
  if (!compUpgrade || !compUpgrade.companion) return;
  
  const companion = compUpgrade.companion;
  
  // è‡ªå‹•è™•ç†å±¬æ€§é¸æ“‡ï¼ˆæ ¹æ“šè·æ¥­é¡å‹æ™ºèƒ½é¸æ“‡ï¼‰
  if (compUpgrade.attributeSelections && compUpgrade.attributeSelections.length > 0) {
    const companionType = COMPANION_TYPES[companion.companionTypeId];
    compUpgrade.attributeSelections.forEach(selection => {
      if (!selection.selected) {
        // æ ¹æ“šè·æ¥­é¡å‹å„ªå…ˆé¸æ“‡æˆé•·å€¼é«˜çš„å±¬æ€§
        let selectedAttr = null;
        if (companionType && companionType.levelUpBonus) {
          const levelUpBonus = companionType.levelUpBonus;
          // æ‰¾å‡ºæˆé•·å€¼æœ€é«˜çš„å±¬æ€§
          const sortedAttrs = Object.entries(levelUpBonus)
            .sort((a, b) => b[1] - a[1])
            .map(([attrId]) => attrId);
          if (sortedAttrs.length > 0) {
            // 70%æ©Ÿç‡é¸æ“‡æˆé•·å€¼æœ€é«˜çš„å±¬æ€§ï¼Œ30%æ©Ÿç‡é¸æ“‡ç¬¬äºŒé«˜çš„å±¬æ€§
            const index = Math.random() < 0.7 ? 0 : Math.min(1, sortedAttrs.length - 1);
            selectedAttr = ATTRIBUTES.find(attr => attr.id === sortedAttrs[index]);
          }
        }
        // å¦‚æœæ²’æœ‰æ‰¾åˆ°åˆé©çš„å±¬æ€§ï¼Œéš¨æ©Ÿé¸æ“‡
        if (!selectedAttr) {
          selectedAttr = ATTRIBUTES[Math.floor(Math.random() * ATTRIBUTES.length)];
        }
        companion.attributes[selectedAttr.id] = (companion.attributes[selectedAttr.id] || 0) + selection.bonus;
        selection.selected = true;
        selection.selectedAttribute = selectedAttr.id;
      }
    });
  }
  
  // è‡ªå‹•è™•ç†æŠ€èƒ½é¸æ“‡ï¼ˆå„ªå…ˆé¸æ“‡æœ¬è·æ¥­æŠ€èƒ½ï¼‰
  if (compUpgrade.skillSelections && compUpgrade.skillSelections.length > 0) {
    const companionType = COMPANION_TYPES[companion.companionTypeId];
    const heroType = companionType?.heroType || companion.heroType;
    
    // ç¢ºå®šä¸»è¦æµæ´¾
    const initialFlowMap = {
      attacker: 'sword',
      mage: 'magic',
      healer: 'recovery',
      defender: 'defender',
      agile: 'agility',
      sage: 'magic', // è³¢è€…ä¸»è¦æµæ´¾æ˜¯é­”æ³•
      paladin: 'defender', // è–é¨å£«ä¸»è¦æµæ´¾æ˜¯é˜²å®ˆ
      weaponmaster: 'sword', // æ­¦å™¨å¤§å¸«ä¸»è¦æµæ´¾æ˜¯åŠæŠ€
    };
    const primaryFlow = heroType ? (initialFlowMap[heroType] || 'sword') : 'sword';
    
    compUpgrade.skillSelections.forEach(selection => {
      if (!selection.selected && selection.options.length > 0) {
        // éæ¿¾å¯ç”¨æŠ€èƒ½
        const availableSkills = selection.options.filter(skill => {
          const heroLevel = companion.stats.level;
          return heroLevel >= (skill.requiredLevel || 0);
        });
        
        if (availableSkills.length > 0) {
          let selectedSkill = null;
          // 70%æ©Ÿç‡é¸æ“‡è©²æµæ´¾çš„æŠ€èƒ½
          if (Math.random() < 0.7) {
            const primaryFlowSkills = availableSkills.filter(skill => {
              const skillObj = SKILL_LOOKUP.get(skill.id);
              return skillObj && skillObj.flow === primaryFlow;
            });
            if (primaryFlowSkills.length > 0) {
              selectedSkill = primaryFlowSkills[Math.floor(Math.random() * primaryFlowSkills.length)];
            }
          }
          
          // å¦‚æœæ²’æœ‰æ‰¾åˆ°è©²æµæ´¾çš„æŠ€èƒ½ï¼Œæˆ–30%æ©Ÿç‡ï¼Œéš¨æ©Ÿé¸æ“‡
          if (!selectedSkill) {
            selectedSkill = availableSkills[Math.floor(Math.random() * availableSkills.length)];
          }
          
          if (selectedSkill) {
          learnCompanionSkill(companion, selectedSkill);
          selection.selected = true;
          selection.selectedSkillId = selectedSkill.id;
          } else {
            // æ²’æœ‰å¯ç”¨æŠ€èƒ½ï¼Œæ¨™è¨˜ç‚ºå·²è·³é
            selection.selected = true;
            selection.selectedSkillId = null;
          }
        } else {
          // æ²’æœ‰å¯ç”¨æŠ€èƒ½ï¼Œæ¨™è¨˜ç‚ºå·²è·³é
          selection.selected = true;
          selection.selectedSkillId = null;
        }
      }
    });
  }
}

function saveGameState() {
  if (typeof localStorage === 'undefined') return;
  if (!state.hero || state.ui.startMenu) return;
  if (state.hero.stats.hp <= 0) {
    clearSavedGame();
    return;
  }
  if (state.ui.battle) return; // é¿å…åœ¨æˆ°é¬¥ä¸­å­˜æª”é€ æˆç‹€æ…‹æ··äº‚
  try {
    const payload = {
      hero: state.hero,
      companions: state.companions,
      world: state.world,
      log: state.log.slice(-MAX_LOG_ENTRIES),
      levelUp: state.ui.levelUp,
      relics: state.relics, // ä¿å­˜æ‰€æœ‰åœ£ç‰©
      obtainedRelics: state.obtainedRelics || [], // ä¿å­˜å·²è·å¾—çš„åœ£ç‰©ID
      timestamp: Date.now(),
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
    updateStartMenuButtons();
  } catch (error) {
  }
}

function loadSavedGame() {
  if (typeof localStorage === 'undefined') return null;
  const raw = localStorage.getItem(STORAGE_KEY);
  if (!raw) return null;
  try {
    return JSON.parse(raw);
  } catch (error) {
    return null;
  }
}

function clearSavedGame() {
  if (typeof localStorage === 'undefined') return;
  localStorage.removeItem(STORAGE_KEY);
  updateStartMenuButtons();
}

// ä¿å­˜éšæ®µå‚™ä»½ï¼ˆæ¯å€‹éšæ®µçš„ç¬¬ä¸€å€‹ç¯€é»ï¼‰
function saveStageBackup() {
  if (typeof localStorage === 'undefined') return;
  if (!state.hero || !state.world) return;
  if (state.world.currentNodeIndex !== 0) return; // åªä¿å­˜ç¬¬ä¸€å€‹ç¯€é»çš„ç‹€æ…‹
  
  try {
    const payload = {
      hero: JSON.parse(JSON.stringify(state.hero)), // æ·±æ‹·è²
      companions: JSON.parse(JSON.stringify(state.companions || [])),
      world: {
        stage: state.world.stage,
        currentNodeIndex: 0,
        nodes: JSON.parse(JSON.stringify(state.world.nodes)),
        currentArea: state.world.currentArea,
      },
      log: state.log.slice(-MAX_LOG_ENTRIES),
      relics: state.relics, // ä¿å­˜æ‰€æœ‰åœ£ç‰©
      obtainedRelics: state.obtainedRelics || [], // ä¿å­˜å·²è·å¾—çš„åœ£ç‰©ID
      timestamp: Date.now(),
    };
    localStorage.setItem(STAGE_BACKUP_KEY, JSON.stringify(payload));
  } catch (error) {
  }
}

// è¼‰å…¥éšæ®µå‚™ä»½
function loadStageBackup() {
  if (typeof localStorage === 'undefined') return null;
  const raw = localStorage.getItem(STAGE_BACKUP_KEY);
  if (!raw) return null;
  try {
    return JSON.parse(raw);
  } catch (error) {
    return null;
  }
}

// æ¸…é™¤éšæ®µå‚™ä»½
function clearStageBackup() {
  if (typeof localStorage === 'undefined') return;
  try {
    localStorage.removeItem(STAGE_BACKUP_KEY);
  } catch (error) {
    // å¿½ç•¥éŒ¯èª¤
  }
}

// å¾éšæ®µç¬¬ä¸€å€‹ç¯€é»é–‹å§‹
function restartFromStageStart() {
  const backup = loadStageBackup();
  if (!backup || !backup.hero || !backup.world) {
    // å¦‚æœæ²’æœ‰éšæ®µå‚™ä»½ï¼Œå¾é ­é–‹å§‹
    restartGame();
    return;
  }
  
  // è¼‰å…¥éšæ®µå‚™ä»½
  state.hero = {
    ...backup.hero,
    stats: {
      ...backup.hero.stats,
      gold: backup.hero.stats && backup.hero.stats.gold != null ? backup.hero.stats.gold : 0,
      hp: backup.hero.stats.maxHp, // è£œæ»¿HP
      mp: backup.hero.stats.maxMp, // è£œæ»¿MP
    },
    items: backup.hero.items && backup.hero.items.length > 0
      ? backup.hero.items
      : STARTING_ITEMS.map((entry) => ({ ...entry })),
    equipment: backup.hero.equipment || {
      weapon: 'wooden_stick',
      shield: null,
      armor: 'cloth_armor',
      accessory: null,
    },
    equipmentInventory: backup.hero.equipmentInventory || [],
    superiorEquipment: backup.hero.superiorEquipment || {},
  };
  
  state.world = {
    ...backup.world,
    stage: backup.world.stage || 1,
    nodes: Array.isArray(backup.world.nodes) && backup.world.nodes.length > 0
      ? backup.world.nodes
      : generateRoute(backup.world.stage || 1),
    currentNodeIndex: 0,
  };
  
  state.log = backup.log || [];
  state.companions = (backup.companions || []).map(companion => ({
    ...companion,
    stats: {
      ...companion.stats,
      hp: companion.stats.maxHp, // è£œæ»¿HP
      mp: companion.stats.maxMp, // è£œæ»¿MP
    },
  }));
  
  // åŠ è½½åœ£ç‰©æ•°æ®
  if (backup.relics && Array.isArray(backup.relics)) {
    state.relics = backup.relics;
  } else {
    // å¦‚æœæ²¡æœ‰ä¿å­˜çš„åœ£ç‰©ï¼Œé‡æ–°ç”Ÿæˆ
    generateAllRelics();
  }
  
  // åŠ è½½å·²è·å¾—çš„åœ£ç‰©
  state.obtainedRelics = backup.obtainedRelics || [];
  
  // æ¸…ç©ºæ­»äº¡ç›¸é—œç‹€æ…‹
  state.ui.deathInfo = null;
  state.ui.gameStats = null;
  state.ui.battle = null;
  state.ui.levelUp = null;
  
  // è£œæ»¿æ‰€æœ‰äººçš„HP/MP
  if (state.hero && state.hero.stats) {
    state.hero.stats.hp = state.hero.stats.maxHp;
    state.hero.stats.mp = state.hero.stats.maxMp;
  }
  if (state.companions && state.companions.length > 0) {
    state.companions.forEach(companion => {
      if (companion && companion.stats) {
        companion.stats.hp = companion.stats.maxHp;
        companion.stats.mp = companion.stats.maxMp;
      }
    });
  }
  
  pushLog(`å¾ç¬¬${state.world.stage}éšæ®µçš„ç¬¬ä¸€å€‹ç¯€é»é‡æ–°é–‹å§‹å†’éšªã€‚`);
  pushLog('æ‰€æœ‰äººçš„HPå’ŒMPéƒ½å·²è£œæ»¿ï¼');
  
  renderBackground();
  renderAll();
}

function handleGameOver() {
  // ç¢ºä¿æœ‰æ­»äº¡ä¿¡æ¯å’ŒéŠæˆ²çµ±è¨ˆï¼ˆå¦‚æœæ²’æœ‰ï¼Œå‰µå»ºé»˜èªçš„ï¼‰
  if (!state.ui.deathInfo) {
    state.ui.deathInfo = {
    cause: 'unknown',
    attacker: 'æœªçŸ¥',
    damage: 0,
    skill: null,
    isCrit: false,
  };
  }
  
  if (!state.ui.gameStats) {
    state.ui.gameStats = {
    level: state.hero ? state.hero.stats.level : 1,
    stage: state.world ? state.world.stage : 1,
    currentNodeIndex: state.world ? state.world.currentNodeIndex : 0,
    gold: state.hero ? state.hero.stats.gold : 0,
    companionsCount: (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0).length,
    skillsCount: state.hero && state.hero.skills ? state.hero.skills.length : 0,
    equipmentCount: state.hero && state.hero.equipmentInventory ? state.hero.equipmentInventory.length : 0,
  };
  }
  
  // èª¿è©¦ä¿¡æ¯
  
  // renderLevelModal æœƒè™•ç†é¡¯ç¤ºæ­»äº¡çµ±è¨ˆç•Œé¢
}

// å‹•ç•«å‡½æ•¸ï¼ˆä¿ç•™ä»¥å‚™å°‡ä¾†ä½¿ç”¨ï¼‰
function animateHeroAttack(callback) {
  if (callback) callback();
}

function animateEnemyAttack(callback) {
  if (callback) callback();
}

function showDamageNumber(amount, target, type) {
  // æš«æ™‚ä¸é¡¯ç¤ºå‚·å®³æ•¸å­—
}

function showSkillEffect(skill, target, callback) {
  if (callback) callback();
}

// è™•ç†æŠ€èƒ½è¨“ç·´å¸«äº‹ä»¶
function handleSkillTrainerEvent(option) {
  const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
  
  if (activeCompanions.length === 0) {
    pushLog('æŠ€èƒ½è¨“ç·´å¸«ï¼šä½ æ²’æœ‰æ´»è‘—çš„åŒä¼´ï¼Œç„¡æ³•é€²è¡ŒæŠ€èƒ½è¨“ç·´ã€‚');
    advanceToNextNode();
    renderAll();
    return;
  }
  
  state.ui.skillTrainer = {
    step: 'selectCompanion',
    selectedCompanionIndex: null,
    skillOptions: [], // æ–°æŠ€èƒ½é¸é …ï¼ˆå››é¸ä¸€ï¼‰
  };
  state.ui.skillTrainerConfirmCancel = false;
  
  renderAll();
}

// æ¸²æŸ“æŠ€èƒ½è¨“ç·´å¸«å°è©±æ¡†
function renderSkillTrainerDialog(trainerState) {
  const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
  
  // å¦‚æœé¡¯ç¤ºç¢ºèªå–æ¶ˆå°è©±æ¡†
  if (state.ui.skillTrainerConfirmCancel) {
    return `
      <h2>æŠ€èƒ½è¨“ç·´å¸«</h2>
      <div class="event-message">
        <p style="white-space: pre-line; font-size: 14.4px; line-height: 1.8; margin: 20px 0;">
          ç¢ºå®šè¦æ”¾æ£„æŠ€èƒ½è¨“ç·´å—ï¼Ÿ
        </p>
      </div>
      <div class="event-choices" style="display: flex; flex-direction: column; gap: 10px; margin-top: 20px;">
        <button class="continue-btn" onclick="cancelSkillTrainer();" style="background: #d32f2f;">ç¢ºå®šæ”¾æ£„</button>
        <button class="continue-btn" onclick="cancelConfirmCancelSkillTrainer();" style="background: #666;">è¿”å›</button>
      </div>
    `;
  }
  
  if (trainerState.step === 'selectCompanion') {
    const companionButtons = activeCompanions.map((companion, index) => `
      <button class="dialog-option" onclick="selectSkillTrainerCompanion(${index});">
        <strong>${companion.name}</strong>
        <small>Lv ${companion.stats.level} | ${formatHpDisplay(companion)}</small>
        </button>
    `).join('');
    
    return `
      <h2>æŠ€èƒ½è¨“ç·´å¸«</h2>
      <div class="event-message">
        <p style="white-space: pre-line; font-size: 14.4px; line-height: 1.8; margin: 20px 0;">
          ä½ é‡åˆ°äº†ä¸€ä½æŠ€èƒ½è¨“ç·´å¸«ã€‚ä»–å¯ä»¥å¹«åŠ©åŒä¼´å­¸ç¿’ä¸€å€‹æ–°çš„æŠ€èƒ½ã€‚
        </p>
        <p style="margin-top: 15px; font-weight: bold;">è«‹é¸æ“‡è¦è¨“ç·´çš„åŒä¼´ï¼š</p>
      </div>
      <div class="event-choices" style="display: flex; flex-direction: column; gap: 10px; margin-top: 20px;">
        ${companionButtons}
        <button class="continue-btn" onclick="confirmCancelSkillTrainer();" style="background: #666;">å–æ¶ˆ</button>
      </div>
    `;
  } else if (trainerState.step === 'selectNewSkill') {
    const companion = activeCompanions[trainerState.selectedCompanionIndex];
    
    if (!companion || !trainerState.skillOptions || trainerState.skillOptions.length === 0) {
      cancelSkillTrainer();
      return '';
    }
    
    const skillButtons = trainerState.skillOptions.map((skill, index) => {
      const flowLabel = FLOWS[skill.flow]?.label || skill.flow;
      const flowColor = FLOW_PALETTE[skill.flow] || '#fff';
      const skillTypeLabel = skill.kind === 'passive' ? 'è¢«å‹•' : 'ä¸»å‹•';
      const skillTypeColor = skill.kind === 'passive' ? '#d4a5f5' : '#9fc5e8';
      return `
        <button class="dialog-option" onclick="selectSkillTrainerNewSkill(${index});">
          <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
            <span class="badge" style="background:${flowColor}">${flowLabel}</span>
            <span class="badge" style="background:${skillTypeColor}">${skillTypeLabel}</span>
            <strong>${skill.name}</strong>
          </div>
          <small>${skill.description}</small>
          ${skill.requiredLevel !== undefined ? `<small>éœ€æ±‚ç­‰ç´šï¼šLv${skill.requiredLevel}</small>` : ''}
        </button>
      `;
    }).join('');
    
    return `
      <h2>æŠ€èƒ½è¨“ç·´å¸«</h2>
      <div class="event-message">
        <p style="white-space: pre-line; font-size: 14.4px; line-height: 1.8; margin: 20px 0;">
          ç‚º ${companion.name} é¸æ“‡ä¸€å€‹æ–°æŠ€èƒ½å­¸ç¿’ï¼š
        </p>
      </div>
      <div class="event-choices" style="display: flex; flex-direction: column; gap: 10px; margin-top: 20px;">
        ${skillButtons}
        <button class="continue-btn" onclick="cancelSkillTrainer();" style="background: #666;">æ”¾æ£„</button>
      </div>
    `;
  }
  
  return '';
}

// é¸æ“‡æŠ€èƒ½è¨“ç·´å¸«çš„åŒä¼´
function selectSkillTrainerCompanion(companionIndex) {
  const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
  if (!state.ui.skillTrainer || companionIndex < 0 || companionIndex >= activeCompanions.length) {
    return;
  }
  
  const companion = activeCompanions[companionIndex];
  if (!companion) return;
  
  // ç²å–æ‰€æœ‰å·²å­¸ç¿’çš„æŠ€èƒ½IDé›†åˆï¼ˆåŒ…æ‹¬æ‰€æœ‰åŒä¼´å’Œå‹‡è€…ï¼‰
  const allLearnedSkills = new Set(companion.skills);
  if (state.hero && state.hero.skills) {
    state.hero.skills.forEach(skillId => allLearnedSkills.add(skillId));
  }
  (state.companions || []).forEach(comp => {
    if (comp && comp.skills) {
      comp.skills.forEach(skillId => allLearnedSkills.add(skillId));
    }
  });
  
  // ç²å–æ‰€æœ‰æœªå­¸éçš„æŠ€èƒ½ï¼ˆæ’é™¤å·²å­¸ç¿’çš„ã€heroæµï¼‰
  const allSkills = Array.from(SKILL_LOOKUP.values());
  const candidateSkills = allSkills.filter(skill => {
    // ä¸èƒ½æ˜¯å·²å­¸ç¿’çš„æŠ€èƒ½
    if (allLearnedSkills.has(skill.id)) return false;
    // ä¸èƒ½æ˜¯heroæµçš„æŠ€èƒ½
    if (skill.flow === 'hero') return false;
    // å¯ä»¥æ˜¯ä¸»å‹•æˆ–è¢«å‹•æŠ€èƒ½ï¼ˆä¸é™åˆ¶é¡å‹ï¼‰
    // æª¢æŸ¥ç­‰ç´šè¦æ±‚
    const companionLevel = companion.stats.level;
    if (skill.requiredLevel !== undefined && companionLevel < skill.requiredLevel) return false;
    return true;
  });
  
  if (candidateSkills.length === 0) {
    pushLog('æŠ€èƒ½è¨“ç·´å¸«ï¼šæ²’æœ‰å¯å­¸ç¿’çš„æ–°æŠ€èƒ½ã€‚');
    cancelSkillTrainer();
    return;
  }
  
  // éš¨æ©Ÿæ‰“äº‚ä¸¦é¸æ“‡4å€‹æŠ€èƒ½
  const shuffled = [...candidateSkills].sort(() => Math.random() - 0.5);
  const skillOptions = shuffled.slice(0, Math.min(4, shuffled.length));
  
  state.ui.skillTrainer.selectedCompanionIndex = companionIndex;
  state.ui.skillTrainer.skillOptions = skillOptions;
  state.ui.skillTrainer.step = 'selectNewSkill';
  renderAll();
}

// é¸æ“‡æŠ€èƒ½è¨“ç·´å¸«çš„æ–°æŠ€èƒ½
function selectSkillTrainerNewSkill(skillIndex) {
  if (!state.ui.skillTrainer) return;
  
  const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
  const companion = activeCompanions[state.ui.skillTrainer.selectedCompanionIndex];
  const newSkill = state.ui.skillTrainer.skillOptions[skillIndex];
  
  if (!companion || !newSkill) {
    cancelSkillTrainer();
    return;
  }
  
  // å­¸ç¿’æ–°æŠ€èƒ½
  learnCompanionSkill(companion, newSkill);
  pushLog(`æŠ€èƒ½è¨“ç·´å¸«ï¼š${companion.name} å­¸æœƒäº†ã€Œ${newSkill.name}ã€ï¼`);
  
  // æ¸…é™¤ç‹€æ…‹ä¸¦é€²å…¥ä¸‹ä¸€å€‹ç¯€é»
  state.ui.skillTrainer = null;
  advanceToNextNode();
  renderAll();
}

// è¿”å›æŠ€èƒ½è¨“ç·´å¸«ï¼ˆå·²ç§»é™¤ï¼Œç¾åœ¨ä¸èƒ½è¿”å›ï¼‰
function backSkillTrainer() {
  // ä¸å†æ”¯æŒè¿”å›åŠŸèƒ½
  return;
}

// ç¢ºèªå–æ¶ˆæŠ€èƒ½è¨“ç·´å¸«ï¼ˆåœ¨ç¬¬ä¸€å±¤æ™‚ï¼‰
function confirmCancelSkillTrainer() {
  if (!state.ui.skillTrainer || state.ui.skillTrainer.step !== 'selectCompanion') {
    // å¦‚æœä¸æ˜¯åœ¨ç¬¬ä¸€å±¤ï¼Œç›´æ¥è¿”å›
    backSkillTrainer();
    return;
  }
  
  // é¡¯ç¤ºç¢ºèªå°è©±æ¡†
  state.ui.skillTrainerConfirmCancel = true;
  renderAll();
}

// å–æ¶ˆç¢ºèªå–æ¶ˆæŠ€èƒ½è¨“ç·´å¸«ï¼ˆè¿”å›ç¹¼çºŒè¨“ç·´ï¼‰
function cancelConfirmCancelSkillTrainer() {
  if (state.ui.skillTrainer) {
    state.ui.skillTrainerConfirmCancel = false;
    renderAll();
  }
}

// å–æ¶ˆæŠ€èƒ½è¨“ç·´å¸«ï¼ˆç¢ºèªå¾Œï¼‰
function cancelSkillTrainer() {
  state.ui.skillTrainer = null;
  state.ui.skillTrainerConfirmCancel = false;
  advanceToNextNode();
  renderAll();
}

// å°‡å‡½æ•¸æš´éœ²åˆ°å…¨å±€
window.selectSkillTrainerCompanion = selectSkillTrainerCompanion;
window.selectSkillTrainerNewSkill = selectSkillTrainerNewSkill;
window.cancelSkillTrainer = cancelSkillTrainer;
window.confirmCancelSkillTrainer = confirmCancelSkillTrainer;
window.cancelConfirmCancelSkillTrainer = cancelConfirmCancelSkillTrainer;

// ==================== å¿ƒç†æ²»ç™‚æ‰€ç³»çµ± ====================

// è™•ç†å¿ƒç†æ²»ç™‚æ‰€äº‹ä»¶
function handlePersonalityTherapyEvent(option) {
  const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
  
  if (activeCompanions.length === 0) {
    pushLog('å¿ƒç†æ²»ç™‚æ‰€ï¼šä½ æ²’æœ‰æ´»è‘—çš„åŒä¼´ï¼Œç„¡æ³•é€²è¡Œå¿ƒç†æ²»ç™‚ã€‚');
    advanceToNextNode();
    renderAll();
    return;
  }
  
  state.ui.personalityTherapy = {
    step: 'selectCompanion',
    selectedCompanionIndex: null,
    personalityOptions: [],
  };
  
  renderAll();
}

// æ¸²æŸ“å¿ƒç†æ²»ç™‚æ‰€å°è©±æ¡†
function renderPersonalityTherapyDialog(therapyState) {
  const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
  
  if (therapyState.step === 'selectCompanion') {
    const companionButtons = activeCompanions.map((companion, index) => {
      const personality = COMPANION_PERSONALITIES[companion.personalityId || 'balanced'];
      return `
        <button class="dialog-option" onclick="selectPersonalityTherapyCompanion(${index});">
          <div style="display: flex; align-items: center; gap: 10px;">
            <span style="font-size: 24px;">${companion.icon || 'ğŸ‘¤'}</span>
            <div>
              <strong>${companion.name}</strong>
              <p style="margin: 5px 0; font-size: 12px; color: #ccc;">ç•¶å‰å€‹æ€§ï¼š${personality ? personality.name : 'æœªçŸ¥'}</p>
            </div>
          </div>
        </button>
      `;
    }).join('');
    
    return `
      <h2>å¿ƒç†æ²»ç™‚æ‰€</h2>
      <div class="event-message">
        <p style="white-space: pre-line; font-size: 14.4px; line-height: 1.8; margin: 20px 0;">
          ä½ é‡åˆ°äº†ä¸€é–“å¿ƒç†æ²»ç™‚æ‰€ã€‚æ²»ç™‚å¸«å¯ä»¥å¹«åŠ©åŒä¼´æ”¹è®Šå€‹æ€§ï¼Œé¸æ“‡ä¸€å€‹åŒä¼´ä¾†é€²è¡Œå¿ƒç†æ²»ç™‚ï¼š
        </p>
      </div>
      <div class="dialog-options">
        ${companionButtons}
      </div>
      <button class="continue-btn" onclick="cancelPersonalityTherapy();" style="background: #666;">å–æ¶ˆ</button>
    `;
  } else if (therapyState.step === 'selectPersonality') {
    const companion = activeCompanions[therapyState.selectedCompanionIndex];
    if (!companion) {
      cancelPersonalityTherapy();
      return '';
    }
    
    const currentPersonality = COMPANION_PERSONALITIES[companion.personalityId || 'balanced'];
    const personalityButtons = therapyState.personalityOptions.map((personality, index) => {
      const isCurrent = personality.id === companion.personalityId;
      return `
        <button class="dialog-option" onclick="selectPersonalityTherapyPersonality(${index});" ${isCurrent ? 'disabled style="opacity: 0.5;"' : ''}>
          <div>
            <strong>${personality.name}${isCurrent ? 'ï¼ˆç•¶å‰å€‹æ€§ï¼‰' : ''}</strong>
            <p style="margin: 5px 0; font-size: 12px; color: #ccc;">${personality.description}</p>
          </div>
        </button>
      `;
    }).join('');
    
    return `
      <h2>å¿ƒç†æ²»ç™‚æ‰€</h2>
      <div class="event-message">
        <p style="white-space: pre-line; font-size: 14.4px; line-height: 1.8; margin: 20px 0;">
          ${companion.name} çš„ç•¶å‰å€‹æ€§æ˜¯ã€Œ${currentPersonality ? currentPersonality.name : 'æœªçŸ¥'}ã€ã€‚<br>
          è«‹é¸æ“‡ä¸€å€‹æ–°çš„å€‹æ€§ï¼š
        </p>
      </div>
      <div class="dialog-options">
        ${personalityButtons}
      </div>
      <button class="continue-btn" onclick="backPersonalityTherapy();" style="background: #666;">è¿”å›</button>
    `;
  }
  
  return '';
}

// é¸æ“‡å¿ƒç†æ²»ç™‚æ‰€çš„åŒä¼´
function selectPersonalityTherapyCompanion(companionIndex) {
  const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
  if (!state.ui.personalityTherapy || companionIndex < 0 || companionIndex >= activeCompanions.length) {
    return;
  }
  
  const companion = activeCompanions[companionIndex];
  const currentPersonalityId = companion.personalityId || 'balanced';
  
  // ç²å–æ‰€æœ‰å€‹æ€§ID
  const allPersonalityIds = Object.keys(COMPANION_PERSONALITIES);
  
  // æ’é™¤ç•¶å‰å€‹æ€§ï¼Œç„¶å¾Œéš¨æ©Ÿé¸æ“‡3å€‹
  const availablePersonalities = allPersonalityIds
    .filter(id => id !== currentPersonalityId)
    .sort(() => Math.random() - 0.5)
    .slice(0, 3)
    .map(id => COMPANION_PERSONALITIES[id]);
  
  state.ui.personalityTherapy.selectedCompanionIndex = companionIndex;
  state.ui.personalityTherapy.personalityOptions = availablePersonalities;
  state.ui.personalityTherapy.step = 'selectPersonality';
  
  renderAll();
}

// é¸æ“‡å¿ƒç†æ²»ç™‚æ‰€çš„å€‹æ€§
function selectPersonalityTherapyPersonality(personalityIndex) {
  if (!state.ui.personalityTherapy) return;
  
  const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
  const companion = activeCompanions[state.ui.personalityTherapy.selectedCompanionIndex];
  const newPersonality = state.ui.personalityTherapy.personalityOptions[personalityIndex];
  
  if (!companion || !newPersonality) {
    cancelPersonalityTherapy();
    return;
  }
  
  // æª¢æŸ¥æ˜¯å¦é¸æ“‡äº†ç•¶å‰å€‹æ€§
  if (newPersonality.id === companion.personalityId) {
    pushLog('å¿ƒç†æ²»ç™‚æ‰€ï¼šé€™å·²ç¶“æ˜¯è©²åŒä¼´çš„ç•¶å‰å€‹æ€§äº†ã€‚');
    return;
  }
  
  const oldPersonality = COMPANION_PERSONALITIES[companion.personalityId || 'balanced'];
  companion.personalityId = newPersonality.id;
  
  pushLog(`å¿ƒç†æ²»ç™‚æ‰€ï¼š${companion.name} çš„å€‹æ€§å¾ã€Œ${oldPersonality ? oldPersonality.name : 'æœªçŸ¥'}ã€æ”¹è®Šç‚ºã€Œ${newPersonality.name}ã€ã€‚`);
  
  state.ui.personalityTherapy = null;
  advanceToNextNode();
  renderAll();
}

// è¿”å›å¿ƒç†æ²»ç™‚æ‰€ï¼ˆå¾ç¬¬äºŒå±¤è¿”å›åˆ°ç¬¬ä¸€å±¤ï¼‰
function backPersonalityTherapy() {
  if (!state.ui.personalityTherapy) return;
  
  state.ui.personalityTherapy.step = 'selectCompanion';
  state.ui.personalityTherapy.selectedCompanionIndex = null;
  state.ui.personalityTherapy.personalityOptions = [];
  
  renderAll();
}

// å–æ¶ˆå¿ƒç†æ²»ç™‚æ‰€
function cancelPersonalityTherapy() {
  state.ui.personalityTherapy = null;
  advanceToNextNode();
  renderAll();
}

// å°‡å‡½æ•¸æš´éœ²åˆ°å…¨å±€
window.selectPersonalityTherapyCompanion = selectPersonalityTherapyCompanion;
window.selectPersonalityTherapyPersonality = selectPersonalityTherapyPersonality;
window.cancelPersonalityTherapy = cancelPersonalityTherapy;
window.backPersonalityTherapy = backPersonalityTherapy;

// ==================== è·æ¥­é€²éšç³»çµ± ====================

// è·æ¥­é€²éšæ˜ å°„ï¼šå“ªäº›åŸºç¤è·æ¥­å¯ä»¥é€²éšåˆ°å“ªäº›é€²éšè·æ¥­
// æ¯å€‹è·æ¥­éƒ½å¯ä»¥é€²éšåˆ°æ‰€æœ‰ä¸‰ç¨®é€²éšè·æ¥­ï¼šè³¢è€…ã€è–é¨å£«ã€æ­¦å™¨å¤§å¸«
// éµå¯ä»¥æ˜¯ companionTypeId æˆ– heroType
const CLASS_ADVANCEMENT_MAP = {
  // æ‰€æœ‰åŸºç¤è·æ¥­éƒ½å¯ä»¥é€²éšåˆ°ä¸‰ç¨®é€²éšè·æ¥­
  warrior: ['sage', 'paladin', 'weaponmaster'],
  attacker: ['sage', 'paladin', 'weaponmaster'],
  knight: ['sage', 'paladin', 'weaponmaster'],
  defender: ['sage', 'paladin', 'weaponmaster'],
  healer: ['sage', 'paladin', 'weaponmaster'],
  mage: ['sage', 'paladin', 'weaponmaster'],
  thief: ['sage', 'paladin', 'weaponmaster'],
  agile: ['sage', 'paladin', 'weaponmaster'],
};

// è™•ç†è·æ¥­é€²éšäº‹ä»¶
function handleClassAdvancementEvent(option) {
  const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
  
  if (activeCompanions.length === 0) {
    pushLog('è·æ¥­å°å¸«ï¼šä½ æ²’æœ‰æ´»è‘—çš„åŒä¼´ï¼Œç„¡æ³•é€²è¡Œè·æ¥­é€²éšã€‚');
    advanceToNextNode();
    renderAll();
    return;
  }
  
  // éæ¿¾å‡ºå¯ä»¥é€²éšçš„åŒä¼´ï¼ˆæ’é™¤å·²ç¶“æ˜¯é€²éšè·æ¥­çš„åŒä¼´ï¼Œä¸”éœ€è¦é”åˆ°æŒ‡å®šç­‰ç´šï¼‰
  const requiredLevel = GAME_CONFIG.companionAdvancementLevel || 40;
  const eligibleCompanions = activeCompanions.filter(companion => {
    if (!companion.companionTypeId) return false;
    const companionType = COMPANION_TYPES[companion.companionTypeId];
    if (!companionType) return false;
    // æ’é™¤å·²ç¶“æ˜¯é€²éšè·æ¥­çš„åŒä¼´
    if (companionType.isAdvanced) return false;
    // æª¢æŸ¥ç­‰ç´šæ˜¯å¦é”åˆ°è¦æ±‚
    if (!companion.stats || companion.stats.level < requiredLevel) return false;
    // æª¢æŸ¥æ˜¯å¦æœ‰å¯é€²éšçš„è·æ¥­ï¼ˆå„ªå…ˆä½¿ç”¨ companionTypeIdï¼Œå…¶æ¬¡ä½¿ç”¨ heroTypeï¼‰
    const advancementOptions = CLASS_ADVANCEMENT_MAP[companion.companionTypeId] || CLASS_ADVANCEMENT_MAP[companionType.heroType] || [];
    return advancementOptions.length > 0;
  });
  
  if (eligibleCompanions.length === 0) {
    // æª¢æŸ¥æ˜¯å¦æœ‰å·²é€²éšçš„åŒä¼´
    const hasAdvancedCompanions = activeCompanions.some(companion => {
      if (!companion.companionTypeId) return false;
      const companionType = COMPANION_TYPES[companion.companionTypeId];
      return companionType && companionType.isAdvanced;
    });
    
    // æª¢æŸ¥æ˜¯å¦æœ‰ç­‰ç´šä¸è¶³çš„åŒä¼´
    const hasLowLevelCompanions = activeCompanions.some(companion => {
      if (!companion.companionTypeId) return false;
      const companionType = COMPANION_TYPES[companion.companionTypeId];
      if (!companionType || companionType.isAdvanced) return false;
      return companion.stats && companion.stats.level < requiredLevel;
    });
    
    if (hasAdvancedCompanions) {
      pushLog(`è·æ¥­å°å¸«ï¼šä½ çš„åŒä¼´éƒ½å·²ç¶“é€²éšéäº†ï¼Œç„¡æ³•å†æ¬¡é€²éšã€‚`);
    } else if (hasLowLevelCompanions) {
      pushLog(`è·æ¥­å°å¸«ï¼šä½ çš„åŒä¼´ç­‰ç´šä¸è¶³ï¼Œéœ€è¦é”åˆ°ç­‰ç´š ${requiredLevel} æ‰èƒ½é€²éšã€‚`);
    } else {
      pushLog('è·æ¥­å°å¸«ï¼šä½ çš„åŒä¼´ä¸­æ²’æœ‰å¯ä»¥é€²éšçš„è·æ¥­ã€‚');
    }
    advanceToNextNode();
    renderAll();
    return;
  }
  
  state.ui.classAdvancement = {
    step: 'selectCompanion',
    selectedCompanionIndex: null,
    selectedAdvancedClass: null,
    eligibleCompanions: eligibleCompanions.map((c, idx) => activeCompanions.indexOf(c)),
  };
  state.ui.classAdvancementConfirmCancel = false;
  
  renderAll();
}

// æ¸²æŸ“è·æ¥­é€²éšå°è©±æ¡†
function renderClassAdvancementDialog(advancementState) {
  const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
  
  // å¦‚æœé¡¯ç¤ºç¢ºèªå–æ¶ˆå°è©±æ¡†
  if (state.ui.classAdvancementConfirmCancel) {
    return `
      <h2>è·æ¥­å°å¸«</h2>
      <div class="event-message">
        <p style="white-space: pre-line; font-size: 14.4px; line-height: 1.8; margin: 20px 0;">
          ç¢ºå®šè¦æ”¾æ£„è·æ¥­é€²éšå—ï¼Ÿ
        </p>
      </div>
      <div class="event-choices" style="display: flex; flex-direction: column; gap: 10px; margin-top: 20px;">
        <button class="continue-btn" onclick="cancelClassAdvancement();" style="background: #d32f2f;">ç¢ºå®šæ”¾æ£„</button>
        <button class="continue-btn" onclick="cancelConfirmCancelClassAdvancement();" style="background: #666;">è¿”å›</button>
      </div>
    `;
  }
  
  if (advancementState.step === 'selectCompanion') {
    const companionButtons = advancementState.eligibleCompanions.map((companionIndex) => {
      const companion = activeCompanions[companionIndex];
      if (!companion) return '';
      const companionType = COMPANION_TYPES[companion.companionTypeId];
      const advancementOptions = CLASS_ADVANCEMENT_MAP[companion.companionTypeId] || CLASS_ADVANCEMENT_MAP[companionType?.heroType] || [];
      const advancementNames = advancementOptions.map(id => COMPANION_TYPES[id]?.name || id).join('ã€');
      
      return `
        <button class="dialog-option" onclick="selectClassAdvancementCompanion(${companionIndex});">
          <strong>${companion.name}</strong>
          <small>Lv ${companion.stats.level} | ${companionType?.name || 'æœªçŸ¥'} | å¯é€²éšç‚ºï¼š${advancementNames}</small>
        </button>
      `;
    }).join('');
    
    const requiredLevel = GAME_CONFIG.companionAdvancementLevel || 40;
    return `
      <h2>è·æ¥­å°å¸«</h2>
      <div class="event-message">
        <p style="white-space: pre-line; font-size: 14.4px; line-height: 1.8; margin: 20px 0;">
          ä½ é‡åˆ°äº†ä¸€ä½è·æ¥­å°å¸«ã€‚ä»–å¯ä»¥å¹«åŠ©ç­‰ç´šé”åˆ° ${requiredLevel} çš„åŒä¼´é€²éšåˆ°æ›´é«˜ç´šçš„è·æ¥­ï¼Œç²å¾—æ–°çš„æŠ€èƒ½å’Œæ›´å¼·çš„èƒ½åŠ›ã€‚
        </p>
        <p style="margin-top: 15px; font-weight: bold;">è«‹é¸æ“‡è¦é€²éšçš„åŒä¼´ï¼š</p>
      </div>
      <div class="event-choices" style="display: flex; flex-direction: column; gap: 10px; margin-top: 20px;">
        ${companionButtons}
        <button class="continue-btn" onclick="confirmCancelClassAdvancement();" style="background: #666;">å–æ¶ˆ</button>
      </div>
    `;
  } else if (advancementState.step === 'selectClass') {
    const companion = activeCompanions[advancementState.selectedCompanionIndex];
    if (!companion) {
      cancelClassAdvancement();
      return '';
    }
    
    const companionType = COMPANION_TYPES[companion.companionTypeId];
    const advancementOptions = CLASS_ADVANCEMENT_MAP[companion.companionTypeId] || CLASS_ADVANCEMENT_MAP[companionType?.heroType] || [];
    
    if (advancementOptions.length === 0) {
      return `
        <h2>è·æ¥­å°å¸«</h2>
        <div class="event-message">
          <p style="white-space: pre-line; font-size: 14.4px; line-height: 1.8; margin: 20px 0;">
            ${companion.name} æ²’æœ‰å¯é€²éšçš„è·æ¥­ã€‚
          </p>
        </div>
        <button class="continue-btn" onclick="cancelClassAdvancement();">è¿”å›</button>
      `;
    }
    
    const classButtons = advancementOptions.map((advancedClassId, index) => {
      const advancedClass = COMPANION_TYPES[advancedClassId];
      if (!advancedClass) return '';
      
      return `
        <button class="dialog-option" onclick="selectClassAdvancementClass('${advancedClassId}');">
          <div style="display: flex; align-items: center; gap: 10px;">
            <span style="font-size: 24px;">${advancedClass.icon}</span>
            <div>
              <strong>${advancedClass.name}</strong>
              <p style="margin: 5px 0; font-size: 12px; color: #ccc;">${advancedClass.description}</p>
            </div>
          </div>
        </button>
      `;
    }).join('');
    
    return `
      <h2>è·æ¥­å°å¸«</h2>
      <div class="event-message">
        <p style="white-space: pre-line; font-size: 14.4px; line-height: 1.8; margin: 20px 0;">
          è«‹é¸æ“‡ ${companion.name} è¦é€²éšçš„è·æ¥­ï¼š
        </p>
      </div>
      <div class="event-choices" style="display: flex; flex-direction: column; gap: 10px; margin-top: 20px;">
        ${classButtons}
        <button class="continue-btn" onclick="backClassAdvancement();" style="background: #666;">è¿”å›</button>
      </div>
    `;
  } else if (advancementState.step === 'selectPaladinPath') {
    const companion = activeCompanions[advancementState.selectedCompanionIndex];
    if (!companion) {
      cancelClassAdvancement();
      return '';
    }
    
    // å¦‚æœé¸æ“‡çš„è·æ¥­ä¸æ˜¯è–é¨å£«ï¼Œç›´æ¥åŸ·è¡Œé€²éšï¼ˆé¿å…å…¶ä»–è·æ¥­é€²å…¥è·¯å¾‘é¸æ“‡ï¼‰
    const selectedAdvancedClass = advancementState.selectedAdvancedClass;
    if (selectedAdvancedClass !== 'paladin') {
      confirmClassAdvancement();
      return '';
    }
    
    // å¾©ä»‡ä¹‹é“æŠ€èƒ½
    const vengeanceActiveSkill = SKILL_LOOKUP.get('paladin_divine_slash_1');
    const vengeancePassiveSkill = SKILL_LOOKUP.get('paladin_vengeance_will_1');
    
    // ç¥è–ä¹‹é“æŠ€èƒ½
    const sacredActiveSkill = SKILL_LOOKUP.get('paladin_sacred_shield_1');
    const sacredPassiveSkill = SKILL_LOOKUP.get('paladin_guardian_will_1');
    
    return `
      <h2>è·æ¥­å°å¸«</h2>
      <div class="event-message">
        <p style="white-space: pre-line; font-size: 14.4px; line-height: 1.8; margin: 20px 0;">
          ${companion.name} é¸æ“‡æˆç‚ºè–é¨å£«ï¼Œè«‹é¸æ“‡ä¸€æ¢é“è·¯ï¼š
        </p>
      </div>
      <div class="event-choices" style="display: flex; flex-direction: column; gap: 10px; margin-top: 20px;">
        <button class="dialog-option" onclick="selectPaladinPath('vengeance');">
          <div>
            <strong>å¾©ä»‡ä¹‹é“</strong>
            <p style="margin: 5px 0; font-size: 12px; color: #ccc;">
              ä¸»å‹•æŠ€ï¼š${vengeanceActiveSkill?.name || 'è‡³è–æ–¬'} - ${vengeanceActiveSkill?.description || 'é€ æˆé«”åŠ›Ã—120% + æ²»ç™‚èƒ½åŠ›Ã—120%çš„æ”»æ“Šå‚·å®³ã€‚'}<br>
              è¢«å‹•æŠ€ï¼š${vengeancePassiveSkill?.name || 'å¾©ä»‡æ„å¿—'} - ${vengeancePassiveSkill?.description || '25%æ©Ÿç‡è®“æ‰€æœ‰æ•µäººæ¸›å°‘å—åˆ°å‚·å®³çš„ä¸€åŠæ•¸å€¼ï¼ˆè‡³å°‘æ˜¯1ï¼‰ã€‚'}
            </p>
          </div>
        </button>
        <button class="dialog-option" onclick="selectPaladinPath('sacred');">
          <div>
            <strong>ç¥è–ä¹‹é“</strong>
            <p style="margin: 5px 0; font-size: 12px; color: #ccc;">
              ä¸»å‹•æŠ€ï¼š${sacredActiveSkill?.name || 'ç¥è–è­·ç›¾'} - ${sacredActiveSkill?.description || 'æ²»ç™‚æ™‚æœƒé¡å¤–å¾—åˆ°ä¸€å€‹é«”åŠ›å€¼1/3çš„è­·ç›¾ã€‚'}<br>
              è¢«å‹•æŠ€ï¼š${sacredPassiveSkill?.name || 'å®ˆè­·æ„å¿—'} - ${sacredPassiveSkill?.description || 'è¢«æ”»æ“Šæ™‚æœ‰25%æ©Ÿç‡å›å¾©æ‰€æœ‰äºº10%é«”åŠ›çš„HPã€‚'}
            </p>
          </div>
        </button>
        <button class="continue-btn" onclick="backClassAdvancement();" style="background: #666;">è¿”å›</button>
      </div>
    `;
  } else if (advancementState.step === 'selectSagePath') {
    const companion = activeCompanions[advancementState.selectedCompanionIndex];
    if (!companion) {
      cancelClassAdvancement();
      return '';
    }
    
    // å¦‚æœé¸æ“‡çš„è·æ¥­ä¸æ˜¯è³¢è€…ï¼Œç›´æ¥åŸ·è¡Œé€²éšï¼ˆé¿å…å…¶ä»–è·æ¥­é€²å…¥è·¯å¾‘é¸æ“‡ï¼‰
    const selectedAdvancedClass = advancementState.selectedAdvancedClass;
    if (selectedAdvancedClass !== 'sage') {
      confirmClassAdvancement();
      return '';
    }
    
    // å…ƒç´ ä¹‹é“æŠ€èƒ½
    const elementalActiveSkill = SKILL_LOOKUP.get('sage_elemental_burst_1');
    const elementalPassiveSkill = SKILL_LOOKUP.get('sage_elemental_resonance_1');
    
    // æ²»æ„ˆä¹‹é“æŠ€èƒ½
    const healingActiveSkill = SKILL_LOOKUP.get('sage_death_ward_1');
    const healingPassiveSkill = SKILL_LOOKUP.get('sage_sacred_echo_1');
    
    return `
      <h2>è·æ¥­å°å¸«</h2>
      <div class="event-message">
        <p style="white-space: pre-line; font-size: 14.4px; line-height: 1.8; margin: 20px 0;">
          ${companion.name} é¸æ“‡æˆç‚ºè³¢è€…ï¼Œè«‹é¸æ“‡ä¸€æ¢é“è·¯ï¼š
        </p>
      </div>
      <div class="event-choices" style="display: flex; flex-direction: column; gap: 10px; margin-top: 20px;">
        <button class="dialog-option" onclick="selectSagePath('elemental');">
          <div>
            <strong>å…ƒç´ ä¹‹é“</strong>
            <p style="margin: 5px 0; font-size: 12px; color: #ccc;">
              ä¸»å‹•æŠ€ï¼š${elementalActiveSkill?.name || 'å…ƒç´ çˆ†ç™¼'} - ${elementalActiveSkill?.description || 'é€ æˆå›ºå®šå€¼150 + é­”åŠ›Ã—100%çš„é­”æ³•å‚·å®³ï¼Œ30%æ©Ÿç‡é€ æˆ1.5å€å‚·å®³ã€‚'}<br>
              è¢«å‹•æŠ€ï¼š${elementalPassiveSkill?.name || 'å…ƒç´ å…±é³´'} - ${elementalPassiveSkill?.description || 'æœ‰20%æ©Ÿç‡ä½¿ç”¨é­”æ³•æˆ–æ¢å¾©æ™‚ä¸æ¶ˆè€—MPã€‚'}
            </p>
          </div>
        </button>
        <button class="dialog-option" onclick="selectSagePath('healing');">
          <div>
            <strong>æ²»æ„ˆä¹‹é“</strong>
            <p style="margin: 5px 0; font-size: 12px; color: #ccc;">
              ä¸»å‹•æŠ€ï¼š${healingActiveSkill?.name || 'é˜²æ­»è­·ç›¾'} - ${healingActiveSkill?.description || 'æ‰€æœ‰å‹æ–¹ç²å¾—é˜²æ­»æ•ˆæœï¼Œç”Ÿå‘½é™åˆ°0æ™‚æœƒç•™ä¸‹1é»HPï¼Œç„¶å¾Œæ•ˆæœæ¶ˆå¤±ã€‚'}<br>
              è¢«å‹•æŠ€ï¼š${healingPassiveSkill?.name || 'ç¥è–å›éŸ¿'} - ${healingPassiveSkill?.description || 'æ¢å¾©HPæ™‚ï¼Œæœƒå¾—åˆ°ä¸€å€‹20%æ²»ç™‚å€¼çš„ç·©æ…¢æ¢å¾©ï¼Œä¸‹å›åˆé–‹å§‹æ™‚å›å¾©ï¼Œå¯ç´¯åŠ ã€‚'}
            </p>
          </div>
        </button>
        <button class="continue-btn" onclick="backClassAdvancement();" style="background: #666;">è¿”å›</button>
      </div>
    `;
  } else if (advancementState.step === 'selectWeaponmasterPath') {
    const companion = activeCompanions[advancementState.selectedCompanionIndex];
    if (!companion) {
      cancelClassAdvancement();
      return '';
    }
    
    // å¦‚æœé¸æ“‡çš„è·æ¥­ä¸æ˜¯æ­¦å™¨å¤§å¸«ï¼Œç›´æ¥åŸ·è¡Œé€²éšï¼ˆé¿å…å…¶ä»–è·æ¥­é€²å…¥è·¯å¾‘é¸æ“‡ï¼‰
    const selectedAdvancedClass = advancementState.selectedAdvancedClass;
    if (selectedAdvancedClass !== 'weaponmaster') {
      confirmClassAdvancement();
      return '';
    }
    
    // åŠç¥ä¹‹è·¯æŠ€èƒ½
    const swordGodActiveSkill = SKILL_LOOKUP.get('weaponmaster_sword_god_path_1');
    const swordGodPassiveSkill = SKILL_LOOKUP.get('weaponmaster_sword_aura_1');
    
    // åˆºå®¢ä¹‹è·¯æŠ€èƒ½
    const assassinActiveSkill = SKILL_LOOKUP.get('weaponmaster_assassin_path_1');
    const assassinPassiveSkill = SKILL_LOOKUP.get('weaponmaster_armor_pierce_1');
    
    return `
      <h2>è·æ¥­å°å¸«</h2>
      <div class="event-message">
        <p style="white-space: pre-line; font-size: 14.4px; line-height: 1.8; margin: 20px 0;">
          ${companion.name} é¸æ“‡æˆç‚ºæ­¦å™¨å¤§å¸«ï¼Œè«‹é¸æ“‡ä¸€æ¢é“è·¯ï¼š
        </p>
      </div>
      <div class="event-choices" style="display: flex; flex-direction: column; gap: 10px; margin-top: 20px;">
        <button class="dialog-option" onclick="selectWeaponmasterPath('sword_god');">
          <div>
            <strong>åŠç¥ä¹‹è·¯</strong>
            <p style="margin: 5px 0; font-size: 12px; color: #ccc;">
              ä¸»å‹•æŠ€ï¼š${swordGodActiveSkill?.name || 'åŠç¥ä¹‹è·¯'} - ${swordGodActiveSkill?.description || 'æ¶ˆè€—æœ€å¤šæœ€å¤§MPçš„ä¸€åŠï¼Œæœ€å¤šæ¶ˆè€—åˆ°å…¨ç©ºMPï¼Œé€ æˆ 1 + 3x(æ¶ˆè€—MP/æœ€å¤§MPä¸€åŠ) å€çš„æ”»æ“ŠåŠ›å‚·å®³ã€‚'}<br>
              è¢«å‹•æŠ€ï¼š${swordGodPassiveSkill?.name || 'åŠæ°£ç¸±æ©«'} - ${swordGodPassiveSkill?.description || 'æ™®æ”»è®Šæˆå…¨é«”æ”»æ“Šï¼Œä½†é€ æˆå‚·å®³åªæœ‰8æˆï¼ˆæ”»æ“ŠåŠ›-é˜²ï¼‰Ã—0.8ã€‚'}
            </p>
          </div>
        </button>
        <button class="dialog-option" onclick="selectWeaponmasterPath('assassin');">
          <div>
            <strong>åˆºå®¢ä¹‹è·¯</strong>
            <p style="margin: 5px 0; font-size: 12px; color: #ccc;">
              ä¸»å‹•æŠ€ï¼š${assassinActiveSkill?.name || 'æš—å½±çªè¥²'} - ${assassinActiveSkill?.description || 'æ”»æ“ŠåŠ›=æ•æ·Ã—100% + æ”»æ“ŠÃ—50% + (20%æ•æ·çš„ä¸­æ¯’+é™ä½20%æ”»æ“Š)æŒçºŒ2å›åˆã€‚'}<br>
              è¢«å‹•æŠ€ï¼š${assassinPassiveSkill?.name || 'ç ´ç”²ä¹‹åˆƒ'} - ${assassinPassiveSkill?.description || 'é€²å…¥æˆ°é¬¥å¾Œå¾—åˆ°ä¸€å€‹buffï¼Œç‰©ç†æ”»æ“Šå¯ä»¥ç„¡è¦–æ•µæ–¹çš„é˜²åŠ›ï¼Œé€ æˆå‚·å®³ã€‚'}
            </p>
          </div>
        </button>
        <button class="continue-btn" onclick="backClassAdvancement();" style="background: #666;">è¿”å›</button>
      </div>
    `;
  }
  
  return '';
}

// é¸æ“‡è·æ¥­é€²éšçš„åŒä¼´
function selectClassAdvancementCompanion(companionIndex) {
  const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
  if (!state.ui.classAdvancement || companionIndex < 0 || companionIndex >= activeCompanions.length) {
    return;
  }
  
  state.ui.classAdvancement.selectedCompanionIndex = companionIndex;
  state.ui.classAdvancement.step = 'selectClass';
  renderAll();
}

// é¸æ“‡è·æ¥­é€²éšçš„è·æ¥­
function selectClassAdvancementClass(advancedClassId) {
  if (!state.ui.classAdvancement) return;
  
  const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
  const companion = activeCompanions[state.ui.classAdvancement.selectedCompanionIndex];
  const advancedClass = COMPANION_TYPES[advancedClassId];
  
  if (!companion || !advancedClass) {
    cancelClassAdvancement();
    return;
  }
  
  state.ui.classAdvancement.selectedAdvancedClass = advancedClassId;
  
  // å¦‚æœæ˜¯è–é¨å£«ï¼Œéœ€è¦é¸æ“‡è·¯å¾‘
  if (advancedClassId === 'paladin') {
    state.ui.classAdvancement.step = 'selectPaladinPath';
    state.ui.classAdvancement.selectedPaladinPath = null;
    renderAll();
    return;
  }
  
  // å¦‚æœæ˜¯è³¢è€…ï¼Œéœ€è¦é¸æ“‡è·¯å¾‘
  if (advancedClassId === 'sage') {
    state.ui.classAdvancement.step = 'selectSagePath';
    state.ui.classAdvancement.selectedSagePath = null;
    renderAll();
    return;
  }
  
  // å¦‚æœæ˜¯æ­¦å™¨å¤§å¸«ï¼Œéœ€è¦é¸æ“‡è·¯å¾‘
  if (advancedClassId === 'weaponmaster') {
    state.ui.classAdvancement.step = 'selectWeaponmasterPath';
    state.ui.classAdvancement.selectedWeaponmasterPath = null;
    renderAll();
    return;
  }
  
  // å…¶ä»–è·æ¥­ç›´æ¥åŸ·è¡Œé€²éš
  confirmClassAdvancement();
}

// é¸æ“‡è–é¨å£«è·¯å¾‘
function selectPaladinPath(path) {
  if (!state.ui.classAdvancement) return;
  
  state.ui.classAdvancement.selectedPaladinPath = path;
  
  // åŸ·è¡Œé€²éš
  confirmClassAdvancement();
}

// é¸æ“‡è³¢è€…è·¯å¾‘
function selectSagePath(path) {
  if (!state.ui.classAdvancement) return;
  
  state.ui.classAdvancement.selectedSagePath = path;
  
  // åŸ·è¡Œé€²éš
  confirmClassAdvancement();
}

// é¸æ“‡æ­¦å™¨å¤§å¸«è·¯å¾‘
function selectWeaponmasterPath(path) {
  if (!state.ui.classAdvancement) return;
  
  state.ui.classAdvancement.selectedWeaponmasterPath = path;
  
  // åŸ·è¡Œé€²éš
  confirmClassAdvancement();
}

// ç¢ºèªè·æ¥­é€²éš
function confirmClassAdvancement() {
  if (!state.ui.classAdvancement) return;
  
  const activeCompanions = (state.companions || []).filter(c => c && c.stats && c.stats.hp > 0);
  const companion = activeCompanions[state.ui.classAdvancement.selectedCompanionIndex];
  const advancedClassId = state.ui.classAdvancement.selectedAdvancedClass;
  const advancedClass = COMPANION_TYPES[advancedClassId];
  
  if (!companion || !advancedClass) {
    cancelClassAdvancement();
    return;
  }
  
  const oldCompanionType = COMPANION_TYPES[companion.companionTypeId];
  const oldHeroType = oldCompanionType?.heroType || companion.heroType;
  
  // ç²å–æ–°è·æ¥­çš„æµæ´¾
  const flowMap = {
    attacker: 'sword',
    defender: 'defender',
    mage: 'magic',
    healer: 'recovery',
    agile: 'agility',
    sage: ['magic', 'recovery'],
    paladin: ['defender', 'recovery'],
    weaponmaster: ['sword', 'agility'],
  };
  
  const newHeroType = advancedClass.heroType;
  const newPrimaryFlowOrFlows = flowMap[newHeroType] || 'sword';
  const newPrimaryFlows = Array.isArray(newPrimaryFlowOrFlows) ? newPrimaryFlowOrFlows : [newPrimaryFlowOrFlows];
  
  // ç²å–èˆŠè·æ¥­çš„æµæ´¾ï¼ˆç”¨æ–¼æ’é™¤ï¼‰
  const oldPrimaryFlowOrFlows = flowMap[oldHeroType] || 'sword';
  const oldPrimaryFlows = Array.isArray(oldPrimaryFlowOrFlows) ? oldPrimaryFlowOrFlows : [oldPrimaryFlowOrFlows];
  
  // æ”¹è®Šè·æ¥­é¡å‹ï¼ˆä¿ç•™åŸæœ‰æŠ€èƒ½å’Œèƒ½åŠ›ï¼‰
  companion.companionTypeId = advancedClassId;
  companion.heroType = newHeroType;
  
  // å­¸ç¿’æ–°è·æ¥­çš„åˆå§‹æŠ€èƒ½
  const initialSkillsLearned = [];
  const ownedSkills = new Set(companion.skills);
  
  if (advancedClass.initialSkills && Array.isArray(advancedClass.initialSkills)) {
    advancedClass.initialSkills.forEach(skillId => {
        const skill = SKILL_LOOKUP.get(skillId);
      if (!skill) {
        // å¦‚æœæŠ€èƒ½æŸ¥æ‰¾å¤±è´¥ï¼Œè¾“å‡ºè­¦å‘Š
        console.warn(`é€²éšæ™‚ç„¡æ³•æ‰¾åˆ°æŠ€èƒ½ï¼š${skillId}`);
        return;
      }
      
      // æª¢æŸ¥æ˜¯å¦å·²æ“æœ‰ç›¸åŒæˆ–æ›´é«˜ç­‰ç´šçš„æŠ€èƒ½
      let hasHigherTier = false;
      if (skill.chainId) {
        const chain = SKILL_CHAINS.find(c => c.id === skill.chainId);
        if (chain) {
          hasHigherTier = chain.steps.some(step => {
            return step.tier > skill.tier && companion.skills.includes(step.id);
          });
        }
      }
      
      if (!hasHigherTier) {
        // å­¸ç¿’æŠ€èƒ½ï¼ˆlearnCompanionSkill æœƒè‡ªå‹•è™•ç†å‡ç´šï¼šç§»é™¤ä½ç­‰ç´šç‰ˆæœ¬ï¼Œå­¸ç¿’é«˜ç­‰ç´šç‰ˆæœ¬ï¼‰
        const hadSkillBefore = ownedSkills.has(skillId);
          learnCompanionSkill(companion, skill);
        
        // å¦‚æœæˆåŠŸå­¸ç¿’äº†æŠ€èƒ½ï¼ˆæ–°æŠ€èƒ½æˆ–å‡ç´šï¼‰ï¼Œè¨˜éŒ„ä¸‹ä¾†
        if (companion.skills.includes(skillId) || !hadSkillBefore) {
          initialSkillsLearned.push(skill);
        }
        
        // æ›´æ–°å·²æ“æœ‰æŠ€èƒ½åˆ—è¡¨
        ownedSkills = new Set(companion.skills);
      } else {
        // å·²ç¶“æ“æœ‰æ›´é«˜ç­‰ç´šçš„æŠ€èƒ½ï¼Œè·³é
        const higherSkill = SKILL_CHAINS.find(c => c.id === skill.chainId)
          ?.steps.find(step => step.tier > skill.tier && companion.skills.includes(step.id));
        if (higherSkill) {
          initialSkillsLearned.push(SKILL_LOOKUP.get(higherSkill.id));
        }
      }
    });
  }
  
  // éš¨æ©Ÿç²å¾—å…©å€‹èˆ‡åŸæœ¬è·æ¥­ä¸åŒçš„ä¸»å‹•æŠ€èƒ½
  const newActiveSkills = [];
  
  // å¾æ–°è·æ¥­çš„æµæ´¾ä¸­é¸æ“‡ä¸»å‹•æŠ€èƒ½ï¼ˆæ’é™¤èˆŠè·æ¥­çš„æµæ´¾ï¼‰
  const availableFlows = newPrimaryFlows.filter(flow => !oldPrimaryFlows.includes(flow));
  
  if (availableFlows.length > 0) {
    availableFlows.forEach(flow => {
      const tier1Skills = getTier1SingleTargetSkillsByFlow(flow);
      const candidateSkills = tier1Skills.filter(skill => {
        // ä¸èƒ½æ˜¯å·²å­¸ç¿’çš„æŠ€èƒ½
        if (ownedSkills.has(skill.id)) return false;
        // å¿…é ˆæ˜¯ä¸»å‹•æŠ€èƒ½
        if (skill.kind === 'passive') return false;
        return true;
      });
      
      if (candidateSkills.length > 0) {
        const randomSkill = candidateSkills[Math.floor(Math.random() * candidateSkills.length)];
        newActiveSkills.push(randomSkill);
      }
    });
  }
  
  // å¦‚æœé‚„æ²’æœ‰å…©å€‹æŠ€èƒ½ï¼Œå¾æ‰€æœ‰æ–°è·æ¥­æµæ´¾ä¸­é¸æ“‡
  while (newActiveSkills.length < 2 && newPrimaryFlows.length > 0) {
    const flow = newPrimaryFlows[Math.floor(Math.random() * newPrimaryFlows.length)];
    const tier1Skills = getTier1SingleTargetSkillsByFlow(flow);
    const candidateSkills = tier1Skills.filter(skill => {
      if (ownedSkills.has(skill.id)) return false;
      if (skill.kind === 'passive') return false;
      // ä¸èƒ½æ˜¯å·²é¸æ“‡çš„æŠ€èƒ½
      if (newActiveSkills.some(s => s.id === skill.id)) return false;
      return true;
    });
    
    if (candidateSkills.length > 0) {
      const randomSkill = candidateSkills[Math.floor(Math.random() * candidateSkills.length)];
      newActiveSkills.push(randomSkill);
    } else {
      break;
    }
  }
  
  // å­¸ç¿’æ–°ä¸»å‹•æŠ€èƒ½
  newActiveSkills.forEach(skill => {
    learnCompanionSkill(companion, skill);
  });
  
  // éš¨æ©Ÿç²å¾—å››å€‹èˆ‡åŸæœ¬è·æ¥­ä¸åŒçš„è¢«å‹•æŠ€èƒ½ï¼ˆçœ‹éœ€æ±‚è·æ¥­ï¼‰
  const newPassiveSkills = [];
  
  // å¾æ–°è·æ¥­çš„æµæ´¾ä¸­é¸æ“‡è¢«å‹•æŠ€èƒ½ï¼ˆæ’é™¤èˆŠè·æ¥­çš„æµæ´¾ï¼‰
  if (availableFlows.length > 0) {
    availableFlows.forEach(flow => {
      const tier1Passives = getTier1PassiveSkillsByFlow(flow);
      const candidatePassives = tier1Passives.filter(skill => {
        if (ownedSkills.has(skill.id)) return false;
        if (skill.kind !== 'passive') return false;
        return true;
      });
      
      if (candidatePassives.length > 0) {
        const randomPassive = candidatePassives[Math.floor(Math.random() * candidatePassives.length)];
        newPassiveSkills.push(randomPassive);
      }
    });
  }
  
  // å¦‚æœé‚„æ²’æœ‰å››å€‹è¢«å‹•æŠ€èƒ½ï¼Œå¾æ‰€æœ‰æ–°è·æ¥­æµæ´¾ä¸­é¸æ“‡
  while (newPassiveSkills.length < 4 && newPrimaryFlows.length > 0) {
    const flow = newPrimaryFlows[Math.floor(Math.random() * newPrimaryFlows.length)];
    const tier1Passives = getTier1PassiveSkillsByFlow(flow);
    const candidatePassives = tier1Passives.filter(skill => {
      if (ownedSkills.has(skill.id)) return false;
      if (skill.kind !== 'passive') return false;
      if (newPassiveSkills.some(s => s.id === skill.id)) return false;
      return true;
    });
    
    if (candidatePassives.length > 0) {
      const randomPassive = candidatePassives[Math.floor(Math.random() * candidatePassives.length)];
      newPassiveSkills.push(randomPassive);
    } else {
      break;
    }
  }
  
  // å­¸ç¿’æ–°è¢«å‹•æŠ€èƒ½
  newPassiveSkills.forEach(skill => {
    learnCompanionSkill(companion, skill);
    
    // å¦‚æœæ˜¯é˜²å®ˆå‹è¢«å‹•æŠ€èƒ½ï¼ˆHPåŠ æˆï¼‰ï¼Œç«‹å³æ‡‰ç”¨æ•ˆæœ
    if (skill.hpBonus !== undefined) {
      companion.stats.maxHp = Math.ceil(companion.stats.maxHp + skill.hpBonus);
      companion.stats.hp = Math.ceil(companion.stats.hp + skill.hpBonus);
    }
    // å¦‚æœæ˜¯é­”æ³•å‹è¢«å‹•æŠ€èƒ½ï¼ˆMPåŠ æˆï¼‰ï¼Œç«‹å³æ‡‰ç”¨æ•ˆæœ
    if (skill.mpBonus !== undefined) {
      companion.stats.maxMp = Math.ceil(companion.stats.maxMp + skill.mpBonus);
      companion.stats.mp = Math.ceil(companion.stats.mp + skill.mpBonus);
    }
  });
  
  // è–é¨å£«ç‰¹æ®ŠæŠ€èƒ½ï¼šæ ¹æ“šé¸æ“‡çš„è·¯å¾‘çµ¦äºˆå°æ‡‰æŠ€èƒ½
  const specialSkills = [];
  if (advancedClassId === 'paladin') {
    const selectedPath = state.ui.classAdvancement.selectedPaladinPath;
    
    if (selectedPath === 'vengeance') {
      // å¾©ä»‡ä¹‹é“ï¼šè‡³è–æ–¬ + å¾©ä»‡æ„å¿—
      const divineSlashSkill = SKILL_LOOKUP.get('paladin_divine_slash_1');
      const vengeanceWillSkill = SKILL_LOOKUP.get('paladin_vengeance_will_1');
      
      if (divineSlashSkill && !companion.skills.includes('paladin_divine_slash_1')) {
        learnCompanionSkill(companion, divineSlashSkill);
        newActiveSkills.push(divineSlashSkill);
        specialSkills.push({
          name: divineSlashSkill.name,
          description: divineSlashSkill.description,
          kind: divineSlashSkill.kind,
        });
      }
      
      if (vengeanceWillSkill && !companion.skills.includes('paladin_vengeance_will_1')) {
        learnCompanionSkill(companion, vengeanceWillSkill);
        newPassiveSkills.push(vengeanceWillSkill);
        specialSkills.push({
          name: vengeanceWillSkill.name,
          description: vengeanceWillSkill.description,
          kind: vengeanceWillSkill.kind,
        });
      }
    } else if (selectedPath === 'sacred') {
      // ç¥è–ä¹‹é“ï¼šç¥è–è­·ç›¾ + å®ˆè­·æ„å¿—
      const sacredShieldSkill = SKILL_LOOKUP.get('paladin_sacred_shield_1');
      const guardianWillSkill = SKILL_LOOKUP.get('paladin_guardian_will_1');
      
      if (sacredShieldSkill && !companion.skills.includes('paladin_sacred_shield_1')) {
        learnCompanionSkill(companion, sacredShieldSkill);
        newActiveSkills.push(sacredShieldSkill);
        specialSkills.push({
          name: sacredShieldSkill.name,
          description: sacredShieldSkill.description,
          kind: sacredShieldSkill.kind,
        });
      }
      
      if (guardianWillSkill && !companion.skills.includes('paladin_guardian_will_1')) {
        learnCompanionSkill(companion, guardianWillSkill);
        newPassiveSkills.push(guardianWillSkill);
        specialSkills.push({
          name: guardianWillSkill.name,
          description: guardianWillSkill.description,
          kind: guardianWillSkill.kind,
        });
      }
    }
    
    // è¨˜éŒ„é¸æ“‡çš„è·¯å¾‘
    companion.paladinPath = selectedPath;
  } else if (advancedClassId === 'sage') {
    // è³¢è€…ç‰¹æ®ŠæŠ€èƒ½ï¼šæ ¹æ“šé¸æ“‡çš„è·¯å¾‘çµ¦äºˆå°æ‡‰æŠ€èƒ½
    const selectedPath = state.ui.classAdvancement.selectedSagePath;
    
    if (selectedPath === 'elemental') {
      // å…ƒç´ ä¹‹é“ï¼šå…ƒç´ çˆ†ç™¼ + å…ƒç´ å…±é³´
      const elementalBurstSkill = SKILL_LOOKUP.get('sage_elemental_burst_1');
      const elementalResonanceSkill = SKILL_LOOKUP.get('sage_elemental_resonance_1');
      
      if (elementalBurstSkill && !companion.skills.includes('sage_elemental_burst_1')) {
        learnCompanionSkill(companion, elementalBurstSkill);
        newActiveSkills.push(elementalBurstSkill);
        specialSkills.push({
          name: elementalBurstSkill.name,
          description: elementalBurstSkill.description,
          kind: elementalBurstSkill.kind,
        });
      }
      
      if (elementalResonanceSkill && !companion.skills.includes('sage_elemental_resonance_1')) {
        learnCompanionSkill(companion, elementalResonanceSkill);
        newPassiveSkills.push(elementalResonanceSkill);
        specialSkills.push({
          name: elementalResonanceSkill.name,
          description: elementalResonanceSkill.description,
          kind: elementalResonanceSkill.kind,
        });
      }
    } else if (selectedPath === 'healing') {
      // æ²»æ„ˆä¹‹é“ï¼šé˜²æ­»è­·ç›¾ + ç¥è–å›éŸ¿
      const deathWardSkill = SKILL_LOOKUP.get('sage_death_ward_1');
      const sacredEchoSkill = SKILL_LOOKUP.get('sage_sacred_echo_1');
      
      if (deathWardSkill && !companion.skills.includes('sage_death_ward_1')) {
        learnCompanionSkill(companion, deathWardSkill);
        newActiveSkills.push(deathWardSkill);
        specialSkills.push({
          name: deathWardSkill.name,
          description: deathWardSkill.description,
          kind: deathWardSkill.kind,
        });
      }
      
      if (sacredEchoSkill && !companion.skills.includes('sage_sacred_echo_1')) {
        learnCompanionSkill(companion, sacredEchoSkill);
        newPassiveSkills.push(sacredEchoSkill);
        specialSkills.push({
          name: sacredEchoSkill.name,
          description: sacredEchoSkill.description,
          kind: sacredEchoSkill.kind,
        });
      }
    }
    
    // è¨˜éŒ„é¸æ“‡çš„è·¯å¾‘
    companion.sagePath = selectedPath;
  } else if (advancedClassId === 'weaponmaster') {
    // æ­¦å™¨å¤§å¸«ç‰¹æ®ŠæŠ€èƒ½ï¼šæ ¹æ“šé¸æ“‡çš„è·¯å¾‘çµ¦äºˆå°æ‡‰æŠ€èƒ½
    const selectedPath = state.ui.classAdvancement.selectedWeaponmasterPath;
    
    if (selectedPath === 'sword_god') {
      // åŠç¥ä¹‹è·¯ï¼šåŠç¥ä¹‹è·¯ + åŠæ°£ç¸±æ©«
      const swordGodPathSkill = SKILL_LOOKUP.get('weaponmaster_sword_god_path_1');
      const swordAuraSkill = SKILL_LOOKUP.get('weaponmaster_sword_aura_1');
      
      if (swordGodPathSkill && !companion.skills.includes('weaponmaster_sword_god_path_1')) {
        learnCompanionSkill(companion, swordGodPathSkill);
        newActiveSkills.push(swordGodPathSkill);
        specialSkills.push({
          name: swordGodPathSkill.name,
          description: swordGodPathSkill.description,
          kind: swordGodPathSkill.kind,
        });
      }
      
      if (swordAuraSkill && !companion.skills.includes('weaponmaster_sword_aura_1')) {
        learnCompanionSkill(companion, swordAuraSkill);
        newPassiveSkills.push(swordAuraSkill);
        specialSkills.push({
          name: swordAuraSkill.name,
          description: swordAuraSkill.description,
          kind: swordAuraSkill.kind,
        });
      }
    } else if (selectedPath === 'assassin') {
      // åˆºå®¢ä¹‹è·¯ï¼šæš—å½±çªè¥² + ç ´ç”²ä¹‹åˆƒ
      const assassinPathSkill = SKILL_LOOKUP.get('weaponmaster_assassin_path_1');
      const armorPierceSkill = SKILL_LOOKUP.get('weaponmaster_armor_pierce_1');
      
      if (assassinPathSkill && !companion.skills.includes('weaponmaster_assassin_path_1')) {
        learnCompanionSkill(companion, assassinPathSkill);
        newActiveSkills.push(assassinPathSkill);
        specialSkills.push({
          name: assassinPathSkill.name,
          description: assassinPathSkill.description,
          kind: assassinPathSkill.kind,
        });
      }
      
      if (armorPierceSkill && !companion.skills.includes('weaponmaster_armor_pierce_1')) {
        learnCompanionSkill(companion, armorPierceSkill);
        newPassiveSkills.push(armorPierceSkill);
        specialSkills.push({
          name: armorPierceSkill.name,
          description: armorPierceSkill.description,
          kind: armorPierceSkill.kind,
        });
      }
    }
    
    // è¨˜éŒ„é¸æ“‡çš„è·¯å¾‘
    companion.weaponmasterPath = selectedPath;
  }
  
  // è¨˜éŒ„æ—¥èªŒ
  const initialSkillNames = initialSkillsLearned.map(s => s.name).join('ã€');
  const activeSkillNames = newActiveSkills.map(s => s.name).join('ã€');
  const passiveSkillNames = newPassiveSkills.map(s => s.name).join('ã€');
  pushLog(`è·æ¥­å°å¸«ï¼š${companion.name} é€²éšç‚ºã€Œ${advancedClass.name}ã€ï¼`);
  if (initialSkillNames) {
    pushLog(`ç²å¾—åˆå§‹æŠ€èƒ½ï¼š${initialSkillNames}`);
  }
  if (activeSkillNames) {
    pushLog(`ç²å¾—ä¸»å‹•æŠ€èƒ½ï¼š${activeSkillNames}`);
  }
  if (passiveSkillNames) {
    pushLog(`ç²å¾—è¢«å‹•æŠ€èƒ½ï¼š${passiveSkillNames}`);
  }
  
  // å¦‚æœæœ‰ç‰¹æ®ŠæŠ€èƒ½ï¼Œé¡¯ç¤ºç¢ºèªè¦–çª—
  if (specialSkills.length > 0) {
    state.ui.skillLearnDialog = {
      companionName: companion.name,
      skills: specialSkills,
    };
    state.ui.classAdvancement = null;
    renderAll();
    return;
  }
  
  // æ¸…é™¤ç‹€æ…‹ä¸¦é€²å…¥ä¸‹ä¸€å€‹ç¯€é»
  state.ui.classAdvancement = null;
  advanceToNextNode();
  renderAll();
}

// è¿”å›è·æ¥­é€²éšï¼ˆå¾ç¬¬äºŒå±¤è¿”å›åˆ°ç¬¬ä¸€å±¤ï¼‰
function backClassAdvancement() {
  if (!state.ui.classAdvancement) return;
  
  const currentStep = state.ui.classAdvancement.step;
  
  if (currentStep === 'selectClass') {
    // å¾é¸æ“‡è·æ¥­è¿”å›åˆ°é¸æ“‡åŒä¼´
    state.ui.classAdvancement.step = 'selectCompanion';
    state.ui.classAdvancement.selectedCompanionIndex = null;
    state.ui.classAdvancement.selectedAdvancedClass = null;
  } else if (currentStep === 'selectPaladinPath') {
    // å¾è–é¨å£«è·¯å¾‘é¸æ“‡è¿”å›åˆ°é¸æ“‡è·æ¥­
    state.ui.classAdvancement.step = 'selectClass';
    state.ui.classAdvancement.selectedPaladinPath = null;
  } else if (currentStep === 'selectSagePath') {
    // å¾è³¢è€…è·¯å¾‘é¸æ“‡è¿”å›åˆ°é¸æ“‡è·æ¥­
    state.ui.classAdvancement.step = 'selectClass';
    state.ui.classAdvancement.selectedSagePath = null;
  } else if (currentStep === 'selectWeaponmasterPath') {
    // å¾æ­¦å™¨å¤§å¸«è·¯å¾‘é¸æ“‡è¿”å›åˆ°é¸æ“‡è·æ¥­
    state.ui.classAdvancement.step = 'selectClass';
    state.ui.classAdvancement.selectedWeaponmasterPath = null;
  }
  
  renderAll();
}

// ç¢ºèªå–æ¶ˆè·æ¥­é€²éšï¼ˆåœ¨ç¬¬ä¸€å±¤æ™‚ï¼‰
function confirmCancelClassAdvancement() {
  if (!state.ui.classAdvancement || state.ui.classAdvancement.step !== 'selectCompanion') {
    // å¦‚æœä¸æ˜¯åœ¨ç¬¬ä¸€å±¤ï¼Œç›´æ¥è¿”å›
    backClassAdvancement();
    return;
  }
  
  // é¡¯ç¤ºç¢ºèªå°è©±æ¡†
  state.ui.classAdvancementConfirmCancel = true;
  renderAll();
}

// å–æ¶ˆç¢ºèªå–æ¶ˆè·æ¥­é€²éšï¼ˆè¿”å›ç¹¼çºŒé€²éšï¼‰
function cancelConfirmCancelClassAdvancement() {
  if (state.ui.classAdvancement) {
    state.ui.classAdvancementConfirmCancel = false;
    renderAll();
  }
}

// å–æ¶ˆè·æ¥­é€²éšï¼ˆç¢ºèªå¾Œï¼‰
function cancelClassAdvancement() {
  state.ui.classAdvancement = null;
  state.ui.classAdvancementConfirmCancel = false;
  advanceToNextNode();
  renderAll();
}

// æ¸²æŸ“æŠ€èƒ½å­¸ç¿’ç¢ºèªè¦–çª—
function renderSkillLearnDialog(dialogState) {
  if (!dialogState || !dialogState.skills || dialogState.skills.length === 0) return '';
  
  const skillsList = dialogState.skills.map(skill => {
    const skillType = skill.kind === 'attack' ? 'âš”ï¸ ä¸»å‹•æŠ€èƒ½' : skill.kind === 'passive' ? 'âœ¨ è¢«å‹•æŠ€èƒ½' : 'ğŸ›¡ï¸ æ”¯æ´æŠ€èƒ½';
    return `
      <div class="skill-learn-item" style="margin: 15px 0; padding: 15px; background: rgba(0, 0, 0, 0.3); border-radius: 8px; border-left: 4px solid #4a9eff;">
        <div style="font-weight: bold; font-size: 16px; color: #4a9eff; margin-bottom: 8px;">
          ${skillType}ï¼š${skill.name}
        </div>
        <div style="color: #ccc; font-size: 14px; line-height: 1.6;">
          ${skill.description}
        </div>
      </div>
    `;
  }).join('');
  
  return `
    <h2>âœ¨ å­¸æœƒæ–°æŠ€èƒ½ï¼</h2>
    <div class="event-message">
      <p style="white-space: pre-line; font-size: 14.4px; line-height: 1.8; margin: 20px 0;">
        <strong>${dialogState.companionName}</strong> åœ¨é€²éšæ™‚å­¸æœƒäº†ä»¥ä¸‹ç‰¹æ®ŠæŠ€èƒ½ï¼š
      </p>
      <div style="margin: 20px 0;">
        ${skillsList}
      </div>
    </div>
    <button class="continue-btn" onclick="confirmSkillLearnDialog();">ç¢ºèª</button>
  `;
}

// ç¢ºèªæŠ€èƒ½å­¸ç¿’è¦–çª—
function confirmSkillLearnDialog() {
  if (!state.ui.skillLearnDialog) return;
  
  state.ui.skillLearnDialog = null;
  advanceToNextNode();
  renderAll();
}

// å°‡å‡½æ•¸æš´éœ²åˆ°å…¨å±€
window.selectClassAdvancementCompanion = selectClassAdvancementCompanion;
window.selectClassAdvancementClass = selectClassAdvancementClass;
window.selectPaladinPath = selectPaladinPath;
window.selectSagePath = selectSagePath;
window.selectWeaponmasterPath = selectWeaponmasterPath;
window.cancelClassAdvancement = cancelClassAdvancement;
window.backClassAdvancement = backClassAdvancement;
window.confirmCancelClassAdvancement = confirmCancelClassAdvancement;
window.cancelConfirmCancelClassAdvancement = cancelConfirmCancelClassAdvancement;
window.confirmSkillLearnDialog = confirmSkillLearnDialog;

// ==================== ç¾…å¾·è£å‚™ç³»çµ± ====================

// è™•ç†ç¾…å¾·è£å‚™äº‹ä»¶
function handleRodEquipmentEvent(option) {
  const hero = state.hero;
  
  if (!hero || hero.stats.hp <= 0) {
    pushLog('ä½ ç„¡æ³•ç²å¾—ç¾…å¾·è£å‚™ã€‚');
    advanceToNextNode();
    renderAll();
    return;
  }
  
  state.ui.rodEquipment = {
    step: 'selectEquipment',
    selectedEquipmentId: null,
  };
  
  renderAll();
}

// æ¸²æŸ“ç¾…å¾·è£å‚™å°è©±æ¡†
function renderRodEquipmentDialog(rodState) {
  if (rodState.step === 'selectEquipment') {
    const rodSword = EQUIPMENT_LOOKUP.get('rod_sword');
    const rodShield = EQUIPMENT_LOOKUP.get('rod_shield');
    const rodArmor = EQUIPMENT_LOOKUP.get('rod_armor');
    const rodEmblem = EQUIPMENT_LOOKUP.get('rod_emblem');
    
    // æ§‹å»ºè£å‚™æè¿°
    const buildEquipmentDescription = (equipment) => {
      if (!equipment) return '';
      const stats = [];
      if (equipment.attack !== undefined) {
        stats.push(`æ”»æ“Š+${equipment.attack}`);
      }
      if (equipment.defense !== undefined) {
        stats.push(`é˜²ç¦¦+${equipment.defense}`);
      }
      if (equipment.attributes) {
        Object.keys(equipment.attributes).forEach(attr => {
          const attrName = ATTRIBUTES.find(a => a.id === attr)?.name || attr;
          stats.push(`${attrName}+${equipment.attributes[attr]}`);
        });
      }
      if (equipment.hpBonus) {
        stats.push(`HP+${equipment.hpBonus}`);
      }
      if (equipment.mpBonus) {
        stats.push(`MP+${equipment.mpBonus}`);
      }
      return stats.join(' ');
    };
    
    return `
      <h2>ç¾…å¾·è£å‚™</h2>
      <div class="event-message">
        <p style="white-space: pre-line; font-size: 14.4px; line-height: 1.8; margin: 20px 0;">
          ä½ ç™¼ç¾äº†å‚³èªªä¸­å‹‡è€…ç¾…å¾·ç•™ä¸‹çš„è£å‚™ã€‚é€™äº›è£å‚™æ•£ç™¼è‘—å¼·å¤§çš„åŠ›é‡ï¼Œä½†åªèƒ½é¸æ“‡å…¶ä¸­ä¸€ä»¶ã€‚
        </p>
        <p style="margin-top: 15px; font-weight: bold;">è«‹é¸æ“‡è¦ç²å¾—çš„è£å‚™ï¼š</p>
      </div>
      <div class="event-choices" style="display: flex; flex-direction: column; gap: 10px; margin-top: 20px;">
        <button class="dialog-option" onclick="selectRodEquipment('rod_sword');">
          <strong>${rodSword?.name || 'ç¾…å¾·ä¹‹åŠ'}</strong>
          <div style="margin-top: 8px; font-size: 12px; color: #ccc;">
            <p>${rodSword?.description || 'å‚³èªªä¸­å‹‡è€…ç¾…å¾·ä½¿ç”¨çš„ç¥åŠ'}</p>
            <p>${buildEquipmentDescription(rodSword)}</p>
          </div>
        </button>
        <button class="dialog-option" onclick="selectRodEquipment('rod_shield');">
          <strong>${rodShield?.name || 'ç¾…å¾·ä¹‹ç›¾'}</strong>
          <div style="margin-top: 8px; font-size: 12px; color: #ccc;">
            <p>${rodShield?.description || 'å‚³èªªä¸­å‹‡è€…ç¾…å¾·ä½¿ç”¨çš„ç¥ç›¾'}</p>
            <p>${buildEquipmentDescription(rodShield)}</p>
          </div>
        </button>
        <button class="dialog-option" onclick="selectRodEquipment('rod_armor');">
          <strong>${rodArmor?.name || 'ç¾…å¾·ä¹‹é§'}</strong>
          <div style="margin-top: 8px; font-size: 12px; color: #ccc;">
            <p>${rodArmor?.description || 'å‚³èªªä¸­å‹‡è€…ç¾…å¾·ä½¿ç”¨çš„ç¥é§'}</p>
            <p>${buildEquipmentDescription(rodArmor)}</p>
          </div>
        </button>
        <button class="dialog-option" onclick="selectRodEquipment('rod_emblem');">
          <strong>${rodEmblem?.name || 'ç¾…å¾·ç´‹ç« '}</strong>
          <div style="margin-top: 8px; font-size: 12px; color: #ccc;">
            <p>${rodEmblem?.description || 'å‚³èªªä¸­å‹‡è€…ç¾…å¾·ä½¿ç”¨çš„ç´‹ç« '}</p>
            <p>${buildEquipmentDescription(rodEmblem)}</p>
          </div>
        </button>
        <button class="continue-btn" onclick="cancelRodEquipment();" style="background: #666;">å–æ¶ˆ</button>
      </div>
    `;
  }
  
  return '';
}

// é¸æ“‡ç¾…å¾·è£å‚™
function selectRodEquipment(equipmentId) {
  if (!state.ui.rodEquipment) return;
  
  const hero = state.hero;
  if (!hero) {
    cancelRodEquipment();
    return;
  }
  
  const equipment = EQUIPMENT_LOOKUP.get(equipmentId);
  if (!equipment) {
    pushLog('ç„¡æ³•æ‰¾åˆ°è©²è£å‚™ã€‚');
    cancelRodEquipment();
    return;
  }
  
  // å°‡è£å‚™æ·»åŠ åˆ°é“å…·è¢‹
  const itemId = `equipment_${equipmentId}`;
  const existingItem = hero.items.find(entry => entry.id === itemId);
  
  if (existingItem) {
    existingItem.qty += 1;
  } else {
    hero.items.push({ id: itemId, qty: 1 });
  }
  
  pushLog(`ä½ ç²å¾—äº†${equipment.name}ï¼`);
  
  state.ui.rodEquipment = null;
  advanceToNextNode();
  renderAll();
}

// å–æ¶ˆç¾…å¾·è£å‚™é¸æ“‡
function cancelRodEquipment() {
  state.ui.rodEquipment = null;
  advanceToNextNode();
  renderAll();
}

// å°‡å‡½æ•¸æš´éœ²åˆ°å…¨å±€
window.selectRodEquipment = selectRodEquipment;
window.cancelRodEquipment = cancelRodEquipment;

// ==================== å‹‡è€…ä¹‹è¡€ç³»çµ± ====================

// è™•ç†å‹‡è€…ä¹‹è¡€äº‹ä»¶
function handleHeroBloodEvent(option) {
  const hero = state.hero;
  
  if (!hero || hero.stats.hp <= 0) {
    pushLog('ä½ ç„¡æ³•ç²å¾—å‹‡è€…ä¹‹è¡€çš„åŠ›é‡ã€‚');
    advanceToNextNode();
    renderAll();
    return;
  }
  
  state.ui.heroBlood = {
    step: 'selectBlood',
    selectedBloodType: null,
  };
  
  renderAll();
}

// æ¸²æŸ“å‹‡è€…ä¹‹è¡€å°è©±æ¡†
function renderHeroBloodDialog(bloodState) {
  if (bloodState.step === 'selectBlood') {
    const warriorSkill = SKILL_LOOKUP.get('hero_blood_warrior_skill');
    const warriorPassive = SKILL_LOOKUP.get('hero_blood_warrior_passive_skill');
    const recoverySkill = SKILL_LOOKUP.get('hero_blood_recovery_skill');
    const recoveryPassive = SKILL_LOOKUP.get('hero_blood_recovery_passive_skill');
    const mageSkill = SKILL_LOOKUP.get('hero_blood_mage_skill');
    const magePassive = SKILL_LOOKUP.get('hero_blood_mage_passive_skill');
    
    return `
      <h2>å‹‡è€…ä¹‹è¡€</h2>
      <div class="event-message">
        <p style="white-space: pre-line; font-size: 14.4px; line-height: 1.8; margin: 20px 0;">
          ä½ ç™¼ç¾äº†ä¸€è™•å¤è€çš„ç¥­å£‡ï¼Œä¸Šé¢æµæ·Œè‘—ä¸‰ç¨®ä¸åŒçš„å‹‡è€…ä¹‹è¡€ã€‚æ¯ä¸€ç¨®è¡€éƒ½è˜Šå«è‘—å¼·å¤§çš„åŠ›é‡ï¼Œä½†åªèƒ½é¸æ“‡ä¸€ç¨®ã€‚
        </p>
        <p style="margin-top: 15px; font-weight: bold;">è«‹é¸æ“‡è¦ç²å¾—çš„å‹‡è€…ä¹‹è¡€ï¼š</p>
      </div>
      <div class="event-choices" style="display: flex; flex-direction: column; gap: 10px; margin-top: 20px;">
        <button class="dialog-option" onclick="selectHeroBloodType('warrior');">
          <strong>æˆ°å£«ä¹‹è¡€</strong>
          <div style="margin-top: 8px; font-size: 12px; color: #ccc;">
            <p>ä¸»å‹•æŠ€èƒ½ï¼š${warriorSkill?.name || 'å…¨é«”é–ƒé›»æ–¬'} - ${warriorSkill?.description || 'å…¨é«”æ”»æ“Šï¼šæ”»æ“ŠåŠ› + é­”åŠ› Ã— 50%'}</p>
            <p>è¢«å‹•æŠ€èƒ½ï¼š${warriorPassive?.name || 'æˆ°å£«ä¹‹è¡€'} - ${warriorPassive?.description || 'å…¨èƒ½åŠ› +20'}</p>
          </div>
        </button>
        <button class="dialog-option" onclick="selectHeroBloodType('recovery');">
          <strong>å›å¾©ä¹‹è¡€</strong>
          <div style="margin-top: 8px; font-size: 12px; color: #ccc;">
            <p>ä¸»å‹•æŠ€èƒ½ï¼š${recoverySkill?.name || 'å…¨é«”è£œè¡€'} - ${recoverySkill?.description || 'å…¨é«”å›å¾©ï¼š200 + å›å¾©åŠ› Ã— 50%'}</p>
            <p>è¢«å‹•æŠ€èƒ½ï¼š${recoveryPassive?.name || 'å›å¾©ä¹‹è¡€'} - ${recoveryPassive?.description || 'å›å¾©åŠ› +60ï¼ŒMP +50'}</p>
          </div>
        </button>
        <button class="dialog-option" onclick="selectHeroBloodType('mage');">
          <strong>æ³•å¸«ä¹‹è¡€</strong>
          <div style="margin-top: 8px; font-size: 12px; color: #ccc;">
            <p>ä¸»å‹•æŠ€èƒ½ï¼š${mageSkill?.name || 'æ³•å¸«ä¹‹è¡€'} - ${mageSkill?.description || 'å–®é«”é­”æ³•æ”»æ“Šï¼šå¨åŠ› 400 + é­”åŠ› Ã— 50%'}</p>
            <p>è¢«å‹•æŠ€èƒ½ï¼š${magePassive?.name || 'æ³•å¸«ä¹‹è¡€'} - ${magePassive?.description || 'MP +50ï¼Œé­”åŠ› +60'}</p>
          </div>
        </button>
        <button class="continue-btn" onclick="cancelHeroBlood();" style="background: #666;">å–æ¶ˆ</button>
      </div>
    `;
  }
  
  return '';
}

// é¸æ“‡å‹‡è€…ä¹‹è¡€é¡å‹
function selectHeroBloodType(bloodType) {
  if (!state.ui.heroBlood) return;
  
  const hero = state.hero;
  if (!hero) {
    cancelHeroBlood();
    return;
  }
  
  let activeSkillId = '';
  let passiveSkillId = '';
  let bloodName = '';
  
  switch (bloodType) {
    case 'warrior':
      activeSkillId = 'hero_blood_warrior_skill';
      passiveSkillId = 'hero_blood_warrior_passive_skill';
      bloodName = 'æˆ°å£«ä¹‹è¡€';
      break;
    case 'recovery':
      activeSkillId = 'hero_blood_recovery_skill';
      passiveSkillId = 'hero_blood_recovery_passive_skill';
      bloodName = 'å›å¾©ä¹‹è¡€';
      break;
    case 'mage':
      activeSkillId = 'hero_blood_mage_skill';
      passiveSkillId = 'hero_blood_mage_passive_skill';
      bloodName = 'æ³•å¸«ä¹‹è¡€';
      break;
    default:
      cancelHeroBlood();
      return;
  }
  
  const activeSkill = SKILL_LOOKUP.get(activeSkillId);
  const passiveSkill = SKILL_LOOKUP.get(passiveSkillId);
  
  if (!activeSkill || !passiveSkill) {
    pushLog('ç„¡æ³•æ‰¾åˆ°å°æ‡‰çš„æŠ€èƒ½ã€‚');
    cancelHeroBlood();
    return;
  }
  
  // å­¸ç¿’ä¸»å‹•æŠ€èƒ½å’Œè¢«å‹•æŠ€èƒ½
  learnSkill(activeSkill);
  learnSkill(passiveSkill);
  
  pushLog(`ä½ ç²å¾—äº†${bloodName}çš„åŠ›é‡ï¼`);
  pushLog(`å­¸æœƒäº†ä¸»å‹•æŠ€èƒ½ï¼š${activeSkill.name}`);
  pushLog(`å­¸æœƒäº†è¢«å‹•æŠ€èƒ½ï¼š${passiveSkill.name}`);
  
  state.ui.heroBlood = null;
  advanceToNextNode();
  renderAll();
}

// å–æ¶ˆå‹‡è€…ä¹‹è¡€é¸æ“‡
function cancelHeroBlood() {
  state.ui.heroBlood = null;
  advanceToNextNode();
  renderAll();
}

// å°‡å‡½æ•¸æš´éœ²åˆ°å…¨å±€
window.selectHeroBloodType = selectHeroBloodType;
window.cancelHeroBlood = cancelHeroBlood;

// ==================== æ¸¬è©¦æ¨¡å¼è·æ¥­é€²éšç³»çµ± ====================

// æ¸²æŸ“æ¸¬è©¦æ¨¡å¼è·æ¥­é€²éšå°è©±æ¡†
function renderTestModeAdvancementDialog(advancementState) {
  const companion = advancementState.companion;
  if (!companion) {
    state.ui.testModeAdvancement = null;
    return '';
  }
  
  // å¦‚æœæ˜¯è·¯å¾‘é¸æ“‡æ­¥é©Ÿ
  if (advancementState.step === 'selectSagePath') {
    // å…ƒç´ ä¹‹é“æŠ€èƒ½
    const elementalActiveSkill = SKILL_LOOKUP.get('sage_elemental_burst_1');
    const elementalPassiveSkill = SKILL_LOOKUP.get('sage_elemental_resonance_1');
    
    // æ²»æ„ˆä¹‹é“æŠ€èƒ½
    const healingActiveSkill = SKILL_LOOKUP.get('sage_death_ward_1');
    const healingPassiveSkill = SKILL_LOOKUP.get('sage_sacred_echo_1');
    
    return `
      <h2>è·æ¥­é€²éš</h2>
      <div class="event-message">
        <p style="white-space: pre-line; font-size: 14.4px; line-height: 1.8; margin: 20px 0;">
          ${companion.name} é¸æ“‡æˆç‚ºè³¢è€…ï¼Œè«‹é¸æ“‡ä¸€æ¢é“è·¯ï¼š
        </p>
      </div>
      <div class="event-choices" style="display: flex; flex-direction: column; gap: 10px; margin-top: 20px;">
        <button class="dialog-option" onclick="selectTestModeSagePath('elemental');">
          <div>
            <strong>å…ƒç´ ä¹‹é“</strong>
            <p style="margin: 5px 0; font-size: 12px; color: #ccc;">
              ä¸»å‹•æŠ€ï¼š${elementalActiveSkill?.name || 'å…ƒç´ çˆ†ç™¼'} - ${elementalActiveSkill?.description || 'é€ æˆå›ºå®šå€¼150 + é­”åŠ›Ã—100%çš„é­”æ³•å‚·å®³ï¼Œ30%æ©Ÿç‡é€ æˆ1.5å€å‚·å®³ã€‚'}<br>
              è¢«å‹•æŠ€ï¼š${elementalPassiveSkill?.name || 'å…ƒç´ å…±é³´'} - ${elementalPassiveSkill?.description || 'æœ‰20%æ©Ÿç‡ä½¿ç”¨é­”æ³•æˆ–æ¢å¾©æ™‚ä¸æ¶ˆè€—MPã€‚'}
            </p>
          </div>
        </button>
        <button class="dialog-option" onclick="selectTestModeSagePath('healing');">
          <div>
            <strong>æ²»æ„ˆä¹‹é“</strong>
            <p style="margin: 5px 0; font-size: 12px; color: #ccc;">
              ä¸»å‹•æŠ€ï¼š${healingActiveSkill?.name || 'é˜²æ­»è­·ç›¾'} - ${healingActiveSkill?.description || 'æ‰€æœ‰å‹æ–¹ç²å¾—é˜²æ­»æ•ˆæœï¼Œç”Ÿå‘½é™åˆ°0æ™‚æœƒç•™ä¸‹1é»HPï¼Œç„¶å¾Œæ•ˆæœæ¶ˆå¤±ã€‚'}<br>
              è¢«å‹•æŠ€ï¼š${healingPassiveSkill?.name || 'ç¥è–å›éŸ¿'} - ${healingPassiveSkill?.description || 'æ¢å¾©HPæ™‚ï¼Œæœƒå¾—åˆ°ä¸€å€‹20%æ²»ç™‚å€¼çš„ç·©æ…¢æ¢å¾©ï¼Œä¸‹å›åˆé–‹å§‹æ™‚å›å¾©ï¼Œå¯ç´¯åŠ ã€‚'}
            </p>
          </div>
        </button>
        <button class="continue-btn" onclick="skipTestModeAdvancement();" style="background: #666;">æ”¾æ£„é€²éš</button>
      </div>
    `;
  } else if (advancementState.step === 'selectWeaponmasterPath') {
    // åŠç¥ä¹‹è·¯æŠ€èƒ½
    const swordGodActiveSkill = SKILL_LOOKUP.get('weaponmaster_sword_god_path_1');
    const swordGodPassiveSkill = SKILL_LOOKUP.get('weaponmaster_sword_aura_1');
    
    // åˆºå®¢ä¹‹è·¯æŠ€èƒ½
    const assassinActiveSkill = SKILL_LOOKUP.get('weaponmaster_assassin_path_1');
    const assassinPassiveSkill = SKILL_LOOKUP.get('weaponmaster_armor_pierce_1');
    
    return `
      <h2>è·æ¥­é€²éš</h2>
      <div class="event-message">
        <p style="white-space: pre-line; font-size: 14.4px; line-height: 1.8; margin: 20px 0;">
          ${companion.name} é¸æ“‡æˆç‚ºæ­¦å™¨å¤§å¸«ï¼Œè«‹é¸æ“‡ä¸€æ¢é“è·¯ï¼š
        </p>
      </div>
      <div class="event-choices" style="display: flex; flex-direction: column; gap: 10px; margin-top: 20px;">
        <button class="dialog-option" onclick="selectTestModeWeaponmasterPath('sword_god');">
          <div>
            <strong>åŠç¥ä¹‹è·¯</strong>
            <p style="margin: 5px 0; font-size: 12px; color: #ccc;">
              ä¸»å‹•æŠ€ï¼š${swordGodActiveSkill?.name || 'åŠç¥ä¹‹è·¯'} - ${swordGodActiveSkill?.description || 'æ¶ˆè€—æœ€å¤šæœ€å¤§MPçš„ä¸€åŠï¼Œæœ€å¤šæ¶ˆè€—åˆ°å…¨ç©ºMPï¼Œé€ æˆ 1 + 3x(æ¶ˆè€—MP/æœ€å¤§MPä¸€åŠ) å€çš„æ”»æ“ŠåŠ›å‚·å®³ã€‚'}<br>
              è¢«å‹•æŠ€ï¼š${swordGodPassiveSkill?.name || 'åŠæ°£ç¸±æ©«'} - ${swordGodPassiveSkill?.description || 'æ™®æ”»è®Šæˆå…¨é«”æ”»æ“Šï¼Œä½†é€ æˆå‚·å®³åªæœ‰8æˆï¼ˆæ”»æ“ŠåŠ›-é˜²ï¼‰Ã—0.8ã€‚'}
            </p>
          </div>
        </button>
        <button class="dialog-option" onclick="selectTestModeWeaponmasterPath('assassin');">
          <div>
            <strong>åˆºå®¢ä¹‹è·¯</strong>
            <p style="margin: 5px 0; font-size: 12px; color: #ccc;">
              ä¸»å‹•æŠ€ï¼š${assassinActiveSkill?.name || 'æš—å½±çªè¥²'} - ${assassinActiveSkill?.description || 'æ”»æ“ŠåŠ›=æ•æ·Ã—100% + æ”»æ“ŠÃ—50% + (20%æ•æ·çš„ä¸­æ¯’+é™ä½20%æ”»æ“Š)æŒçºŒ2å›åˆã€‚'}<br>
              è¢«å‹•æŠ€ï¼š${assassinPassiveSkill?.name || 'ç ´ç”²ä¹‹åˆƒ'} - ${assassinPassiveSkill?.description || 'é€²å…¥æˆ°é¬¥å¾Œå¾—åˆ°ä¸€å€‹buffï¼Œç‰©ç†æ”»æ“Šå¯ä»¥ç„¡è¦–æ•µæ–¹çš„é˜²åŠ›ï¼Œé€ æˆå‚·å®³ã€‚'}
            </p>
          </div>
        </button>
        <button class="continue-btn" onclick="skipTestModeAdvancement();" style="background: #666;">æ”¾æ£„é€²éš</button>
      </div>
    `;
  } else if (advancementState.step === 'selectPaladinPath') {
    // å¾©ä»‡ä¹‹é“æŠ€èƒ½
    const vengeanceActiveSkill = SKILL_LOOKUP.get('paladin_divine_slash_1');
    const vengeancePassiveSkill = SKILL_LOOKUP.get('paladin_vengeance_will_1');
    
    // ç¥è–ä¹‹é“æŠ€èƒ½
    const sacredActiveSkill = SKILL_LOOKUP.get('paladin_sacred_shield_1');
    const sacredPassiveSkill = SKILL_LOOKUP.get('paladin_guardian_will_1');
    
    return `
      <h2>è·æ¥­é€²éš</h2>
      <div class="event-message">
        <p style="white-space: pre-line; font-size: 14.4px; line-height: 1.8; margin: 20px 0;">
          ${companion.name} é¸æ“‡æˆç‚ºè–é¨å£«ï¼Œè«‹é¸æ“‡ä¸€æ¢é“è·¯ï¼š
        </p>
      </div>
      <div class="event-choices" style="display: flex; flex-direction: column; gap: 10px; margin-top: 20px;">
        <button class="dialog-option" onclick="selectTestModePaladinPath('vengeance');">
          <div>
            <strong>å¾©ä»‡ä¹‹é“</strong>
            <p style="margin: 5px 0; font-size: 12px; color: #ccc;">
              ä¸»å‹•æŠ€ï¼š${vengeanceActiveSkill?.name || 'è‡³è–æ–¬'} - ${vengeanceActiveSkill?.description || 'é€ æˆé«”åŠ›Ã—120% + æ²»ç™‚èƒ½åŠ›Ã—120%çš„æ”»æ“Šå‚·å®³ã€‚'}<br>
              è¢«å‹•æŠ€ï¼š${vengeancePassiveSkill?.name || 'å¾©ä»‡æ„å¿—'} - ${vengeancePassiveSkill?.description || '25%æ©Ÿç‡è®“æ‰€æœ‰æ•µäººæ¸›å°‘å—åˆ°å‚·å®³çš„ä¸€åŠæ•¸å€¼ï¼ˆè‡³å°‘æ˜¯1ï¼‰ã€‚'}
            </p>
          </div>
        </button>
        <button class="dialog-option" onclick="selectTestModePaladinPath('sacred');">
          <div>
            <strong>ç¥è–ä¹‹é“</strong>
            <p style="margin: 5px 0; font-size: 12px; color: #ccc;">
              ä¸»å‹•æŠ€ï¼š${sacredActiveSkill?.name || 'ç¥è–è­·ç›¾'} - ${sacredActiveSkill?.description || 'æ²»ç™‚æ™‚æœƒé¡å¤–å¾—åˆ°ä¸€å€‹é«”åŠ›å€¼1/3çš„è­·ç›¾ã€‚'}<br>
              è¢«å‹•æŠ€ï¼š${sacredPassiveSkill?.name || 'å®ˆè­·æ„å¿—'} - ${sacredPassiveSkill?.description || 'è¢«æ”»æ“Šæ™‚æœ‰25%æ©Ÿç‡å›å¾©æ‰€æœ‰äºº10%é«”åŠ›çš„HPã€‚'}
            </p>
          </div>
        </button>
        <button class="continue-btn" onclick="skipTestModeAdvancement();" style="background: #666;">æ”¾æ£„é€²éš</button>
      </div>
    `;
  }
  
  const companionType = COMPANION_TYPES[companion.companionTypeId];
  const advancementOptions = CLASS_ADVANCEMENT_MAP[companion.companionTypeId] || CLASS_ADVANCEMENT_MAP[companionType?.heroType] || [];
  
  if (advancementOptions.length === 0) {
    // æ²’æœ‰å¯é€²éšçš„è·æ¥­ï¼Œç›´æ¥æ¸…é™¤ç‹€æ…‹
    state.ui.testModeAdvancement = null;
    // ç¹¼çºŒæ­£å¸¸çš„åŒä¼´é¸æ“‡æµç¨‹
    continueCompanionSelection();
    return '';
  }
  
  const classButtons = advancementOptions.map((advancedClassId) => {
    const advancedClass = COMPANION_TYPES[advancedClassId];
    if (!advancedClass) return '';
    
    return `
      <button class="dialog-option" onclick="selectTestModeAdvancementClass('${advancedClassId}');">
        <div style="display: flex; align-items: center; gap: 10px;">
          <span style="font-size: 24px;">${advancedClass.icon}</span>
          <div>
            <strong>${advancedClass.name}</strong>
            <p style="margin: 5px 0; font-size: 12px; color: #ccc;">${advancedClass.description}</p>
          </div>
        </div>
      </button>
    `;
  }).join('');
  
  return `
    <h2>è·æ¥­é€²éš</h2>
    <div class="event-message">
      <p style="white-space: pre-line; font-size: 14.4px; line-height: 1.8; margin: 20px 0;">
        ${companion.name}ï¼ˆ${companionType?.name || 'æœªçŸ¥'}ï¼‰å·²é”åˆ° Lv ${companion.stats.level}ã€‚
        <br>æ˜¯å¦è¦é€²è¡Œè·æ¥­é€²éšï¼Ÿ
      </p>
    </div>
    <div class="event-choices" style="display: flex; flex-direction: column; gap: 10px; margin-top: 20px;">
      ${classButtons}
      <button class="continue-btn" onclick="skipTestModeAdvancement();" style="background: #666;">æ”¾æ£„é€²éš</button>
    </div>
  `;
}

// é¸æ“‡æ¸¬è©¦æ¨¡å¼è·æ¥­é€²éšçš„è·æ¥­
function selectTestModeAdvancementClass(advancedClassId) {
  if (!state.ui.testModeAdvancement) return;
  
  const companion = state.ui.testModeAdvancement.companion;
  const advancedClass = COMPANION_TYPES[advancedClassId];
  
  if (!companion || !advancedClass) {
    skipTestModeAdvancement();
    return;
  }
  
  // å¦‚æœæ˜¯è–é¨å£«ï¼Œéœ€è¦é¸æ“‡è·¯å¾‘
  if (advancedClassId === 'paladin') {
    state.ui.testModeAdvancement.selectedAdvancedClass = advancedClassId;
    state.ui.testModeAdvancement.step = 'selectPaladinPath';
    renderAll();
    return;
  }
  
  // å¦‚æœæ˜¯è³¢è€…ï¼Œéœ€è¦é¸æ“‡è·¯å¾‘
  if (advancedClassId === 'sage') {
    state.ui.testModeAdvancement.selectedAdvancedClass = advancedClassId;
    state.ui.testModeAdvancement.step = 'selectSagePath';
    renderAll();
    return;
  }
  
  // å¦‚æœæ˜¯æ­¦å™¨å¤§å¸«ï¼Œéœ€è¦é¸æ“‡è·¯å¾‘
  if (advancedClassId === 'weaponmaster') {
    state.ui.testModeAdvancement.selectedAdvancedClass = advancedClassId;
    state.ui.testModeAdvancement.step = 'selectWeaponmasterPath';
    renderAll();
    return;
  }
  
  // åŸ·è¡Œé€²éšï¼ˆä½¿ç”¨èˆ‡æ­£å¸¸é€²éšç›¸åŒçš„é‚è¼¯ï¼‰
  const oldCompanionType = COMPANION_TYPES[companion.companionTypeId];
  const oldHeroType = oldCompanionType?.heroType || companion.heroType;
  
  // ç²å–æ–°è·æ¥­çš„æµæ´¾
  const flowMap = {
    attacker: 'sword',
    defender: 'defender',
    mage: 'magic',
    healer: 'recovery',
    agile: 'agility',
    sage: ['magic', 'recovery'],
    paladin: ['defender', 'recovery'],
    weaponmaster: ['sword', 'agility'],
  };
  
  const newHeroType = advancedClass.heroType;
  const newPrimaryFlowOrFlows = flowMap[newHeroType] || 'sword';
  const newPrimaryFlows = Array.isArray(newPrimaryFlowOrFlows) ? newPrimaryFlowOrFlows : [newPrimaryFlowOrFlows];
  
  // ç²å–èˆŠè·æ¥­çš„æµæ´¾ï¼ˆç”¨æ–¼æ’é™¤ï¼‰
  const oldPrimaryFlowOrFlows = flowMap[oldHeroType] || 'sword';
  const oldPrimaryFlows = Array.isArray(oldPrimaryFlowOrFlows) ? oldPrimaryFlowOrFlows : [oldPrimaryFlowOrFlows];
  
  // æ”¹è®Šè·æ¥­é¡å‹ï¼ˆä¿ç•™åŸæœ‰æŠ€èƒ½å’Œèƒ½åŠ›ï¼‰
  companion.companionTypeId = advancedClassId;
  companion.heroType = newHeroType;
  
  // éš¨æ©Ÿç²å¾—å…©å€‹èˆ‡åŸæœ¬è·æ¥­ä¸åŒçš„ä¸»å‹•æŠ€èƒ½
  const newActiveSkills = [];
  const ownedSkills = new Set(companion.skills);
  
  // å¾æ–°è·æ¥­çš„æµæ´¾ä¸­é¸æ“‡ä¸»å‹•æŠ€èƒ½ï¼ˆæ’é™¤èˆŠè·æ¥­çš„æµæ´¾ï¼‰
  const availableFlows = newPrimaryFlows.filter(flow => !oldPrimaryFlows.includes(flow));
  
  if (availableFlows.length > 0) {
    availableFlows.forEach(flow => {
      const tier1Skills = getTier1SingleTargetSkillsByFlow(flow);
      const candidateSkills = tier1Skills.filter(skill => {
        if (ownedSkills.has(skill.id)) return false;
        if (skill.kind === 'passive') return false;
        return true;
      });
      
      if (candidateSkills.length > 0) {
        const randomSkill = candidateSkills[Math.floor(Math.random() * candidateSkills.length)];
        newActiveSkills.push(randomSkill);
      }
    });
  }
  
  // å¦‚æœé‚„æ²’æœ‰å…©å€‹æŠ€èƒ½ï¼Œå¾æ‰€æœ‰æ–°è·æ¥­æµæ´¾ä¸­é¸æ“‡
  while (newActiveSkills.length < 2 && newPrimaryFlows.length > 0) {
    const flow = newPrimaryFlows[Math.floor(Math.random() * newPrimaryFlows.length)];
    const tier1Skills = getTier1SingleTargetSkillsByFlow(flow);
    const candidateSkills = tier1Skills.filter(skill => {
      if (ownedSkills.has(skill.id)) return false;
      if (skill.kind === 'passive') return false;
      if (newActiveSkills.some(s => s.id === skill.id)) return false;
      return true;
    });
    
    if (candidateSkills.length > 0) {
      const randomSkill = candidateSkills[Math.floor(Math.random() * candidateSkills.length)];
      newActiveSkills.push(randomSkill);
    } else {
      break;
    }
  }
  
  // å­¸ç¿’æ–°ä¸»å‹•æŠ€èƒ½
  newActiveSkills.forEach(skill => {
    learnCompanionSkill(companion, skill);
  });
  
  // éš¨æ©Ÿç²å¾—å››å€‹èˆ‡åŸæœ¬è·æ¥­ä¸åŒçš„è¢«å‹•æŠ€èƒ½
  const newPassiveSkills = [];
  
  // å¾æ–°è·æ¥­çš„æµæ´¾ä¸­é¸æ“‡è¢«å‹•æŠ€èƒ½ï¼ˆæ’é™¤èˆŠè·æ¥­çš„æµæ´¾ï¼‰
  if (availableFlows.length > 0) {
    availableFlows.forEach(flow => {
      const tier1Passives = getTier1PassiveSkillsByFlow(flow);
      const candidatePassives = tier1Passives.filter(skill => {
        if (ownedSkills.has(skill.id)) return false;
        if (skill.kind !== 'passive') return false;
        return true;
      });
      
      if (candidatePassives.length > 0) {
        const randomPassive = candidatePassives[Math.floor(Math.random() * candidatePassives.length)];
        newPassiveSkills.push(randomPassive);
      }
    });
  }
  
  // å¦‚æœé‚„æ²’æœ‰å››å€‹è¢«å‹•æŠ€èƒ½ï¼Œå¾æ‰€æœ‰æ–°è·æ¥­æµæ´¾ä¸­é¸æ“‡
  while (newPassiveSkills.length < 4 && newPrimaryFlows.length > 0) {
    const flow = newPrimaryFlows[Math.floor(Math.random() * newPrimaryFlows.length)];
    const tier1Passives = getTier1PassiveSkillsByFlow(flow);
    const candidatePassives = tier1Passives.filter(skill => {
      if (ownedSkills.has(skill.id)) return false;
      if (skill.kind !== 'passive') return false;
      if (newPassiveSkills.some(s => s.id === skill.id)) return false;
      return true;
    });
    
    if (candidatePassives.length > 0) {
      const randomPassive = candidatePassives[Math.floor(Math.random() * candidatePassives.length)];
      newPassiveSkills.push(randomPassive);
    } else {
      break;
    }
  }
  
  // å­¸ç¿’æ–°è¢«å‹•æŠ€èƒ½
  newPassiveSkills.forEach(skill => {
    learnCompanionSkill(companion, skill);
    
    // å¦‚æœæ˜¯é˜²å®ˆå‹è¢«å‹•æŠ€èƒ½ï¼ˆHPåŠ æˆï¼‰ï¼Œç«‹å³æ‡‰ç”¨æ•ˆæœ
    if (skill.hpBonus !== undefined) {
      companion.stats.maxHp = Math.ceil(companion.stats.maxHp + skill.hpBonus);
      companion.stats.hp = Math.ceil(companion.stats.hp + skill.hpBonus);
    }
    // å¦‚æœæ˜¯é­”æ³•å‹è¢«å‹•æŠ€èƒ½ï¼ˆMPåŠ æˆï¼‰ï¼Œç«‹å³æ‡‰ç”¨æ•ˆæœ
    if (skill.mpBonus !== undefined) {
      companion.stats.maxMp = Math.ceil(companion.stats.maxMp + skill.mpBonus);
      companion.stats.mp = Math.ceil(companion.stats.mp + skill.mpBonus);
    }
  });
  
  // è–é¨å£«ç‰¹æ®ŠæŠ€èƒ½ï¼šæ ¹æ“šé¸æ“‡çš„è·¯å¾‘çµ¦äºˆå°æ‡‰æŠ€èƒ½
  if (advancedClassId === 'paladin') {
    const selectedPath = state.ui.testModeAdvancement.selectedPaladinPath;
    
    if (selectedPath === 'vengeance') {
      // å¾©ä»‡ä¹‹é“ï¼šè‡³è–æ–¬ + å¾©ä»‡æ„å¿—
      const divineSlashSkill = SKILL_LOOKUP.get('paladin_divine_slash_1');
      const vengeanceWillSkill = SKILL_LOOKUP.get('paladin_vengeance_will_1');
      
      if (divineSlashSkill && !companion.skills.includes('paladin_divine_slash_1')) {
        learnCompanionSkill(companion, divineSlashSkill);
        newActiveSkills.push(divineSlashSkill);
      }
      
      if (vengeanceWillSkill && !companion.skills.includes('paladin_vengeance_will_1')) {
        learnCompanionSkill(companion, vengeanceWillSkill);
        newPassiveSkills.push(vengeanceWillSkill);
      }
    } else if (selectedPath === 'sacred') {
      // ç¥è–ä¹‹é“ï¼šç¥è–è­·ç›¾ + å®ˆè­·æ„å¿—
      const sacredShieldSkill = SKILL_LOOKUP.get('paladin_sacred_shield_1');
      const guardianWillSkill = SKILL_LOOKUP.get('paladin_guardian_will_1');
      
      if (sacredShieldSkill && !companion.skills.includes('paladin_sacred_shield_1')) {
        learnCompanionSkill(companion, sacredShieldSkill);
        newPassiveSkills.push(sacredShieldSkill);
      }
      
      if (guardianWillSkill && !companion.skills.includes('paladin_guardian_will_1')) {
        learnCompanionSkill(companion, guardianWillSkill);
        newPassiveSkills.push(guardianWillSkill);
      }
    }
    
    // è¨˜éŒ„é¸æ“‡çš„è·¯å¾‘
    companion.paladinPath = selectedPath;
  }
  
  // è³¢è€…ç‰¹æ®ŠæŠ€èƒ½ï¼šæ ¹æ“šé¸æ“‡çš„è·¯å¾‘çµ¦äºˆå°æ‡‰æŠ€èƒ½
  if (advancedClassId === 'sage') {
    const selectedPath = state.ui.testModeAdvancement.selectedSagePath;
    
    if (selectedPath === 'elemental') {
      // å…ƒç´ ä¹‹é“ï¼šå…ƒç´ çˆ†ç™¼ + å…ƒç´ å…±é³´
      const elementalBurstSkill = SKILL_LOOKUP.get('sage_elemental_burst_1');
      const elementalResonanceSkill = SKILL_LOOKUP.get('sage_elemental_resonance_1');
      
      if (elementalBurstSkill && !companion.skills.includes('sage_elemental_burst_1')) {
        learnCompanionSkill(companion, elementalBurstSkill);
        newActiveSkills.push(elementalBurstSkill);
      }
      
      if (elementalResonanceSkill && !companion.skills.includes('sage_elemental_resonance_1')) {
        learnCompanionSkill(companion, elementalResonanceSkill);
        newPassiveSkills.push(elementalResonanceSkill);
      }
    } else if (selectedPath === 'healing') {
      // æ²»æ„ˆä¹‹é“ï¼šé˜²æ­»è­·ç›¾ + ç¥è–å›éŸ¿
      const deathWardSkill = SKILL_LOOKUP.get('sage_death_ward_1');
      const sacredEchoSkill = SKILL_LOOKUP.get('sage_sacred_echo_1');
      
      if (deathWardSkill && !companion.skills.includes('sage_death_ward_1')) {
        learnCompanionSkill(companion, deathWardSkill);
        newActiveSkills.push(deathWardSkill);
      }
      
      if (sacredEchoSkill && !companion.skills.includes('sage_sacred_echo_1')) {
        learnCompanionSkill(companion, sacredEchoSkill);
        newPassiveSkills.push(sacredEchoSkill);
      }
    }
    
    // è¨˜éŒ„é¸æ“‡çš„è·¯å¾‘
    companion.sagePath = selectedPath;
  }
  
  // æ­¦å™¨å¤§å¸«ç‰¹æ®ŠæŠ€èƒ½ï¼šæ ¹æ“šé¸æ“‡çš„è·¯å¾‘çµ¦äºˆå°æ‡‰æŠ€èƒ½
  if (advancedClassId === 'weaponmaster') {
    const selectedPath = state.ui.testModeAdvancement.selectedWeaponmasterPath;
    
    if (selectedPath === 'sword_god') {
      // åŠç¥ä¹‹è·¯ï¼šåŠç¥ä¹‹è·¯ + åŠæ°£ç¸±æ©«
      const swordGodPathSkill = SKILL_LOOKUP.get('weaponmaster_sword_god_path_1');
      const swordAuraSkill = SKILL_LOOKUP.get('weaponmaster_sword_aura_1');
      
      if (swordGodPathSkill && !companion.skills.includes('weaponmaster_sword_god_path_1')) {
        learnCompanionSkill(companion, swordGodPathSkill);
        newActiveSkills.push(swordGodPathSkill);
      }
      
      if (swordAuraSkill && !companion.skills.includes('weaponmaster_sword_aura_1')) {
        learnCompanionSkill(companion, swordAuraSkill);
        newPassiveSkills.push(swordAuraSkill);
      }
    } else if (selectedPath === 'assassin') {
      // åˆºå®¢ä¹‹è·¯ï¼šæš—å½±çªè¥² + ç ´ç”²ä¹‹åˆƒ
      const assassinPathSkill = SKILL_LOOKUP.get('weaponmaster_assassin_path_1');
      const armorPierceSkill = SKILL_LOOKUP.get('weaponmaster_armor_pierce_1');
      
      if (assassinPathSkill && !companion.skills.includes('weaponmaster_assassin_path_1')) {
        learnCompanionSkill(companion, assassinPathSkill);
        newActiveSkills.push(assassinPathSkill);
      }
      
      if (armorPierceSkill && !companion.skills.includes('weaponmaster_armor_pierce_1')) {
        learnCompanionSkill(companion, armorPierceSkill);
        newPassiveSkills.push(armorPierceSkill);
      }
    }
    
    // è¨˜éŒ„é¸æ“‡çš„è·¯å¾‘
    companion.weaponmasterPath = selectedPath;
  }
  
  // è¨˜éŒ„æ—¥èªŒ
  const activeSkillNames = newActiveSkills.map(s => s.name).join('ã€');
  const passiveSkillNames = newPassiveSkills.map(s => s.name).join('ã€');
  pushLog(`è·æ¥­é€²éšï¼š${companion.name} é€²éšç‚ºã€Œ${advancedClass.name}ã€ï¼`);
  if (activeSkillNames) {
    pushLog(`ç²å¾—ä¸»å‹•æŠ€èƒ½ï¼š${activeSkillNames}`);
  }
  if (passiveSkillNames) {
    pushLog(`ç²å¾—è¢«å‹•æŠ€èƒ½ï¼š${passiveSkillNames}`);
  }
  
  // æ¸…é™¤ç‹€æ…‹ä¸¦ç¹¼çºŒåŒä¼´é¸æ“‡æµç¨‹
  state.ui.testModeAdvancement = null;
  continueCompanionSelection();
}

// é¸æ“‡æ¸¬è©¦æ¨¡å¼è–é¨å£«è·¯å¾‘
function selectTestModePaladinPath(path) {
  if (!state.ui.testModeAdvancement) return;
  
  state.ui.testModeAdvancement.selectedPaladinPath = path;
  
  // åŸ·è¡Œé€²éš
  const companion = state.ui.testModeAdvancement.companion;
  const advancedClassId = state.ui.testModeAdvancement.selectedAdvancedClass;
  const advancedClass = COMPANION_TYPES[advancedClassId];
  
  if (!companion || !advancedClass) {
    skipTestModeAdvancement();
    return;
  }
  
  // åŸ·è¡Œé€²éšé‚è¼¯ï¼ˆé‡ç”¨ä¸Šé¢çš„ä»£ç¢¼ï¼‰
  const oldCompanionType = COMPANION_TYPES[companion.companionTypeId];
  const oldHeroType = oldCompanionType?.heroType || companion.heroType;
  
  // ç²å–æ–°è·æ¥­çš„æµæ´¾
  const flowMap = {
    attacker: 'sword',
    defender: 'defender',
    mage: 'magic',
    healer: 'recovery',
    agile: 'agility',
    sage: ['magic', 'recovery'],
    paladin: ['defender', 'recovery'],
    weaponmaster: ['sword', 'agility'],
  };
  
  const newHeroType = advancedClass.heroType;
  const newPrimaryFlowOrFlows = flowMap[newHeroType] || 'sword';
  const newPrimaryFlows = Array.isArray(newPrimaryFlowOrFlows) ? newPrimaryFlowOrFlows : [newPrimaryFlowOrFlows];
  
  // ç²å–èˆŠè·æ¥­çš„æµæ´¾ï¼ˆç”¨æ–¼æ’é™¤ï¼‰
  const oldPrimaryFlowOrFlows = flowMap[oldHeroType] || 'sword';
  const oldPrimaryFlows = Array.isArray(oldPrimaryFlowOrFlows) ? oldPrimaryFlowOrFlows : [oldPrimaryFlowOrFlows];
  
  // æ”¹è®Šè·æ¥­é¡å‹ï¼ˆä¿ç•™åŸæœ‰æŠ€èƒ½å’Œèƒ½åŠ›ï¼‰
  companion.companionTypeId = advancedClassId;
  companion.heroType = newHeroType;
  
  // å­¸ç¿’æ–°è·æ¥­çš„åˆå§‹æŠ€èƒ½
  const initialSkillsLearned = [];
  let ownedSkills = new Set(companion.skills);
  
  if (advancedClass.initialSkills && Array.isArray(advancedClass.initialSkills)) {
    advancedClass.initialSkills.forEach(skillId => {
      const skill = SKILL_LOOKUP.get(skillId);
      if (!skill) {
        // å¦‚æœæŠ€èƒ½æŸ¥æ‰¾å¤±è´¥ï¼Œè¾“å‡ºè­¦å‘Š
        console.warn(`æ¸¬è©¦æ¨¡å¼é€²éšæ™‚ç„¡æ³•æ‰¾åˆ°æŠ€èƒ½ï¼š${skillId}`);
        return;
      }
      
      // æª¢æŸ¥æ˜¯å¦å·²æ“æœ‰ç›¸åŒæˆ–æ›´é«˜ç­‰ç´šçš„æŠ€èƒ½
      let hasHigherTier = false;
      if (skill.chainId) {
        const chain = SKILL_CHAINS.find(c => c.id === skill.chainId);
        if (chain) {
          hasHigherTier = chain.steps.some(step => {
            return step.tier > skill.tier && companion.skills.includes(step.id);
          });
        }
      }
      
      if (!hasHigherTier) {
        // å­¸ç¿’æŠ€èƒ½ï¼ˆlearnCompanionSkill æœƒè‡ªå‹•è™•ç†å‡ç´šï¼šç§»é™¤ä½ç­‰ç´šç‰ˆæœ¬ï¼Œå­¸ç¿’é«˜ç­‰ç´šç‰ˆæœ¬ï¼‰
        const hadSkillBefore = ownedSkills.has(skillId);
        learnCompanionSkill(companion, skill);
        
        // å¦‚æœæˆåŠŸå­¸ç¿’äº†æŠ€èƒ½ï¼ˆæ–°æŠ€èƒ½æˆ–å‡ç´šï¼‰ï¼Œè¨˜éŒ„ä¸‹ä¾†
        if (companion.skills.includes(skillId) || !hadSkillBefore) {
          initialSkillsLearned.push(skill);
        }
        
        // æ›´æ–°å·²æ“æœ‰æŠ€èƒ½åˆ—è¡¨
        ownedSkills = new Set(companion.skills);
      } else {
        // å·²ç¶“æ“æœ‰æ›´é«˜ç­‰ç´šçš„æŠ€èƒ½ï¼Œè·³é
        const higherSkill = SKILL_CHAINS.find(c => c.id === skill.chainId)
          ?.steps.find(step => step.tier > skill.tier && companion.skills.includes(step.id));
        if (higherSkill) {
          initialSkillsLearned.push(SKILL_LOOKUP.get(higherSkill.id));
        }
      }
    });
  }
  
  // éš¨æ©Ÿç²å¾—å…©å€‹èˆ‡åŸæœ¬è·æ¥­ä¸åŒçš„ä¸»å‹•æŠ€èƒ½
  const newActiveSkills = [];
  
  // å¾æ–°è·æ¥­çš„æµæ´¾ä¸­é¸æ“‡ä¸»å‹•æŠ€èƒ½ï¼ˆæ’é™¤èˆŠè·æ¥­çš„æµæ´¾ï¼‰
  const availableFlows = newPrimaryFlows.filter(flow => !oldPrimaryFlows.includes(flow));
  
  if (availableFlows.length > 0) {
    availableFlows.forEach(flow => {
      const tier1Skills = getTier1SingleTargetSkillsByFlow(flow);
      const candidateSkills = tier1Skills.filter(skill => {
        if (ownedSkills.has(skill.id)) return false;
        if (skill.kind === 'passive') return false;
        return true;
      });
      
      if (candidateSkills.length > 0) {
        const randomSkill = candidateSkills[Math.floor(Math.random() * candidateSkills.length)];
        newActiveSkills.push(randomSkill);
      }
    });
  }
  
  // å¦‚æœé‚„æ²’æœ‰å…©å€‹æŠ€èƒ½ï¼Œå¾æ‰€æœ‰æ–°è·æ¥­æµæ´¾ä¸­é¸æ“‡
  while (newActiveSkills.length < 2 && newPrimaryFlows.length > 0) {
    const flow = newPrimaryFlows[Math.floor(Math.random() * newPrimaryFlows.length)];
    const tier1Skills = getTier1SingleTargetSkillsByFlow(flow);
    const candidateSkills = tier1Skills.filter(skill => {
      if (ownedSkills.has(skill.id)) return false;
      if (skill.kind === 'passive') return false;
      if (newActiveSkills.some(s => s.id === skill.id)) return false;
      return true;
    });
    
    if (candidateSkills.length > 0) {
      const randomSkill = candidateSkills[Math.floor(Math.random() * candidateSkills.length)];
      newActiveSkills.push(randomSkill);
    } else {
      break;
    }
  }
  
  // å­¸ç¿’æ–°ä¸»å‹•æŠ€èƒ½
  newActiveSkills.forEach(skill => {
    learnCompanionSkill(companion, skill);
  });
  
  // éš¨æ©Ÿç²å¾—å››å€‹èˆ‡åŸæœ¬è·æ¥­ä¸åŒçš„è¢«å‹•æŠ€èƒ½
  const newPassiveSkills = [];
  
  // å¾æ–°è·æ¥­çš„æµæ´¾ä¸­é¸æ“‡è¢«å‹•æŠ€èƒ½ï¼ˆæ’é™¤èˆŠè·æ¥­çš„æµæ´¾ï¼‰
  if (availableFlows.length > 0) {
    availableFlows.forEach(flow => {
      const tier1Passives = getTier1PassiveSkillsByFlow(flow);
      const candidatePassives = tier1Passives.filter(skill => {
        if (ownedSkills.has(skill.id)) return false;
        if (skill.kind !== 'passive') return false;
        return true;
      });
      
      if (candidatePassives.length > 0) {
        const randomPassive = candidatePassives[Math.floor(Math.random() * candidatePassives.length)];
        newPassiveSkills.push(randomPassive);
      }
    });
  }
  
  // å¦‚æœé‚„æ²’æœ‰å››å€‹è¢«å‹•æŠ€èƒ½ï¼Œå¾æ‰€æœ‰æ–°è·æ¥­æµæ´¾ä¸­é¸æ“‡
  while (newPassiveSkills.length < 4 && newPrimaryFlows.length > 0) {
    const flow = newPrimaryFlows[Math.floor(Math.random() * newPrimaryFlows.length)];
    const tier1Passives = getTier1PassiveSkillsByFlow(flow);
    const candidatePassives = tier1Passives.filter(skill => {
      if (ownedSkills.has(skill.id)) return false;
      if (skill.kind !== 'passive') return false;
      if (newPassiveSkills.some(s => s.id === skill.id)) return false;
      return true;
    });
    
    if (candidatePassives.length > 0) {
      const randomPassive = candidatePassives[Math.floor(Math.random() * candidatePassives.length)];
      newPassiveSkills.push(randomPassive);
    } else {
      break;
    }
  }
  
  // å­¸ç¿’æ–°è¢«å‹•æŠ€èƒ½
  newPassiveSkills.forEach(skill => {
    learnCompanionSkill(companion, skill);
    
    // å¦‚æœæ˜¯é˜²å®ˆå‹è¢«å‹•æŠ€èƒ½ï¼ˆHPåŠ æˆï¼‰ï¼Œç«‹å³æ‡‰ç”¨æ•ˆæœ
    if (skill.hpBonus !== undefined) {
      companion.stats.maxHp = Math.ceil(companion.stats.maxHp + skill.hpBonus);
      companion.stats.hp = Math.ceil(companion.stats.hp + skill.hpBonus);
    }
    // å¦‚æœæ˜¯é­”æ³•å‹è¢«å‹•æŠ€èƒ½ï¼ˆMPåŠ æˆï¼‰ï¼Œç«‹å³æ‡‰ç”¨æ•ˆæœ
    if (skill.mpBonus !== undefined) {
      companion.stats.maxMp = Math.ceil(companion.stats.maxMp + skill.mpBonus);
      companion.stats.mp = Math.ceil(companion.stats.mp + skill.mpBonus);
    }
  });
  
  // è–é¨å£«ç‰¹æ®ŠæŠ€èƒ½ï¼šæ ¹æ“šé¸æ“‡çš„è·¯å¾‘çµ¦äºˆå°æ‡‰æŠ€èƒ½
  if (advancedClassId === 'paladin') {
    const selectedPath = state.ui.testModeAdvancement.selectedPaladinPath;
    
    if (selectedPath === 'vengeance') {
      // å¾©ä»‡ä¹‹é“ï¼šè‡³è–æ–¬ + å¾©ä»‡æ„å¿—
      const divineSlashSkill = SKILL_LOOKUP.get('paladin_divine_slash_1');
      const vengeanceWillSkill = SKILL_LOOKUP.get('paladin_vengeance_will_1');
      
      if (divineSlashSkill && !companion.skills.includes('paladin_divine_slash_1')) {
        learnCompanionSkill(companion, divineSlashSkill);
        newActiveSkills.push(divineSlashSkill);
      }
      
      if (vengeanceWillSkill && !companion.skills.includes('paladin_vengeance_will_1')) {
        learnCompanionSkill(companion, vengeanceWillSkill);
        newPassiveSkills.push(vengeanceWillSkill);
      }
    } else if (selectedPath === 'sacred') {
      // ç¥è–ä¹‹é“ï¼šç¥è–è­·ç›¾ + å®ˆè­·æ„å¿—
      const sacredShieldSkill = SKILL_LOOKUP.get('paladin_sacred_shield_1');
      const guardianWillSkill = SKILL_LOOKUP.get('paladin_guardian_will_1');
      
      if (sacredShieldSkill && !companion.skills.includes('paladin_sacred_shield_1')) {
        learnCompanionSkill(companion, sacredShieldSkill);
        newPassiveSkills.push(sacredShieldSkill);
      }
      
      if (guardianWillSkill && !companion.skills.includes('paladin_guardian_will_1')) {
        learnCompanionSkill(companion, guardianWillSkill);
        newPassiveSkills.push(guardianWillSkill);
      }
    }
    
    // è¨˜éŒ„é¸æ“‡çš„è·¯å¾‘
    companion.paladinPath = selectedPath;
  }
  
  // è¨˜éŒ„æ—¥èªŒ
  const initialSkillNames = initialSkillsLearned.map(s => s.name).join('ã€');
  const activeSkillNames = newActiveSkills.map(s => s.name).join('ã€');
  const passiveSkillNames = newPassiveSkills.map(s => s.name).join('ã€');
  pushLog(`è·æ¥­é€²éšï¼š${companion.name} é€²éšç‚ºã€Œ${advancedClass.name}ã€ï¼`);
  if (initialSkillNames) {
    pushLog(`ç²å¾—åˆå§‹æŠ€èƒ½ï¼š${initialSkillNames}`);
  }
  if (activeSkillNames) {
    pushLog(`ç²å¾—ä¸»å‹•æŠ€èƒ½ï¼š${activeSkillNames}`);
  }
  if (passiveSkillNames) {
    pushLog(`ç²å¾—è¢«å‹•æŠ€èƒ½ï¼š${passiveSkillNames}`);
  }
  
  // æ¸…é™¤ç‹€æ…‹ä¸¦ç¹¼çºŒåŒä¼´é¸æ“‡æµç¨‹
  state.ui.testModeAdvancement = null;
  continueCompanionSelection();
}

// é¸æ“‡æ¸¬è©¦æ¨¡å¼è³¢è€…è·¯å¾‘
function selectTestModeSagePath(path) {
  if (!state.ui.testModeAdvancement) return;
  
  state.ui.testModeAdvancement.selectedSagePath = path;
  
  // åŸ·è¡Œé€²éšï¼ˆé‡ç”¨è–é¨å£«çš„é€²éšé‚è¼¯ï¼‰
  const companion = state.ui.testModeAdvancement.companion;
  const advancedClassId = state.ui.testModeAdvancement.selectedAdvancedClass;
  const advancedClass = COMPANION_TYPES[advancedClassId];
  
  if (!companion || !advancedClass) {
    skipTestModeAdvancement();
    return;
  }
  
  // åŸ·è¡Œé€²éšé‚è¼¯ï¼ˆé‡ç”¨ä¸Šé¢çš„ä»£ç¢¼ï¼‰
  const oldCompanionType = COMPANION_TYPES[companion.companionTypeId];
  const oldHeroType = oldCompanionType?.heroType || companion.heroType;
  
  // ç²å–æ–°è·æ¥­çš„æµæ´¾
  const flowMap = {
    attacker: 'sword',
    defender: 'defender',
    mage: 'magic',
    healer: 'recovery',
    agile: 'agility',
    sage: ['magic', 'recovery'],
    paladin: ['defender', 'recovery'],
    weaponmaster: ['sword', 'agility'],
  };
  
  const newHeroType = advancedClass.heroType;
  const newPrimaryFlowOrFlows = flowMap[newHeroType] || 'sword';
  const newPrimaryFlows = Array.isArray(newPrimaryFlowOrFlows) ? newPrimaryFlowOrFlows : [newPrimaryFlowOrFlows];
  
  // ç²å–èˆŠè·æ¥­çš„æµæ´¾ï¼ˆç”¨æ–¼æ’é™¤ï¼‰
  const oldPrimaryFlowOrFlows = flowMap[oldHeroType] || 'sword';
  const oldPrimaryFlows = Array.isArray(oldPrimaryFlowOrFlows) ? oldPrimaryFlowOrFlows : [oldPrimaryFlowOrFlows];
  
  // æ”¹è®Šè·æ¥­é¡å‹ï¼ˆä¿ç•™åŸæœ‰æŠ€èƒ½å’Œèƒ½åŠ›ï¼‰
  companion.companionTypeId = advancedClassId;
  companion.heroType = newHeroType;
  
  // å­¸ç¿’æ–°è·æ¥­çš„åˆå§‹æŠ€èƒ½
  const initialSkillsLearned = [];
  let ownedSkills = new Set(companion.skills);
  
  if (advancedClass.initialSkills && Array.isArray(advancedClass.initialSkills)) {
    advancedClass.initialSkills.forEach(skillId => {
      const skill = SKILL_LOOKUP.get(skillId);
      if (!skill) {
        // å¦‚æœæŠ€èƒ½æŸ¥æ‰¾å¤±è´¥ï¼Œè¾“å‡ºè­¦å‘Š
        console.warn(`æ¸¬è©¦æ¨¡å¼é€²éšæ™‚ç„¡æ³•æ‰¾åˆ°æŠ€èƒ½ï¼š${skillId}`);
        return;
      }
      
      // æª¢æŸ¥æ˜¯å¦å·²æ“æœ‰ç›¸åŒæˆ–æ›´é«˜ç­‰ç´šçš„æŠ€èƒ½
      let hasHigherTier = false;
      if (skill.chainId) {
        const chain = SKILL_CHAINS.find(c => c.id === skill.chainId);
        if (chain) {
          hasHigherTier = chain.steps.some(step => {
            return step.tier > skill.tier && companion.skills.includes(step.id);
          });
        }
      }
      
      if (!hasHigherTier) {
        // å­¸ç¿’æŠ€èƒ½ï¼ˆlearnCompanionSkill æœƒè‡ªå‹•è™•ç†å‡ç´šï¼šç§»é™¤ä½ç­‰ç´šç‰ˆæœ¬ï¼Œå­¸ç¿’é«˜ç­‰ç´šç‰ˆæœ¬ï¼‰
        const hadSkillBefore = ownedSkills.has(skillId);
        learnCompanionSkill(companion, skill);
        
        // å¦‚æœæˆåŠŸå­¸ç¿’äº†æŠ€èƒ½ï¼ˆæ–°æŠ€èƒ½æˆ–å‡ç´šï¼‰ï¼Œè¨˜éŒ„ä¸‹ä¾†
        if (companion.skills.includes(skillId) || !hadSkillBefore) {
          initialSkillsLearned.push(skill);
        }
        
        // æ›´æ–°å·²æ“æœ‰æŠ€èƒ½åˆ—è¡¨
        ownedSkills = new Set(companion.skills);
      } else {
        // å·²ç¶“æ“æœ‰æ›´é«˜ç­‰ç´šçš„æŠ€èƒ½ï¼Œè·³é
        const higherSkill = SKILL_CHAINS.find(c => c.id === skill.chainId)
          ?.steps.find(step => step.tier > skill.tier && companion.skills.includes(step.id));
        if (higherSkill) {
          initialSkillsLearned.push(SKILL_LOOKUP.get(higherSkill.id));
        }
      }
    });
  }
  
  // éš¨æ©Ÿç²å¾—å…©å€‹èˆ‡åŸæœ¬è·æ¥­ä¸åŒçš„ä¸»å‹•æŠ€èƒ½
  const newActiveSkills = [];
  
  // å¾æ–°è·æ¥­çš„æµæ´¾ä¸­é¸æ“‡ä¸»å‹•æŠ€èƒ½ï¼ˆæ’é™¤èˆŠè·æ¥­çš„æµæ´¾ï¼‰
  const availableFlows = newPrimaryFlows.filter(flow => !oldPrimaryFlows.includes(flow));
  
  if (availableFlows.length > 0) {
    availableFlows.forEach(flow => {
      const tier1Skills = getTier1SingleTargetSkillsByFlow(flow);
      const candidateSkills = tier1Skills.filter(skill => {
        if (ownedSkills.has(skill.id)) return false;
        if (skill.kind === 'passive') return false;
        return true;
      });
      
      if (candidateSkills.length > 0) {
        const randomSkill = candidateSkills[Math.floor(Math.random() * candidateSkills.length)];
        newActiveSkills.push(randomSkill);
      }
    });
  }
  
  // å¦‚æœé‚„æ²’æœ‰å…©å€‹æŠ€èƒ½ï¼Œå¾æ‰€æœ‰æ–°è·æ¥­æµæ´¾ä¸­é¸æ“‡
  while (newActiveSkills.length < 2 && newPrimaryFlows.length > 0) {
    const flow = newPrimaryFlows[Math.floor(Math.random() * newPrimaryFlows.length)];
    const tier1Skills = getTier1SingleTargetSkillsByFlow(flow);
    const candidateSkills = tier1Skills.filter(skill => {
      if (ownedSkills.has(skill.id)) return false;
      if (skill.kind === 'passive') return false;
      if (newActiveSkills.some(s => s.id === skill.id)) return false;
      return true;
    });
    
    if (candidateSkills.length > 0) {
      const randomSkill = candidateSkills[Math.floor(Math.random() * candidateSkills.length)];
      newActiveSkills.push(randomSkill);
    } else {
      break;
    }
  }
  
  // å­¸ç¿’æ–°ä¸»å‹•æŠ€èƒ½
  newActiveSkills.forEach(skill => {
    learnCompanionSkill(companion, skill);
  });
  
  // éš¨æ©Ÿç²å¾—å››å€‹èˆ‡åŸæœ¬è·æ¥­ä¸åŒçš„è¢«å‹•æŠ€èƒ½
  const newPassiveSkills = [];
  
  // å¾æ–°è·æ¥­çš„æµæ´¾ä¸­é¸æ“‡è¢«å‹•æŠ€èƒ½ï¼ˆæ’é™¤èˆŠè·æ¥­çš„æµæ´¾ï¼‰
  if (availableFlows.length > 0) {
    availableFlows.forEach(flow => {
      const tier1Passives = getTier1PassiveSkillsByFlow(flow);
      const candidatePassives = tier1Passives.filter(skill => {
        if (ownedSkills.has(skill.id)) return false;
        if (skill.kind !== 'passive') return false;
        return true;
      });
      
      if (candidatePassives.length > 0) {
        const randomPassive = candidatePassives[Math.floor(Math.random() * candidatePassives.length)];
        newPassiveSkills.push(randomPassive);
      }
    });
  }
  
  // å¦‚æœé‚„æ²’æœ‰å››å€‹è¢«å‹•æŠ€èƒ½ï¼Œå¾æ‰€æœ‰æ–°è·æ¥­æµæ´¾ä¸­é¸æ“‡
  while (newPassiveSkills.length < 4 && newPrimaryFlows.length > 0) {
    const flow = newPrimaryFlows[Math.floor(Math.random() * newPrimaryFlows.length)];
    const tier1Passives = getTier1PassiveSkillsByFlow(flow);
    const candidatePassives = tier1Passives.filter(skill => {
      if (ownedSkills.has(skill.id)) return false;
      if (skill.kind !== 'passive') return false;
      if (newPassiveSkills.some(s => s.id === skill.id)) return false;
      return true;
    });
    
    if (candidatePassives.length > 0) {
      const randomPassive = candidatePassives[Math.floor(Math.random() * candidatePassives.length)];
      newPassiveSkills.push(randomPassive);
    } else {
      break;
    }
  }
  
  // å­¸ç¿’æ–°è¢«å‹•æŠ€èƒ½
  newPassiveSkills.forEach(skill => {
    learnCompanionSkill(companion, skill);
    
    // å¦‚æœæ˜¯é˜²å®ˆå‹è¢«å‹•æŠ€èƒ½ï¼ˆHPåŠ æˆï¼‰ï¼Œç«‹å³æ‡‰ç”¨æ•ˆæœ
    if (skill.hpBonus !== undefined) {
      companion.stats.maxHp = Math.ceil(companion.stats.maxHp + skill.hpBonus);
      companion.stats.hp = Math.ceil(companion.stats.hp + skill.hpBonus);
    }
    // å¦‚æœæ˜¯é­”æ³•å‹è¢«å‹•æŠ€èƒ½ï¼ˆMPåŠ æˆï¼‰ï¼Œç«‹å³æ‡‰ç”¨æ•ˆæœ
    if (skill.mpBonus !== undefined) {
      companion.stats.maxMp = Math.ceil(companion.stats.maxMp + skill.mpBonus);
      companion.stats.mp = Math.ceil(companion.stats.mp + skill.mpBonus);
    }
  });
  
  // è³¢è€…ç‰¹æ®ŠæŠ€èƒ½ï¼šæ ¹æ“šé¸æ“‡çš„è·¯å¾‘çµ¦äºˆå°æ‡‰æŠ€èƒ½
  if (advancedClassId === 'sage') {
    const selectedPath = state.ui.testModeAdvancement.selectedSagePath;
    
    if (selectedPath === 'elemental') {
      // å…ƒç´ ä¹‹é“ï¼šå…ƒç´ çˆ†ç™¼ + å…ƒç´ å…±é³´
      const elementalBurstSkill = SKILL_LOOKUP.get('sage_elemental_burst_1');
      const elementalResonanceSkill = SKILL_LOOKUP.get('sage_elemental_resonance_1');
      
      if (elementalBurstSkill && !companion.skills.includes('sage_elemental_burst_1')) {
        learnCompanionSkill(companion, elementalBurstSkill);
        newActiveSkills.push(elementalBurstSkill);
      }
      
      if (elementalResonanceSkill && !companion.skills.includes('sage_elemental_resonance_1')) {
        learnCompanionSkill(companion, elementalResonanceSkill);
        newPassiveSkills.push(elementalResonanceSkill);
      }
    } else if (selectedPath === 'healing') {
      // æ²»æ„ˆä¹‹é“ï¼šé˜²æ­»è­·ç›¾ + ç¥è–å›éŸ¿
      const deathWardSkill = SKILL_LOOKUP.get('sage_death_ward_1');
      const sacredEchoSkill = SKILL_LOOKUP.get('sage_sacred_echo_1');
      
      if (deathWardSkill && !companion.skills.includes('sage_death_ward_1')) {
        learnCompanionSkill(companion, deathWardSkill);
        newActiveSkills.push(deathWardSkill);
      }
      
      if (sacredEchoSkill && !companion.skills.includes('sage_sacred_echo_1')) {
        learnCompanionSkill(companion, sacredEchoSkill);
        newPassiveSkills.push(sacredEchoSkill);
      }
    }
    
    // è¨˜éŒ„é¸æ“‡çš„è·¯å¾‘
    companion.sagePath = selectedPath;
  }
  
  // è¨˜éŒ„æ—¥èªŒ
  const initialSkillNames = initialSkillsLearned.map(s => s.name).join('ã€');
  const activeSkillNames = newActiveSkills.map(s => s.name).join('ã€');
  const passiveSkillNames = newPassiveSkills.map(s => s.name).join('ã€');
  pushLog(`è·æ¥­é€²éšï¼š${companion.name} é€²éšç‚ºã€Œ${advancedClass.name}ã€ï¼`);
  if (initialSkillNames) {
    pushLog(`ç²å¾—åˆå§‹æŠ€èƒ½ï¼š${initialSkillNames}`);
  }
  if (activeSkillNames) {
    pushLog(`ç²å¾—ä¸»å‹•æŠ€èƒ½ï¼š${activeSkillNames}`);
  }
  if (passiveSkillNames) {
    pushLog(`ç²å¾—è¢«å‹•æŠ€èƒ½ï¼š${passiveSkillNames}`);
  }
  
  // æ¸…é™¤ç‹€æ…‹ä¸¦ç¹¼çºŒåŒä¼´é¸æ“‡æµç¨‹
  state.ui.testModeAdvancement = null;
  continueCompanionSelection();
}

// é¸æ“‡æ¸¬è©¦æ¨¡å¼æ­¦å™¨å¤§å¸«è·¯å¾‘
function selectTestModeWeaponmasterPath(path) {
  if (!state.ui.testModeAdvancement) return;
  
  state.ui.testModeAdvancement.selectedWeaponmasterPath = path;
  
  // åŸ·è¡Œé€²éšï¼ˆé‡ç”¨è–é¨å£«çš„é€²éšé‚è¼¯ï¼‰
  const companion = state.ui.testModeAdvancement.companion;
  const advancedClassId = state.ui.testModeAdvancement.selectedAdvancedClass;
  const advancedClass = COMPANION_TYPES[advancedClassId];
  
  if (!companion || !advancedClass) {
    skipTestModeAdvancement();
    return;
  }
  
  // åŸ·è¡Œé€²éšé‚è¼¯ï¼ˆé‡ç”¨ä¸Šé¢çš„ä»£ç¢¼ï¼‰
  const oldCompanionType = COMPANION_TYPES[companion.companionTypeId];
  const oldHeroType = oldCompanionType?.heroType || companion.heroType;
  
  // ç²å–æ–°è·æ¥­çš„æµæ´¾
  const flowMap = {
    attacker: 'sword',
    defender: 'defender',
    mage: 'magic',
    healer: 'recovery',
    agile: 'agility',
    sage: ['magic', 'recovery'],
    paladin: ['defender', 'recovery'],
    weaponmaster: ['sword', 'agility'],
  };
  
  const newHeroType = advancedClass.heroType;
  const newPrimaryFlowOrFlows = flowMap[newHeroType] || 'sword';
  const newPrimaryFlows = Array.isArray(newPrimaryFlowOrFlows) ? newPrimaryFlowOrFlows : [newPrimaryFlowOrFlows];
  
  // ç²å–èˆŠè·æ¥­çš„æµæ´¾ï¼ˆç”¨æ–¼æ’é™¤ï¼‰
  const oldPrimaryFlowOrFlows = flowMap[oldHeroType] || 'sword';
  const oldPrimaryFlows = Array.isArray(oldPrimaryFlowOrFlows) ? oldPrimaryFlowOrFlows : [oldPrimaryFlowOrFlows];
  
  // æ”¹è®Šè·æ¥­é¡å‹ï¼ˆä¿ç•™åŸæœ‰æŠ€èƒ½å’Œèƒ½åŠ›ï¼‰
  companion.companionTypeId = advancedClassId;
  companion.heroType = newHeroType;
  
  // å­¸ç¿’æ–°è·æ¥­çš„åˆå§‹æŠ€èƒ½
  const initialSkillsLearned = [];
  let ownedSkills = new Set(companion.skills);
  
  if (advancedClass.initialSkills && Array.isArray(advancedClass.initialSkills)) {
    advancedClass.initialSkills.forEach(skillId => {
      const skill = SKILL_LOOKUP.get(skillId);
      if (!skill) {
        // å¦‚æœæŠ€èƒ½æŸ¥æ‰¾å¤±è´¥ï¼Œè¾“å‡ºè­¦å‘Š
        console.warn(`æ¸¬è©¦æ¨¡å¼é€²éšæ™‚ç„¡æ³•æ‰¾åˆ°æŠ€èƒ½ï¼š${skillId}`);
        return;
      }
      
      // æª¢æŸ¥æ˜¯å¦å·²æ“æœ‰ç›¸åŒæˆ–æ›´é«˜ç­‰ç´šçš„æŠ€èƒ½
      let hasHigherTier = false;
      if (skill.chainId) {
        const chain = SKILL_CHAINS.find(c => c.id === skill.chainId);
        if (chain) {
          hasHigherTier = chain.steps.some(step => {
            return step.tier > skill.tier && companion.skills.includes(step.id);
          });
        }
      }
      
      if (!hasHigherTier) {
        // å­¸ç¿’æŠ€èƒ½ï¼ˆlearnCompanionSkill æœƒè‡ªå‹•è™•ç†å‡ç´šï¼šç§»é™¤ä½ç­‰ç´šç‰ˆæœ¬ï¼Œå­¸ç¿’é«˜ç­‰ç´šç‰ˆæœ¬ï¼‰
        const hadSkillBefore = ownedSkills.has(skillId);
        learnCompanionSkill(companion, skill);
        
        // å¦‚æœæˆåŠŸå­¸ç¿’äº†æŠ€èƒ½ï¼ˆæ–°æŠ€èƒ½æˆ–å‡ç´šï¼‰ï¼Œè¨˜éŒ„ä¸‹ä¾†
        if (companion.skills.includes(skillId) || !hadSkillBefore) {
          initialSkillsLearned.push(skill);
        }
        
        // æ›´æ–°å·²æ“æœ‰æŠ€èƒ½åˆ—è¡¨
        ownedSkills = new Set(companion.skills);
      } else {
        // å·²ç¶“æ“æœ‰æ›´é«˜ç­‰ç´šçš„æŠ€èƒ½ï¼Œè·³é
        const higherSkill = SKILL_CHAINS.find(c => c.id === skill.chainId)
          ?.steps.find(step => step.tier > skill.tier && companion.skills.includes(step.id));
        if (higherSkill) {
          initialSkillsLearned.push(SKILL_LOOKUP.get(higherSkill.id));
        }
      }
    });
  }
  
  // éš¨æ©Ÿç²å¾—å…©å€‹èˆ‡åŸæœ¬è·æ¥­ä¸åŒçš„ä¸»å‹•æŠ€èƒ½
  const newActiveSkills = [];
  
  // å¾æ–°è·æ¥­çš„æµæ´¾ä¸­é¸æ“‡ä¸»å‹•æŠ€èƒ½ï¼ˆæ’é™¤èˆŠè·æ¥­çš„æµæ´¾ï¼‰
  const availableFlows = newPrimaryFlows.filter(flow => !oldPrimaryFlows.includes(flow));
  
  if (availableFlows.length > 0) {
    availableFlows.forEach(flow => {
      const tier1Skills = getTier1SingleTargetSkillsByFlow(flow);
      const candidateSkills = tier1Skills.filter(skill => {
        if (ownedSkills.has(skill.id)) return false;
        if (skill.kind === 'passive') return false;
        return true;
      });
      
      if (candidateSkills.length > 0) {
        const randomSkill = candidateSkills[Math.floor(Math.random() * candidateSkills.length)];
        newActiveSkills.push(randomSkill);
      }
    });
  }
  
  // å¦‚æœé‚„æ²’æœ‰å…©å€‹æŠ€èƒ½ï¼Œå¾æ‰€æœ‰æ–°è·æ¥­æµæ´¾ä¸­é¸æ“‡
  while (newActiveSkills.length < 2 && newPrimaryFlows.length > 0) {
    const flow = newPrimaryFlows[Math.floor(Math.random() * newPrimaryFlows.length)];
    const tier1Skills = getTier1SingleTargetSkillsByFlow(flow);
    const candidateSkills = tier1Skills.filter(skill => {
      if (ownedSkills.has(skill.id)) return false;
      if (skill.kind === 'passive') return false;
      if (newActiveSkills.some(s => s.id === skill.id)) return false;
      return true;
    });
    
    if (candidateSkills.length > 0) {
      const randomSkill = candidateSkills[Math.floor(Math.random() * candidateSkills.length)];
      newActiveSkills.push(randomSkill);
    } else {
      break;
    }
  }
  
  // å­¸ç¿’æ–°ä¸»å‹•æŠ€èƒ½
  newActiveSkills.forEach(skill => {
    learnCompanionSkill(companion, skill);
  });
  
  // éš¨æ©Ÿç²å¾—å››å€‹èˆ‡åŸæœ¬è·æ¥­ä¸åŒçš„è¢«å‹•æŠ€èƒ½
  const newPassiveSkills = [];
  
  // å¾æ–°è·æ¥­çš„æµæ´¾ä¸­é¸æ“‡è¢«å‹•æŠ€èƒ½ï¼ˆæ’é™¤èˆŠè·æ¥­çš„æµæ´¾ï¼‰
  if (availableFlows.length > 0) {
    availableFlows.forEach(flow => {
      const tier1Passives = getTier1PassiveSkillsByFlow(flow);
      const candidatePassives = tier1Passives.filter(skill => {
        if (ownedSkills.has(skill.id)) return false;
        if (skill.kind !== 'passive') return false;
        return true;
      });
      
      if (candidatePassives.length > 0) {
        const randomPassive = candidatePassives[Math.floor(Math.random() * candidatePassives.length)];
        newPassiveSkills.push(randomPassive);
      }
    });
  }
  
  // å¦‚æœé‚„æ²’æœ‰å››å€‹è¢«å‹•æŠ€èƒ½ï¼Œå¾æ‰€æœ‰æ–°è·æ¥­æµæ´¾ä¸­é¸æ“‡
  while (newPassiveSkills.length < 4 && newPrimaryFlows.length > 0) {
    const flow = newPrimaryFlows[Math.floor(Math.random() * newPrimaryFlows.length)];
    const tier1Passives = getTier1PassiveSkillsByFlow(flow);
    const candidatePassives = tier1Passives.filter(skill => {
      if (ownedSkills.has(skill.id)) return false;
      if (skill.kind !== 'passive') return false;
      if (newPassiveSkills.some(s => s.id === skill.id)) return false;
      return true;
    });
    
    if (candidatePassives.length > 0) {
      const randomPassive = candidatePassives[Math.floor(Math.random() * candidatePassives.length)];
      newPassiveSkills.push(randomPassive);
    } else {
      break;
    }
  }
  
  // å­¸ç¿’æ–°è¢«å‹•æŠ€èƒ½
  newPassiveSkills.forEach(skill => {
    learnCompanionSkill(companion, skill);
    
    // å¦‚æœæ˜¯é˜²å®ˆå‹è¢«å‹•æŠ€èƒ½ï¼ˆHPåŠ æˆï¼‰ï¼Œç«‹å³æ‡‰ç”¨æ•ˆæœ
    if (skill.hpBonus !== undefined) {
      companion.stats.maxHp = Math.ceil(companion.stats.maxHp + skill.hpBonus);
      companion.stats.hp = Math.ceil(companion.stats.hp + skill.hpBonus);
    }
    // å¦‚æœæ˜¯é­”æ³•å‹è¢«å‹•æŠ€èƒ½ï¼ˆMPåŠ æˆï¼‰ï¼Œç«‹å³æ‡‰ç”¨æ•ˆæœ
    if (skill.mpBonus !== undefined) {
      companion.stats.maxMp = Math.ceil(companion.stats.maxMp + skill.mpBonus);
      companion.stats.mp = Math.ceil(companion.stats.mp + skill.mpBonus);
    }
  });
  
  // æ­¦å™¨å¤§å¸«ç‰¹æ®ŠæŠ€èƒ½ï¼šæ ¹æ“šé¸æ“‡çš„è·¯å¾‘çµ¦äºˆå°æ‡‰æŠ€èƒ½
  if (advancedClassId === 'weaponmaster') {
    const selectedPath = state.ui.testModeAdvancement.selectedWeaponmasterPath;
    
    if (selectedPath === 'sword_god') {
      // åŠç¥ä¹‹è·¯ï¼šåŠç¥ä¹‹è·¯ + åŠæ°£ç¸±æ©«
      const swordGodPathSkill = SKILL_LOOKUP.get('weaponmaster_sword_god_path_1');
      const swordAuraSkill = SKILL_LOOKUP.get('weaponmaster_sword_aura_1');
      
      if (swordGodPathSkill && !companion.skills.includes('weaponmaster_sword_god_path_1')) {
        learnCompanionSkill(companion, swordGodPathSkill);
        newActiveSkills.push(swordGodPathSkill);
      }
      
      if (swordAuraSkill && !companion.skills.includes('weaponmaster_sword_aura_1')) {
        learnCompanionSkill(companion, swordAuraSkill);
        newPassiveSkills.push(swordAuraSkill);
      }
    } else if (selectedPath === 'assassin') {
      // åˆºå®¢ä¹‹è·¯ï¼šæš—å½±çªè¥² + ç ´ç”²ä¹‹åˆƒ
      const assassinPathSkill = SKILL_LOOKUP.get('weaponmaster_assassin_path_1');
      const armorPierceSkill = SKILL_LOOKUP.get('weaponmaster_armor_pierce_1');
      
      if (assassinPathSkill && !companion.skills.includes('weaponmaster_assassin_path_1')) {
        learnCompanionSkill(companion, assassinPathSkill);
        newActiveSkills.push(assassinPathSkill);
      }
      
      if (armorPierceSkill && !companion.skills.includes('weaponmaster_armor_pierce_1')) {
        learnCompanionSkill(companion, armorPierceSkill);
        newPassiveSkills.push(armorPierceSkill);
      }
    }
    
    // è¨˜éŒ„é¸æ“‡çš„è·¯å¾‘
    companion.weaponmasterPath = selectedPath;
  }
  
  // è¨˜éŒ„æ—¥èªŒ
  const initialSkillNames = initialSkillsLearned.map(s => s.name).join('ã€');
  const activeSkillNames = newActiveSkills.map(s => s.name).join('ã€');
  const passiveSkillNames = newPassiveSkills.map(s => s.name).join('ã€');
  pushLog(`è·æ¥­é€²éšï¼š${companion.name} é€²éšç‚ºã€Œ${advancedClass.name}ã€ï¼`);
  if (initialSkillNames) {
    pushLog(`ç²å¾—åˆå§‹æŠ€èƒ½ï¼š${initialSkillNames}`);
  }
  if (activeSkillNames) {
    pushLog(`ç²å¾—ä¸»å‹•æŠ€èƒ½ï¼š${activeSkillNames}`);
  }
  if (passiveSkillNames) {
    pushLog(`ç²å¾—è¢«å‹•æŠ€èƒ½ï¼š${passiveSkillNames}`);
  }
  
  // æ¸…é™¤ç‹€æ…‹ä¸¦ç¹¼çºŒåŒä¼´é¸æ“‡æµç¨‹
  state.ui.testModeAdvancement = null;
  continueCompanionSelection();
}

// è·³éæ¸¬è©¦æ¨¡å¼è·æ¥­é€²éš
function skipTestModeAdvancement() {
  state.ui.testModeAdvancement = null;
  continueCompanionSelection();
}

// ç¹¼çºŒåŒä¼´é¸æ“‡æµç¨‹
function continueCompanionSelection() {
  // æª¢æŸ¥æ˜¯å¦é‚„éœ€è¦é¸æ“‡æ›´å¤šåŒä¼´
  const initialCount = (typeof GAME_CONFIG.initialCompanionCount !== 'undefined') 
    ? GAME_CONFIG.initialCompanionCount 
    : 1;
  const maxCompanionCount = GAME_CONFIG.maxCompanionCount || 4;
  const isNewCompanionAfterBoss = state.ui.companionSelection === 'boss-reward';
  
  if (isNewCompanionAfterBoss) {
    // æ‰“å€’é­”ç‹å¾Œé¸æ“‡æ–°åŒä¼´ï¼Œé¸æ“‡å®Œç•¢å¾Œé¡¯ç¤ºåœ£ç‰©é¸æ“‡
    state.ui.companionSelection = null;
    
    // é¸æ“‡å®ŒåŒä¼´å¾Œï¼Œå¼·åˆ¶é¡¯ç¤ºåœ£ç‰©é¸æ“‡ç•Œé¢ï¼ˆä¸å†å…è¨±é¸æ“‡æ›´å¤šåŒä¼´ï¼‰
    handleBossReward(true);
    return;
  } else if (initialCount <= 0 || state.companions.length >= initialCount || state.companions.length >= maxCompanionCount) {
    // å¦‚æœåˆå§‹æ•¸é‡ç‚º0ã€å·²é¸æ“‡è¶³å¤ çš„åˆå§‹åŒä¼´ã€æˆ–é”åˆ°æœ€å¤§åŒä¼´æ•¸é‡ä¸Šé™ï¼Œé–‹å§‹éŠæˆ²
    // ç¢ºä¿æ‰€æœ‰åŒä¼´éƒ½å‡ç´šåˆ°ç›®æ¨™ç­‰ç´šï¼ˆéæ¸¬è©¦æ¨¡å¼ï¼‰
    if (!GAME_CONFIG.testMode) {
      const targetLevel = GAME_CONFIG.defaultTargetLevel || 15;
      if (targetLevel > 1) {
        const activeCompanions = (state.companions || []).filter(c => c && c.stats);
        activeCompanions.forEach(companion => {
          if (companion.stats.level < targetLevel) {
            const companionLevelsToGain = targetLevel - companion.stats.level;
            const upgradeInfo = levelUpCompanion(companion, companionLevelsToGain);
            // è‡ªå‹•è™•ç†å±¬æ€§é¸æ“‡å’ŒæŠ€èƒ½é¸æ“‡ï¼ˆåˆå§‹å‡ç´šæ™‚è‡ªå‹•é¸æ“‡ï¼‰
            if (upgradeInfo) {
              autoProcessCompanionUpgrade(upgradeInfo);
            }
            companion.stats.hp = companion.stats.maxHp;
            companion.stats.mp = companion.stats.maxMp;
          }
        });
      }
    }
    
    state.ui.companionSelection = null;
    
    // å¦‚æœå¾ç¬¬ä¸€éšæ®µé–‹å§‹ï¼Œé¡¯ç¤ºç¬¬ä¸€ç« æ•…äº‹ï¼ˆåœ¨å®Œæˆæ‰€æœ‰åˆå§‹è¨­ç½®å¾Œï¼‰
    const currentStage = state.world?.stage || 1;
    if (currentStage === 1) {
      // é¡¯ç¤ºæ•…äº‹ï¼Œä½†ä¸è¦ç«‹å³é—œé–‰æ¨¡æ…‹è¦–çª—ï¼ˆæ•…äº‹æœƒè‡ªå·±ç®¡ç†æ¨¡æ…‹è¦–çª—ï¼‰
      showStageStory(1);
    } else {
      // å¦‚æœä¸æ˜¯ç¬¬ä¸€éšæ®µï¼Œç›´æ¥é—œé–‰æ¨¡æ…‹è¦–çª—ä¸¦é–‹å§‹éŠæˆ²
    dom.modalLayer.classList.add('hidden');
    dom.levelModal.innerHTML = '';
    }
    
    setTimeout(() => {
      renderAll();
    }, 0);
  } else {
    // é‚„éœ€è¦é¸æ“‡æ›´å¤šåŒä¼´ï¼Œç¹¼çºŒé¡¯ç¤ºé¸æ“‡ç•Œé¢
    // ç¢ºä¿æ¨¡æ…‹è¦–çª—ä¿æŒæ‰“é–‹ï¼Œä¸¦ä¿æŒé¸æ“‡ç‹€æ…‹
    state.ui.companionSelection = true; // ç¢ºä¿ç‹€æ…‹ä¿æŒç‚º true
    // ç›´æ¥èª¿ç”¨ renderAll è®“å®ƒè™•ç†ç•Œé¢æ¸²æŸ“
    setTimeout(() => {
      renderAll();
    }, 50); // ç¨å¾®å»¶é²ä»¥ç¢ºä¿ç‹€æ…‹æ›´æ–°å®Œæˆ
  }
}

// å°‡å‡½æ•¸æš´éœ²åˆ°å…¨å±€
window.selectTestModeAdvancementClass = selectTestModeAdvancementClass;
window.selectTestModePaladinPath = selectTestModePaladinPath;
window.selectTestModeSagePath = selectTestModeSagePath;
window.selectTestModeWeaponmasterPath = selectTestModeWeaponmasterPath;
window.skipTestModeAdvancement = skipTestModeAdvancement;


// åˆå§‹åŒ–æ™‚è¼‰å…¥è¨­å®šï¼ˆåœ¨DOMContentLoadedä¹‹å‰å…ˆè®€å–ä¸€æ¬¡ï¼‰
console.log('[MAIN.JS] è…³æœ¬è¼‰å…¥å®Œæˆï¼Œæº–å‚™åˆå§‹åŒ–');
console.log('[MAIN.JS] document.readyState:', document.readyState);

loadSettings();

// æ·»åŠ  DOMContentLoaded ç›£è½å™¨
console.log('[MAIN.JS] æ·»åŠ  DOMContentLoaded ç›£è½å™¨');
let initCalled = false;

function callInitOnce() {
  if (initCalled) {
    console.log('[MAIN.JS] init() å·²ç¶“è¢«èª¿ç”¨éï¼Œè·³é');
    return;
  }
  initCalled = true;
  console.log('[MAIN.JS] èª¿ç”¨ init()');
  init();
}

document.addEventListener('DOMContentLoaded', function() {
  console.log('[MAIN.JS] DOMContentLoaded äº‹ä»¶è§¸ç™¼');
  callInitOnce();
});

// å¦‚æœ DOM å·²ç¶“è¼‰å…¥å®Œæˆï¼Œç›´æ¥èª¿ç”¨ init
if (document.readyState === 'complete' || document.readyState === 'interactive') {
  console.log('[MAIN.JS] DOM å·²ç¶“è¼‰å…¥ï¼ˆreadyState:', document.readyState, 'ï¼‰ï¼Œç«‹å³èª¿ç”¨ init()');
  setTimeout(function() {
    console.log('[MAIN.JS] setTimeout åŸ·è¡Œ init()');
    callInitOnce();
  }, 0);
} else {
  console.log('[MAIN.JS] DOM å°šæœªè¼‰å…¥ï¼ˆreadyState:', document.readyState, 'ï¼‰ï¼Œç­‰å¾… DOMContentLoaded');
}

// å‚™ç”¨æ©Ÿåˆ¶ï¼šå¦‚æœ 1 ç§’å¾Œé‚„æ²’æœ‰èª¿ç”¨ initï¼Œå¼·åˆ¶èª¿ç”¨
setTimeout(function() {
  console.log('[MAIN.JS] å‚™ç”¨æ©Ÿåˆ¶ï¼šæª¢æŸ¥ init() æ˜¯å¦å·²èª¿ç”¨');
  if (!initCalled) {
    console.warn('[MAIN.JS] init() å°šæœªè¢«èª¿ç”¨ï¼Œå¼·åˆ¶èª¿ç”¨');
    callInitOnce();
  }
}, 1000);
